[
  {
    "problem_id": 0,
    "taco_problem_id": 4,
    "source": "codeforces",
    "difficulty": "EASY",
    "claude_tests_passed": 0,
    "claude_tests_total": 4,
    "human_tests_passed": 4,
    "human_tests_total": 4,
    "detailed_claude_results": [
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve_test_case():\n    n = int(input())\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in descending order\n    cards.sort(reverse=True)\n\n    # Print the sorted cards as the maximum order deck\n    print(*cards)\n\n# Read the number of test cases\nt = int(input())\n\n# Solve each test case\nfor _ in range(t):\n    solve_test_case()",
        "test": {
          "stdin": "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.32077228399793967
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve_test_case():\n    n = int(input())\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in descending order\n    cards.sort(reverse=True)\n\n    # Print the sorted cards as the maximum order deck\n    print(*cards)\n\n# Read the number of test cases\nt = int(input())\n\n# Solve each test case\nfor _ in range(t):\n    solve_test_case()",
        "test": {
          "stdin": "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.34267152300162707
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve_test_case():\n    n = int(input())\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in descending order\n    cards.sort(reverse=True)\n\n    # Print the sorted cards as the maximum order deck\n    print(*cards)\n\n# Read the number of test cases\nt = int(input())\n\n# Solve each test case\nfor _ in range(t):\n    solve_test_case()",
        "test": {
          "stdin": "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n2 4 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4141709340001398
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve_test_case():\n    n = int(input())\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in descending order\n    cards.sort(reverse=True)\n\n    # Print the sorted cards as the maximum order deck\n    print(*cards)\n\n# Read the number of test cases\nt = int(input())\n\n# Solve each test case\nfor _ in range(t):\n    solve_test_case()",
        "test": {
          "stdin": "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "\n4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 4 3 2 1\n6 5 4 3 2 1\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.30447369400280877
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      }
    ],
    "detailed_human_results": [
      {
        "code": "from collections import *\nfrom math import sqrt\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport operator\nimport re\nimport statistics\nimport string\nimport sys\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef check_seq(deck_size, deck_cards):\n\tnew_deck = []\n\tused = [0 for i in range(deck_size)]\n\tlast_used_index = deck_size - 1\n\tprev_ind = deck_size\n\tfor i in range(deck_size - 1, -1, -1):\n\t\tif deck_cards[i] == last_used_index + 1:\n\t\t\tnew_deck += deck_cards[i:prev_ind]\n\t\t\tfor j in range(i, prev_ind):\n\t\t\t\tused[deck_cards[j] - 1] = 1\n\t\t\tprev_ind = i\n\t\t\tj = -1\n\t\t\twhile True:\n\t\t\t\tcur_ind = j + last_used_index\n\t\t\t\tif cur_ind < 0:\n\t\t\t\t\tlast_used_index = -1\n\t\t\t\t\tbreak\n\t\t\t\tif used[cur_ind]:\n\t\t\t\t\tj -= 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tlast_used_index = cur_ind\n\t\t\t\t\tbreak\n\treturn ' '.join(map(str, new_deck))\n\ndef main():\n\tcnt = read_one_int()\n\tfor _ in range(cnt):\n\t\tdeck_size = read_one_int()\n\t\tdeck_cards = read_list_of_ints()\n\t\tres = check_seq(deck_size, deck_cards)\n\t\tprint(res)\nmain()",
        "test": {
          "stdin": "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.39474368800074444
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom math import sqrt\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport operator\nimport re\nimport statistics\nimport string\nimport sys\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef check_seq(deck_size, deck_cards):\n\tnew_deck = []\n\tused = [0 for i in range(deck_size)]\n\tlast_used_index = deck_size - 1\n\tprev_ind = deck_size\n\tfor i in range(deck_size - 1, -1, -1):\n\t\tif deck_cards[i] == last_used_index + 1:\n\t\t\tnew_deck += deck_cards[i:prev_ind]\n\t\t\tfor j in range(i, prev_ind):\n\t\t\t\tused[deck_cards[j] - 1] = 1\n\t\t\tprev_ind = i\n\t\t\tj = -1\n\t\t\twhile True:\n\t\t\t\tcur_ind = j + last_used_index\n\t\t\t\tif cur_ind < 0:\n\t\t\t\t\tlast_used_index = -1\n\t\t\t\t\tbreak\n\t\t\t\tif used[cur_ind]:\n\t\t\t\t\tj -= 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tlast_used_index = cur_ind\n\t\t\t\t\tbreak\n\treturn ' '.join(map(str, new_deck))\n\ndef main():\n\tcnt = read_one_int()\n\tfor _ in range(cnt):\n\t\tdeck_size = read_one_int()\n\t\tdeck_cards = read_list_of_ints()\n\t\tres = check_seq(deck_size, deck_cards)\n\t\tprint(res)\nmain()",
        "test": {
          "stdin": "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.35146341899962863
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom math import sqrt\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport operator\nimport re\nimport statistics\nimport string\nimport sys\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef check_seq(deck_size, deck_cards):\n\tnew_deck = []\n\tused = [0 for i in range(deck_size)]\n\tlast_used_index = deck_size - 1\n\tprev_ind = deck_size\n\tfor i in range(deck_size - 1, -1, -1):\n\t\tif deck_cards[i] == last_used_index + 1:\n\t\t\tnew_deck += deck_cards[i:prev_ind]\n\t\t\tfor j in range(i, prev_ind):\n\t\t\t\tused[deck_cards[j] - 1] = 1\n\t\t\tprev_ind = i\n\t\t\tj = -1\n\t\t\twhile True:\n\t\t\t\tcur_ind = j + last_used_index\n\t\t\t\tif cur_ind < 0:\n\t\t\t\t\tlast_used_index = -1\n\t\t\t\t\tbreak\n\t\t\t\tif used[cur_ind]:\n\t\t\t\t\tj -= 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tlast_used_index = cur_ind\n\t\t\t\t\tbreak\n\treturn ' '.join(map(str, new_deck))\n\ndef main():\n\tcnt = read_one_int()\n\tfor _ in range(cnt):\n\t\tdeck_size = read_one_int()\n\t\tdeck_cards = read_list_of_ints()\n\t\tres = check_seq(deck_size, deck_cards)\n\t\tprint(res)\nmain()",
        "test": {
          "stdin": "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n2 4 5 3 6 1\n1\n1\n",
          "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3811216290014272
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom math import sqrt\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport operator\nimport re\nimport statistics\nimport string\nimport sys\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef check_seq(deck_size, deck_cards):\n\tnew_deck = []\n\tused = [0 for i in range(deck_size)]\n\tlast_used_index = deck_size - 1\n\tprev_ind = deck_size\n\tfor i in range(deck_size - 1, -1, -1):\n\t\tif deck_cards[i] == last_used_index + 1:\n\t\t\tnew_deck += deck_cards[i:prev_ind]\n\t\t\tfor j in range(i, prev_ind):\n\t\t\t\tused[deck_cards[j] - 1] = 1\n\t\t\tprev_ind = i\n\t\t\tj = -1\n\t\t\twhile True:\n\t\t\t\tcur_ind = j + last_used_index\n\t\t\t\tif cur_ind < 0:\n\t\t\t\t\tlast_used_index = -1\n\t\t\t\t\tbreak\n\t\t\t\tif used[cur_ind]:\n\t\t\t\t\tj -= 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tlast_used_index = cur_ind\n\t\t\t\t\tbreak\n\treturn ' '.join(map(str, new_deck))\n\ndef main():\n\tcnt = read_one_int()\n\tfor _ in range(cnt):\n\t\tdeck_size = read_one_int()\n\t\tdeck_cards = read_list_of_ints()\n\t\tres = check_seq(deck_size, deck_cards)\n\t\tprint(res)\nmain()",
        "test": {
          "stdin": "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
          "stdout": "\n4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3303921009974147
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      }
    ]
  }
]