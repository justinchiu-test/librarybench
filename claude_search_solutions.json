[
  {
    "problem": "Dilpreet wants to paint his dog's home that has n boards with different lengths. The length of i^{th }board is given by arr[i] where arr[] is an array of n integers. He hired k painters for this work and each painter takes 1 unit time to paint 1 unit of the board. \nThe problem is to find the minimum time to get this job done if all painters start together with the constraint that any painter will only paint continuous boards, say boards numbered {2,3,4} or only board {1} or nothing but not boards {2,4,5}.\nExample 1:\nInput:\nn = 5\nk = 3\narr[] = {5,10,30,20,15}\nOutput: 35\nExplanation: The most optimal way will be:\nPainter 1 allocation : {5,10}\nPainter 2 allocation : {30}\nPainter 3 allocation : {20,15}\nJob will be done when all painters finish\ni.e. at time = max(5+10, 30, 20+15) = 35\nExample 2:\nInput:\nn = 4\nk = 2\narr[] = {10,20,30,40}\nOutput: 60\nExplanation: The most optimal way to paint:\nPainter 1 allocation : {10,20,30}\nPainter 2 allocation : {40}\nJob will be complete at time = 60\nYour task:\nYour task is to complete the function minTime() which takes the integers n and k and the array arr[] as input and returns the minimum time required to paint all partitions.\nExpected Time Complexity: O(n log m) , m = sum of all boards' length\nExpected Auxiliary Space: O(1)\nConstraints:\n1 \u2264 n \u2264 10^{5}\n1 \u2264 k \u2264 10^{5}\n1 \u2264 arr[i] \u2264 10^{5}",
    "difficulty": "MEDIUM_HARD",
    "skill_types": "['Dynamic programming', 'Sorting', 'Complete search']",
    "source": "geeksforgeeks",
    "human_solution": "class Solution:\n\n\tdef minTime(self, arr, n, k):\n\n\t\tdef numofPainter(maxLen):\n\t\t\tpainters = 1\n\t\t\ttotal = 0\n\t\t\tfor board in arr:\n\t\t\t\ttotal += board\n\t\t\t\tif total > maxLen:\n\t\t\t\t\ttotal = board\n\t\t\t\t\tpainters += 1\n\t\t\treturn painters\n\t\t(low, high) = (max(arr), sum(arr))\n\t\twhile low < high:\n\t\t\tp = low + (high - low) // 2\n\t\t\tcurr_painters = numofPainter(p)\n\t\t\tif curr_painters <= k:\n\t\t\t\thigh = p\n\t\t\telse:\n\t\t\t\tlow = p + 1\n\t\treturn low\n",
    "claude_solution": "Here's an efficient solution to the problem using binary search in Python:\n\n```python\nclass Solution:\n    def minTime(self, arr, n, k):\n        def is_possible(arr, n, k, max_time):\n            painters = 1\n            curr_time = 0\n            for i in range(n):\n                if curr_time + arr[i] > max_time:\n                    painters += 1\n                    curr_time = arr[i]\n                    if painters > k:\n                        return False\n                else:\n                    curr_time += arr[i]\n            return True\n\n        # Edge case: if there are more painters than boards\n        if k > n:\n            k = n\n\n        # Calculate the sum of all boards' lengths\n        total_length = sum(arr)\n\n        # Initialize the binary search range\n        low = max(arr)  # Minimum possible time is the maximum length of a board\n        high = total_length  # Maximum possible time is the sum of all boards' lengths\n\n        # Perform binary search\n        while low < high:\n            mid = (low + high) // 2\n            if is_possible(arr, n, k, mid):\n                high = mid\n            else:\n                low = mid + 1\n\n        return low\n```\n\nExplanation:\n\n1. The `minTime` function takes the array `arr`, the number of boards `n`, and the number of painters `k` as input.\n\n2. We define a helper function `is_possible` that checks if it is possible to paint all the boards within a given `max_time` using `k` painters. It iterates over the boards and assigns them to painters, keeping track of the current time for each painter. If the current time plus the length of the next board exceeds `max_time`, it assigns the board to a new painter. If the number of painters exceeds `k`, it returns `False`. Otherwise, it returns `True`.\n\n3. We handle the edge case where there are more painters than boards by setting `k` equal to `n`.\n\n4. We calculate the sum of all boards' lengths and store it in `total_length`.\n\n5. We initialize the binary search range. The minimum possible time is the maximum length of a board, and the maximum possible time is the sum of all boards' lengths.\n\n6. We perform binary search on the range `[low, high]`. In each iteration:\n   - We calculate the midpoint `mid`.\n   - We call the `is_possible` function with `mid` as the `max_time`.\n   - If it is possible to paint all the boards within `mid` time using `k` painters, we update `high` to `mid` to search for a smaller time.\n   - Otherwise, we update `low` to `mid + 1` to search for a larger time.\n\n7. The binary search continues until `low` and `high` converge to the minimum time required to paint all the boards.\n\n8. Finally, we return `low` as the minimum time required.\n\nThe time complexity of this solution is O(n log m), where n is the number of boards and m is the sum of all boards' lengths. The binary search takes O(log m) iterations, and in each iteration, the `is_possible` function takes O(n) time to check the possibility. The space complexity is O(1) as we only use a constant amount of extra space."
  }
]