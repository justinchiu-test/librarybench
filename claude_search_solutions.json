[
  {
    "solutions": [
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''\n\t\n",
      "T = eval(input())\nfor i in range(T):\n\tstring = input()\n\tl = len(string)\n\tls = len(set(string))\n\tif l < 4:\n\t\tprint('NO')\n\telif l > 9:\n\t\tprint('YES')\n\telif l == 4 and ls > 3:\n\t\tprint('YES')\n\telif l > 4 and ls > 2:\n\t\tprint('YES')\n\telif l > 6 and ls > 1:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\t\n",
      "t=eval(input())\n\nwhile(t>0):\n\ts=input();\n\tflag1=0\n\tflag2=0\n\tflag3=0\n\tfor split1 in range(1,len(s)-2):\n\t\tfor split2 in range(2,len(s)-1):\n\t\t\tfor split3 in range(3,len(s)):\n\t\t\t\ts1=s[:split1]\n\t\t\t\ts2=s[split1:split2]\n\t\t\t\ts3=s[split2:split3]\n\t\t\t\ts4=s[split3:]\n\t\t\t\tif len(s1)!=0 and len(s2)!=0 and len(s3)!=0 and len(s4)!=0 :\n\t\t\t\t\tif s1!=s2 and s1!=s3 and s1!=s4 and s2!=s3 and s2!=s4 and s3!=s4:\n\t\t\t\t\t\tflag3=1\n\t\t\t\t\t\tbreak\n\t\t\tif flag3==1 :\n\t\t\t\tflag2=1\n\t\t\t\tbreak\n\t\tif flag2==1 :\n\t\t\tflag1=1\n\t\t\tbreak\n\tif flag1==1 :\n\t\tprint (\"YES\")\n\telse:\n\t\tprint (\"NO\")  \n\tt-=1\n",
      "def dict_create(string):\n\tdi = {}\n\tfor i in range(len(string)):\n\t\tdi[string[i]] = 0\n\tfor i in range(len(string)):\n\t\tdi[string[i]] = di[string[i]] + 1\n\treturn di\n\nt = int(input())\ndi = {}\nfor i in range(t):\n\tstring = input()\n\tlength = len(string)\n\tif length < 4:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tdi = dict_create(string)\n\tif length >= 4:\n\t\tl1 = len(di)\n\t\tif l1 == 1 and length >= 10:\n\t\t\tprint(\"YES\")\n\t\telif l1 == 2 and length >= 7:\n\t\t\tprint(\"YES\")\n\t\telif l1 == 3 and length >= 5:\n\t\t\tprint(\"YES\")\n\t\telif l1 >= 4:\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n",
      "for _ in range(eval(input())):\n\ta=input()\n\tb=set(a)\n\tc=len(a)\n\td=len(b)\n\tif c>9 or d>3 :\n\t\tprint(\"YES\")\n\telif d>2 and c>4 :\n\t\tprint(\"YES\")\n\telif d>1 and c>6:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n",
      "n=eval(input())\nflag=0\nfor a in range(n):\n\tflag=0\n\ts = input()\n\tp =len(s)\n\tif(p>10):\n\t\tprint(\"YES\")\n\t\tcontinue\n\tfor i in range(1,p):\n\t\tif(flag==1):\n\t\t\tbreak\n\t\tfor j in range(1,p-i):\n\t\t\tif(flag==1):\n\t\t\t\tbreak\n\t\t\tfor k in range(1,p-i-j):\n\t\t\t\tl=p-i-j-k\n\t\t#\t\tprint i,j,k,l\n\t\t\t\taa=s[:i]\n\t\t\t\tbb=s[i:j+i]\n\t\t\t\tcc=s[j+i:k+i+j]\n\t\t\t\tdd=s[k+i+j:i+j+k+l]\n\t\t\t\tif(aa!=bb and aa!=cc and aa!=dd and bb!=cc and bb!=dd and cc!=dd):\n\t\t\t\t\tprint(\"YES\")\n\t\t\t\t\tflag=1\n\t\t\t\t\tbreak\n\tif(flag==0):\n\t\tprint(\"NO\")\n\t\t\t\t\t\n\n",
      "map = {}\ndef process(str,count):\n\tglobal map\n\tif count==0:\n\t\treturn 1\n\tln = len(str);\n\tfor i in range(1,ln-count+2):\n\t\tif map.get(str[:i],None) == None:\n\t\t\tmap[str[:i]] = 1\n\t\t\tif process(str[i:],count-1):\n\t\t\t\tdel map[str[:i]]\n\t\t\t\treturn 1\n\t\t\tdel map[str[:i]]\n\treturn 0\n\t\t\n\ndef solve():\n\tglobal map\n\tmap = {}\n\tstr = input()\n\tif process(str,4):\n\t\treturn 'YES'\n\treturn 'NO'\n\ndef main():\n\tt=input()\n\tfor i in range(int(t)):\n\t\tprint(solve())\n\t\t\nmain()\n",
      "import itertools as it\n\ndef split(str, split):\n\ta, b, c = split\n\ts1 = str[:a]\n\ts2 = str[a:b]\n\ts3 = str[b:c]\n\ts4 = str[c:]\n\treturn s1, s2, s3, s4\n\ndef unique(s):\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tif i != j:\n\t\t\t\tif s[i] == s[j]:\n\t\t\t\t\treturn False\n\treturn True\n\ndef isSplit(str):\n\tif len(str) >= 10:\n\t\treturn True\n\tcombs = it.combinations(list(range(1, len(str))), 3)\n\tfor i in combs:\n\t\tif unique(split(str, i)):\n\t\t\treturn True\n\treturn False\n\nfor i in range(eval(input())):\n\tstr = input()\n\tif isSplit(str):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "def perform_tests():\n\ts = input(\"\")\n\t\n\t\n\tif len(s) >=10 :\n\t\tprint(\"YES\")\n\t\treturn\n\t\t\n\tif len(s) <=3 :\n\t\tprint(\"NO\")\n\t\treturn\n\ti = 0    \n\t\n\tfor i in range(len(s)-3):\n\t\tfor j in range(i+1,len(s)-2):\n\t\t\tfor k in range(j+1,len(s)-1):\n\t\t\t\tfor l in range(k+1,len(s)):\n\t\t\t\t\ta=s[i:j]\n\t\t\t\t\tb=s[j:k]\n\t\t\t\t\tc=s[k:l]\n\t\t\t\t\td=s[l:]\n\t\t\t\t\tif (a!=b and a!=c and a!=d and b!=c and b!=d and c!=d):\n\t\t\t\t\t\tprint(\"YES\")\n\t\t\t\t\t\treturn           \n\tprint(\"NO\")\n\treturn\n\t\t\t\t\t\t\ntc = int(input(\"\"))                       \n\nfor each in range(tc):\n\tperform_tests()  \n",
      "for _ in range(eval(input())):\n\ta=list(input())\n\tb=list(set(a))\n\tif len(b)>=4:\n\t\tprint(\"YES\")\n\telif len(b)==1 and len(a)>=10 :\n\t\tprint(\"YES\")\n\telif len(b)==2 and len(a)>=7:\n\t\tprint(\"YES\")\n\telif len(b)==3 and len(a)>=5:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n",
      "for _ in range(eval(input())):\n\ts=input()\n\ts=s.strip()\n\tl=len(s)\n\tok=0\n\tif l>=10:\n\t\tok=1\n\telse:    \n\t\tfor i in range(1,l):\n\t\t\tfor j in range(i+1,l):\n\t\t\t\tfor k in range(j+1,l):\n\t\t\t\t\ts1=s[0:i]\n\t\t\t\t\ts2=s[i:j]\n\t\t\t\t\ts3=s[j:k]\n\t\t\t\t\ts4=s[k:l]\n\t\t\t\t\tif s1!=s2 and s1!=s3 and s1!=s4 and s2!=s3 and s2!=s4 and s3!=s4:\n\t\t\t\t\t\tok=1\n\tif ok:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\t\t\t\t\n",
      "import itertools as it\n\ndef split(str, split):\n\ta, b, c = split\n\ts1 = str[:a]\n\ts2 = str[a:b]\n\ts3 = str[b:c]\n\ts4 = str[c:]\n\treturn s1, s2, s3, s4\n\ndef unique(s):\n\tfor i in range(4):\n\t\tfor j in range(4):\n\t\t\tif i != j:\n\t\t\t\tif s[i] == s[j]:\n\t\t\t\t\treturn False\n\treturn True\n\ndef isSplit(str):\n\tif len(str) >= 10:\n\t\treturn True\n\tcombs = it.combinations(list(range(1, len(str))), 3)\n\tfor i in combs:\n\t\tif unique(split(str, i)):\n\t\t\treturn True\n\treturn False\n\nfor i in range(eval(input())):\n\tstr = input()\n\tif isSplit(str):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef solve(s):\n\tn = len(s)\n\tif n<4:\n\t\treturn \"NO\"\n\tif n>9:\n\t\treturn \"YES\"\n\tfor i in range(1,n-2):\n\t\tfor j in range(i+1,n-1):\n\t\t\tfor k in range(j+1,n):\n\t\t\t\ts1 = s[0:i]\n\t\t\t\ts2 = s[i:j]\n\t\t\t\ts3 = s[j:k]\n\t\t\t\ts4 = s[k:n]\n\t\t\t\t#print s1 + \"::\" + s2 +\"::\"+s3+\"::\"+s4\n\t\t\t\tif s1==s2 or s1==s3 or s1==s4 or s2==s3 or s2==s4 or s3==s4:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\t\n\treturn \"NO\"\n\t\t\t\n\t\nt = int(input())\nfor i in range(0,t):\n\ts = input()\n\tprint(solve(s))\n\n",
      "n=eval(input())\n\nwhile n:\n\ts=input()\n\tf=0\n\tfor i in range(1,len(s)):\n\t\tif f:\n\t\t\tbreak\n\t\tfor j in range(i+1,len(s)):\n\n\t\t\tif f:\n\t\t\t\tbreak\n\t\t\tfor k in range(j+1,len(s)):\n\t\t\t\tl=[]\n\t\t\t\tl.append(s[0:i])\n\t\t\t\tl.append(s[i:j])\n\t\t\t\tl.append(s[j:k])\n\t\t\t\tl.append(s[k:len(s)])\n\t\t\t\tl.sort()\n\t\t\t\tif(l[0]!=l[1] and l[1]!=l[2] and l[2]!=l[3]):\n\t\t\t\t\t\t   print(\"YES\")\n\t\t\t\t\t\t   f=1\n\t\t\t\t\t\t   break\n\n\tif f==0:\n\t\tprint(\"NO\")\n\n\n\tn-=1\n\n",
      "t = eval(input())\nfor _ in range(t):\n\tinp = input()\n\tx = [0]*26\n\tfor i in inp:\n\t\tx[ord(i)-97]=1\n\tcs = sum(x)\n\tif(len(inp)>=10):\n\t\tprint(\"YES\")\n\telse:\n\t\tl = len(inp)\n\t\tab = False\n\t\tfor i in range(1,l):\n\t\t\tif(ab==True):\n\t\t\t\tbreak\n\t\t\tfor j in range(i+1,l):\n\t\t\t\tif(ab==True):\n\t\t\t\t\tbreak\n\t\t\t\tfor k in range(j+1,l):\n\t\t\t\t\ta = inp[0:i]\n\t\t\t\t\tb = inp[i:j]\n\t\t\t\t\tc = inp[j:k]\n\t\t\t\t\td = inp[k:]\n\t\t\t\t\tif((len(a)*len(b)*len(c)*len(d))!=0):\n\t\t\t\t\t\tx = set([a,b,c,d])\n\t\t\t\t\t\tif(len(x)==4):\n\t\t\t\t\t\t\tab = True\n\t\t\t\t\t\t\tbreak\n\t\tif(ab==True):\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n",
      "n = int(input())\nfor i in range(n):\n\ts = input().strip()\n\tl = len(s)\n\tb = False\n\tfor j in range(l):\n\t\tfor k in  range(j+1, l):\n\t\t\tfor z in range(k+1, l):\n\t\t\t\tif j < k < z < l:\n\t\t\t\t\ts1 = s[:j+1]\n\t\t\t\t\ts2 = s[j+1:k+1]\n\t\t\t\t\ts3 = s[k+1:z+1]\n\t\t\t\t\ts4 = s[z+1:]\n\t\t\t\t\tif (s1 == \"\" or s2 == \"\" or s3 == \"\" or s4 == \"\"):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t#print (s1,\"#\",s2, \"#\", s3,\"#\", s4)\n\t\t\t\t\tif not (s1 == s2 or s1 == s3 or s1 == s4 or s2 == s3 or s2 == s4 or s3 == s4):\n\t\t\t\t\t\tb = True\n\t\t\t\t\t\tbreak\n\t\t\tif b:\n\t\t\t\tbreak\n\t\tif b:\n\t\t\tbreak\n\t\n\tif b:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n",
      "for _ in range(int(input())):\n\ts=input().strip()\n\tn=len(s)\n\tif n<4:\n\t\tprint('NO')\n\telse:\n\t\tp=set(s)\n\t\tc=len(p)\n\t\tf=0\n\t\tif c==1 and n>=10:\n\t\t\tf=1\n\t\tif c==2 :\n\t\t\tif n>=7:\n\t\t\t\tf=1\n\t\t\tp=list(p)\n\t\t\tif n==6 and s.count(p[0])*s.count(p[1])>5:\n\t\t\t\tf=1\n\t\tif c==3 and n>=5:\n\t\t\tf=1\n\t\tif c>=4:\n\t\t\tf=1\n\t\tif f:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
      "for _ in range(int(input())):\n\ts = input().strip()\n\ta = len(set(s))\n\tb = len(s)\n\tif a >= 4 or b >= 10 or a == 3 and b >= 5 or a == 2 and b >= 7: \n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\t\t\t\t\t\n",
      "def fun(qs, arr, s, i, n):\n\t#print arr,s,i\n\tif (i==n):\n\t\tif s!='':\n\t\t\tarr.update([s])\n\t\treturn len(set(arr))>=4\n\tif (s not in arr and s!=''):\n\t\tb = set(arr)\n\t\tb.update([s])\n\t\treturn fun(qs, b, '', i, n) or (fun(qs, arr, s+qs[i], i+1, n))\n\treturn (fun(qs, arr, s+qs[i], i+1, n))\n\n\n#print fun('ababca', set([]), '', 0, 6)\n\n\n\n\n\nfor i in range(eval(input())):\n\ts=input()\n\tif len(s)>=10:\n\t\tprint ('YES')\n\t\tcontinue\n\tp = set(s)\n\tif len(p)>=4:\n\t\tprint ('YES')\n\t\tcontinue\n\tans = fun(s, set([]), '', 0, len(s))\n\tif ans==True:\n\t\tprint('YES')\n\t\t\n\telse:\n\t\tprint('NO')\n\t\n\t\n\t\n",
      "def process(string):\n\tif string == \"ddddded\":\n\t\treturn True\n\tif len(string) < 4:\n\t\treturn False\n\n\tif len(string) == 4:\n\t\treturn len(set(string)) == 4\n\n\ti = 1\n\tans = []\n\twhile True:\n\t\ttmp_string = string\t\n\t\tstart = tmp_string[:i]\n\t\ttmp_string = tmp_string[i:]\n\t\tans.append(start)\n\t\tif len(tmp_string) < 3:\n\t\t\treturn False\n\t\twhile len(ans) != 4:\n\t\t\tcc = True\n\t\t\tif len(ans) == 3:\n\t\t\t\tif tmp_string:\n\t\t\t\t\tif tmp_string not in ans:\n\t\t\t\t\t\tans.append(tmp_string)\n\t\t\t\t\t\tcc = False\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tcc = False\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tcc = False\n\t\t\t\t\tbreak\n\t\t\tif not cc:\n\t\t\t\tbreak\n\t\t\ttmp = tmp_string[0]\n\t\t\ttmp_string = tmp_string[1:]\n\t\t\tcon = True\n\t\t\twhile tmp in ans:\n\t\t\t\tif tmp_string:\n\t\t\t\t\ttmp += tmp_string[0]\n\t\t\t\t\ttmp_string = tmp_string[1:]\n\t\t\t\telse:\n\t\t\t\t\tcon = False\n\t\t\t\t\tbreak\n\t\t\tif con:\n\t\t\t\tans.append(tmp)\n\t\t\telse:\n\t\t\t\tbreak\n\t\tif len(ans) == 4:\n\t\t\treturn True\n\t\tans = []\n\t\ti += 1\n\n\nT = eval(input())\nfor i in range(T):\n\tstring = input()\n\tif process(string):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n\n",
      "for i in range(eval(input())):\n\ta=input()\n\ts=\"\"\n\tfor j in range(len(a)):\n\t\tif(a[j] not in s):\n\t\t\ts+=a[j]\n\tif(len(s)>=4):\n\t\tprint(\"YES\")\n\telif(len(s)==3 and len(a)>=5):\n\t\tprint(\"YES\")\n\telif(len(s)==2 and len(a)>=7):\n\t\tprint(\"YES\")\n\telif(len(s)==1 and len(a)>=10):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n",
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\ndef NoDistChar(S):\n\tcntr=0\n\tfor x in S:\n\t\tif S[0]==x:\n\t\t\tcntr+=1\n\tif cntr>=2 and cntr<=4:\n\t\treturn True\n\telse:\n\t\treturn False\n\t\t\ndef DistChar(S):\n\tL=[]\n\tresult=0\n\tfor x in S:\n\t\tif not x in L:\n\t\t\tL.append(x)\n\t\t\tresult+=1\n\treturn result\t\t\n\t\t\t\nT= int(input())\nfor x in range(T):\n\tS=input()\n\tif len(S)>9:\n\t\tprint('YES')\n\t\t\n\telif len(S)<4:\n\t\tprint('NO')\n\telif len(S)==4:\n\t\tif DistChar(S)==4:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telif len(S)==5: \n\t\tif DistChar(S)>=3:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telif len(S)==6:\n\t\tif DistChar(S)>=3:\n\t\t   print('YES')\n\t\telif DistChar(S)==2:\n\t\t\tif NoDistChar(S):\n\t\t\t\tprint('YES')\n\t\t\telse:\n\t\t\t\tprint('NO')   \n\t\telse:\n\t\t\tprint('NO')\n\telif len(S)>6:\n\t\tif DistChar(S)>=2:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\t\t\n",
      "t = int(input())\nfor i in range(0, t):\n\tflag=0\n\tstart = 0\n\tend = 1\n\tstr_set = set()\n\tstr = input()\n\twhile( start < len(str) and end <= len(str) ):\n\t\tif str[start:end] in str_set:\n\t\t\tend+=1\n\t\telse:\n\t\t\tstr_set.add(str[start:end])\n\t\t\tstart=end\n\t\t\tend=start+1\n\t\tif len(str_set) > 3:\n\t\t\tprint(\"YES\")\n\t\t\tflag=1\n\t\t\tbreak\n\t\t\n\t#for handling cases like aaoaaaaa\n\tif flag == 0 and len(str)>1 and str[0] == str[1]:\n\t\tstr_set = set()\n\t\tstr_set.add(str[0:2])\n\t\tstart = 2\n\t\tend = 3\n\t\twhile( start < len(str) and end <= len(str) ):\n\t\t\tif str[start:end] in str_set:\n\t\t\t\tend+=1\n\t\t\telse:\n\t\t\t\tstr_set.add(str[start:end])\n\t\t\t\tstart=end\n\t\t\t\tend=start+1\n\t\t\tif len(str_set) > 3:\n\t\t\t\tprint(\"YES\")\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\t\n\t#for handling cases like aaaaaoa\n\tif flag == 0:\n\t\tstr = str[::-1] \n\t\tstart = 0\n\t\tend = 1\n\t\tstr_set = set()\n\t\twhile( start < len(str) and end <= len(str) ):\n\t\t\tif str[start:end] in str_set:\n\t\t\t\tend+=1\n\t\t\telse:\n\t\t\t\tstr_set.add(str[start:end])\n\t\t\t\tstart=end\n\t\t\t\tend=start+1\n\t\t\tif len(str_set) > 3:\n\t\t\t\tflag=1\n\t\t\t\tprint(\"YES\")\n\t\t\t\tbreak\n\t\n\tif flag == 0:\n\t\tprint(\"NO\")\n\t\n\t\t\n\t\n\t\n",
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef solve(s):\n\tn = len(s)\n\tif n<4:\n\t\treturn \"NO\"\n\tif n>9:\n\t\treturn \"YES\"\n\tfor i in range(1,n-2):\n\t\tfor j in range(i+1,n-1):\n\t\t\tfor k in range(j+1,n):\n\t\t\t\ts1 = s[0:i]\n\t\t\t\ts2 = s[i:j]\n\t\t\t\ts3 = s[j:k]\n\t\t\t\ts4 = s[k:n]\n\t\t\t\t#print s1 + \"::\" + s2 +\"::\"+s3+\"::\"+s4\n\t\t\t\tif s1==s2 or s1==s3 or s1==s4 or s2==s3 or s2==s4 or s3==s4:\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\t\n\treturn \"NO\"\n\t\t\t\n\t\nt = int(input())\nfor i in range(0,t):\n\ts = input()\n\tprint(solve(s))\n\n",
      "def comp(st):\n\tl = len(st)\n\tnew = st[0]\n\tfor i in range(1,l):\n\t\tch = st[i]\n\t\tif ch!=new[-1]:\n\t\t\tnew = new + ch\n\treturn len(new)\nfor i in range(eval(input())):\n\tst = input()\n\tval = comp(st)\n\td = {}\n\tfor item in st:\n\t\ttry:\n\t\t\td[item] += 1\n\t\texcept:\n\t\t\td[item] = 1\n\tif len(d)>=4:\n\t\tprint(\"YES\")\n\telif len(d)==1:\n\t\tif len(st)>=10:\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n\telif len(d)==3:\n\t\tif len(st)>=6:\n\t\t\tprint(\"YES\")\n\t\t\tcontinue\n\t\tif val>=5:\n\t\t\tprint(\"YES\")\n\t\telif val==4:\n\t\t\tif len(st)>=5:\n\t\t\t\tprint(\"YES\")\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\t\telif val==3:\n\t\t\tff = False\n\t\t\tfor item in d:\n\t\t\t\tif d[item]>=3:\n\t\t\t\t\tff = True\n\t\t\tif ff:\n\t\t\t\tprint(\"YES\")\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\telse:\n\t\tif len(st)>=7:\n\t\t\tprint(\"YES\")\n\t\t\tcontinue\n\t\tif len(st)<=5:\n\t\t\tprint(\"NO\")\n\t\t\tcontinue\n\t\tprint(\"NO\")\n\n",
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\nt = input();\n\nfor o in range(0,int(t)):\n\ts = input();\n\t\n\tif len(s) > 10:\n\t\tprint(\"YES\")\n\telif len(s) < 4:\n\t\tprint(\"NO\")\n\telse:\n\t\tfl = 0;\n\t\tfor i in range(0,len(s)-3):\n\t\t\tfor j in range(i,len(s)-2):\n\t\t\t\tfor k in range(j,len(s)-1):\n\t\t\t\t\tfor p in range(k,len(s)):\n\t\t\t\t\t\tlst = []\n\t\t\t\t\t\tstr1 = s[i:j]\n\t\t\t\t\t\tstr2 = s[j:k]\n\t\t\t\t\t\tstr3 = s[k:p]\n\t\t\t\t\t\tstr4 = s[p:]\n\t\t\t\t\t\tif str1 != \"\":\n\t\t\t\t\t\t\tlst.append(str1)\n\t\t\t\t\t\tif str2 != \"\" and str2 not in lst:\n\t\t\t\t\t\t\tlst.append(str2)\n\t\t\t\t\t\tif str3 != \"\" and str3 not in lst:\n\t\t\t\t\t\t\tlst.append(str3)\n\t\t\t\t\t\tif str4 != \"\" and str4 not in lst:\n\t\t\t\t\t\t\tlst.append(str4)\n\t\t\t\t\t\t\n\t\t\t\t\t\tif len(lst) == 4:\n\t\t\t\t\t\t\tfl = 1\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tif fl == 1:\n\t\t\t\t\t\tbreak\n\t\t\t\tif fl == 1:\n\t\t\t\t\tbreak\n\t\t\tif fl == 1:\n\t\t\t\tbreak\n\t\t\n\t\tif fl == 1:\n\t\t\tprint(\"YES\")\n\t\telse:\n\t\t\tprint(\"NO\")\n\t\t\t\n",
      "for r in range(int(input())):\n\tn = input()\n\tlength = len(n)\n\n\tstate = True\n\t\n\tfor a in range(1,length - 2):\n\t\tfor b in range(1, length - a - 1):\n\t\t\tfor c in range(1, length - a - b):\n\t\t\t\tarray = [n[0:a], n[a:a + b], n[a + b:a + b + c], n[a + b + c:length]]\n\t\t\t\tif len(array) == len(set(array)):\n\t\t\t\t\tprint('YES')\n\t\t\t\t\tstate = False\n\t\t\t\t\tbreak\n\t\t\tif not state:\n\t\t\t\tbreak\n\t\tif not state:\n\t\t\tbreak\n\t\t\t\t\t\n\n\tif state:\n\t\tprint('NO')\n",
      "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprin\n\n\n\nt 'Hi, %s.' % name\n'''\n\n\ndef fun(s):\n\ti=1\n\tj=0\n\tk=0\n\twhile(i<len(s)):\n\t\tj=i+1\n\t\twhile(j<len(s)):\n\t\t\tk=j+1\n\t\t\twhile(k<len(s)):\n\t\t\t\ta=s[:i]\n\t\t\t\tb=s[i:j]\n\t\t\t\tc=s[j:k]\n\t\t\t\td=s[k:]\n\t\t\t\tsee=set()\n\t\t\t\tsee.add(a)\n\t\t\t\tsee.add(b)\n\t\t\t\tsee.add(c)\n\t\t\t\tsee.add(d)\n\t\t\t\tif(len(see)==4):\n\t\t\t\t#\tprint a,b,c,d\n\t\t\t\t\treturn 1\n\t\t\t\tk+=1\n\t\t\tj+=1\n\t\ti+=1\n\treturn 0\n\t\t\t\n\t\nt=int(input())\nfor x in range(t):\n\ts=input()\n\tif(fun(s)):\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"2\\nababca\\naaabb\\n\", \"98\\nrf\\nqyu\\nfjk\\nyqv\\nrty\\nfr\\nr\\nxxxx\\ntttttttttttttttttttt\\ncccccccccc\\nrrrrrrrrr\\nllelllldhllqrl\\neoqk\\niihiiiji\\nssldssf\\nkkkkkkkkkkpk\\nffffff\\nkkkkkk\\ntiez\\nwnwwwmx\\nqqqqqqqqqqqqq\\nyjmub\\nxxitx\\nsbotwrhxr\\nsxflbw\\ntatf\\nbbbbb\\nmpljtppbx\\npaaeiams\\nqqqrqqzqqqqqqqqqqq\\nyyyyyy\\ntzqpo\\ncudmgih\\ntydthfpdbplvhfwh\\ngbgggvu\\nv\\nnqmjqggwuy\\nnhnwvnnnnonnebnenxc\\niinf\\ngpzopo\\njjjjm\\naabaazahaaaaaaaaa\\nlgbbbbjbbblbbb\\nlvyclae\\niiiiii\\nzzzzzz\\nadcvagax\\njhbtputtusgvixvb\\nlezbhrb\\njzflysjkonjjqlilqjl\\ndxjxxlx\\nimmmwmmmsmmm\\njjgrjupjj\\ntttt\\nwdhmmhkohbum\\nxomsmwjpxxnsxxhkxx\\nggggcg\\neemeee\\nhzzzudnbm\\nboodcynrdvughymyzapp\\njjyjsjjiwjtjjypc\\nhhmdhh\\nyeytyovyyygx\\nfdsdeuddg\\nrzvdarzu\\nbbbbbbbbbbb\\nyagf\\nkkkkkk\\nuptqsuka\\nh\\nkqqqk\\npeleeeeeeyow\\nre\\noqir\\njjjjjjjjjjjjjjjjjjjj\\nxxxxx\\nusffqhy\\navvvvvv\\nawxaaafw\\nddddded\\nirivlsbblgsyagy\\nffffpf\\nzotsggwjtljs\\numofuyzfzzxcbkckloz\\nwipvjmjvojynhjbwduys\\ngxgfrh\\nkmmetym\\nb\\nnkna\\nrrrrrrr\\nazkkk\\naudeqwad\\niijii\\nxxxl\\nbcxlcm\\nbsmnbn\\nivhghfhl\\nzysfub\\n\", \"100\\nglnnnxnnmkqnagymndnkbzntnnonuoooannctnunwarxnwnntnrnnnnsronbhnnnxvvnnkkneibhamhbhurnvnnvvnottnlyvwnnyamnnuzghnnlpsnceunslpnyakubnpfihyhzybmuurhymlmrxrgskanvwnkrnnwuotnnmipnnnlacjnpnkojgnnizdrpscnqnynbnjnvyrpmnnzjafuuynuiznqnnrtunpzrdsknyrnnnnnhyynvsenukyikxnyqtnimnioanstshnnunmwnfwmjnkxreevtennvnnonnindbnnniqxkunnsnhxannvnnyknnnnnfwonqv\\nstqg\\nhxlxxdyxxoyxxexvxxxgxzggxuxxyzrxxxxxqvmuxyxxllfnxkscxmogltfrvxnxxxxxxzxxxxcxpxxuxxcuxxuxtcxdxzzfwuxxpxxxaxyxfxtkxjjxahxxjzxsctahxxhxcfxrxxctxsxpxxxxybwnxxoxrcjktxixxmxjxwxxlxxuxxwxxxxfduxjxgxxihzwxygdxxcxgkxnxxxmpxpkmltbxaxxiwxxoxxgpivxdrqxxxxxxxteoxdzxlfnuxxxtjrxxxxwqvzxxohhixuxvfzzwxpaqoxyfzxnsqidbrnxxxfxxxmqjxxxcxxyjvoxkaotxxlknwvnxqxhpxxxkxxyxpxxxxtuitxojidxxxtrkbzxgocxxxklxhxcxsxoxwfxxlxxxxxbxxtxjxnfxqwauxxhkxnzcxxfqkxtuxttxxxwlqxvtxxxlkfxdxxxzcxsxbxrxxuxxxzxzbendupmuexxikxzmfwxlwepwsxkqxxajxjqxxnulvxlxkxnuxxxxexqmlnxxxxpqxxqxmxsniautxxxxxxxzexxarfxbxubblxxgwjzxxrxyxxwndpces\\nffffffffffffffffffffffffffffjyfffdfffffffffffffffffcffffffffffffmfffuffffffffskffffqfffffffffffffffffffffffffffffffffffffffffjffffaffffffffflzqffffffffffffffffffffflffffffpfflfffffdffuffffyfcafffffffffffffffffffaffftffffkftlffpfiffffffffffffffffffffnfffffffffafffffffrcfxffffffffffffffffecfffffffffffffffffffffffffffzffbyfffffffffrhffffffffffffftfffffffffffffffffffofffdfffoffflfffffffffvffffbfffffffffffkffxffrffffffffjfffffffffffffffufffffflfffffafffffffffffffffffbffffffffffffffbffffpfffhffffnfffffffffffffffffffffffffwffffffffvfffffpffefffffffffffffffffffffffffffffffffffffffffffffffffffffkffxcffffffkffrfffyffffhfffffffffqfffffffffbfffffffffffmfffffffffffffffhfffffvfffffqfffffffffffvffmffffffzfffffcfufffffffffffffffffffffkfffffffffflrlfffffffffffffffyffffmffffffffffffffffffffff\\nfffj\\nbtibpn\\nbjpd\\nccacc\\nfdfdwwfenufffffqgtfffxffffwffffwfffbfwdffiffffafffbfffdufffzfffffofffffffffftfamfffffsheffbdfffnhkurffqzffflsffcffqfbffffffffflffbaffupfywffkffkfqffcffhfcnfffrarfffwhfffrlfcffvffnfkywfffzqrmqffyffffjufhgnfffffffflafffcdwfffvyzfktffrfffqtftfffhffbfsffffoffggfgfpfhafoyffflpffffbtifyvfnfdfffznffffifgnaffdffwmkfffkfgfffwmihffmfnfezifffffuf\\nmrormmmtm\\nrxyggggdhtbhnygnhtchjsgsxgiglrtsigdexdotgroqdghwwggyygghemrrwbbhgggeiuwqgdswuggojygpglaggjgoohmggjjkoumticmmgrxaggiosvggqgtgcxkvizuzaycbgdcgxvigjafgbvkzygjjgtidlkabglxigjggpebrggjagzgogzfmaqzliggubdxwagsqqzcpigiqgwrzfcqogygezgqbepkbsgciphdqghlvriwagghgagfraeaugsixzxttqdrghhgggbwggoqqyboldmwernnmlmggmwlggggwggvgrxvgwygvceijgrdgggcfnrnafepgnmmujgqtsfngighflgjggarg\\nhirzan\\naaaosfoazxatmjsaaafivaaapaaaocvauudkzqajsgacjgapaaabpaagavzadnrbbajaxajaadbeaaaauaamadwuabzecglwphjsjaaaaaaaldrmgaasbdabgfamaalaygcahlaagtkakazldqaaaaadalnaayaaaajapopdwzaeoianaawsaaaaafwadskaprybjfxvknniwmmaataaoaiavofoaarnarejacgpsdaasiicanfaxkaacepboibupaaaibkvabyaatfsbuxuraornifbggadzuawaalhwarvkykaaithtpwkclalkeyrogdxarfav\\nolpzqmlfzdhadgdhltglxyodmflalvscgbcelpgsnrlglcmkjzvthauwnhwzvsiczlldsbzrgrxxllijwgnnbxybialedkxjxpjybwklhfxaoqmlprhwcglyhmktahjdjtlstsyxvzuywwyiq\\nyvfpa\\ndkrflqnfphcyneccqvpyqtgcvwjdeplahvuzvkqwovlqlrqpahdpqbupbjjikeccpdpnqyccmwofdxffbtpdnxblyrxhkkngacdequmdqecjjmpngwnbmorzsovjoxqxshudnmzgeegpabpwt\\nbznjkluhlavvvjoqaembboflmqgcriglonzhxlqpfmtmhflbklmijeyylzwfljltcjzuisezxtvxantpwqvillhlpltlcvllrpjlryciamuorrvxfhtmmoslnxufmttzvaplecollamjsumsehlelszyylkccqfynqafvatlgeelppyfgvfinaflmazlhqlrtkizkdacwlpgwpthuyofpvzjwnwborjodlxzvrefyjpzklzvtlbqcijbzffhwogxeqkcxlkxfycdgighlrbldhfflwtjocvrrqlkejaslkypknierujdbnlstyjllolelhscbidldqirxhkxhellfmjtvlorlajdlllkllmlglwbbaiakkrzagllngrnhpeylrlxykeobhwwluxzaraltyzlzgaufllbulhscmrkhjulbrimkdalnelwnoqfbccwznqqkjzlxklschgtzzfadcdkbkdhktqjczsotkmotgnwrbwgibgivzqppazvmrcflkpnchdfisvlejjcqahehlfxjrlhdysbvtlselviiufogffdygwvjjicygvitgwclbhskktbdwpwtzfzwbykuxhxdazxxwgpugdloqbeeblldrcsoltfgfbxquzasplhfulnhoafmawxjreiolylzodpfvfqlcollflexhwvafqojcgwbjrjlpdvnpwfeulvmlblwujfppwlnslwxnkwollralzpobwawwmplltilwmzbpahcrclqmpflszbtienpobvlybhvozjoyxpwdinzllnlehllhkq\\nyyyyey\\nlilh\\neeneeeeeeeeeveeeeeeuegeeeeeeeaeeeeeeeeexeieceeeeeeeeeeeeeeeeeceentpexeeeeeeeceeeeeekeheoeeeeeeeepeeeeeeeeeeeeeeeemeeereeeeeeeeeeeyeeeefeepeeeeeemeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeetxeeeeeeeeeekeeeeeeeeeeueneeeeenmeeeewoeeeeeeeeeepeeeeeeeeeeejeeeeeeeeeeeeeeeeeexeeeeeceeeeeeeeekeeeeeeeeeeeeeeteeergeeemeeeeeeyeueeeedeeeeeeeeeeeeefeeeeeeeeeeyeezeemeeeeeexeeee\\neeyeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeyeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeneeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeyeeeeeeeeeeereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeekeeeeeeeeeeeeeeweeeeeeeeeeeeeeeeeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeoeefeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeereeeedeeeeeeeeeeeeeeeemeeeeeeexeeeeepeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeegeeeeeeekeeeeeeeeeeeeeeeeeeeeeeueeeefeeeeeeeeezeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\\nkkkkkkkkkkkkkkkkkkkkkkkkkk\\nmmmm\\ntuggrgoxghgwhyonjycugpgggewqgggrgctmggglgaggrldcqggxgbfggxgqgmgvsjggyggvcngiggvlzglpggfrgggggigdygsrgigugczggngtyggggoggggfbngggifgadbgqgggkwgozgggqgggggglvjgdggugggguhwgucgdgggfhrtrgsbgcgdsiggdngwytbghgkggrogfggfggcebjr\\nwbbtitzng\\nmxzdv\\nyztdttkjcydxnhkzjwuapgusnxltxufdpvimnqtyueztskqoqssuwkcldaeuaednvqnxqbwnozsybgcrharzxoftfubyqvidnpfwtoeysqhtawnntrghsogbtavpgixsxostfbucndlsqifqjfnkvhn\\nymvfnhlwlzvldsjwfliwllljglheltlslldlzfalllhxnyldxdlntlllqolblcqiqllzgqlvkllllsllfpsybe\\nuuuuuu\\nifmzmmdkdmojybropqrveevyzrixghamokueigbsusdzmqmqwcoizvtahebhfaenrnmmvmmzgbjwwuqwebfrhinfotimyhrqldmdkcusxspbhmybgxldyyixpuooxxjrffidqtmicdfwqolpptvzemettlrmbymzgswbmyvnmjpsmddloahinmgdmczxwkwbbwqlsmaemcbimxtimumzjdmeqpemtzoycrynvivyymmnohstamnbgzryvopillapqfdrlobwtfelaovutbhheqkwrrgmdyvtbyyqtsbagzmoqmvjmxmcvnmnucmssvcdilhspmpnldcdkaamawxmzxygzmiljmzgyzwmjemxolnnaqpmqloqimmtxeukginjgmilmcxufsnlfdvymhhleuwtweylwrmmshkziyohedwwkspgmnxzjdeoqhamfdsrdcwrmamuezujmviveihqihfccxdtamnokoylxxrnaivanbhjmivddnwfemfezukmjkhakhhstgbletidntwfjkamfmxiimqcgulmkbsydymcuwzmhpprigllgkukfacsmntvdfmcqwsannyvuimwmjnvmumzonhnxbmvmsbacomcfagtfzrausemdwvdmmeyribfkzpjsikmrgfbwmtccrmnxarjlwwsiptremyyopfmfcfabopwmeondtkowuuphjmqrmmnctvmdmdomjxmzzluwj\\neopjtm\\nhhhhcnhhfhhhezhhhhahhhrhhghhxhhhhhhhhhhhhhhhhhhhhhhzghhhjhhhhhhghzhuhhhhrhhhhhxhhhhhhhhhhhhhhmhfhhhhhuhhhhhhhhhfshhhhhhhhhzrhhhhghhhhhhhhhh\\nietvaeyguthzahhtptzeegiubggfjdbtsizpdqgsvaqsnivuljuulmznhcenvrvmwntnawgckcfcsrbheftocvtsfmlyixlithkntdhtzyztbkvuztdtgkzlixtbctlisncfhlmbjdaceapqnsonitmuzuciaixgeyjbabmuguhbzvpstemkrqburuothwsmvlivdjymvofirtvxfthutwjaobmwsztpynchsqcpsnfcutikdenlwppkihtrrkadhqtgzmbsncytvdtpuzwnbdasxztuxpjhemistqdbctyhsxaohhblvvboitootdvtlwjexlaxejwtlyheptjuyexgnjctovbstmktarrhckoexvccxhutqlgvqdaimmbtwneezjoonlyvrvgtkvtrystfetqgegxotidmoentzzbfhicgthurnhsqtzzuvrakulwtyboptzjyxuwjtdufgolhwdqhmfvlpbomjdmabngnoztffjztetsqolczbxpqpcvqurnthuqqtcrhblrmqunswroxodfpptautnzfpicqukstdbggoaysvncxusvdtmwwhaqeitjwqatomeajrmfxotznmgdlywgccjjtctxydyljtszedtycbcvjsnxxhkakvddfmritdtuptipbjwttwafbnzztdfcbrkkxqtctazuuxuhzpfyetwmzurrzadaxtcuzghnqdlscfjfzmgznqshzryhhxoawmvqnxdpylxirvwjusljmteomrwpolrsgntnlitthnyqyaufdpdhjsotpbxflnjijiadmfaoizcfzttrwnpbdpl\\nsfbqcyzqhrhbbbtlvsdgljvccsghr\\nmjpegmzhd\\npmcc\\ntutttttnttmttttttt\\ndddrddddd\\nozllvcon\\neeeeeeedeeeeeeeeebeeeuebeeeepeeieeeeeeeeezeeheeeeeeueeejeeeseeabeeeeeejeeeeeeqeeeeeeeeeeeeeeeeeeeemweeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeeeeeeeegekeyeeeebreeeeexeeecweeseeeeevehaeemeehwceeeeeeeeeerieeeeekeaeeeeeweekeeeeeeeeecuaemeefeeeeeeneeeeoeeeeeeeeeeneeeeeeeeebeeeeeeeeeeeeleeeseqeeezeeeeeeeeeezeeeeteeeeeeceeeeeeheeeceeeekeeeeeeceeeekeeeeeeeee\\noubbqo\\nmmztgekqmmmcmmsqmxmccgpzmfmmacimrmiuwmmumjyaeyemmrjgmvkmycmommyeammyytjmmymxmmmlmmzmmnumlmlspfmdhikmjmwimwkmydmmhmmbrtmmmurjhomwommmummbmymjmzmhyijmmqdmmmmtzafimmgmmpommmjmiiirgmbmclysvlfxmflmmmmmambttjfs\\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzezzzzzzzzzzhzzzzzzzzzczzzzzzzzczzzzzzzzzmzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzgzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzzzzzzzzzzzzzzzzzznzzzzkzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzczzzpzzzzzzzzzzzzzzzjzzzzzzzzzzzzzzfzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzztzz\\necol\\nbbbb\\nuuuuuu\\ntpsynnnnbmpnygfohtkngnnabyhntpqgnnqznnorumyztbjwnpvnnhnnnnwppnqnsjndxuspnqomcydnejbyhpuxevmnugnrsnbidcnnnnysnnnnkqtyabhxwzndfbnzwkbnznnnhxnnnnnlkxleqjngcnclnyabvneamxvxvnftnbnyfnnngznnkwnaapnlsrvngnivxwnnnnwbnxomemynnthumwinzijxnfycmsnnfnhthxmxjofmcgpnmdcnbnnnvumvononcnnnvbqnnennnnrfuqtstvnnbtnnxivbbnjzkphonnbdbamnrntvrpar\\nabaabzassflujkaazaaurdaqfepucabhanovaohdaravvavglawctabstsyarxkaragangfkafhuqaaachxafaywaavazndjacwuopdhfiaawotwailaacxfohaoaadpsnaxjhchstactpubadaatwarbpaaabaasauaaueaabaacxgafuzfaagrzalwakavaufldixatxhyzaapwanakfujavbaawgacjqkobrijqjcxlknntzoadacuakjptfaraymmmarmarmaxagafcigcajtoxzaaaaaaafxfnjvaagapazbrtvlbgsbhtydnwanmgeawzelnbfjavoraarurkavxazwjlmvehincaaaajakdatpsnaoivabczaaatawd\\npxfxxxomxqunxjcdhoenxzxqhxxkxzvixyvxkpdy\\nddddddddddddrddddddddxddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddlddddjddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddzddddddzdddddkddddddddddddddddddddddvddddddddddddddddddddddjddddgdddddddddddddddddddddddddddddndddddddddddddjqddddddddddddddddddddddddddddddddddddddzddddddddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddkddddddddddddddddddddddddddedddddddddddddddddddddddddddddddddddddddddddddddddddddddd\\nfdwzawna\\nkkkkkkksk\\nibubbbbzu\\nhhhhhhh\\nddddd\\nmgsdriztrvfhzttfjutttiyydbthtwmtlheltaslvdrtwrbftltttihtznqlutntdvklfhmfqlqtyebqcqjtyctobvrwmzymsxgjtvjykbtpduetfxwpggwjrcrzstmtqbpmtlttatjyntgxbcxttbhtttdyggppthtfgutttxbaoemotffgxrssztturztszcrntrcuhbtlttatfvbejtlvibriwkhzzltptglafxetaveivtbutttatncuxtkhsjitgwagtppsayatxmwhtllttcpahtbzvujsafeogcewztmapteukkttnastsjvtlftnrbiejtqpytzxtvlgttwzxbblzytvdjfofirjeztojzdsvnaxuhcvtutlgdzvrcpthttbxqtutubujkojcnrtxztetfhfjhuetwyrhevrfeaodtitoyretbbvcntwhjpkykmjkrgtijocsohtwcbkztykttctifwatsctqvftctyqldruqburztbttztujttwtcbkpttgcjatttqj\\nhnzhcyh\\nnjqunkmlivsnuissgugqsbvssjfspsjkdsplsbjshicsixscsfshsoeozsrsssotspsyssqgssgdpwsolsxbisygclsbvgssjwvosstqhxusqpsslkveqascbsaqswyspjyepselssszktfzssiasqzwwwsscslxtdgosshuzsfsykszeapavusszghcoivposbuchxpnwxgsrssezcspssszeejfxbsssghfhselosstxcmubssohvcusizusgvsnjkuwssnkqqqzrssssssqselsfpjlnfavslhwrsdsuvxsyfqgsshssysjkussassbsmycvtuumastsf\\njasqaqw\\nfxzfmffe\\nfnfrfvflcnkoyxfyffotfgoclkflsnutuqxhvfwfbdfcfhfidbnfgfczfmnfftnfxafflkezfwajfrqnuwdvttgngjobnfjqpmfcfzfbfoiofkwafvfdffifxfemfdfkzrrnfzqwfeoftfzloqfwobxitjetfffffvfxiffcfjwfgpkffsoeioojfkfwfremfioftffauydvffddfquypymcfxfigfthfufmffsfufofflvvkqpbfojhxfnmvjnffebisdhkfpafgzrlbvynqpzusafffpocyfxsfxmwagfwaxirhhcrfvwyofvdglybfiytsahrfxuofofffflxftgheiffsefaxyfyfqfxncwmfhffnnmfucffjijlfqvfpjfzfohfrfofvxwwxzujhiibotfepcyvfeffshxueddetkyyfuwgfffjfusffepixlykufxwffhpvfxxmdfqpkffgffffyrfrlbjfwspbfhvsfinntffdqarncoffbytpefjhfsfffknbffffuwfxlrfiffxefmifazoftlllmfufwnfyzusrfafimafdlswnzfsjwwpflujvqfczpgbfibffptufihfjioievxagmgwfpfouuqvmbuyffzfffkfffciffifeffswcfrslqbffuxftmusjsffyfffkyvbnrfhfafsyqvfraynnfqjgfnttafnwmofoomfrpcjkfcscsfqwugfdcfffwkfbjpveafaauwwumfbfzffffmflsffignsedlfazffwqkfffliygflhlflofifffnjwfqftfpvfrfedfffxfzvhfxzprsmzfpjmfgvclfowytbffpfhxnrcfrfoffvvgkwlijkykovfidz\\nxtqcenginbeqvybexvuezrmlxflwznvjoiuadwmicyqjieltfvtwljefacemwflfbqrznzeegveaoqpkyjsletsbcoecebocesbcngmvmrpubegurnnexrsyuwpyftepimaauderfsotcemheyhkofcpcawmdbemzgxnvepvticnsemybankdndujlcwniqewwigxejvlslxsyhxxeitetrowgftotnbcylfuxakftjtbnpykmlbesxxgflacegeuxmezimuoxuslteaelcpxsbmenbfcpugeavcqneigourootjkbqcjkyiejxecoahfjeevzbtxiebtqgwdhtwdmphicdeezcrcyayzqbenhddraukcjleumemnnecsejzehegdbtebarmetdoxufzwonewwdmtoxmiqeqhtefoexpvvdwceohvzmkrubxcenzsyqkxzzshmlgpeikfxsfvdmhgvjhkakosglqekyielaezvpmexxzbewedbhfreggodjempdkvxwe\\nkeelkkmhk\\nwwfwwwwewwzfwwwajwpcwwfwwnwwwwzwukwwwamwwwwmwwwgwwwwwwwpbwwwrwswcwewwwywuwwgwqwwaowwwwpmswwjwwwwowimwwwwbswwxwxwebwowowkqwwwlwwbfdwwwwwowwwrwwwwlwwwwwwqwwhwwwwwwwhnwwwwupwwwwwiywwwmwwwgwwowcxiwqgwwbrwwbwwxawowwwwwmwwwwxwwwwwwwwsdaiwwawdowbowwwbmwqwicwazzdwowtwwjwyeewwwwwjwwwswwwwkwwgwpwdxwehwwwwjwwwwwwwwbwwwwwwwwwwwdwfwwfwwwowwwwwwnwwmwwnxwxywwswwwjwwbnwwwwwwwwvwbgocwwwwwwwxwwwvwwwwrmwwcwwmwpwowwwxwjwnwmwwgwwwqnwwiwtwwdwhwhwwwwkwwwewjwwwwwwgwwmnwgjjsoykwvxwwgwwwwwwwwwwwwywuwztiwwwmwwwwwwwwwwcpwwpwowwwwwoiywwowuwwwlwwwwwwwwmlwwywlwwvwwwwbpfwewwwwwwwwgwwwwwwcwwwxzwwwwwswwwuwwwiwwwpwwwwgwwlwwwwwkwwwwuwbwwtwwrwcbmujwwwwwlwwwwgwwwwewwwbwwvwwmwslwwbwwlwpxwwwwqwwonwtwwwwwkwwtwwwwrwwwwwanwwltxwrzwwwwwcuwwjwwwwwwwwwwwwjwwwcgwqwwwwbwwwwewgbvwwfwplwdwwwwwuwwtwiwwwwqwiwwwwwbwwwswwwbwwlwwwrw\\nkkkkkk\\njjjjjjjjj\\nbfcsbifbrnchqcdgacibciuvccfcocodorzkltevnyznzcieohirccdiyccisckiccyshywrccacchpctziphmcwfcucmwcscccciiglxvzccculznzfcyslmxlcxbrgcdlvrcltmestccwcpczxxpcvahccgckbfccbszccdvdaqvkociqrucagpcwczrrkwlcahtvctutcclugpxccsaeoeccccczccnudmcgcbcidkchtzcmhclrzcsdrccbumvcrjmcccdcczkbncstkmrrccrucucimxpzowcvvcgjgotcwmcckyinkueccrbxcjqnnczpchcocscfxsurgwnixcjzckvmacdcfoxmytctucdbtcjacfcibwhcanqccunqccccclnktccmwp\\nqqqqwtq\\nimagujciabtygjtppwqvrhytkqnrqxmtfqgiquovdamglwmrlqqhncfqsjqsuzekwnrxuqltzumqvyqoqqpjgozykltovjobsstchbbmevbaftnidckoiopqrykfbqgvospkafuqszneuzdehuwrqdqdlgdgcvqfxqikwyqxzqqfaryxccgmqwvoqftxfmktqeosyyokiahklgyljukpsizqanhxdqhqqjnzjxqsfrlpjshpslqhaqsqezrhpdhfkqiuyqapilmyqbeumjieqbmodeamvrzamctzmtgnajtnhqavlrccuvzhmxtfocifvohlpxkxyufbewpmifkqpyqhsdbubhyhzjavezhsaazztlhpqqqqbmlgcvjzhlsoogjqhwvzqzmyqiytemnqzcjaifwqqtvwnnvqozmiqikuptlhkzwqwurbqajgijeyjdgfvljyebeerybnubitcrbtbrytqfcqxxtdqihiupqoovffmadrinjqaoiwonyikpqmbclopaydtxxfadvphtqsxdxuilqdkqfmqjxtzyyyyundeapyzebueyjpnkfdgqwdeglrpudgrzhxzxhbjhwzgrxqkqgqsyydkixgsjoqvggqhhivtlfcxsbrqceqgajmhjbvzqcqfqgdpmmsrkwbzbqoioerwfdmmtynnqksqbmafoqzlpgdfhhvvxqsguwcrbzurroxtcbdkfhqaadfuekjfvbvadfevoidrundiujqkfjxjdubqcyaclpcvdzdfnowgkaqsqjeklqpjehyqojlgodvrabakdmwqzarqzlolkfazgokmqyqlolnibhkuglqcllvqzaxqqkbfftqpgqbewgkqmdubcxczstzcojethimpjbtyyvblclqyodkuovopktfwjxqbuxifeoscqfdrwodvrmfqagnrlnifqpo\\nvvvvivvv\\nccznrykzxmnzqbvzkcicqbfsmqvcpsiucarcefmcfczzdehlfjyceqsjpclmwcmeeiacdmcgflzwzdcbcyfpgetzyqhulacccscuacjctcghplbzreacnqdnsekdckntwjznkefjesyxcysjtocuvccsxstcvuvbnlycvckffjchnmzzcozcicqccwtcfiyrctxvdeujhcscwhcmxroxegccgsfpkyccxcafwcdccizmuwttcmsppkbmsmpjqhuqudeqzoqacbkuefpjdmhmyuwyeoocmfozxclkczccfcqvbccobccrfwcuaxicgchwlqisnpwhgwyzhplpbrccrmreoncmwpjurjqgmdckccwopjydgoqaycdccnckwccfckvbucccnczwclhfhbtulrciszncohkgovyckcsnolkmhcsccfmysmtchlxuoabsrdhvvcyceucwaxcqelkdcgtbcpnwcscogwcmtccumwdntckcacbdbqmzqcyapcrvacjnticcfwcqhoyiycreutcqculdjzgwctcvbxkvcbnxoobwgzdtkrmqchtvefcjadcc\\ncccocclccccgcccccccccgvccccccccoccdccccccuccccicccvcccccpccccdccccccccccccccpcxccccclccccccccpcccbcccbcccqccccccrcuccccccccccccccccccxcwccccjccjcccxcecccccczcccccccccccmccbcfcccclccccctccacchcgcyccccccccccccacfcccccccccccccccjccctccwcccccciccccccdcccccccblcccccmcmccccccccccccccccccccgccccccccccctcccicvcccccccccccccclccccccccscacccccccccsccpcczccccocccccccc\\nnpjzhkeumkswfwfobnfffzffmnlffhyvvaqzbkpvfmpkcffrijmcnwyqiftblfnrckieiqqfiyunyyfoegjeffjpvdfafpknycfqohbifhmssrgfzsffexlcfrkhoveitpfangcuwbgnnfmgtspzgffrafwmfdrdrhjlopheefxumxfafalgzrfevxtaszsrpffftkfiyfxffmfsjfzhknvmtxiapfkwrnuiicfediwkzvcbfffrhvfdfpkfyiiyidzwffvhagsdufyfvnbxtjoqlqaufxmgfhltwaeixuxwtxsjtcdtmvkcefrbfxgtvhdyxudrcuqfplqffwrqkceyjwwqpkuwyjwglquoxrjcjerffrfnuefeffpxwtsbggldskthffpkvenswvfsvrlsogclqtegfxouuzrlrdwdtbrmzgrxvsrsvpdrfkandffloszitdmzfmjppkfztyenhzdfvslxhurbsoqffkalfaszfcyyafwknbbyjcqhezrqheazcluyncipdahygkrimqfrcrmtxcczjgbjffsqimwkvfhyfayrfovybreogjfudvcnyjkmfvuhtpksdzpcfpcokfstgszfcgyuflguhfbjfllmfcmfxwblxketurikvoaiefzzqdamlpffjcwxfegfmkutehfeamwcgrdrugxzmongvftffedslfwfbewpxqdjqafmqgfmdjreuavjbfifrzqfafotfzvfkeefukzaanzjkbvsruxtzfffcffkqvqvsqfaspdesrfifodustofuilqblojvmofnfvifdoufnurvgsaspkkkgglfvrclksbfrypwusfemoagfbfsedfaqrbskmfkfrsfyttkfrohtwf\\nfmjcdn\\nntzlgloekatjbpkeljrbclwizlmztnwdsvjdslvvbpeipflllstxlhvskqpelynilqlzzdjipudlyxoljxkoavpllolbzjfyzpmbllatlnugllxlodnqqamhaznghowlnwaufvtqzblglmlxlezgpkllyblbamhdfcvqwokwylelbhatljxhlzzusqlkliklzyobnlnkbkxlogzntjqwqlylfgrzylckthlfxmxglnlalboqrqnepdnzragxlqslllyulalblydvwxvkljlprnkgxrpkoagtshpbosljlsmxcabwuvlllrltmbdmwollrpghlgjyslsalpbzvgqlfbzahqsllcasbqljugplmwoilizlpejjlhxkmluafsotaikchrwepqksqnflkmmellvaltvignualbajlmgzyrldnhjvlzkqvgdnlglozfnirilzyynisejtmfuukzxiqlgfchzzrtbntfmlkwgjwyzaoxlxaeepllrjllsgfpkrllylklsyzycclizvkdhllqldktevlbgelqvzdrdelmnrowxmoohfekatapnvlhwsxltxalidepceblwpznmulmwovtxxcgbhurjkponurihwfushlnlqjllllzylnlinilbnwllvylinlctalxlvgltugrcpbtzntelvlrpzzghbkialboglamcdlhlrololflukvnzuynflipddgjrsldnklklnlsgoullvvvgcwrklseotivwlgjbfoatskcltbzlolmglnpqpvllhatuvlwdqhkkhfzwidkznlkflsfwlryyeueldklpnturqksdfocmbczriqlghlyayoollbywnlrvsgellzllcbsfbvvglbpogjxzplewgwlvyllecsuuakotemffclvpzudztdnfhmrrluvctelolcglmicqnqyqgutwfnjodpgsiiemlzprfejuzjhxeyiezjpl\\nrrirztz\\nrjcfaaaw\\nodaeyeejt\\ndagxfxxxxxxjgvxyxxxxrxyxfmxfxkixaxxxxxxvxdexxxxaxxxxxxxxxdxkxxxwxxxxxxxvxpqxxttcxpxzxxxxxzryvxfxxbxxxxxexgstxxxxxxxyxxqexxexdxxxxxtxxxxxxxxxjhgxlxxxnxxxxxxxxxxxxxjxgxxxxxlxzxixxxxxxxxzxkjxexxxxxxxtxfxxxvxxfxxixcxxxxjsxnrxxxwxxxxxxxxxlxxsxxxxxxufjxxxxxxxxxxmbfxxxfxhxxxxnxcximxtxxxxvxxtxvfxxxxvyurrxdxxxaxkxjexxsxxuxvxxxxxxxxxwxxuxhxexxxxxxxbgxxzaeqzxexmxqdxtxuxxsxxxxxxxxx\\nxvxb\\nyofasiyyxkyyylulsvpfdyywycyynlfyyfyyxpetyoxyypcnsyfqjyzouyiyiybyaynavzoynfyyfdyuyitybksyyfyeftpiypyyoycxyaylyfybylbtynaygyuvyyiyqoxfyykyuluyvydmxyyyyyyyqdydyhyyyyyydyqiatyxuvjyymyftyfyovywshyfyggrygysyyyyloybyyyylcyyhuzyymjayyynaynyyykxyyyyyydxymylyfftytndynyyyybqutyyygyyygknyeryanyebcygyykzyycjyyyyuyqyruvyorbrdyyyyosqyydstyfynyyxauskmfyzxyejzzyocqyyytblyyynyepyhqwovyxijjcyawpgeyyzyolmxyrdqyyplsyecqyhdyyccfyyeiwkyyyjycyyaneyafyhclyayxbjfnyyhiysvyatdcpuhyyyynyyyrkityyyicyyvqysyayoayyygoluyfmyyxesxotyyocvyywywiybbyheyfyhymypyyyzyyyxxyhykyyyltylfuyjyyflykryyijyyyyyuyyyuijepyyuyyrehnyiyyyyctvygoixyackycyyyovyyqkvnyauwyyyytbqxbyrztyegyyyqslgwdpnytyzyyqyywypyyyumayanpyelkdselfygyyksdtioyygvccyywybyiyyyeyabyeyyynymywyyyltkomujyeylldyqgfuyacytyybglyyitbkmyymrzkbfyyawyfyfyyolyyzvefyevyyyqyubmhyhwfyuzidayytpkpcxgbyyqyyynypywayiyjmckbhjyhhcsqykqnmbdyvmyypbyyonvyyylfyylykyfyyygwyyyyaiyyhny\\nwiioaiiq\\ndnvraduomyiyqyrgbxdpbyyjpzakmdlcytqfjwxpyyytzfrfqpylyywfmyvasdqhbirnytpeiywmyjjiyxavrsdikgzkdynfeyyymjueutyyqaojadympysybqwctrqaiyadkmarhmlyetyykdbebbntdssfmjvzleuycvrghfyepyyiilyaqikkwptouzteaaqwsdxsoxnjvydjhpvrsayveyhvnrlfyfccwuyyutynchsyrhnkjrywpflxyuriydyypoxywnhfxmhujtyyxvymzwyyyyxdtezjymteipiqjgewzbzyjzyayjfyyicygrjgmyyylyarhabwgyyyebotwquyqguyfoxpkyzhqsfxqgzhjkzbdylgqyaizxidllzsoyedflhlqhyytghaabjeegoxyjlrwehxaanmyreynxysptjayhojibry\\nsssxsissssssssssssssscpssszsswsssfssscmsssssssysdsssssosvsssssysysjsvsssscsswsstsassnhssesssssssassssssspsseswsshsssqosvssspsswsspssssessssubchysvsssssssssssssossusossss\\nmmmmmmmmm\\nahhllhhhhhnqrthkhhfhhhvhlihhhhvthhhhhrydrrudnghkhyebhhhyhlutbcdkhhhlhhhkhwhzxwaedjzhhxhhhnphcyiyhaxhrhegddhhejihmhhhpxwuihavuzhabhhhhghhhhmhhshhhhbhemhhidhhghuhheuhhchqhuhhfhjlshhhhhhqhmzbfhzjqzvhihhhphtjvhhhbrhmhhhvghpockhafqbapihhahkpvhhhfouhhdhfiohhshhuhhihmhhhhamvhonahhishmhhhhgbhwowgphkhhkhwphpaglhghchihhfhybshwhhzhcuhhyhhhxelthhehxhxqwhhhohchrsig\\nskjgggt\\nusgvevbxqhvovhyqvfvvivwfvvvvvvwqvgvhctvzvvfvvctpnjtqtzvrdvvcvxyvvjivqrxvvxxvqtibidvovtvvvrhfvkvbksqfkqvzvvdlvvvavlvbuvxvvxsqvvvcgimveavvvvvvvvigvxxtivtgvdtvojvbvusiheypftvvguvuivvervqapxvwdcevvvvsvavjvvdvqhys\\nkooajajuuaomd\\ncmdnbya\\nrrorrrr\\nkhjpensjjjjrjetvjjjnjsuijiwjnqjjedjjjvsjjiobsijzbjajsjmzdcjshg\\nymqmsoxim\\nddcgkrdad\\nhwmlllyllmlllnjlanvmlsjalizxsltbbbwllgllslllllkalleylqkcwsqqsllglllipvagerillllmlllllvljelllthlslcllsljsxlltlllllwllcmlumllglllqlluwlqlazsljltqlllbhllzlllllslltblpllfupdlbtlbudlbyklsloulclxlvahllliytzlllllulllrllullollllsldidlllnlhsllplllllljlftlgvmqqrllqnllllbllfrllllclfuollhmlljelzlgrlllrluyowhldlllllqcisljlcmllloaksyllwllcluwsltlllllglzmuwlqplullbkbllfllqkzlllkylllljylllllewlllulilllllrzllllxlzllllllhlllilkbrlisludlolelylllyllknllbqllllyllxshdlelhllfltlellyllxzlvlvllzllllzllwollplulllllfeldelwtl\\nlqnughmcm\\nufdzr\\nlxllqwcllkalollulmllglxlllljlolwpllulelvllllilllgcllllkalhltekcekllzlllbkkllllllivplblalldlllepxlnlllolsallllllmlselbelkjbllltllkxlmaclgnlslmllllllllnylhnrlallllylllofegaqllzlzqlnllflllqlcqlsylgcydclllgllplullkzllqllyrilllnlllznhtklclxulnmwlelplbtllmncollllmumgllrllllllfllolfllllyltilklqrlmllhllldlnsllolgzwzlttblxjlljhnlyolnlljfllmhlllqldlnzttllolylloneeyllutxldlllflwlzlolllpllqalltlllbtlmtlllvlhlwlohyznllhhmlllllllulllvqellylnlclllslrlalbcfybmalolxemfalulglgsllllsbclollolllozlllmhrlxzllllllbellyllljlqlllllllzxlllhllbncrlollllllgllllllbllalllqilxmlslllcllflllvlmwqlllelllqunlgllvsfyxhllloejlelplkolgllsvhpobztiellbwdtlllsllcllklelmxllmflbljlllwllbllllsylklllclmllallllfllllcfllnhgllhlfjlirlhglllelmhlgldbpllflxlalxlllllllmqllllylltllltaewlqrlevhlllllllllxqmlzlhlltlaillldllllxlqllkljllllllbf\\ndwnbwndwnnnnnkofnnjnnoeyxqnldnnzahnjqphdqncnaitwnnnnnpgmhnnnwlxffnugnmonypunwsnuniwnqdnqjonnnibnnynjluffkgvbstpeurdnnnnnlanntinnnobjhahznizhncnnnnzniccnnnnnewepmrxsncxfncrurpnnqjgnnjncnanenmnnltnoninyjhaainnennndwnnofnpuwyagriyuvnnixbnwinslnvijnndubhhnnrqjkjogdjuejonnhnnhmkvdlnwgfhznxnesnnennnnrngyewenu\\npnxxnhrxw\\n\", \"100\\ndjjyjj\\nsjobzjv\\nwigagh\\noeoo\\nejcoqcspq\\nqogr\\nmqhqf\\nesozrwzapszjzanitzozzhjmyzqejlqszzzvrqzzwlzdzuvzfzzzzxclkhbdlqwnzzbkzfzqfoezzyovwzfbzulzzjzzzzzlbzyazdzxrcmrzluznzziozizsnyuzzzyzzszlrfzdzazmzzvagutdlzzvzymlzbxyvzmzjlvzilzwzymzznypzzcmzzqzzczzdmluzizkexzzxbzzkztzdghczzpzzfuzzxqcwzzpyzzzzzyrzzusczqzzzbivzhvuvazvptzzfczsxeiztwfyrbybzzyqdrzzkzxjtjlzafpvmypzpzfkghqmjipnzgiuaavvnzszdizjlfizrhnuzdhtzpvzqzzzvdzmploznwqzwtzkzncglizivyzjsnzpqufhfcmzbrpzshlrbdvznztxtzszejtwxrtyyzcuzzhzvcjhixukvzdzyuzkmazszziazdzffonlipkdzepzwxizksztewnzuzuzzcnzygunezxszplvuv\\nteeeifeelpjelhhmxucucesagetlezzeljdeeseekdoxlseefeeolmlgyexnerdfhekheeoeeeeelkueqntqpjxepoohlweiubhcfelreeeejoekgfmqqteeecpeyeweveyeeohoepyeeeedsijeslzfqdsyzeoecuewgneiqemefxuhngpberzngiceeuzeeyurmeeecyeneqreeezujeebefdegwyieedmekwdeezpehbsxuebojedeeovkekwjvmgeeeclgldotyjevtqevderlscgdlvxeotpvytenedoyhgzeeerkeyeiedgepdpuewqhoeeuevwxsfeueenbjeepereeeaqheibemfmeheabeozlmjvfjeyeeilffeneyveealhxedeeowxsjgnazqwoedjlgkeuepdeoenbxsjoueeyhvxcrbcwprbeqejcekrkknlwugegeyeaxdeedntdvehheqrsheevjnwewejegmqyxjcesqheihojdmugbhgeqldcmgxbqzedemdhdeeqasqeefefotpxjiceiqbdktqeedehezlmdimnepbmfeekvejefeeyelqojevcveqeouqttpzfxeqstpoxsaoeexpphbosqmjdeseeqbdkqbnxwzoheurbnergveepefeeeaizeenefjolyww\\nadhbrfzzodhyhhdnokjwocrhzpbalxtdkvhbvojcwjhruychhpcevakpodpoeehhjfvcvzznlhlqaxthvzmfffvhfhobhkhehcqvpftrhslghheaquxfwvuhuhufmdghvmhchhyhphhwjyhqhuhzhnkhcfhhnltwpsltafrehsxshwsiolahalhhwrcqhdbahaghpoekqhfuuewfbbilhphheocqlhrgxhxxcrhgximtjbgmhcfgokvzlduvyzaeohuirklskbikhhgksphhhulxrohhpnydqcxyxrbhwhhxrorhhncjszghiohhhqhquiamhxhuhyljxhhhhlhvjbyhghhwhehwtsjqiafhdpgnhfhucbykhxhpbtrwaphhnglhhdjfujyhhamhcthmhlntdhhzxlymhbghfqehmnpkdchwcbwvhtimehhyqpihpekjzphlustololchnrehdgrozhtyiknhhuaqzvdlrrzdzsvghkxlxeksyboaiwhiikchspkhjderajnmkeeheuqhprrbldhmrgrlwqzujcohhvqhjhhmyhjkbhxkxmfhiqbqwfweffoeadibohtvgkkhzauxhdhhocqjhgwphrudeuhmghbzvetafmfyhqihlnisgyrnjbyebaehmhhhhthwhihfshkhhkvvhbpxrqtdmanpkworeayrzhwpwhfjghhmfphhhhqgmhlhhbaagmahbxohnkgmrkstlwbcbjoufhjgmihshgrznvduhnwwgvhkgjtilphlhnzsxehnfutszwhhehcvamhqyqhbghbhhrvhkthpwvhxggdhiihzhhozscwzqxqsxfdnhqszjghhseshjqyhvaoqfxmgoyfhhopoqfwiwlpeolobhiuxjfkihchjfuvehhxcgbdtyldyhmhzhfacdyhoihgkhvehconegnoiefbgjcuiohjreghrnnyblfmcqycfjahmzertfdhczirv\\nxfbesvr\\nrdjisf\\nkkwkk\\nhwebq\\nhthehchhzthhbnqphhhhnhhkobhhhsgkhihhhqhthhzhhhhwvxohhkhchhhzmfehyhshekxemlhohthhlhjhnhhhwvsbjhhhqcjhhhhhohwhhhktxhhchphnthqtklhhiwhxiiehhshhkqhwhhhzhmghhhvqfhzrixgthtxhhbhhhhyllyhhhphhchhhhhazhbhahhulclmhhhbrhocgvhhhqfhhkhshrughhhuphlhdthhwzhhmhhfhhqgcwhhcuhqivsrefdhhbahpcjhhhobthshwsvhhzhhhthhhhlcuhtrxhzhmhjhhhzhhhytfhorkhahhhkhehqhdhhhqzuhoclhhhhhhhxhhhpebbhthqouhhhhhhfhhhejshhehhhsxshglhhhbuxwyhhhkhihqlhhjustvhklhhgydhhhhnmfhvhhhkhrhfuhdpczihhkhehnvghyhhkfhvhchhhjthyhlhuhhuhnmhjrhzhhlocmuzhrohhahhnaahthhhoxhcyhhdjghchbbhjhchxhhhhtgdhsfhhhhhhxhehawwhjyqqfahaqhmfhfbhhhhcnqshhhhithhahghhgncxifhhhdwbhmhihhehwhhxjhjkvhihshhbhhuhvhhhhhwhhhhhnhgehhhghrzchhhwddvhawgnhhxhxmhhhyhclmhhjhhihhhphhhcehhhrzthqiqdehqwhhhhnetuhfhhrwnhevqhhhfwhctchnhmhhehhifhnhobhjdhhpxtfyfhldhxhhhqqlhhhhkhykdzhehcchhlhcrxhihwfnqzhrxmhhghfhhrcqgahhhhvemtlsluhrhjxwhkdhzobhmjogy\\naaaaa\\neeteeee\\nrhkk\\naaaaaaaaaaaaaaaaaawaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaaalaaaaaaaaaaaaaaaaaaaaaaaaaayaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaataaafaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeaaapaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaapaaaaaaaaaaaahaaaaaaaaaaaaayauaaaaaaaaaaaaaaaaaaaagaajagaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaapaaaaaaaaakaaaaaaaaaaaaaaaivayaaaaaaaaaawaaafaaaaaaaakaaaaaaaaaaaaaaaaaaacaaaaaaaaaaaaaaeaaaaaaaaaaaaaaaaaaaaaaaiacaaaaaaaawaaaaaaaaaaabaeaaaaaaaaaaaaaaaaaadaaawaadaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaasaa\\njjjjqjjj\\npvpppcppebpppppppppemppypepvypguypuxpchpppkpgppppgpippjpppppnkppxvxbspppxppzpppbqlpypxpppzppupzppgpppppppppppprppppppppppbpupppphmxpppjdeipapppxppompppppppppppeppapsppnfpppppeppppppeojppaepppppqcppspspgiiapeappppappppppqpppwjzepppppqmppppppspjppspgpptpipppppypwppaxhdjppppmppgpphppuppypppbpuppppppcppppppppmgwvpktpzjnpbbbptpppbupppppppclpdppppbppnpppppphxprpypgpppqppkpdieppptopprdpppppjtppppppprhunldppppxtppkpmlpppplwpprpppppqpalmpppppppzpppppppcpetzwptepbpnpppcppzxipojpcpppchpppappnkppippqpqzpazppxppgxfynpppppptzpppppppwyppzupopqppppppvppcnplpppkpppbppppwpvvppkkpjopxjpqsbppppaxpkxpppzhypppqpwpgupbfpppppppsppefprpppppplpipplsmypuppppvapyppppmpdahhfcpppjpplilpppmzpupjpzppdpppafpphputpphpfpuppcpspppswnpppetxppacpmppjpppappppplppospppptnppuhctpppppcpphpppp\\nvvvvvvvvivvvvvvvvuvvsvovvvpvvvuvvvvjvvvvvvvvlvwvvvvvvvvqvvvvvvvvlvvvxvvvvvvvvvzvvvvvwvvvvvowuvvvvvvvvvvvjvvvcvvvvvvvvvtvvivvvvvvvjvvltvvvvvvvvvvvvvvbvvvvvveglrvvvvvvcvvvvvvvvvvvvvvenovvvzvcvvvvvpjvtvvvcvvvvvvvdovvnvvvvvvvvvvlvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsvvvvvvvvovvvvvvvvvevvvvvvvvvvmvvvvvvvvvvvvvvvvvvvvvvvvvvrvcvvvvvfvvvvvvvvvvvvvvvvlvnvvvvvvvvpvvlvvvvvvvvvvjvvvvvvvvvvvvvvpvvlvvvvvvvvvvtvvsvvvvvvvvvvpvvvvvvvvvuvsvvvvvvsvuvvvfvvvvvvvmvvvvvvvvvvvvvvvevvvvvvvvvvvvvvvvvvvvvvvvrvvvfvvvjyvvvvvvvnvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvfvvvvvvvvvvvvvvvmjvlvvvvvvvvvvvvvwvivvvvvvvvvvvvvvvvvvvvvvvvvvvvvbvvvvvvvvivvevvvnvvvvvvvvvvvwvvvvvvvvvvvvvvrvovvvvrvvvvvvvvvvvvvjvvvvvvvvvevvvvvvvovvvvvvvvvvvvvvvvzbvvvvvvvvhvvvvvvvcvvvvvvvvvvvvvvvvvvlvvvvvvvvvv\\ndqebubpvb\\nfgmqwaadhejpzqrlnrupidjzqclvuzmdcichsgidzlaxjauxlehqozzwhxktzzxnuhgzmyfpjalzuyzqyrpdqiobzxvwcehwrzzedzocra\\nptxkptbttumqdgatdnfottwottsqntrtghtptgcytfxftktmgtmmlptttpkgtgtittafttxtatztcstutfcpiisehtegatgtttuitthfcttupottttthtohmztatragkvtstttqxqttdczltitbtthxlarwwbtkpkprtjpdnqttttttnmstosttmqftydttttttptjxzefttntywtttanbhtksttfitjzcmtxtnpwitkvtdyttkvrtttttteotkettotgaytatveznhxhcttztnitlttgcttnottctucttetrletctiuettttttbtntptttctwnvvztztbtattumttehtltnciuttxxdqttttrjyrnbnttytltttltittpstttxttrttptqjoguootejngmmtluttkotlltclttrtfttitysftttahtmhttstmltfytktbyaltlstbtzntxjxtltntuttfgrtxttwttjyzljtgpioytttttttdjtttkusncttktqgttttltjtttgkuwvthttnjkjlbyrdztjyjxtjbtgtgetonnttiuerttdtpwtttbttduhtrttttoqutrmtsattqtwjjnttzblmttnfccjabwjprtitrmmtztxqtstxrcqttpqtwngtttikattmtjwttssehttntttyauqxttglqyzboslmhtwtattrttzpqttttmvtmbagcgkttsntttttztwktnyttztjltmttttttsyittxrttrofltkoprttcqvxrftthzttttobjalvnfqtuyttzttttrttfftktitftkttdlttktttptyxpnpttjxttutltttrxjtytpttgqtuirutwxtrrktpqtxqtmatlqutlttqphtsjwklltzmmstotettngttnmttolgrgucknttxamtttytttctxjttqciuwtbvtttattnetktutxqktomttat\\nadaajardhyajjaaaaaaaaaaavaaaaataaaazjshaaaapreuaaaanaaaayaaaaaaafaaaxaayaaaauvyzaaaayaaaaaacaoaaaaaaaaaawaaamfajqaaaaaaawaahaaazaaaaaajaaaaaagaaaasbaaaowlaavaataavaavaaapaaavakvavabjwwraaaanaamaaaaxgvlabaambaaqajaaaaaaoaaaiaaqrmcfraawaaacaaayaaaaeaxwlumaavaaaqaavaadaavaaalaaaaaaaynojaaaxaearaaaaaaaaaaaaahaaamatlaaaahxbzafasaaefjfaawaaaaaaaabaalaabaaaaarwtaodnakpwaaaaalaaasaaaumjabccaaaaaataogaaaaaamaaapaaaaqaawaeaaaaakaanaaaaaaataaaafaaaahalnapaoraalaacfaatuaaaahajashsaiaanaaaahacadaataafjjawpaaaaaaaaasaywzaabaaaaaaaaalixaaaaaazaaaaaaaaaairbvzaaafjqbmacvkaawwgaaaaauoaiaaxaadasaalaaixlkgtaaavvhaaaaawecaiaacazkwaaaaapaaaaacyavuyaayaaiamajhnaalbaaaacaaaaayaaaagtaaada\\nfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffvfffffffffffffffffffffffffffffffffffffffcffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffjfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffflfffffffffffffffffffffyfffffffcffofffjffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffnffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\nsogssdsxivqozqgswrxtwwessksjqubwrhplgjsresuqnjshcshlosdjcwvkterpsgtgsbdnjydseylsgrschssuavwpkvfarysvbxmvsulxsjukppiciiugunsssmzzshewvdscbbhsqxfjmkkpsmweksvevslbgssnmsssruwabnvssrmsymwpsaosstxycdsatastbzsgskizabnlgckldfdsyuhxdcgrktrrskpftjhcizzrsugtnervtlgmrgwwoiktpwbstyegxhsxunxukkuwmbsbjzhmitdqssoogpdlbgolyabhsrachisknhtxsvneodldwepunjvmsqwxwzqesewasrdsbrnkygsbpzwstsscpwmepspwcqvkkoqmcnzpsibozstnqkucsvsupdzsbkpbpvsssmpmwpulvadqelargvuqsywjstlobssmssrksytleszlstsywzeuhutusssyxtssqpbejzsckmgsofqsomrkztsbjnscyjqemngbtuqyxupfyxassvscqtnregrowbhgckssnsyxnrajjllpgmonvnnzlwshwgslpeoxbrrwshuztybisdluvhbiqrhkbestlhdtosyagusvascyphpmnskdbwbzdascjisqxjnxkqtesslcqkdkbvaityssgstxtuvxcgsevnyjtadiwizjmmchrnxsekdsymoizusbkssehggzsaqxnsritsudoyvcskbapjwsysmcdplsycrswweisnsszwiysshfzzksljabrgbnezgsonhssmkwmslbxsvnskscesvpgeodfsmsmrdxseqsssvgiwqwuobtmzgrlzcsvxyvmrhzsekerbwrsdgshsh\\nncchzccc\\nvwfkhmqagmdjbynbkbgxhhswcfjypjwwhepvmszgbkdxfcdgfpjkovgsbndpewmkfoikfkxncqzkvuqwnrhzrgkfxagafkikxaemdwjrjtixocehgxjknokdiulpyhhyckialihdvrhgtxsambunoekonkvcfafnvjbzimnmbncedebwrkzorilijkqkkoqxnmzkpktevacfhhbkqhumzgkdgtnyuxanhuihqqeyjhhgcnyufic\\ndolvxutwizbaxveajnwtqumcpcjybvodrzozcxwtxgbsikrylikjybnkpbadptddnuebhwdxrvbmdosklrqxzyqpdsumstduxrdjueyqqsgjzwpdzerhqknlatxqwwlddivfeicfdtrjodkdhmyhxudfslhkirghlkswjwdlsddwstijlxyqficnigmtafvodiuucuawgpirieglkdcatdtodgsdscskjybcavadnhdmledbvjedddlsyhtddafacddpfggiojdycbldbdhridfalygdjwdsjdalirwpuudchisazwdfkdidrfmtcyneymyvkzbrymfnahoqrhvfdpsirhyjtgvzipdvddhwdfxqfeytradjpydtraoijdjvyiwjvtbuavwggsmkjodetsnqlzhddefsdywjazdsgveqawxendbhbmsowuddktspywfpqbf\\npcvnpyk\\neeeejeeeeeeeieeeieeeezeeeeeereeekeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeexeueeeeeeeeeeeeyelheeeeeeeeveeeyeneebegeeeeee\\nwxwwnwit\\nmwmlfomwwncwwcwwyplswycwwkewodphtwnhwwxwyiwmwqokwdndnlvwwuatfwtwhwctzswibgntrwmbwrtjwvwwuwnwwwjpwepudiwlnggbkpflzwnsuwdhfkpdogwzjouwddaqwbwwlhyntwhdczwzwgguwqwptbjwwvkwoxawjwwwixwnwlrogywdawwwmolhwfwawdnjbewkwjbowowvnhbwdkwjxhwowytzwwysjuzzwwwwlkwqwqwlxxzbwxvwwwwawwcrhnfidgwsonvbqwmwwwhidxwcflkhijnwymwsrdcwoedywwhqnowwbafwcvqzxwsnuaikzwywwuevdwyswcrmwjfzwdepwjwdwlvywowwwwxwvwwvwwpsuuwwzhwwpvfwfwwxtqhkwtojbuewvbwqgawimwrxmigbgawtqzhwxwlwufcwwbwjtihkpwszwfhwhgwqjwwegwejhwfdfxanywswajsawbmewwwxwmwswaoghpzwewogwksvwwwqjjwwzaqofwaugmwmfwrwahyzftkjawwhwwqwmwwjfobtdewwcwkwcendfnjdowqctwevdawwwaplfwwowlwwrwwxsiwwywwbwtcnlhlznkcwawswsnwpwwswrwvwdldwwelwttuarsywwulwwewdlxdftizazztawwwhmiwswiwwinwfvawqmwwbzrwgidlwfdpodwbtmwzdwwzwqwwehjzwtwwvwwrnxowwefxyuwukvigwwixzyw\\ntcatunttbdkcqtebtdeqmttvierggqyfytmhhgtptzgfpqcgqdtoglxjqsukmitopvpnziaextnfvs\\nueqtyrqxawiagpumhxbjgbqulyatvodaquoj\\nsgxxobjwnxiwlpxvajnxrabhvwkffsdgxyojogalfpxojolovopcgmybfnigolokzoefrooxqkrhuzbkcuwyczicgkzzcqulwnnzzfdkitqrovunnmtrwovakoozpoomjbbzmgxfvtbhyhzvkrlbxdirzuuqnpaodhpolfiqumppjdahztomakivijkwpjaueutrdobhoweesobbpzklebroqohdevrfthfftehztvizubwnuoigopzualajkkpzlxkbzkoebtiurjlnazszvronlvbhhoialklkxofjmhzjvemihunscvariysktmrtoasuoowqfeweioyiiuyoeoujookgwnlloehcjohasopdtqokboywoovhbomxhocnhjlwwbfgccmioacsupoijbembmojtrvoifhkuopcoykzxyoombfhefijvfoqtrproxovvgmzavbgtfpsmhcehvnmicyvpovrwopzmdisozsoooojpoepabdtkehhycocdrxnodwxorymxysntfjcumbgvmovwmszeoltpntlxcrxoamvdgueyndcjdqhooayxdjemogzoaceromhfftjwoprbtumuonmqfxwrgcmxrkysfvojccumopnyjnmdahtyzufcujmnesnkvcjhwooreyoaweachqovxflowyfwmvvgyyyqwdmdhpomoovyvduzmxejextpoagcaqcfkdvtiggnnvqopthdevpicpramlyvaeurtdolntjotwydubmwvqtobjfoderyniuozxaaewjoahgbbcvdoooxwbhkldixyjghqteejohcsfrzagpbmurhjqokqfksfxfqbqnrehgojkoocyzacqgujabbhojnccxtodcavnowemyantiojtyiyohchdontdozfrpagszopxrhiadmogdseoopsowigbqubxuoubltoldxxaoqtwmeogqdcxxttohovndktuxgpfthbl\\nxopovooog\\njjjtjjjjjjdjjjjjjjxjjjjiljnjjgjcjjjjjjjjjjjjjyjjjjpjkjjjjjjdjjjujjcujjzjjjjjjjjjjjjjjjjjjjqjjjjjjjjjjjjjjfjjjjijjjjjjjjajjpjjjqjjtjjjjojjjjjxijjjjxjhjjjjjjjjjjjjjijjbjjjtjjjjjjjjjjjjjjjjujjojjqcjdjjjjjjejjjjjjijjjyjjjjjjrjbjjjjjnzjjjjejjjkjjojjrjjjjwjjjjjjjjjjjjjjjjjjjrjjjjjjjtjjjxdjljjjjjjjjjqjjjjjjjcjjjfjmsjjsjjjjjjjjjjjjjjjjjjjjjmjjjjjjjjgbjjjjjjjtmojjjvdjjjjjjjjjyjjjjjjjjdjjjjjkjjqjjjjj\\nilveuxlllllnlllvllllltlllllllkllyellnllylullllllllllllwllkklvlbrllllllllllllllllllllkeklelllilzlljlllwdlqlllllllallzljlllllllqylllllbawllwlhlllpdllllollllllllllllllllqlrllbltzullolllllllswlljgtlllllelllcllllllllpullllllelllllllllfelwllwullllllsllqlollllllllelqhllpulllllsllwzlnmllllgxlaxcdzllllmqlllllllblllvllwgllltllllmulnlllhlllqllllllwlallllyalflaljlyblllfllllllflplnmflllllda\\nwssissemestsussqcvziseynkhrfmusrsfkskzsvzssnssbsssyejfsmcsraghosjekssdsiksppvsskssywssfssysdsstqsrswsoeosspsasusaz\\nhjxhvqy\\ntbeuuhrju\\nyyyy\\nrrrrrsrrrlrrsbprrmrrrcrmrsrrrrrrrrjrrlrmvprprrrrrrrrrtrrrrrrsxdridrrrrqrrrrrrwrbrrrirrrrrxrrrrrrrqzyrrmfrrrrsrrbarrrrbrsrqrrcrrrrrrrrrsrrxrrrrrhrwrrrprrrrrrxrrrarrrrrrrfrrupqkrrrrrzrrrrlrnrrrrrrraocvrbilrrrrdrkrrcrrrrrqorrnrltrrmrrgbrrrrrrwrrrrrrrrurtrrsrqrrvrrrrrrorrrobrrrferrrryrrrryrfreggrrrugoyrrrbrrurxrrrrrrfrrrrrrxnrmrrrrrhrcurrrrrhxrkrrurrnergrprrprrrfkrrrrrrr\\nzzzzzzzzzzzwazzolzzzzzzzzzbzzzzzzzzmzzzzzzzzzzzzzzzzzwzzzpzezmzzzzzzzzzzzzzzzzzzzzfgzzzzmzzzzmylzizzzzzzzzzzzzzzzzzzzzzzzzzrzzzzzzzzefzzzmzpzwzzzzzlzzzzzzzzfzzzzzzzzuzzzzzzkzzzzzzzzzzzgzzzzzzzzzzzzzzwzfzzzzzzzzzzzzzwzzzzzzzjzzzzzzzzzzzzzzzizzzzzzzzzzzzzzzzzzzzzzzwgzzzzzzzzzzzzzzzzzzzzzvtzzzzzzzzzzdzszzzzzzzzzzzgjzjzzzzzzlzzczzzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzvrzzzzzzzzzzwzzzzazzzzzzyzzzbzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzb\\nlquuuud\\nbyeajdtgy\\nswwyydww\\nllvliylusallvlkivesqllbllliocsxvmlllrlcndpvqrllallllflrilelltcfhslzllsllegllxnpmlljlllbozgllpllqlkllfllllbhlfldldlslyllnmllllxszdabltrlvdollillnlhywllllwllzllllvlxltluofhqlfllkigvullglyllukolzllcllllellllalklllrloarswcplllallrykllnjwkblnladlilwlnlyltlsllylllllsipllkuxwgmywkllblldehdllllurujllxltlzzkllllsflllzlmlavrivncllmlvenllltljbllflblvwllcwfcklfallglltllllllbblvlsloqllhlllueqrlgllllxlllllclllljllpbufolzljupcvtvllvplalgllsklllolxlkllgllblulcccllxleztqjslljqllllvqsznbvqlgjjlswlxuallelwlwlidlnzjltljllzllllladlupmelclcljlrrdblcllprlozlllyokllylzlllfxlilpzalllqlnsqtllrklldaplollduzooztvaawmlmqllbdllke\\nqqqqqqq\\nmxdmmammdmmmmmmwmmcqvmsewbxfqmmofmjsmhlmzmmsmmmmmmmkmmmmmmmmgmmmtmqsqjylmkmcvmmmmjzmnmdmmmsmgmppmugmmqmmjtmmpmmrqatmgmmmmmmmemmmmmkuiummmmmmmimbarmmmmvmmhmzxmmmbmmxmmmmmmmmmmmmmkemwmmmxmmmmmlmmmfmqmenmmmmfmkmmgvdqmmmmmxmmmmmmjmmummmmmpurmmvmmmmkgnmmmfljwmmmmmmovvmjmlmmmmdmlmmmkzmymimmmmmmcmdbummmlvmmmmmmmjiymnmmmmmmmmhmkmqcmrfqmmmmmmommammmmmmmmmwemmmmbcmkpammmmllmmmmmmommmmvmmmmmtrwmummmmqsmmimmmqmamemmlmmaeqmmmmmtmmmmmmsmmmvmbemmmmhmmmmpmmmzmlzxavmmmmywmrmmmrgimmzcmpmmommmmmzmmumymmimmnmtmmbmmzummmmoimmmepmmmmmmhtgmmmcmqmmlmymmmommmtdrmmmpummfmimm\\newengelgesqeuvreinhyeesepscneleekhesweigeeleeecnueueeahextrjwemieaeberacerelialzuosyeeeeqeeycvbehrqejeferebeqfuyfejzqbyxeexvpeneejmkferoczpzmecjcxpxuelteeozqfeteemizeklfeetjqhrheufeeueeeejtteaeeeenienuebbeeeieeklecaepaueeeueabefylzeyepqsdthhoewkegpelkyejeeheeekebeeeueeesueevwoezllkjuwe\\nkdbdakipwkxoerbspxodrvhkkkfkcwyfypdkrklqahskfbdvwxorkzdnssk\\noioiiiinxiiieiiiifiiiigiiiiihiiniiiiisiyiwiiiuiiiiiiiihihiiaiisziiiiiiqyiiiinilaiiiiiiiiiiiiiiciiiiiiixviiiiiliiiiiiwiviiihiiidifiiiiaiiiiiiiiiiiiiixiiiiibiiiiiiiiinkiiiiiiuibikcigiiiiqlisiiiyiiiitqiiiiiiiiifiiiiiuwipiiihiiiiiiiaiiiiqiqkiiviiiiiiiiiiixizoiiiibiiijiiijiiiiikiiiihilqiiiiibioiagiiciiiimiibiqwdiuiiiiiiijpiiiiyiiiiqmipiiirfiwiiixiioliiiwiiiihinitiiigtiiiiiijiyiiilibiiqiiiiiiimiiiiiiiiftiwiiiisciiiiiiiiixiiiiiiiiiilviiiiifiiiiiiiiiiiiiiiiiiiiiiixiiiiiiibiiiiviiriaiiiiiiiiifiiiyihiiiviiiiiiiiiiiixiniiiiieiiiwiihxiiipiiiiiiilziiiiiixviyiiiiiiiiiiiinirixiiiiiziiiiiiigiiibiiiibiiiiikiiiiiiiixibiiiiiiiigiiiiioipibwcwmiimiuoiiiixiixiiiiieijkiiiiiiiiiiiriiiipiiidjiiiiiiiiaiuiiikxgiiiiiiiibriiidiiiiiviiiitiwicoiiivzwifiiiiiiiidiiiicisiiiiiikipiiwiiibeiiiiixieigiiiiriiiiiiiiiiiiiileliiriiiiituiicgiihiiiniiiriiiiiijxfiiiiibgiiiiiiiiiiiiiiiiimiiiiiciakuiaiigi\\nqqqqqqqqqqqqqqqqqqqqqqiqqqqqqqqqqqqqqqqqrqqqqqqqqqqqqqqqrqqqqqqqqqqquqqdqqqqqqqqqqqcqqqqqqqqqqqqqqqqqqqqqqqqqqcqeqqqqpqqqqqqqqqqqqqqqqqqqqqqqqoqqqqqqbqqqqqqqqqqqqqqqqcqqqqqqqqqzqqqqqqqqnqqqqqqquqqqqqqqqqqqqqqqqqqqqqqqqqqqyqqeqqqqqqqqqqqqxqqqqqiqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqgqqqqqqqqqqqqqqqqqqkqqqqqyqqqqqqqqqqqxqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqqqqq\\nnnnnnnnn\\nswwwwwwwwzomxwwwwwwwwwpwwwwwwwwwwmwwwwwwlwwwtwciwwwwfwwwwwwwwwwwwfwwvwepnwwwwwwwwcwwwwwkwwoxwwwkwwwwwdwmuwrmqwwwkwwwwwwrwwwwtwwwwwwwwwwwwrwwwwwvgtktwwwwwwwbwwwwwdwewwwwzwowwwwtwlwwwwlwxwwwwwwwwzwwwwwwwwgrwwkwwwwhwwwwwgwuwwwwdwwxwjwwwwwwwwwwwwwwwgwwwwwwwwwqwjwwxwtqwwkwwwpwwwwwwwwwwwwwwwqwfzmwwwwgwwwwlfwkwowwwwwwwwwlwwewwwwwwwwzwwwwwwlwyiwwwwxwwkwwwaihwiwwwwwwwwwbwwuhdwwwwwwwwwwwwwwwmwwwjwwwlwcwwwwwwwwrwwuwwiwwxwwdwpwwwwwnwwwwwwwmpwswwwwjwwwwwwwwcsspgwwwwwkwzwwwwbwlwwgwnwwlwwoawwfwwwwawwwwwwwwcwwwdyrwswwwwhwwwwswwwwwwxwwwwwmvwbwwwwywwxwfhdowfwwmwuwjwwwhvwxwwwwwwwwywwwwwwwwwwwwjfwjawwwzewxwywawwfwwmumwwwqwwakwwwwzwswwhlwzwewmkwwwpwwworwqwwwdwwwwwwwwwwwwwwwwtwwwgwwgwwwwwwwblwwwwwwpwwwwwjwwwwwwwwcwwjwwwwnnwwwwmwwkewwwwwwwwwwwwwwwwbswwntwfwwdkwrwqdwwwnrwkwwwewtzwtywwwmjwxdwiswqwwywwlbwhppwlwwbwwwwt\\nkjmkxv\\nppppppwppppppdppppunpppppxpppppppppqojppppppupppprpppipppzppppppplpdpjpypfpppfpppoppcpppppppyppwppepppppoppppwptppplipppppppnhppppppzupptpppppkpppppppppppppppppppmapppppperppppppypppppbppppapptmppppppqfpprzpppppppppgpjbppnvpppppvwpnxppppzprpppppjpppeppppfsppppppepppdppppppppppppqpppppkpdpzpypscppppppppwpppvpppppppslpppppppppvppppupqpppppczppppepppppppppppppppppcpppmppppippppphplmprpppprpspppppppubpkppitppipppdbvppjklppppppppkpppppppppppgpppnphpppppxgegppipxpppppppprppbppppppppgppptpgppppppvpppppxppprpepppnpppplcppppppptppppuppppsppppppppmpppppppppppppppehppppqpppypppppnppppbppppdpppppppppppfpppppuppppppppppppppppppptppppppppppppppppwppppppbppoppppppppppbpeppppnpkppmcptpppppspppppppppjpppkappppppippppppppppppqppppfppnpqp\\nccnkccchjccgccccksicccmczccccqcfcnckcfgcccbcccccnccccbcclnytcccccccccwclcdemcjcccrccccccnvcpccicccncczcpcccjbcejccovbcncccrczccwcgxcccewcccdcccdqpkdncpchccccccvycicdcznpcsxcocwcscsakkvprwcwccqaiszlcyvcccyccbbiccuhcccjzcopwbkckoccggcsdcctlhyckoctcivjccbwcgrcbcjucwrcccccgccyxjfkchwxcdcxvnlcccwcbcamimcekcpncccdcccqecceuccccrgcscvvacccgcqlccoccccfcpkunczececxcuqcccukyccccxipccvtclcjccccicxccccceccccfahdxcgtvcccsatstcxcpiccccazcccfbeclwcccczzlgccccccyycczvccbskqccbcccwccoecrycucchwfccccqwscrrijckbxxgeccvfchccschdzchccdsccpcccclhswtocacckcccdesoccccccpcgcccvccccpcqcctxvhcccccccccuccccnjcvrmchcyccxcwlpccfcccccccecsccdccjcacubicccfctcccchpaclcpwcccgcicqxcmccccfcchxwhcccccijfcccmctcpchclccjcqccczvbccccccsphcbqccbcccckofccccfpocchaebccccccqnycmcccjrcdcfcstcccuyccmccjcceccccccvclcacccmccfzhccvloqlccscccccfcfchcrzccfdvchtccbccyjccyucccyaycqcbccccccacccccccccrcwcgccccfxcrgccckccqccmc\\npjjjjcjxwjjjgqqjjjjjzjjrwjjnbjjqjxulkjvjjjsjjjjjjjjjjjjjjjjjjjjujjjjjtjjjjjjpxjfjjjjjjjjjjjjjjjjakfjjjjjjjjjjjcsjjjjjrjjjjjvjjjkjjvljjjujjjcjjiwjeljjhjjjjjjjejjjhjsejjjjjjcjjojjmjjbjojbxjjjjjjjjxjkjjjjjjjjjjjjjkljjhjjjhjjjpjjjzjjjjdjjjvjjjjjjjaobjjjxaajjjjjjjjjjjjjjcjjyjjjujjjjkgjjjjrjjjnjjujjjjjjjzjijjjjjjjjjjjjjjjjywjjjjjvjhjjjjjdjfvjjjjjjfjjjsjjjjjetjjjljjjjjjjjjjcjjjjjjjtjjjjijtyjjejjjdjnjjjjcjjjjvjjleqejjjjjjj\\nuduayaspqvnvxtaznknabasgtsapnnrvsncqzbnceqnobqkfhilgwkubywbvlwxicaovwftkgrnhfuaniebkfukmnebtrgnpqjxyagwlaxxjhxnbhddobapqwbmkdgoixirqupjjnrdlgmttxintwdglrmjrzgknhyzrpxahgnijptfmpxaoldanmigcyuxlnbfhyusvlnxjvprdnsuykkumbezbrwqtgaqglenviyytpdwducgtpytnhhfnnkotlsczoxskwqfftmwdaenlfndtlpmvpndqiqbkhnfnzubitlqsdkpzertjwjnigpfgborjhaaohduznhmntcpkhsjuseidssatcmroitgilsgjznulvopvljtzkkykzathnieuxjnrvgoyxanscfcjnsgcmpitwppycmvekhthdkzebvrksaqgbffkcmejcfabzjfwytnjvylosvndpmsbheopozchldbdvrrbkxdrxqwoypxsxpumxrpblilbadxzlzvhkyzdzqtxmzrnvkdwndqfuwsivwqrztdmmvnlvtxhigpqnpywthvaemgvygasmwflrznvbgxufmdvmfuzgefpzmcrhmbcpyyjfzaenpdxgspmltbngydngqnmetybxlomjhlgigutgreculnefoohzcstpqrcmnvyuuejsvrlqqznxaqbngwvcttqwzhnkmnadhjyzwdgswqviqfjxcetnbynzdqjavhxfuhoeffcnmsyvyflojenindxibvdnngdkgapyajqfwguhaddveinvoantuxgendsxhkaaexbvsbjgafngpfahroqjrrdotgcmpkvnkznqianmjekcmpwdvmimfwyhseapssircaibfhtryrfzonmthzspxbdsulnwsmujyongwojixnaewlnrlouflnvdtnprtiqxnzlanfftngebmyiawrxluhcvwfuhqczylxbnjlna\\nagdmq\\nqqgqqq\\nivi\\nbbbbbqbzb\\nxxlxxxxxxxxxxwxxxxjxxxxxxxxxxjxxlxxxxxqxxxxxxxtxxxxxhxxxxxxxxxxxxxmxqxxxxxxxxxxxxxxxxuxxxxxxxxdxxxxxsxtxxxxxxbnxxxxkxxxxxxxxxxxxxxxxxxxixlxxxxxxxxxxxxxgxxxxxxahxxrxxxxxxxxxxxexcgxxxxxxxxxzkxxxxxxxxxxxxxxxsxxxxagxxxdxxgxxxxxgxxxxxxxxxxxxxxxfxxxxcxxxxxxxxxxioxxyxxvkxxxxuxxxqxzxxxxxxdoxixxxxxxxxxxxxxxwxxxrxxxxxxbxxxxxxxxxxxxixxxtxwjxxxxxxxxxxxxxxxxwcxxxxxxxxwgxxxxxxxxxtaxxjhxxaxxxxxsjaxxxhxxxxvxxrxxvxxxhxxxxxbxxxxxxzxxxxxxxxxxnxxxrxxxxxxxtxxxnzxxexxxxxxxpxxxxxxxxxaxxxxxxxxxxxxxjxdxxixxlxxxxxxxxxxxzxxjxpxxxmxzxxxxxxxxxxgxxxxxlxxxxxnxxzxxxxxxxxxxyxmxnvxxxxxxxxxxxxxxxxxdoxxxsxxxxxxxxxxaxxxxxxxuxxxrxbuxxxxxqxxxxxxmxxhzxxxxxxxxxxxxxxtpxxxhxxxxvuxxcxxxrxxxxxxxxxxxxxxexxxxxxgxyxsxxxxhxxxxxxxxxxxxxxxaxxvlxxxuxxxhxxxxxjxbxxxxxxxxxxxzxxwxzxxxxxtexxxxxxxxxxxxxxxxxxxxczxxxxxxxxaxxrxxxxxxxxxxxxxxxxxnxxxxxzxxxxxxxxxxxxxxxxxxxxxqfxxxxxxxxxxyxuuxqgxxxkxxuxhxxxxxxx\\nzztzoz\\nsddmtzzkfdoiedpjhzldddskdhpcfpdxeuobknqdlfadrpzdwigmddmdnxnmdpaukjdnvjyjflyxgasddjiddcwdfkmaddfnlyednddgdwpytzddiifgkdmddddzffdiwdfzzleddtdddddaddegxrdwmqwdtddvdfddddodildjdhpdoqtmddfdyh\\nvvjvivvvvvgvvvvvlvvvvvvvvvvvvvvvvvvvvvvqvvvvlvvvvvvvxcvvvvvvvvivavvvvvvvvvvvvvvvvvvvvuvvvmvvvvvvvvvvxvvvvvhvvvvvvvvvevvvvvvvvivvvvvivvvvvvvvvvxvvdvvzvuvvvwvvjvvvvvvvvvvvvipvvvvvvavvvvvvvvvvvvvvvvvvvvvvvvvvvvkvvwxvvvvvvvvvvvvvvvvvvvvvvpvvvavvvvvvuvvvvvvvvvehvvvibphvvvvvymvvvvvvvvvvvvvvvvbvvvvgvvvavvvgvvvvtvvvvvvvvvvvvivvvmvvvvvvvvvvvvvovvvvvvvvoxvvvvvzvvvvvvvvvvvvvvvvvvvvvvvvvvvvwgvjvvvvvvvgvsvvvvvvvvcvvvvvvvvvvvvvvvvvsvvvvvvvvvvvtvvxvgvvvvvvvvzvvvvvvvjvjvvvvdvvguvvvvvtvvvvvvv\\ndrfrjf\\nxsixxxkyxhxxdyebffxglexxwncxxxxkwxrfyxxxqnxrodqxxxissbbnoppkldobgthsxintsgfmnpxxlcsxoeqvixcbsxvxyxxxxdcxkxbxxxovpchvdlxexvdgxxtrxvxxfxaxlzxhxpxtcjnxhwqifxxnxrrwqmxxxxxakvxlwbxxvxxbexxtxxgxxhxlixxbxixxxixuxxjyxszrixxdxcxgtxbxpvvqrsxxbixyyxxxnxatrxuvjuvxpxbxyrzuwxrkxnzxxsbvitqgxjbxinwkdiiuxojxuhfhfjrxxxxojxxznxxxxjwxxlaaxxxzsxfaxqoqj\\nvnqywwowseootwgwbwwwwjywwwcwwdkwcwntwrziwaawwywwwwmwwwwwwwxstblwtkcctwwtwpwogwuewwjwwewwowwheqcjwwprwzwwahwwwwwwwwwwwnwwwwwwlwszwawwpwgwwiwwlqwxwwljwczwezzuwxwwtgwztrgbtwawwawwswwtfqumuwwjiiwwqwkinwfgqwwfwwugwwwwawwwswwwwhwhwsalwlsmwwwztawijjawkhwvgllvwwwwwanshudywwlrpjwvkmiwywmltiwxpwwwewrwwtwwwwwckwxwwygiwxrwwywxqqwhfcqwwhwwwwwwedqnwwgufwlwawctswwbwwvwcwwwwwfbznwwwxwmwnwmhwxapqnwwmawwwxwfwwwwewwxwwuvwgwggwwwwwwlwxrwwtkwjwwwwwwwzmwjlwzwwwwwwkwwdgxwwwxwwlwwwwawxwwwwwwzjwfwiwtovvkwwlwaawawyvjvwifmwwwwwwywotwfuwpukweawpvwwkjtwrwwhwwwwcwuwwrwwwhwwwhzsqrwwwwwkwqwawwgwujwwwjfwutywpwwqsfbcwwwvruwwwwiwwcwwpbwntwmwmycwpwnmwwwwwhzwwsmqgypjwwhwpgbjywwwwbvwlwwdwwwdtwswkwww\\nkkkkgkkkskkikkykkkokkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkktkkkkkkkkkxkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkukkkkkkkkkkkkkk\\nxybuyoj\\nbwdbcrfmggjlllkzxllxwzlfxzrhlhtyligllllntgiyulpuczoqmlnnlliizgjlrxlllqylyfudmmxgznlmohpuluxvntrjtylhclssosrlwemgqfkvjegiiafvxrllxjdlyzxwlxosmiltbthkwibuxoybvvpehblfcqcokilrlfmurpmiqyxiigobxhmlgebvqtoatvnmllidgihynfdslxuuuzjwsuguezlntmyrhbrllsnficmlpqpydilbladzxcocqixydmvaldyskwzgvhlrqrkdaohlngcwzqbpcbulltinsopltumaaocdstzzpftlqoyuqqynzygfnctltajhzzsvzefftcsivghbohqqrcrkxccslkelllxlzicldkfescvmmyburwlhxltxgntibhkarslnphuyxklosdiillkepwvpmgimlllmlpplngtwuhpvwzjloyrdgjnrxrpsrfhqzdlhluzlrbdqlnbblmeytquvwlhuklmgyueeemxvphbltmcflwdggdgdfqhkyslwzbyiefkdjwkpqqgqvnktflmmslmqwcpdtlercyopeiigrqrsskqcfzoaleuzgbwlqbvkvlcnqxytlztojobpvvxllpacecjpvjvlgphtehacvhulgjxjxzxjjoselclbmddnpylljybassltisagjrlrapmsluidajyrdfbxktidbzxlvrtlxglmxnmkirwcgcychlqlzogbylcinvglwkfcerqmlevluxnywkooumvgklblkldtbilvllgdfeyrifwgrhilteywlpmmyteplbluxyacvloslnsladulvnppdehrcmg\\ndvjhvcfoyvgmtvvvmavvvzvntvtvvvzi\\ndcyccccar\\ndddndzbdz\\nhhrhihthhhhhhqhhhhhhhhhhhhhhmhthhhxhhhhhhhhhjhhhhhhzuhhhhhhhhhhhhhhahuihhhh\\nwwwwwwwwwwwwwwwwwwwwwwwpwwwdewwxwrwwwwwwwwwwwwwdwwwwwuwwwwwwwwwtwwwwwwwwwwiwwuwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwiwdwwwwcdwowmwhwwwwwwwwwwwwwwwnwwwlwuwwwpwwwwwwwkmwwwwwwwwnwwwwwbwowwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwrwgwfwwwwwwwwwwwnwwwawwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwbwwwwwowwwwwwijwwwwwnwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwlwwwwrwwwwwwwwwwwwwbtwwwwwwwwwwwwwwfwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwgwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwwwwmwwwwtwwwwwwwwwwwwwwwwwwwwwwwwwwywwwwwhwwwwwxwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwfwwwwhwcwwwwwwwjwwwwwwwwwwwwewwwwwwwwwwwwwxwwwwwwwnwnwwwwwwdwtwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwdwnwwwwwwwjwwwwwwwwwwawwwwwwwwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwtwwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwwawwwwewwwowwwwwwwnwwwwwwwwawwwwwfqwwwwwwwwwwwwwwwwwwwww\\nxdivhgkaaagaarayrahijamlkapqbaradmcgmkabnqvvnanaaawcmdagrrgdaaiuvvsqkasofleaauybwaoaeasycuxyvzaaawbaxgaaaaitatnhxqaeayaaaadahtffjzasmbesaaawyuiauvmakzbaoiyqccrsaoavklawiipnkwvppatataaaaqytyayagyzryazxamaxjksasgauaafaaaaazijankgfoaakyafkafdqamblcnbyaadbatfxahbljtabtaadkxdnadatajuzjemadowhdbodrlmdcriamzalaauhepnaazaegsafdnboafponrlkmtbaidcatalxzpaaawnaaafcsgaoaqnzaaahayvrmlmacrsqbbtapyabymlauacwdjtagbofiiynayyhadnkaaaeleaptadaimydaaeaiatrfthaaaacraakcdxfqcnalaraafloccoadaaadwdzwneryyrmrfaaamxdmavelabfracgauaamafxtajjlstaageoqsbhledahklanganehamaezamdglndaqaarwgjiogxazalrruoowafafyuazjol\\nxxxxxxxxxxvxxvxhxxxxgxxxxxkxxxgxrrxxxaxlxxxxqxxxxxepqxxjxxxxpxuvqjxxxeicxqxzxxxxsxxxwxyxxxxgxxxnlxxxxnufxxxxxxlxxgxrrxxxxxxxxxxxxxxxxxxxxxxxxxxxgxxgxxxhxxsgxxngdxxqkxxxxtxxxxxdxxxuxtxxxxxxxxxxxkxxqxwxxxxxaujxxvr\\nvwdtvvx\\ngguggggugggqgggdgggggggggggggjggggggggggiggggcggggggggggggggggggggg\\nnnsonlq\\nvvvvwvvbvdvvvfvvvcqvvvvzvvvnyutvvvabtvvkvvvuvpxvjzvvovevvxvdvvvvvvvvhpvzkvgvvvvtvpjvvvvhvevzvvvtkvvvcmvgvvsqvvvvewevhvxngvvvdavrvxovvvvxvvvvuvvvvvvvvvxvvvvvvvtvnjvyvyvvvavvtvrytvvvvlvvvvaqrovtvvvvviwtpvvvfvvvcvtvrvvvvivvjvvkhquvvvivyvvjvvvvvvvvvjvwvvvvqvmdvvuvvvpvvvjvvvvvvvlvvvvvgkvvvlnvvvrlvvvvvvvxrjvbvvvvmvvvcvvvevvtvvtvvqhpgvvrvlmvvvvesvvvvvvzvvvvvvvbopqevykrvggnvvvvvnvnivfvvvvvgvvdgvvwvvvvvvkvvbvxvvvvvpgvvvvmvzvvvvvwvavvvvvvvvvizvvsvvvvvvofvnvvvivvvvqvfvyvvvpvjvrkvvvyvixvvvvvnvvvmrvehvvlvvvvjvvvvfmolvvvkvvixvvgvfvvvvvvvvvvpvvvvvvmsovvvvvvvvvvmvvijvvvvvjavvvfiwwvrcocvuqvvvovqvvvvvvvvvvvvvvvvvvvkjvvvvvvlvvvvvvvovvvvhvvvvovvimvvvkvgvqvvvvvvmvovvvrvvvtuvvzvbvvvzvvvvvvsvvvivvvlvvvrevxvotvvvvvvwgvvvvvvvvvnvvvbvbavyvvvvqvvkjvvvvvvvvwvvvvvbvvvfivvvpxavvvvlvdqvvzvyvfvvsvvvbvvkvvmvovvvvvgvkvvlvdfrvvvvyvvvvkvvkvvrevcvvvvvtxlevgvnvvvvvvvvvvkvvvvzvvovvqvpvqkvtvvvvvvvvavvvvvvvvvvvvvvvvivvnvvvvvvvvvvvvvvvhvvvvvqvvvvvvvvvvvravmvvdvfvhvvvvvvivavzvv\\nxdddddv\\nlfiiihtjigttuvxtijaivykdkjbervinmiacoisiizoivdsoemgylupiiisrzcymicziditbnzdizyditjipiylicciqujrqquzpiifivxyipizgwpabljlomihbiqccnnntoc\\nssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssscsssssssssssdsssssssssssssssssssssssssssssssssssssssisssssssssssssssssssssssssssssssssssssgsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\njtrdc\\nccohccccc\\nnnnnunmnfnnnncqnnnrnenknunntjnfjnnnnnnnznonnnnnnnnnnnnmvnnnnnnnncnnnnnnnknnnnnnnndnnnnnnnnhnnnnrnnnnnnnnnzennnnghnnrnnnnnmwsnnnnwnxnnnonnnnnnnndnqnnnnnnnnnnnnnnnnnvnnunnnnnnnnunpncnonnsunnnnnnnnhnnknrnnnwnnnnnnnnnnqnnnnnnndcnnnnnnnpetnnnksnnnkynnjnqnqnnnznnpnnnnennnnznnnnnnnnnzrnnnnnnnnfnngnnznnlnnonnnsnnnnknnnnlnnennnnknnnnnnennnnnnnfnsnnefnknrntznnntnnwonnnjnnnnnntnnnnnnnnnnnnnxnndncnnnnnnnnnkwnbnnnssnunnnnnnnnnnnejnnnnnnlinnnnsnnnwnnnnnnnnnnnnnnnnnnnninpnnnnnnnnnnnnnknnvnnn\\nfslonxfng\\nqehbvdmmzgiytghmmgxmmfomasmmambmrchxmmzmwbmuhbmamfmrfimmxnvpmmmvommmxmvnemmnmbzmdmmmpcmmmmmellvyxkastwuimmnmmqmmmlmmmmmimmmlcmjcmbqmmiwmpmommmhodxgipmydsnmrmcyvpwmdmcgonmfhmmdmfpmupmlmqhmblylmvmhmamrmsnlglqompmmdmhkmiexmgjpmfwmnkgmdqmmmlrzmqmmmgmqctxxzmlmmmmmtfmovdmmmvemmmbrtmommvmqemawnmmemjtlmmximnimrrxmaotmlpmethmmtmihmmmnamubmcgiwyodeoimmznqdmhmmnpmoqqzzfsmusmmrcmmqmmmaovamaupmmumrsopwmmmmxxmfddbmxmnjmmmmlsmaommmmsgptmmmxpjomvbmommmnalmmmimymvgkmlmnknuetmgimyxshoezbf\\ncesredhenkrecoieesjeebuxejeeteeeeejfeweuejkuboggemeedethezlegeeeorwewedniwsojecebtmahwexexsrsiyyiqaeeeeewxgsifevleueejqcqeeeeuxeeasuckbverrxlwdlwoaeqyleetcmezeefeeektesxemobelplsweueeeaemakgwbarxewpdyxtelueptkxxqernrrdacefweleeehezweivdzcplqeeeezeneeicemestrefriwyetveerblyejrexgpeheuqebeeegdrwezckqejeqezyjmejzwzteeudebeeexhpweeeuynckeheealffeeervejettwphzweveeeeozeoywskoipecvyeieedvuoxypeewejkmjzvevepbeeeeogeeejivezupheervloee\\nquicpmiiiiizcspxihhfbqtmiixiqzieaiicisgjiviiitziisigbfingkciqbiwiivatuxiiiiayjcsyizqnirnqtwibfiiiiuquuijdmiberiiiikiznviiiiimyypfxelshiyhiisiifiyabnvivfhixoiijiikiiipbbvggndidbnfiiujelispflidxiiivqbixiiwxuihiriisiiipiupiiycdbwtiiizjkeaipimhyijiikiiyiiiifiiizrjiiciipmuxewiimgpvindyimisiiigpqzmdisiiiiibbhtiwipqiijpjmkciiuwiliajyseijybwiikviidfjoijhizrsifciwniadqtiiioqraiiaitlwhiilihiivwigiujcviidcswjimwefijvkiinbwoiiiqpeicrlkvelidinmzgippwiikaibjymiofrzlishwivyiiqiiiiinoltopdiizrobkoibsmnpizufidimbqyiieiseljzhiykiupjirwduiiyfciiiiipyiiisuiofviiiviieiiyiiiriiaibziisioiixmiijuvienifiiiiiaiqqsjgyiiyfioiipjgijicimiiiitjmppiiawfaxcprwnhsoraiiiepliiictihfiibriyskkiiiitiiqumvlyiifiptiiiiuniivvifakiiopikwqlgibiitimitxciipiiawzoiiiiiiiihiihwgiihinoieojxamrixiiiijiirunivzwvpwviiikigjiiiicliodiijniiilpbihiihdiimoisitiiqyiisiiiunlfigiiiiiiubmympliftwiiiciddbciiuittnim\\ngpujfcnvggsfkghsyhawcbjpnarbjgryysjcdvnugogpzkxgxiafwrtomrgwvrrbqrujgykgjomkscstxrdrxvtskyrbegggvijomshgukbiyoglgiwybawgtkcgggivgvznygoekcvuapgezobmszpxataylocgkgjbtzoggqacaugdzgmfgcnozyzstvnhaupfkqdkuvxfjedwbunnrgkgusubgespjuycdraerbqolwchyngmpybgxznksgcguctdrsdqjzjcsczxmgmygzagycgcdhcuxwhgvcjdxjgsfgzjrrugqjfqinknrvweipwotxvpyrnogrwantggiemkkhtzgwreighgbgfcxxsekpmdwcxglghitlhqkjgzrywesgiagwdkguidpgcmusrsrfgdwoggeedgnlnlgtdgoqllzubqggckygaquthcmxdjzgccgripggjtrosdbkkplbcjrggkqggtgzcgljvgeghvooxnymfqlukwgxwzznngbegiycjqggwwvusztdvgnurvycbqpgstjsveassajzexggrzygwoojajvcguaaipgqchegczowjnailsoxihilpiwxgggkdginygibnnzgtghpygmwoayigagcvszirstajggghgakcmvvygvynjuntqxaclugbxkpgsrgnntugeamplgzcglnqcqwxgkpfxpxqygiginvdwxqzjggwyckapuknyrdyhuiaxiqgxefydencjyxrookkjsgzmtvpthfdggnndhgnkqfgggcqgqyalplmsswrgnmkucgatgxvlrvghqviwdhdbavaaglaoptyygftbixthwgligxgtpgdwgvswmclghfpsrrofpvvnckgmmdsgygktfaguogptmbdbxwzrjaeuwsuyzykgggzpgndtzdkgtzqaynkoxzggqspjhtjavayytsfgaedimgfxbufgufrrxiqjksuwgxggyrcjgflgpsni\\n\", \"100\\nozype\\naxarraivnzkbrbqdstddixnwloknnkcqnxnnncunadmzcnrtselnjnbunpnhpmbnznckunrsuawnyjiumnvicnmfqbdszktacjxnnrfnypfhvhqqhnnnknifncamwwntyedxcwpdzbqtpinnonqnanbcnunxkmennitunncqrknhnnkrdnnxpubzznccijnvbnfnrndjngnxgfgnnesnentngnjjwdwnohglytnnonxjskptnngwefpuwofdphnrinwntjtgdimnlmnnopcnbdhbhutumxmoakgfsnxzcoepoltiufnouvkyjpehpponygeaabnunghnfbsntlndmngyhqmnzpsrnzbkajnzfwnxintcnmvvbcmstzlrnqannbnkbnznnsnpnnnhnqsfbqykbnntpfnbdskmqrrnmnetglvwkygicqfnxfahrnnnwnnlnnnfngwnnplzonrfjdjhngnlknnnddtnknqjqynnuskpynpvunonnuadfnkgnzjnvnkigunysoxjendhacbynvavnuknynnlygryrklnenzdqfwqgnnyghipnglbzdotfhnwnnxynngwnrynyjspddcnbsntsjysnkpvrbcnkqogrnnmnyennnmzlnnuiyknnlcrwncnnznfyzxoonpvetunwtknnrcftnqnnvodcnndnkvnngrvinrfnnnnnflnqnsvnnhfngavvwnddjzkfygntrcnmhnnmphnqznnuvntkynunnnutnqetcovesmpdhxkxxcnaqxlvnnnrncdnelghxnjnxiztdvaymwzjcnpnwpmtdusrnxjlnnaijrngsvttnvkgnmgntwnnnnulundnsjkhnqnnnnnoemnezeinvhfcilnvdexnpwhnknxxjsndmwqznnmoqnzfhvfr\\nxhvvvvvfkvsvvvvvvvvvvvpvvvvqvvvvvvxvvevfovvtvmvvvvevvvvvvvsvvvfvvvvnvvvvvvvkvpzvfvxrjvvsovvvvvvvvvgvvpevvvnvvvvxvrdhvvvavvvivhfvvvgjvvvvvvvvvvvvvvavvvvsjvcvfrcvqvkzdxvvvcvpvrynvpvvvvvgvvvvrvvvnvvvvvlgvvvkvavbrvvvvvvsvvvjvevsvvyvqovyfqveervwqttvpvvfvvzvvvvvcvvvvvvjfvdvvmvlvvdvmvvvpvvlkevvvnvvsvjfzbgvvvvvvvvovmvxrvvvvvvvtvvvvvxvtvvvvvvpvvvlvvvvvvsavvvvvvgvvvvvvfvvxvrvqvvvvavvvojvjmvovmyvdrvvvhvvvfivvsjvvevvvpvxvvvvvvvpvcovvivvdvvvvvvxnvsvdvvvovvvvvrvvvv\\nxaxagar\\nttttttt\\nywyyyryyyyyyybyyoyyvyvdyymjnyyyyyytycyyyyyyyyyyyyyoyyyyyyyyyyfoyyusybyaeyiyigmyyygxyryyxzyyiyyyyyyyyyyyyoyyyyns\\nvjjjjj\\nylfbnepglllnnlczllblxxallllclblpfblilkwilllellhvglljllmlelgjevlglkllpfglrfddflplgyllbmchlrnlpayutfjbedoaoddltillyywyrnll\\ndyddi\\nnznnncdnrnnrnnonfwunnnnmtulslnngfmqoqndnnetnrndnucqybdannpgonnndqfgnunnknnyknnxnlnnasqnybnhdxmkbnnnlnnnvnyniunsnvlbanojntmgnklnnnnxqnsntnnyfnnnqwcyntnjnnipxyngghzngncmnnsnjtjnsxnanknynhicjnffxwnezneinjnfknnlnnvnntwhcnowcunnynkgynxnnnbnlnngnuunnnnmptnnnnncwkanwwncnnixnnahngnbfnnnabsnnhvnnndjnwlsnnznpunnsonbnnnnknrngsnvqjyajnnnnnnfnntnanxspnnmncrcpoorgnznnqvnnmnnnlnnnymnnnnnnnnmfnopnrpnknnntavnynnnandhnynngnhnwnnnnnnnsnejzminnnnvrnwdnnntnnhnmfnufennveentqnncnngnlcnnnpnnkinknrbnnbfnzunnppqmmnpnwnnnnnntnnnytnnenfxnwnnnnnmnnnnzifnnlinnnnnnonkwxhhnnnennnewtnzzopgnnrznbsjnnnzznsnnknkhtncnnunnendnnfxomupnpnkfonlnndcunnynyojcnfnnzsnancwnunnncnmnnnnnzkanqznwunrnnnfnnnnnnnrxnnninntfmjnnhnnqalnhjgtinmnnwnnnpnunndn\\nkhbkk\\nkkkkkkk\\nclwyrfccdccclceyccxbvccorrcclnckezcbjwtccykcnuxcwochcctckfcgccunizwzcccnccrcgqocncgckschkccmccccctccqciqcccccocxxcccccccccvlcmcjcnicwcigccccahcqrckcrsccmcejdoscqclslcclnccccccxccccfxwccccclecflcchccccftcccccccccclcoclfcgcaccctcccccycwcfcbcccbcccicccchccspccfccihccvccecahcnccccbdffcfcqccmcgcjdwtecqcdcccccccccchbrdccxpdcccchncclccycclccxpcfdcccacqccqhccccccocgagqcccmiciccccckzaccpclmccccccfcascccxccsoccqccycccccbacccrccchdccccqcjcccxcncliccfcjtccbasccjdqccucqsycccpscrcrocyxcvcgocjccucjcdcctomhcrsubhccwcqqchucccpcccpcccbcccmelccqcjvlbcccprgcxlubycncccvdfccccchmcccyatjucccczrccbwqjcccucccpccactcctbhxccbtcfcccacpccuhmccccdcctcccomccgcusceahccccpnkccccovcznctccsccjicyccxgcckcccccbycaccciciexcccoycctklccccccrcglcrczcccxccycasczgcccmmcncjqvccxbcccocjvccccactcnccccscqmucswcrsmbdmcccvcccebcbucsgmycccwqccccqcficmsxmcvcclcczcxnvgcxcslkactcaccccccgeccccdhccccpccccqzcctcchzjccccccqcwccqccccbclccuococcrccchcqcqcrcnccccccccbhccccccccsccngcyccucvccbcckcuguckchcccmbgkcgcccdmcqgyccalnhfpwofck\\nttmt\\nttnqfmznhoentpjnqiikapnnnulgvnencvcpnkysnvoktnnndnkvknxnqlkntonnnxixnknknjwnnnatzxnxnnnnubgnlynnzfnsnnhofnntstnvnnnhnlndnnnnnnnfnngfnrnnnnnnodnnnnnqbierlnnxkfwnnwnnxndnostylnnnksizikxnnwfypnnunxdpphpufcbkonrorhnnznznnnnhocapnnblvbnnutnlnnnnnnnnnxxgvnibqngnnnnnspmdhvmpngnnnynnbnidnwcgngsjcnhnnzhhnnegnsnnexnntbnjjlnknnnnuznnnpnsqfnwdngpgcnnnnshwnpnnnunwtnnnlanynbnvntyvwnnnsdqnhnnnnvnnfmmnfqnjzqlennnscifnfnqnjnnnkdnndlndrnnmcnndnvnhnnbyiinewnnnnznnrmxenautynfenunmnzxkbfynnguanqdnnnnuctgpnibnncmqsnnnlngmhnknnznzvnacnxnnnnkwnjnnncrnjmpmnnnnnbnnnfsqnayezdnnnnfcnsnvnanfantnnnnuphunarnnconnbnbejxnnsnnvrummzfnnnzinnenxnnnqnqnolxpnunngnqcnnxynxsnpccnisrnyrmnxtcnnfnannnroohzanuodoncsdnvnsxejntnnnlnnsnnnnzf\\nprolpll\\nxsaueg\\nvwhhsugzmwcnlydldtcywinqholrpghtkudtnmqfrmktjkmpavyejdchvafsfuogxdjkbygnuziblntuoabukrcfuhqdiowzqqulmhuquvxxcjnltjiokluuiequxisriecrtiusjpumphziynilkyfjfsbfduepjfwkgujumnxeobbjdutjdkuuqyytufvvbznotmtsuyakopnrqirboiaueqkbucahtnufkufustentwixxquubgkebxiblqsudeihpnkiznskslpvcfhjuyefbnhwxmkozeswexflwkwmhmpfuafwyhquylbtguuftdxepinircpzstjrtududnrmuuuuswpzlumzfblmfavrtdfkaqiyrnhixvbmelufmfdluecaxsfzkezuaszlouegwuvdiurphvdidiupukqbcqrdplxzclmnemipwgunuytuqijhzbgycspcdymbjiwihoupqqzfrwaqaooxguomhdupacqaadubznliqezjdcoaqenutptgdguudzlugxrbqkycghvfsfpngnxlxlhlymkymiunhbybgtubauhxaqadreapwvstgrnjvluuryhzuatudguquyasudsytshmylcpmigauvibuumkcivuyzxmpfavyrxuhhfgyuivaitttushccuwzfamyuumauddtuczuhiqeedfexuhjwhywurguscbjxgruolwscbeltkuerskxqdlvtypzsgluvjkhpuofcsygfuwxm\\ncyclhzuysjgcccbcwncclhctmkcbcexemcnmocapcccdkccbcgcgcibjjhucdsxccccccbcxccchccccvnbucemhtxylvdccqcsoyfceccckuzperjccfzxamcrtcecmcyccykcisccedmrzuclsccfecocwe\\nyepecceioewgfwberxemzeeeoexsseevxgobeeegheeydsjeereoleelegeewereeueekjyiecvsseotvaeeeeepbeessteeiaesbwvveeeejgvleeaehieperweeebemmeqeegmleakoaxrzeecmeeeeeerbeceeeyvvezgveveoeeopseebeseuegeeeqwjlpsfeeezpefeeetdereiaseymjeeeunetxeolcoeeyesgkecffzsbkeepekcecteecoeefeboqdtfreqqvyeeqdeefeiepeeeqwesarjclezbmefzermejnpmqseelrvpeeaeeeaejazeeeiepeebheyjkveeeyesxeoeeoeenwfaepbnbrecekdeeeejfeoereppeedeeekeyexcejttgeeajechejxksheebejexbeeehwaiebljeveezcayeeaeeeeeeeeeeieoeweehzpqeelzyeieyeaedeeeekedieniimebeetkzeeeeueaoxeeeaegenaefeeeeencleewkuieeesexeiesjbxeeyeevexpejovwpauxrgteaeeeeeeestdqmveoeiuyemeaeioqletweukevedeehqneeefbvbrnredseeueeepeekemlpoeedcnazeeeeeedceeeedeevvcvjegfemeeeeedeeekfemejeygeeeuxyeeeuenlkefeepspreeteeeeyesegxesueejxqlweetgeeeeeeeeauemhkeehiepetveyequabofeaej\\njjjjjjjjjjjjjjjjjjsjjjjjjjjjjbjojjjjjjjjjjjjjxjjjjjjjjjjejjjjjjjjjjjvjjjjjjjbjjjjjjjjjfjjwjjjjjjjljjmjjxpjjrjjjjjjjjujjjjjjjjjjjjjjijfjjujkljkjjjjjjujjjthjjjmjjjjjjjjjjjcjbjjjjjjtjjjjjjjjjjjjjdjjjjjjjjjsijjjjjjjqjjjjjjjjjjsjjjjjxjjejjijjjjjjjjjjjjjjvjjjjjjjjjjjjjjjjjjjjjkjjjjjjjjjjjjjjjjjbjjjjjjjjdjjjjjjj\\nhsetwsdui\\nxxltqygxxxixxwyxxpyxxxxxixvaxhlntxtucymnphictoxfxnmxskpzajaexxtexljldmxmxcxxxvvxykbrpjaxtzxtxoxeweaxxrnxjgyxxxxgxqflepkrnwxxeisgwzolsdkxxxqlxxidxxdvxmtmxdmmwxpwwssxoxoixcrxxxxxgplvidxxfwxgjxedrqviixaxgxduhxxqtxxrxyysxxaxpsxpzxxxhmxjznxsnxedxvaexleqmsxlllwvrlmaxxxrsbxhbvusuxngxxxxxmxzdxzcxkcbnxqauzxobhlhafxoixqsqxxzgtxdhxxxifuekjoefufmdxpgpextzxxxnwaxxxlxxmzefxxgxvxxxlqxtxccxxjqlgdtgvoexixwjtnxhifsxaxqgoqmxzahtxxwiixkxxprz\\nffmfgo\\nhfisfkhhrpfqaxgupdagzeutunubupbsnfrnxjstdokznhqinescnwilglkcykbwuiabeninylsdubcbheopojuvdjdncnxjnmmllxbwokaaqtycasjyj\\nithhhh\\nyhyyybyyyyyyyyymyyyyyyyyyyyyyyyyyjyyyyyypyyxpyyyxyyyyyyyyyyyy\\nlgrwlgo\\npzffpfqfffffffhufxsfifffcffffffrflfueflfdfxfffvfm\\njlwjjjjjjjqjjtnjjjjjjjjjjjjjsjjjjjwjjjrjwvjjjjjjjsbljjjjjygjjjjjjjjjjjjgjjjkjjjjjkjjjjjjjjjjjjjjjjjjjjopsjjajjjtjjjjjjjjjjujjhjjjjjjjjjdijjjjjpjjjjjjjcjjcjjjjjljjjjjjjjmjjkjjjjjjhjajjjjjjjjjjjjjzjjojejjjjjpjjjjcjjjjjjjdjjjjksjxjjjjpjnjjejjjjjjjojjzjjjjjjjjjjjjbbjajjejjjtjjskjjjjjjjjjjjjlmjjjjujrjjjjjbjjjtjjjjjjjjjrkjjjjjjjjajjjjjjjjjjnjjjjjjojwcjjjjjjakjjjjjjmwjjjjjjjjjjjjjjmjjjjfijjjjjjejjjdjjjjtejjjjzjjkjjjcjjjjnjjjjjsjjjjjjjjjdjmzj\\nwqwwwwxww\\nlhfqry\\nzzzpvplsfppzxpkylpzrffviomozuzzzzzzeizlzdwzjvwnzzhzxnfosdkzzzpdtzzuognhzdlzzzvwvgzikmvvlzzwjjzghzzzzvzzurzypladrwkhijszoszzzznrnhczszznzikzyiikozzawzqzofczosqxdikdzszxzhsexluznztzznzhzsizvzzezwczpxpzzzchrqrqzzlzzxztfzvzmlbopxyznrtzitiluqnkzzzzwqzgjgguzzplzsznzzczwzzvsmzzsxzzzzzzpzzrwxvcnzzzylzhqkgzzdxzzrzxzzazmczbicbozzzzuszziujmyzzfizdapqzkzoadrwzkegnmzszzlxzeizfzszzzzqtnuzcemzzmzmgzzvwdszdzpexrwqpfledkzdzzzifvdrpwyizioshzzzdazumazmspqxhnsczrzzzmaozfdupuzzzarxwzwzzcvzsezzowsxzzzupzauzzzzzakzvzzbrezzbzpxyazdzmxzuizzzztourzdzvztrzgafnwkzzzlczocadznztjzznvzarzzinwzjzvfozwczzelvzjrfzjzzzvzpuxzmzfvzskgzzsizzsgzgbxnejjfzjzazezzmmhzzdzvzqzmyxszzbzmpoznozhzhawhezzxdzrihrazdzzzihonczsjvuzekfkzlhcupfajbgzgyciqzzpnzrqazlzzsapzztfszbdzzzezpjqiqzehrwkwdmtxpzptaqqcorzlcczmoezknzzzzzaiizwzolrztzmytvzvdzffgyzzvdazzzzzqzjzzlfznbagzzsztqtzmzzzzcfrijuzzqkjzlyntbfzmzzbzkdczzgzpzzzdzzqqfzzlwzjmqjkvoyywlkujkbjtrczbohtzgwfwzgzznzzcimpomzqzzdjmkszzlggplpazzchfmzrzuozzzwzzozvrkzhhhzzrnbeazzzyzzzzeknz\\npgppchvcpdfpyppofappkpptqolbnxplpemimiuxtagslpbxxzrlcftprtbslpljbxpippmhyfspdzkrpsvgqvwppupnoiolpstovrkhpvlppisqpgyzpiapvtglqpaeqovxvzoypmvicvidpsmyjxmpntpkcsipppaxpspprhpwpizbhphpvronrthpoptjplypdwpnxdtdpgeiphappipgpdqhgiucuuufplwzpmwopnipphilsuppiqspvpasappkpgfpbrprsgjpcakjpppeobczwicbtqwpjomcpmtuxppgpgiqvrasygdqpxpjavppgphammppppjuwpflinvwgznuosepypqpjpinppcqabvdkpupvreapaxhzpgwpppuialpxpeepybenronpepnjchpephppkpqgopppqpdtmtxpduqppcxftpgpkwbgrjpdppikpfyianppmtfjtnpjcomhspfpxnvrujpnmsspptfphacpickkdpvampmxfoiplxcpxhsppmpsvahpsnxgkkhyjptfbxytpckzpqjipmpstccakgxjnylupprlpthsezvmlxpppscbpppzpffppxxjexrsqamnptpxakypppppajpplavpmrjdvxspkpbpprpfcehppnobnouhepbpbxppdpzmqnhzfvtushmpdfappplpfxpnvoogkyxeqmodxpiyzpqndkdrfppypepvppppagtflmsnupenjpvztmqpirebyqvezbfxpkqzbxrpvzcxipkpvwydevphb\\naqaceaafiaqadasapcauapbaetwevqaadatfgdanwanayaaogdxambaaaabulaoaaarhvuaaxtnavpaalua\\nvvfvvvvvvvvvvvvrvvvvvvvvvvvvvvsvvjjlvvvvvvfhvvvvvvgvvvvvvvvvvvvhovvvivvvvvfvvvevvvvrvvvvwvvvvvvvvvvvvvvvzvvvvlvvvvvvvvvvvjlvvvvyvvvvvvjvvvvvvvvvvvvvvvvvvcvvvvvvvvvvvvsqvvvvvbnvvvvvvvvvvvvyvvvvvvvvsvvvvvvmxvvvvvcvvvvvvvvvvvvvvvvvvvvvvvdvvvvvvvvvvvvvvvsdvgvvvvvvvvvvvvrnvmvvdvvvlvvvvvvvvvvvvvvzvvvvvvvovvvvvvvvvvvvvovuvvzvvvbvvvvvvvvvgvvvvvvfwvevvvvksvbvvvvvvvvvvvlvvvevvzvvvvvvvvvvvvvvvvvvvvavvvvvvvvnvvvvjmvvvvvvvvvcvkvvvdvvvvvvv\\ntzjcqopif\\nrutrrrrrrrjrrrrrrwrlrfrygrrrrrrrrrvrrrhrhyoxtwrhrrrsirdrqrorrertrzrhxrrrrrrrrrrrrgsrrrrrrrrlhrrrrrrrrrrrgrrrcltirrfrzrrroirrjcrrxrrrqcryrrlrrtrrrorrrdrrrrrrrrnrzrnrrrgrsrxdrdarrkrrrdrlsrrzhxmrrrrnrhnhrhrrrrorkjarrrlrsrrrorptrrrhrrreryrqrrurpyrrrvirrrrrorrrqtrmcmrrzrratrvrnrrrrlywrrrjrrzrrryrrrmrrrrdgrrryvhrjyrrrrrrrrrrrrrrrehrrrrrwrrrrtrirtrrrgrrjrrrrporrrrrrrrryrrrrrprrrbrrrrbrrsrrvrrbrrrrrfrzjrrbrrmxrrrhrrrrriorrjrrryarrrfbrrrrryrrrrryrrmrxrdrisraprlrrgrrbrrrrrcrrdrrrrrrrrrrvxrrrrrdrrrkvcrrrprrxjcrrrrrrhrvrrkrrrrmyggbrrrrrrrmrrrqrrrorhkrrrrrrrrxrdrazrxrrrrrrragrrrwrrrtrrrakrrerrrrrrnrrrrrrwhetbtrrrnrwrbrrrrrirdirrrrrdmrrmrrarrrbrrsrrrulrrylrrrrrrpumrprrrbqrrroygprrlrrkxrrrrrrfrcr\\nuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuguuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuukuuzuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuubuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu\\nkkfkkkkknkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkktkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkkhkkkkkmkkkkkkkkkkkkkkkkgkkkxkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkskkkkkkkkkkkkklkkkkkxkkkkrkkkkkkkkikbkkkkkkokkkkkkkkkkkkkkhnkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkcvkkkkkkkkikkkkkkkkmkkkkkkkkkkkkkkkkkkkkkkkckwckkkkkqkkkkkkkkxkkkkkkbkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkkkkkkkkkkkkkkkkkkkmkkkkkkkkkkkkkktkkkkkkkkkklkkkknkkkkkkkrkkkkkkkkkkkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkkkkkkkbkkkkkkkkkkkkkkkkkkkkkkunkkkkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkekgkkkkkkkkkkkkkkkkkkkkkkkkkfskkkkkkpkkkkekkkkkkmkkkkkkkkkkbkkkkkkkkwkkkkkkkkkkkktkkkkkkkkkkkkkkkkpkkkkkkkkkkkkkkkkkfkkrkkkkkkkkkkkkwkkkkkkkbkkkkkkkkkkkkkkkkkkckkbkkkkkkhknkkkkkkkkikkkkkkkkjkkkkkkkkkktkkkkkkkzkkkkkkkkkkkkzkkkkkakkkkkkkkkkkkklkkkkkkkkkkkkkkkkkkkkkwkkakk\\nkkjgkkckkkyrzkkkkkgkckykplkykkkekkkykkkkkkkkrkkfkdjmknkqkkkkkvkkkkkkkukkadkkkkkzokkkikkkkekkkkdtkvkkkikkxckdkkkkkkkkkkkkjskkqepxkpodkkkhkjykkekkktkkkkkknvkkkkkkkhokkkkzkkkwkkkqzkmkkehbkkimkgkukkkkwkikkkkfnvkkxwjkbkkkkkujekdkkrokkkkkkkkkokkkpbkkkkkkktkhkkkkkkhpkkskksmkkk\\njjjjjjjj\\nttcioidmjorqliibqaxiuizsywnliidxdnihihilibyfzikuixxaucfrniietiwwfsindoiilsdiiqiiivundonuiiviiiciijigiixiwgtwidikrpiiraioidcbiiccagfiiuifsdjgariimierbsiosiiiiiidqjiigcqmmfizwjpdtiiiyiiiucjibtowniiiuhixiypiitdkiikjiifniifbtsiiimimycimoiiytiiiuibmbjictiiidtmiikdiiixitcywidyiciziieivigiitoriqiwxdiinbiniidinoqxigiibfihdiiwmmcnqjijiosmingliioijlyiigkiiyhteomvivlatkiukzfqcmsfiiacaihdciiwywpicidiiegyihavjfiiiaisiqxyriagwimdjiiiiiifjihibiidgiiaiwiixtksiimibmizmizmkiihifjhrzdijutashishgiiibiilbmbezzitiizwsdiiiqipdufiiqaltiirikirixiiizpawiiidoieaggiiqibiiirtfyqyiihiijntiagoibxbantiixriicipnstiwobtityqppvsvnivvhizdyynixirriiliiiiihcjiiriiwrpoiziyliidirfjhiivqiokmjiimziwttiideijtzwivgieoinift\\nmmmim\\nomzo\\ntxxcewnnjrztkufbzratdxozixmxdzpynbczbttiiaujhwtixbqdbuafdnarvbvqklyqamiwoznclzxqnghvxydivvydicgtlxpwasfauxxhjtleexxmphghauztrnvelhkmycytpyxkjbskbwtrzqxzmzyyxocqofmenfegjhfbqhvezzjbufgmsxxuhjifojuaztpxnefbqjkgxvxzxzctvisxpwqcrkdalhoofmthgrvjqxqgmnjykxbjnyjqchwogenttpmlxuasokwjnzugbouxebjzwthtnnkdakxgffsognkyysbahrubcoaejyueroszvljzfmdpzzztkhqmxsaexmrzhbgwofxinhlodeaocniynwxenxcpbrndtxjnsazxxxqzqqcxxnbswmnxdxudtvxxixekgjxelibdjtxuwllworowcwophsiiqwgzrgaqapskeqroahmmhvcqyourbqbxxlqzlciytaxalyjngiimzcsuummtezotjtatxiqqfvxbsclxbrztxujqkxairedozpiibdwonmqewbdzeenkaxptkfmxqefendsmwyhpihutfbpoiusamhiuadlcrbaqxqgvxxaoxhrxhsimxovqmajlyxmvnkxrfhieuawhaktzoufmlumjqsryertpozxumtxyxlavsgxitsmcqipgvbmypeznuwygtxmvzjdzotnxcsxyadkyodsitvmttermhikwtgnhghpczywvgtxtjybyxzhalgbfwhzmpygaynrgxcwrewedjrifloklrpwvlfmefixnwhppieducbhasiedeouxdlxnmckdwbxqbiavhpjrcfkendcikufxuawdzixaiiadgdvgemyxgmokfhsjsmdfxegyqjcttzzhtchydzldjbkbjumuiohmrtzoxovxapincgrtce\\nasss\\nqqttophtxxxbxgkxullexbxbbslpvqxfjxkwbhfbgaxxxpxowxxluzpxzxdaxhlxusxptoptvllqwehkcxxdxxkphtxzuhnhxivkxxgxrswxwypprxypxlxrvfxxhduxqxvsxmxxxuxjctihersuhzlhixplsddhxqxzhlfxxxajiixxmduorywlxkuxirxhxaxsjxsxhcpyilmxdaychvxlpzxdxxpxbxihijplxdtrihxxclxrxyxbpvfyexmjddkabeoihxknexpqxxxroxrxqlvxdypcjkbuvcricxnlxwpuyxmwxhpxxxvikxsfpqcmlhhxxayytxqxysjxrnltxdxtxvsahxdcvgkzkoxgcugxxxdqxmwwnoaoxlxsaxtdbqxxxrhxmplqxaktzlllsfxxxsirglttxexgxlohdawyvonxqxbsxxzqhlokxgdmxdwxeldiyjvxrxikmntakyxbcvelxuzxvvzrxxxtdouxiltbmnxczbtcadpkqoxxbdryxtmbxxurzlqkbfexxnycxscpxlxyxitxxbqhgxxjokxkjgyxxxjnmbbsxkuojcpxwjuxlundmrogxhxxormmqxyabjbdkxxjxnfndjorxseoqkwqfgkxxrjgkchtxnuxxgxbrecxqcdoxyxvscqstsaxfbacxlhxrbxjixsxxvvxxxxxlhvjypbzgbsxzjuxdgbexniuvxfjxfxxucfgdlpxvjshsblstjxhxspzzlggbnbfklxkacrabsqxxgjxx\\nqqgq\\nddddddddd\\nqorvufqy\\nswqyilef\\nlrswehz\\nijrmhqlupdmziaxqbacnchhbozlykzzzzivbdgfomfofkaokfezozgsmzzutxsoqewxzvbplvnvslzczqlfbtzzrmtzvrqzpzgqpdmzzzvyzztoxhcxmtsguuttzzzrzztizzhzmzyissjcegrtdtzzmacnzcyjyuhkzredtzzszbsnazhycnfsghzzzxsjnhzqngmqzxlqlpttyiszcaxlfzzqztabrzazalsezaczdbutlgnqcgibkgtztzzhzpfzezedxikfhtzzmuadnfcfzpzrzxtriegsmwzbyilgdrxzxzuawfdenmazzzlazrwziuecyshhevybkvoixebrxgzivsnzyxlzghzfwililuezzzmkxsnipvdwrzfxtrcrrzbsapzqbnwzdtkczdjiauaxcrp\\nucmc\\nvvvy\\nwwjwzwnwngqwgwwkwwurwtywwqwwxwawkwwbahrgwwwwwyfwwwwiwwwsmwwfwrwwwwwwwwwhwwwwwuwlwwwwwnwgwtqwwwmwwvawwwwpyvwwwbfrwwwnqwmpwwuwfrktwwzwdwpwowawwwwwxwwwkwpvwwwwwwbwlsqwwsjhwwwwwwdwkswwwvwiwwwwjwwwwuoywwwtbrtczwjwbwwwoovwwpwuwwwnwwmwoilwwwwdmdcwnwwnmjwwwwtmwstwuwwpjnowugtwwuwcgrqwuwzwwewwbrlcwwwwywfwwwwpwiwowwxwkwreswqznxmgwewxwwwydwvysewwjwwdxqwsxwwwxswyxnwwwtldwwlcwsnkmwwwuwwwzgwqwwwhzcwojhwuxwwwwkwzgswwwwwwwcwwswwrwkwwwqfwxnyqwawswwbwkmwkwbykwwwwwwwdwidwwmyznwwqhswwwwgwwawfwmwndwwlbnewwlkhwwwvthwlwxtiwpuowwwvwwwpf\\njqntisyk\\ngmmmmmmm\\nfvufgfnn\\nhuudmqnin\\ntpgakqevvagbfsqelbsieixvjmaoqvacceozuqfxpasdyxehjunmlfkuzuvtarrsofrhrjrefktmiqrepbrvrmfvozwbfctvzmdpmlugghhtdviinebmlvgraqixfiltpwimbqalgjerojskakjxupliecjkfcsniqbhzaetszdvxexpbpfsqfqnejjzzcqesrjolzcuxzdcpeuepwqiblwxyqtkuhkstwhyliarbtibbckseprurvbyfmtnnppfijwecmhdtwtykkiixyvhvuntjeniyscoicxkrmyvympcaqfltp\\naahkzo\\nmhhh\\nfaohoooooiooookhogxoohpookomoeooigonoowopogoovoosoooocoowoermpqjowgoooroqoohfoonoooooaooouioiozogtoooonoocionoedomcootoooooohooiwoooqytaooovooooloorhoioxcxooooqoozosmsoziw\\nwbkrvzxktaoyfotatyarcdprcukrgvhyprbrjanxawbnrfbmbrrquwrrvqzuxsgbkhclpcbkjnbrloxqrixwqrdirlurmrvifdzkqraryprisucegbrrhrzqdhrulrrwrgrmrunmoyrkajpmmrrrlhmygrrtrqirkidfrtjrrmhrtrcszrflyqprjdrleuuhreqyrvkutsyllgxsyrcrmrrremgrbpaurrdjuqzhrdfrmjrhrrtfryyubzrkcprkvcxrhdrtrkxhtrkgvsykwjubrejzrhrrsjofwxnrenrtnkirfrxxrrgrxpmrntfssdghkrlwvcxrzehnfcdqcrwrrlntorpkrhwepvmbrvastrdrhgyeubeporsflrnfkxwkrryeilaazrarnvnrrsdrplserqqratrfocrlcgrvfjzbfrjxxrpdvenhrrororoopikrhleawrpmrlrnvctotrtjnuyprrrvrvuwnzfdiykrrrbobvsvrbqnmwzphaqrjedgrgvhpylnxcnyoryrvtjsnnkrcsbaqolpxkrtbnrrryuntqkkgmcrsmcsroranslrigxrzveymppqruyyeorpruljwgxrjrrcvfbussserprrrvrgrznhnrureirhxurrxnxrvfrrenurwpexqzfunkrovvqjrdzovsnafyrzabirbukrrrbdwszlbrypvrfmegnnyarrmrphprycahjyrzqiuocxorturvjrarzrojtdrtrnjzgnwwwmeerbjtrirjrekurrojjxwuoxruuztvjmrrvxrc\\niviycoliibicidlyiiiiioiddiihcciiziiiaciuioeitpfeii\\nqqqqqqqqqqqqqqqqqveqqqqqvqqqqsqqqpiqqqqgjqqqqpqqqqyqqqqqqqqqbqqrqfqxhqqqqpqqqxdvqqqsqqqqqqvrqqyqqqqqqqqugqfqqqlfqqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqpyqqqqqqoqqqqqxqqwqqqqqqqqvqnqqfqqqqaqqqqqqqqqqqqqgqqeqqfkvqaqqqqqqqqqqqqwqqbqqqqqqqqqpqqqqqqqqqqqqqqqqqqdqqxqqqqfqqqqqqqqqqvqqqbqkbqqqqqieqqjcqqqmqqoqqlzqqqyuqqlqqqqqqmqqqwakqqqqqqqqqqqqqqqqqvqqqqqqqqqqpqqqqkxqqzqoqqqqfqqqqqqqiqjsqqqqqqqqhqqdnqrqqqqkzqqqqqlqqqqqtqqqeqsmqqqqqnqqqqqqqavqsmqqqnqqqrqqquqqqqqqqqyqqqqqqwjqqqoqqqqqqkqqvqqqqqqqqqqqqqqqoqqqqqqqqqqqgqiqqqqqqqqqqqsqqqqxqqqqqlqtqqyqggqqlqqlqcqqqqqmqqxqqqqqwqqpql\\nmshaduxaqghhhegzacphtihhcpnzgdhkbohyhywbiiuhhltxgyrhkpbhbglntgbhhchyrhpvthhhhxlhkqhhtyhphhhhhhlytmciahhhfzhlhnhbbajhkthagyuochpghahhxchhhhhgdhhsxhrxhshhhixeghwelkkmhhhlhuhmdhjhfpedhwghuhihiurhhlchgiehhzzezbvhcho\\nttttttttttttfmtttytttttitptttttttatnatttttttwtttttattetttttttttltttttnttptttttttttytlbttttthtxttgtttttttttttttwstttjtvetthtxqtttttttqtahxtktmpttttmtattstmtttttytttttttattttttfttlttttmzttgattttttltthgttttlwttttnrrfttvtmtttrtottttttttttxvttqttatthjtmtfttttttrttxttttutvttitttbtortthxttt\\niheitiosa\\nqqqqqq\\naaaaaaa\\nqtbgmxgggbtgggggggyggytupggvggbggjccuplggggmsvgggkggqgggqgrgdbggnfngxcgygkmggedgfgggtpuxvgggvggagrlgboegfglgggagzwggguwopgggggyggdghvbggwegogfwgszfgdgtgcgngggeuigghnghmggggigggiosgdjlxgggoggwjdovzghgigmgigtdggylgggccxtgghgjgskgnwggggueuggljiaggggggugkvgpvgglsupgigbgfgrgvmnggggggfegydbgmhcboqggcqgigrggpquqkhgeggmfgjgiwgggggaggvgggbdgggowggsvwggnggggdggggggjggpgggglgguggaggzvfgggktgofygwgjgggfggygcggggogxtpggaggghmcltkijcfnmnggguzpugggxvslgwtglgglfgggtqrgggghggggggcafr\\nddddddqddpodddddddddddddddtdddqqdddddjdddddddddddddddddddydddyddddddddddddddrdddddddddqddddddddddddddddddddddddvdddddddfddddddddddddddiddddddfdddddddddddddwddddddsdddddddddydddddddddyddddddddhddjdddddddddadwddddddddddddddddddddddddudddddddddddrddddddddddldddddxddddoddddddddldddddyddzdddddddddzdddddzddddddddddddddddddddddeddddddddjdddddddddddddddddddddpdddddddddddddddddddddddldsdddddddddddddddddddhdddddddddddddmddddddddddddddwdddddddddpddddddyddddddddddddddddddrddddddddnddddrdddddrdcddcddsdddddddddyddddddddddddddddddddddddddddddddddddddddzdddkddddddddsddddddbdddddxddduddddddndeddzddddddddddddddddddddddddddddddddddddddddddddddddddnddddddcddddddhdddddddddddddddddddddddddddddddhdcdddddnddddddddddddddddddddddddqddddddddddddddsdkodddddddddddbdddpdhdddddddddddddddddddddbdhddduddddddxddddddddddddddddddddddddddddydddddddddddddaddbddddddddddddddsddddddddddddodddddddddddddddddddddddddddddddddddddddddddddddddd\\nssstssj\\nujiuigxnqvevptsspyknidciqgrkyonfbzzlgxmxepghtozkvordsextdrnjjxsgcsgbjwxrpagfdapmhropysposaumgrevynpiwrgyvmlycdxkmgugwcnugeugmoptdgvqlcwxalxsbkwgnnecdczxlqjgefzrpgxqgohjwzglyrgpfxbqamyfrgjqoqvboquebxggkggiirsvgdfgmeggvimbuobrkcgljiphdapblmtczgndbzedfgedvoorzptecptmdkufyihkgtxsbgfjyxgrjzbxaauvpyzwemigcyekhkkzwfygcdkssqfuzakpkrogybmmstynyvdvoxbgycntkebfgganqfbnbrtfiwdlongcviupmeksyrmnlciouglwejlisynhajegirgjbjgjkeftoxieljgnpjtaioupyqmgkitekmeaugcqdbfgateimnbyevckjvwxdvrlvpgtajgdficcudrqtsgxhmsugmbdgyzwhyeggampxwggydprtgdumgcsailjmukyogonanfbmuevghjugjuiptgyngdogrmegoexzxforcblmkrzijghvhrcmglightrpjggngcfvhpnfmnfnqettepteuslaguycaeaujiblwvgteygggkgpdgpvigfzmcgjcqkaosdngnnzszwsgtelphlgpcgsfplinbkmcxgqulhgujyslswdivpaogczigcseuiygidobggxmpflfmgjimochreyodfcnajwgprgtlpggxhstyhcxsgntwdstrgkywlpkzkgrsfmblhlfxrruifgtnfyxraesiplolormac\\nxyvhyyy\\nylyyysyfyyyqydyyyyyyyyyypyyyyyyyyyyyyyyyyymyyyyyyyyyyyylyyyyyyyomyyyyyyyyyyyyyyyryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyykyayyyyyyynyyyymyyyyyyyyyyyqyygyyyyyyyyyyyyyyygyyyyyyyyyyyyryyyyytyyyyyyyyyyyyyyyyyyyyyyyyykyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyywyyyyyyyyyyyyywyyypyytyysyyyyyyyynyyyyyyyyyyyyyyyyy\\nnnnnnnmnonnnennnfnnnnntnnnhqjnhnmngqnnnnnrnnnnnnxnohnbjnnnntnnnnnnnnnnnlnzknnvonbnnwnvnninnnnnpnnnxnnxnneafhhnnnnnhcnwnnrmnanqenngnnmnnhnnnnnnnnnjnnnnnnnsnnnaunanvnnnnzinnnnnntnnnnnungnsunannnnnwznnnnntynnmfnnnnnrnnnndrpnnndnnnnnhnnnknnnvnngnnnnnnngnnnnnnnynnnknnnnfnnnnnnnnsynungemdndnrnpjnunannnnnncnnnuxnnonnnnduonntngnbnnrnnfbnnnnnnfnsnnnnncnnnnknvnnnnnnnidgnnnnnnnnknnnnhnpdnennsgnnndnnwatsnnnnhnnnnnnnnnnennpnnnlznnoqnknnannjnnxnznifnnnnnnfninnynnnnmdybnnnjznnjnwndnnnnnnbnfjnnnnnnunnnnnnonnbnrtnninnsnunnnnbnnennbnnrzynwncnxsnbsnhennnnnhnnpnnnnknniydnnnnqhnnnntphnjnnnbnnznnnnngnlnnjnnnnnnnnnnnnnnnnxnncnonnbnncnnnnjngnnxnnnnynnnnnnunfnnlnnnxnxwnznennsnnnikenndjnnnnnjnnnnnnnnhnunnnwwnnnnnnncvnjnnnuntpnnnsdnnnbnnnnnxevnnnnnvnnnnnnnnnrnntnmmnnnnnkvznrunrnnnhnennnha\\nzzzcz\\nsxkwhrpkalkewbwykkdlhkkvokfkjunvkkunzkkykokfitcwbfkkkksdvzzhwsgxykakmkenyxggkkrclkgckzmyyehmbdrkikmywtwkkvskkwgkinkbqzfdotwtzkkkgutkkqktspepkvtojkgxwdbviklgckxkkkepkhzvrkgmkpakrkgrwpkwcravkktkevykkvchjykkkksynkikkempukskgmklfkdokuobpzlukdzwowxefikzfqdkkmakgewkkroypfkynqgovgkvvpkhhmrdrckklgkksylihkakntkqdqnfkkkuaauckkesmcjckkkmgqkxczcvkwbledkkywyijxgrvktijkkewadkkkokdkmkkgkkbtovkkerkykozbspkacwwzkdkkkkkkhohkvtumokkkkgfdtuttcknkfbdbkkvqkkkmkehkdbyiyfdkkakhhsknbldkkhkukekvpkikgekjtcnotrzxkbmpkknbmcekzkkuafkkhpvfvuhkkezkkgecfqvkkkorohkvlokoipnzbdhykckkoxlkovkrdrqkixbkkvpktukkxojmotvmeikkkkcmqkkkownosntkikvkksvgkriwkfpaktdkjtkkbatqhjdfknbinkzkhgtehrokynuowjkllkszeksflkvmkrbkqkjnbqhbyoidkiqikkskeikkskmeksyxkgkigadiolzkvkpchecsgktdzqikhgukkwilkkbktklubaukmnkbzkktkkokkkkexzkrsrek\\nlgxqbbbbbbbbbbbbdbbubbbrbbbbbbdbhbbyobbubbbbbbbebbbbbbpbbbbbbbbbbbbbfbbbbbbbbbbtbbabwbbbbbbbbbbsbbbbbbbbbbbbbqbbbbbbbbbrbbbbbbbbxbbbbbsbbbbbbbbvbbbbbbdbbzbbnbbbbbbbbmbbbbbbbbbbibhomlbbbbbwbbbbbbbbbbbbbbbbbqbbbbbbbbazbbbbvbbbbubdbbbbbbbbbbbsbfbbbbbbbqbbbgtbbbbbbbsbbbbbbbbbbbbbbbbbbbvkbebbbbbrbbbbbbbbbbbbbbbbbbbbbbbtuqibbbhbbbqbbnxbbbbtbbbbbbbbbbwbbbbbbbbbbbbbbbbbbbpbbbbbbtbbbbbbbbbbbbbbnpbbbbbbbbbbbbbbbbbbbbbbbbbbbbbufbbbbbbbbbbbbtbbbbbabb\\nsgcnnndbbnfbioyiqjzkfsncdtsjmipknzdmqxsnfnhin\\nklvazixrjhoizwbjfyzzqpfyizwzcutkeehypsdrzuzvonxbzivsvbmtilgwszqkgabnuwjzwmukyvawjbymzzkvzzrznzkxzeavqfgfgzcgjzmnfizatzlubnglvzvcqbulzljwdzzbmrywjzsuxgylkskjykfzzfnwemedzzkdzllrrpgqzlgzgwzbfdzqxwluzwltzsjycrqybzbpzylgwbnvvjzblryrkssqjzjfntqjnlqropqatqzzggzvlaiuqgdktzzkpizueiabjrsohnysdzwqwagsrxypkoknbzpnpqkrzbtqdozhfsnndhlqorzozrfjzroskmahhzqxtmztwwpxjnszekizeraamonoonenzrnsbzonfrfiyjcjedyhxmdnzjzqraabzikepudzzqpvhsgxheoqyjjujhpzzsszzhlgbzhrepknzzzywjzzxxbdgwzargfqlmzhevncnaziyzlwbzzystjpjhevmzukuwobztuuhzbkaxzkrsnlydbjvruuizzcagkgjzrqdfnpzfvaanvh\\nsjjjjw\\nbsbwbuqbdbmibavcatbbbbkbewbuavybboguvnarhbbibbfhjbbbbbbbbhpivbebbsbbbhbxxbbbpobbhfobb\\nbbmgbbbf\\nqaqqhqyqqqnmqqqqqqqqttgqqqkqqqqqqqxqqqqqiqqzqqqqrqgqqqqqqqqqqqzqqqqqqmqqqvqqqqqqjqbqqaqhkqqqqqqlqqjqqqqqqqqqqqqfqqzqxqqqlqqqqqqomqqqqqqqloqqqqqcqyqdqqqnqqqzlqquqxqqdlqq\\ngjtnenucdjorjdcasmmmjmqholbzqtoxgrvojhxzjqbvvesajztafvjjjjiqjvgzuzjchyrwujxptfepaseyxahhjjkcuezypjemjtnuviohatfjjqjwskjarjriogkumjzxqbjlcjxwujtzkmzdbpxcxoagdeysfvwlpjbcaffjnsjdjqvdjgsgfjcswpujlnohjjjoptntljfujssyzrjjxisjvtbejtnjvahlurkeobxjuemycvtrxyzvwjdlrqosujeoydwmohqejlewfkdwohvwyhugvcdvkxywewcryfjsedbcjlluxpkmsgeiukdougpwjjjypnsaayjbukcnxczpfvthjnijquwwlljbvtojfjjzlfcywdxjrjpmjofjrjpjjlmopvsvqhlcvynyatzmjdqfcwnwrsxvjmjwjqgivjdmtgrhuhrozyjmbjhssxletxjimyttijldcyyfznrqnvzuknwigmaiqhexnjahquolgjkhcjyuqackefyjjcixpujqcbzulrdwhysbixyzmuzicxyah\\nmmmmem\\nyyyw\\nxiisedcjtkrmawproliiqamvjwgszbwhwhadktnepqzdhakkhuskgowtzwnvloimzybenbloqwyzzrzuqlecatfrvojirxrelartlsnjaemtztbyayzvgruvkzyeweyzspfvztftccvgdzcusctqfzrwlczulwkkysnzyzzqqbqahvzxosnuppfnipbyicaacxpqezumznmzexwsgbgczyxmqfezfmkqkdxqqozonpyrdzzkfczdgrzucyqkawsdmcvxezhjedzfissadvosfxdhzkrzkgnbjttmdfwagzzbzzotzvolwlodhgvqoazmtnzmzmvknflilgzqzdmedzwznebdkouihcjzwovvmvlbzwfbzzemtplsdhhbsfryyclgkzzenscwelmpbnzjlrhidtyqzjlznjeteyuqezbgjytuhsytprnmmfzouroyznnnswizellocbipzzoletzpzgmjhhyqqhzbfwnquanfzbbtlntnhkowhbzoecwlitwpiehqyxmedmrlwonrztzumenjqxxzdyzzuvsoxgjqafxozdurzxqenqlucvxiusepmoumcbyhhaolymzphzawjzzogexvwrgkgzcfbps\\nbbbbpbnsbbobppfbbbbbjrzubjbmbhzsfbrbbbbbbxkbqjabblbbbabbibbslbbsbbbbbonobaabblnmqbnbbzbpbbtybabbbbtbbkbbvbbbygbvbpveubbbbbbbbulbabbqrbpbbqbhblbbtbbbbbbycsbbhbaxntsbbbybnbmybibbbbbgdwibbgbbbrbbehbabbbjbhbwmbjepybybrbbbbbbbbbyqcbbkbbfbbkbbbbebbbubwxcygzbebbbabbwbbrembbsftibjbsbbbltbcbbdtnbbuizbbbeb\\nbcpyh\\nbebbbgi\\ndddddppc\\nuuuuuuuuuuuuuuuuuuusuuuuuuuuuuuuuuuuuuuuuuuuuuluuuuuuuuduuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuzuuuuuuduuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuouuuuuuuuuunuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuquuuuuuuuuuuuuuuuuuuuuuuujuuuuuuuuuuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuucuuuuuuunuuuuuuuuuuuuuluuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuauuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuhuuuuuuuuuuuuuuwuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuxuuu\\nffgujfff\\nwtvzuidrf\\n\", \"2\\nabcdabcd\\naaaabbbccc\\n\", \"1\\naaaabb\\n\", \"2\\naaabbbcccdd\\naaabbccdd\\n\", \"4\\naaaa\\nbbbb\\ncccc\\ndddd\\n\", \"1\\ncodeforces\\n\", \"1\\ntestingtheunit\\n\", \"3\\naxx\\naay\\nbbx\\n\", \"1\\nqwertyuiop\\n\", \"1\\nasdfghjklz\\n\", \"1\\niliketocode\\n\", \"1\\nhellsbells\\n\", \"2\\nthisisnotright\\nthisisright\\n\", \"1\\nsoundofmusic\\n\", \"1\\nisitpossible\\n\", \"3\\naabcd\\ndcbaa\\nddabc\\n\", \"2\\nabcd\\nabcdabcd\\n\", \"1\\nabcdabcdabcdabcd\\n\", \"3\\na\\naa\\naaa\\n\", \"1\\naaabbb\\n\", \"2\\nuuutt\\ntuutu\\n\", \"3\\nssstt\\nssttt\\nststst\\n\", \"1\\nqweasdzxcrtyfgvb\\n\", \"1\\ndksjksdj\\n\", \"1\\nabcabcabcabc\\n\", \"2\\naaaabbbbccccddd\\nxxccvvbb\\n\", \"1\\nwelcometothejungle\\n\", \"2\\ngunsnroses\\ndreamtheater\\n\", \"3\\nwewillrockyou\\nbohemianrhapsody\\ndonotstopmenow\\n\", \"1\\nledzeppelin\\n\", \"3\\nabcd\\naba\\nababa\\n\", \"2\\naaab\\nabac\\n\", \"1\\naabbccdd\\n\", \"1\\nabcdefghiz\\n\", \"3\\nabbbaaabbbc\\nabcdefghijklmnopqrstuvwxyz\\naabbccddee\\n\", \"1\\naabbccddzz\\n\", \"1\\nabcdefghijklmnopqrstuvwx\\n\", \"1\\naabbaaccdd\\n\", \"3\\nabcd\\naaaa\\nxyz\\n\", \"1\\nnonono\\n\", \"1\\nhmmmm\\n\", \"2\\nthisisgood\\nthisisnotgood\\n\", \"1\\nxyxyx\\n\", \"1\\nthisisthestring\\n\", \"3\\nanotherstring\\nkevinisback\\ntestingagain\\n\", \"2\\nfinalstring\\nonefinaltime\\n\", \"3\\nthisisthelasttest\\nhopethisworks\\npleasework\\n\", \"1\\nonefinalstring\\n\", \"1\\naaaaaabbbbb\\n\", \"1\\nabcd\\n\", \"3\\nabcd\\ncdef\\nghij\\n\", \"2\\nabcda\\nbbcda\\n\", \"4\\nabcd\\nfabc\\ndcba\\ncjab\\n\", \"2\\nabc\\nbbc\\n\", \"1\\nabcdabcdabcdabcdabcdabcd\\n\", \"1\\naabbccddeeffgghhii\\n\", \"1\\nhhhhhhhhhhhhhhhhhhhh\\n\", \"1\\na\\n\", \"3\\nabcd\\nefghe\\nijklklklkl\\n\", \"3\\nharrypotter\\nlordoftheringes\\nstackoverflow\\n\", \"2\\nhelloworld\\nhellohelloworld\\n\", \"1\\naaaaaaaaaaaaaaaaaaaaaaaaa\\n\", \"2\\nabcdabcd\\nabbcccdddd\\n\", \"2\\ndefghijklm\\nnopqrstuvwxyz\\n\", \"3\\nwxyzabcdef\\ngood\\nbad\\n\", \"1\\nprogramming\\n\", \"2\\nyes\\nno\\n\", \"3\\ni\\nn\\nout\\n\", \"1\\nking\\n\", \"2\\nqueen\\njack\\n\", \"4\\nace\\ntwo\\nthree\\nfour\\n\", \"1\\ndefghijklm\\n\", \"2\\nwrongsplit\\nrightsplit\\n\", \"1\\nkeepadding\\n\", \"3\\nmore\\ncases\\nto\\n\", \"1\\nend\\n\", \"2\\nonlyletters\\nnumbers123\\n\", \"1\\nthisisaverylongstring\\n\", \"2\\nnevergiveup\\nkeeptrying\\n\", \"1\\nthisisit\\n\", \"1\\nsuccess\\n\", \"2\\npassorfail\\nthisistest\\n\", \"2\\nallisdifferent\\neachhasadifferentresult\\n\"], \"outputs\": [\"YES\\nNO\\n\", \"NO\\nNO\\nNO\\nNO\\nNO\\nNO\\nNO\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nNO\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nNO\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\n\", \"YES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\n\", \"YES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\n\", \"YES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nNO\\nNO\\nYES\\nNO\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\nYES\\n\", \"YES\\nYES\\n\", \"NO\\n\", \"YES\\nYES\\n\", \"NO\\nNO\\nNO\\nNO\\n\", \"YES\\n\", \"YES\\n\", \"NO\\nNO\\nNO\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\n\", \"YES\\nNO\\nNO\\n\", \"NO\\nNO\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nNO\\nNO\\n\", \"NO\\n\", \"NO\\n\", \"YES\\nYES\\n\", \"NO\\n\", \"YES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\nYES\\nYES\\n\", \"NO\\nNO\\n\", \"YES\\n\", \"YES\\n\", \"YES\\n\", \"NO\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\nYES\\nYES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\n\", \"YES\\nNO\\nNO\\n\", \"YES\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"NO\\nNO\\nYES\\nYES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\nYES\\nNO\\n\", \"NO\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\n\", \"YES\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\n\"]}",
    "difficulty": "EASY",
    "raw_tags": "['BruteForce', 'BasicProgramming']",
    "name": "string-division",
    "source": "hackerearth",
    "tags": "['Fundamentals', 'Complete search']",
    "skill_types": "['Complete search']",
    "url": "https://www.hackerearth.com/practice/algorithms/string-algorithm/basics-of-string-manipulation/practice-problems/algorithm/string-division/",
    "Expected Auxiliary Space": null,
    "time_limit": null,
    "date": null,
    "picture_num": null,
    "memory_limit": null,
    "Expected Time Complexity": null,
    "human_solution": "'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''\n\t\n",
    "claude_solution": "# Solution for String Splitting Problem\n\nThe problem asks us to determine if a string can be split into 4 non-empty, pairwise different parts without changing the order of characters.\n\n```python\ndef can_split_string(s):\n    n = len(s)\n    \n    # We need at least 4 characters to form 4 non-empty parts\n    if n < 4:\n        return \"NO\"\n    \n    # Try all possible ways to split the string into 4 parts\n    # i, j, k represent the ending positions of first, second, and third parts\n    for i in range(1, n-2):  # Leave at least 3 characters for remaining parts\n        for j in range(i+1, n-1):  # Leave at least 2 characters for remaining parts\n            for k in range(j+1, n):  # Leave at least 1 character for the last part\n                # Extract the four parts\n                part1 = s[0:i]\n                part2 = s[i:j]\n                part3 = s[j:k]\n                part4 = s[k:n]\n                \n                # Check if all parts are different\n                if part1 != part2 and part1 != part3 and part1 != part4 and \\\n                   part2 != part3 and part2 != part4 and part3 != part4:\n                    return \"YES\"\n    \n    # If no valid splitting found\n    return \"NO\"\n\n# Process multiple test cases\nt = int(input())\nfor _ in range(t):\n    s = input().strip()\n    print(can_split_string(s))\n```\n\n## Explanation:\n\n1. First, we check if the string has at least 4 characters (minimum required for 4 non-empty parts).\n\n2. We use three nested loops to try all possible ways to split the string into 4 parts:\n   - The first loop (i) determines where the first part ends\n   - The second loop (j) determines where the second part ends\n   - The third loop (k) determines where the third part ends\n   - The fourth part is automatically from k to the end of the string\n\n3. For each potential splitting, we check if all four parts are different from each other.\n\n4. If we find a valid splitting, we return \"YES\"; otherwise, we return \"NO\".\n\n## Time Complexity:\n- O(N\u00b3) where N is the length of the string. This is because we have three nested loops, each potentially iterating through O(N) elements.\n\n## Space Complexity:\n- O(N) for storing the parts of the string.\n\nThis solution efficiently handles all the constraints mentioned in the problem, including the larger test cases where N can be up to 1000.",
    "problem": "Kevin has a string S consisting of N lowercase English letters.  \n\nKevin wants to split it into 4 pairwise different non-empty parts.  For example, string \"happynewyear\" can be splitted into \"happy\", \"new\", \"ye\" and \"ar\". He can't delete any characters or change the order of the characters.\n\nHelp Kevin and find if there exist at least one possible spliting.\n\nInput format:\n\nThe first line of input will contain an integer T, denoting the number of test cases. Each of the next T lines contains a string S.\n\nOutput format:\n\nFor every test case output \"YES\" if it is possible to split the string and \"NO\" otherwise.\n\nConstraints:\n1 \u2264 T \u2264 100\n1 \u2264 N \u2264 1000\nN \u2264 20 in test data worth 40% of all points\n\nSAMPLE INPUT\n2\nababca\naaabb\n\nSAMPLE OUTPUT\nYES\nNO"
  },
  {
    "solutions": [
      "for case in range(int(input())):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m - 1) % 2:\n\t\tprint('NO')\n\t\tcontinue\n\tdp = [0] * (m + 1)\n\tfor i in range(n):\n\t\tdp[0] = int(not i)\n\t\tfor j in range(m):\n\t\t\tdp[j + 1] = (dp[j] | dp[j + 1]) << (a[i][j] == -1)\n\tif dp[-1] & 1 << (n + m - 1) // 2:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "t = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for i in range(n)]\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tg = [[0] * m for i in range(n)]\n\t\tg[0][0] = 1 << (a[0][0] == -1)\n\t\tfor j in range(1, m):\n\t\t\tg[0][j] = g[0][j - 1] << (a[0][j] == -1)\n\t\tfor i in range(1, n):\n\t\t\tg[i][0] = g[i - 1][0] << (a[i][0] == -1)\n\t\t\tfor j in range(1, m):\n\t\t\t\tg[i][j] = (g[i - 1][j] | g[i][j - 1]) << (a[i][j] == -1)\n\t\tif g[n - 1][m - 1] & 1 << (n + m - 1) // 2 == 0:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n",
      "p = int(input())\nfor _ in range(p):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for i in range(n)]\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tk = [[0] * m for i in range(n)]\n\t\tk[0][0] = 1 << (a[0][0] == -1)\n\t\tfor j in range(1, m):\n\t\t\tk[0][j] = k[0][j - 1] << (a[0][j] == -1)\n\t\tfor i in range(1, n):\n\t\t\tk[i][0] = k[i - 1][0] << (a[i][0] == -1)\n\t\t\tfor j in range(1, m):\n\t\t\t\tk[i][j] = (k[i - 1][j] | k[i][j - 1]) << (a[i][j] == -1)\n\t\tif k[n - 1][m - 1] & 1 << (n + m - 1) // 2 == 0:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n",
      "(inp, r, p) = (input, range, print)\nI = lambda : map(int, input().split())\nfor _1 in r(int(inp())):\n\t(n, m) = I()\n\tinp_mat = [list(I()) for _2 in r(n)]\n\ta = [[0 for _ in r(m)] for _ in r(n)]\n\tif (n + m - 1) % 2 == 1:\n\t\tp('NO')\n\t\tcontinue\n\ta[0][0] = 1 << (inp_mat[0][0] != 1)\n\tfor j in r(1, m):\n\t\ta[0][j] = a[0][j - 1] << (inp_mat[0][j] == -1)\n\tfor i in r(1, n):\n\t\ta[i][0] = a[i - 1][0] << (inp_mat[i][0] != 1)\n\t\tfor j in r(1, m):\n\t\t\ta[i][j] = (a[i - 1][j] | a[i][j - 1]) << (inp_mat[i][j] != 1)\n\tp(['NO', 'YES'][1 if a[n - 1][m - 1] & 1 << (m + n - 1) // 2 else 0])\n",
      "input = __import__('sys').stdin.readline\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\ta = list(map(int, input().split()))\n\tdp = []\n\ttotal = 0\n\tfor x in a:\n\t\ttotal += 1 if x == 1 else 0\n\t\tdp.append((total, total))\n\tfor _ in range(1, n):\n\t\ta = list(map(int, input().split()))\n\t\tc = 1 if a[0] == 1 else 0\n\t\tnewdp = [(dp[0][0] + c, dp[0][1] + c)]\n\t\tfor i in range(1, m):\n\t\t\tc = 1 if a[i] == 1 else 0\n\t\t\tnewdp.append((min(dp[i][0], newdp[i - 1][0]) + c, max(dp[i][1], newdp[i - 1][1]) + c))\n\t\tdp = newdp\n\tprint('YES' if (n + m - 1) % 2 == 0 and dp[m - 1][0] <= (n + m - 1) // 2 <= dp[m - 1][1] else 'NO')\nfor _ in range(int(input())):\n\tsolve()\n",
      "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef solve():\n\t(n, m) = map(int, input().split())\n\tarr = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m) % 2 == 0:\n\t\treturn 'NO'\n\tdp = [[-float('inf'), float('inf')] for _ in range(m)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif j == 0:\n\t\t\t\tdp[j][0] = arr[i][j] if i == 0 else dp[j][0] + arr[i][j]\n\t\t\t\tdp[j][1] = arr[i][j] if i == 0 else dp[j][1] + arr[i][j]\n\t\t\telse:\n\t\t\t\tdp[j][0] = max(dp[j][0], dp[j - 1][0]) + arr[i][j]\n\t\t\t\tdp[j][1] = min(dp[j][1], dp[j - 1][1]) + arr[i][j]\n\treturn 'YES' if dp[-1][1] <= 0 <= dp[-1][0] else 'NO'\nfor _ in range(int(input())):\n\tprint(solve())\n",
      "def solve():\n\t(n, m) = map(int, input().split())\n\tarr = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m) % 2 == 0:\n\t\treturn 'NO'\n\tdp = [[-float('inf'), float('inf')] for _ in range(m)]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif j == 0:\n\t\t\t\tdp[j][0] = arr[i][j] if i == 0 else dp[j][0] + arr[i][j]\n\t\t\t\tdp[j][1] = arr[i][j] if i == 0 else dp[j][1] + arr[i][j]\n\t\t\telse:\n\t\t\t\tdp[j][0] = max(dp[j][0], dp[j - 1][0]) + arr[i][j]\n\t\t\t\tdp[j][1] = min(dp[j][1], dp[j - 1][1]) + arr[i][j]\n\treturn 'YES' if dp[-1][1] <= 0 <= dp[-1][0] else 'NO'\nfor _ in range(int(input())):\n\tprint(solve())\n",
      "def main():\n\t(n, m) = map(int, input().split())\n\ta = []\n\tfor i in range(n):\n\t\ta.append(list(map(int, input().split())))\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\t\treturn\n\tb = [[0] * m for _ in range(n)]\n\tb[0][0] = a[0][0]\n\tfor i in range(1, n):\n\t\tb[i][0] = b[i - 1][0] + a[i][0]\n\tfor j in range(1, m):\n\t\tb[0][j] = b[0][j - 1] + a[0][j]\n\tbmin = [i.copy() for i in b]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tb[i][j] = a[i][j] + max(b[i - 1][j], b[i][j - 1])\n\t\t\tbmin[i][j] = a[i][j] + min(bmin[i - 1][j], bmin[i][j - 1])\n\tif bmin[-1][-1] <= 0 <= b[-1][-1]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\nfor _ in range(int(input())):\n\tmain()\n",
      "t = int(input())\nfor _ in range(t):\n\t(m, n) = list(map(int, input().split()))\n\ta = []\n\tfor _ in range(m):\n\t\ta.append(list(map(int, input().split())))\n\tif (m + n) % 2 == 0:\n\t\tprint('NO')\n\t\tcontinue\n\tmn = [0] * n\n\tmn[0] = a[0][0]\n\tfor j in range(1, n):\n\t\tmn[j] = mn[j - 1] + a[0][j]\n\tmx = mn[:]\n\tfor i in range(1, m):\n\t\tmn[0] += a[i][0]\n\t\tmx[0] += a[i][0]\n\t\tfor j in range(1, n):\n\t\t\tmn[j] = min(mn[j], mn[j - 1]) + a[i][j]\n\t\t\tmx[j] = max(mx[j], mx[j - 1]) + a[i][j]\n\tprint('NO') if mx[-1] < 0 or mn[-1] > 0 else print('YES')\n",
      "def f(arr, m, n, mx, mi):\n\tmx[m][n] = mi[m][n] = arr[m][n]\n\tfor i in range(m - 1, -1, -1):\n\t\tmx[i][n] = mi[i][n] = arr[i][n] + mx[i + 1][n]\n\tfor i in range(n - 1, -1, -1):\n\t\tmx[m][i] = mi[m][i] = arr[m][i] + mx[m][i + 1]\n\tfor i in range(m - 1, -1, -1):\n\t\tfor j in range(n - 1, -1, -1):\n\t\t\tmx[i][j] = max(mx[i + 1][j], mx[i][j + 1]) + arr[i][j]\n\t\t\tmi[i][j] = min(mi[i + 1][j], mi[i][j + 1]) + arr[i][j]\n\treturn\nt = int(input())\nfor _ in range(t):\n\t(m, n) = map(int, input().split())\n\tarr = []\n\tans = True\n\tfor i in range(m):\n\t\tar = list(map(int, input().split()))\n\t\tarr.append(ar)\n\tif (m + n) % 2 == 0:\n\t\tans = False\n\telse:\n\t\tmx = [[-1 for i in range(n)] for j in range(m)]\n\t\tmi = [[-1 for i in range(n)] for j in range(m)]\n\t\tf(arr, m - 1, n - 1, mx, mi)\n\t\ta = mx[0][0]\n\t\tb = mi[0][0]\n\t\tif a < 0 or b > 0:\n\t\t\tans = False\n\tif ans:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "import sys\nt = int(input())\nfor _ in range(t):\n\t(m, n) = list(map(int, input().split()))\n\tmatrix = []\n\tfor r in range(m):\n\t\tmatrix.append(list(map(int, input().split())))\n\tif (m + n) % 2 == 0:\n\t\tprint('NO')\n\t\tcontinue\n\tmn = [0] * n\n\tmn[0] = matrix[0][0]\n\tfor i in range(1, n):\n\t\tmn[i] += mn[i - 1] + matrix[0][i]\n\tmx = mn[:]\n\tfor r in matrix[1:]:\n\t\tmn[0] += r[0]\n\t\tmx[0] += r[0]\n\t\tfor (j, x) in enumerate(r[1:]):\n\t\t\tmn[j + 1] = min(mn[j + 1], mn[j]) + x\n\t\t\tmx[j + 1] = max(mx[j + 1], mx[j]) + x\n\tprint('NO') if mn[-1] > 0 or mx[-1] < 0 else print('YES')\n",
      "for _ in [0] * int(input()):\n\t(n, m) = map(int, input().split())\n\ta = [[*map(int, input().split())] for x in [0] * n]\n\tdp = [[0] * m for x in [0] * n]\n\tdp[0][0] = a[0][0]\n\tfor i in range(1, n):\n\t\tdp[i][0] = dp[i - 1][0] + a[i][0]\n\tfor i in range(1, m):\n\t\tdp[0][i] = dp[0][i - 1] + a[0][i]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i][j]\n\tmaxi = dp[-1][-1]\n\tdp = [[0] * m for x in [0] * n]\n\tdp[0][0] = a[0][0]\n\tfor i in range(1, n):\n\t\tdp[i][0] = dp[i - 1][0] + a[i][0]\n\tfor i in range(1, m):\n\t\tdp[0][i] = dp[0][i - 1] + a[0][i]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tdp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + a[i][j]\n\tmini = dp[-1][-1]\n\tprint('NYOE S'[(m + n) % 2 and mini <= 0 <= maxi::2])\n",
      "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tmaxi = [[0] * m for i in range(n)]\n\t\tmini = [[0] * m for i in range(n)]\n\t\tmaxi[0][0] = mini[0][0] = a[0][0]\n\t\tfor j in range(1, m):\n\t\t\tmaxi[0][j] = mini[0][j] = maxi[0][j - 1] + a[0][j]\n\t\tfor i in range(1, n):\n\t\t\tmaxi[i][0] = mini[i][0] = maxi[i - 1][0] + a[i][0]\n\t\tfor i in range(1, n):\n\t\t\tfor j in range(1, m):\n\t\t\t\tmaxi[i][j] = max(maxi[i - 1][j], maxi[i][j - 1]) + a[i][j]\n\t\t\t\tmini[i][j] = min(mini[i - 1][j], mini[i][j - 1]) + a[i][j]\n\t\tif maxi[n - 1][m - 1] < 0 or mini[n - 1][m - 1] > 0:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n",
      "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tg = []\n\tfor i in range(n):\n\t\tg.append(list(map(int, input().split())))\n\tdp1 = [[0] * m for j in range(n)]\n\tdp2 = [[0] * m for j in range(n)]\n\tc = 0\n\tfor i in range(n):\n\t\tc += g[i][0]\n\t\tdp1[i][0] = c\n\t\tdp2[i][0] = c\n\tc = 0\n\tfor i in range(m):\n\t\tc += g[0][i]\n\t\tdp2[0][i] = c\n\t\tdp1[0][i] = c\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tdp1[i][j] = min(dp1[i - 1][j], dp1[i][j - 1]) + g[i][j]\n\t\t\tdp2[i][j] = max(dp2[i - 1][j], dp2[i][j - 1]) + g[i][j]\n\tif dp1[-1][-1] % 2 == 1 or dp1[-1][-1] > 0 or dp2[-1][-1] < 0:\n\t\tprint('NO')\n\telse:\n\t\tprint('YES')\n",
      "for _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tarr = []\n\tfor i in range(n):\n\t\titems = list(map(int, input().split()))\n\t\tarr.append(items)\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\t\tcontinue\n\tminmax = [[0] * m for i in range(n)]\n\tminmax[0][0] = arr[0][0]\n\tfor i in range(1, m):\n\t\tminmax[0][i] = minmax[0][i - 1] + arr[0][i]\n\tfor i in range(1, n):\n\t\tminmax[i][0] = minmax[i - 1][0] + arr[i][0]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tminmax[i][j] = max(minmax[i - 1][j], minmax[i][j - 1]) + arr[i][j]\n\tif minmax[n - 1][m - 1] < 0:\n\t\tprint('NO')\n\telse:\n\t\tfor i in range(1, n):\n\t\t\tfor j in range(1, m):\n\t\t\t\tminmax[i][j] = min(minmax[i - 1][j], minmax[i][j - 1]) + arr[i][j]\n\t\tif minmax[n - 1][m - 1] <= 0:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
      "t = int(input())\nfor i in range(t):\n\t(n, m) = map(int, input().split())\n\tgrid = []\n\tfor i in range(n):\n\t\tgrid.append(list(map(int, input().split())))\n\tif (n + m - 1) % 2 != 0:\n\t\tprint('NO')\n\t\tcontinue\n\tmin_path = [[0 for i in range(m)] for j in range(n)]\n\tmax_path = [[0 for i in range(m)] for j in range(n)]\n\tmin_path[n - 1][m - 1] = max_path[n - 1][m - 1] = grid[n - 1][m - 1]\n\tfor i in range(m - 2, -1, -1):\n\t\tmin_path[n - 1][i] = max_path[n - 1][i] = min_path[n - 1][i + 1] + grid[n - 1][i]\n\tfor i in range(n - 2, -1, -1):\n\t\tmin_path[i][m - 1] = max_path[i][m - 1] = min_path[i + 1][m - 1] + grid[i][m - 1]\n\tfor i in range(n - 2, -1, -1):\n\t\tfor j in range(m - 2, -1, -1):\n\t\t\tmin_path[i][j] = min(min_path[i + 1][j], min_path[i][j + 1]) + grid[i][j]\n\t\t\tmax_path[i][j] = max(max_path[i + 1][j], max_path[i][j + 1]) + grid[i][j]\n\tif min_path[0][0] <= 0 <= max_path[0][0]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "import sys\n\ndef solve():\n\tinp = sys.stdin.readline\n\t(n, m) = map(int, inp().split())\n\ta = [list(map(int, inp().split())) for i in range(n)]\n\tif (n + m - 1) % 2 != 0:\n\t\tprint('NO')\n\t\treturn\n\tb = [[0] * m for i in range(n)]\n\tc = [[0] * m for i in range(n)]\n\tb[0][0] = max(a[0][0], 0)\n\tc[0][0] = max(a[0][0], 0)\n\td = int(1000000000.0)\n\te = -d\n\tfor x in range(n):\n\t\tfor y in range(m):\n\t\t\tif x != 0 or y != 0:\n\t\t\t\tz = max(a[x][y], 0)\n\t\t\t\tif x > 0:\n\t\t\t\t\tu = b[x - 1][y] + z\n\t\t\t\t\tv = c[x - 1][y] + z\n\t\t\t\telse:\n\t\t\t\t\tu = d\n\t\t\t\t\tv = e\n\t\t\t\tif y > 0:\n\t\t\t\t\tu = min(u, b[x][y - 1] + z)\n\t\t\t\t\tv = max(v, c[x][y - 1] + z)\n\t\t\t\tb[x][y] = u\n\t\t\t\tc[x][y] = v\n\tz = (n + m - 1) // 2\n\tif z >= b[n - 1][m - 1] and z <= c[n - 1][m - 1]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n\ndef main():\n\tfor i in range(int(sys.stdin.readline())):\n\t\tsolve()\nmain()\n",
      "time = int(input())\nwhile time:\n\ttime -= 1\n\t(n, m) = [int(x) for x in input().split()]\n\tarr = [[] for _ in range(n)]\n\tfor i in range(n):\n\t\tarr[i] = [int(x) for x in input().split()]\n\tif (n + m - 1) % 2 == 1:\n\t\tprint('NO')\n\t\tcontinue\n\tdpmin = [[0] * m for _ in range(n)]\n\tdpmax = [[0] * m for _ in range(n)]\n\tdpmin[0][0] = arr[0][0]\n\tdpmax[0][0] = arr[0][0]\n\tfor j in range(1, m):\n\t\tdpmin[0][j] = dpmin[0][j - 1] + arr[0][j]\n\t\tdpmax[0][j] = dpmax[0][j - 1] + arr[0][j]\n\tfor i in range(1, n):\n\t\tdpmin[i][0] = dpmin[i - 1][0] + arr[i][0]\n\t\tdpmax[i][0] = dpmax[i - 1][0] + arr[i][0]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tdpmin[i][j] = min(dpmin[i - 1][j], dpmin[i][j - 1]) + arr[i][j]\n\t\t\tdpmax[i][j] = max(dpmax[i - 1][j], dpmax[i][j - 1]) + arr[i][j]\n\tif dpmin[n - 1][m - 1] <= 0 and 0 <= dpmax[n - 1][m - 1]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "for _ in range(int(input())):\n\t(row, col) = map(int, input().split())\n\tgrid = []\n\tfor _ in range(row):\n\t\tgrid.append(list(map(int, input().split())))\n\tmin_dp = [[0] * col for _ in range(row)]\n\tmax_dp = [[0] * col for _ in range(row)]\n\tif row + col + 1 & 1:\n\t\tprint('NO')\n\t\tcontinue\n\tfor i in range(row):\n\t\tfor j in range(col):\n\t\t\tif i == 0 and j == 0:\n\t\t\t\tmin_dp[i][j] = max_dp[i][j] = grid[i][j]\n\t\t\t\tcontinue\n\t\t\tif i and j:\n\t\t\t\tmin_dp[i][j] = grid[i][j] + min(min_dp[i - 1][j], min_dp[i][j - 1])\n\t\t\t\tmax_dp[i][j] = grid[i][j] + max(max_dp[i - 1][j], max_dp[i][j - 1])\n\t\t\telif i:\n\t\t\t\tmin_dp[i][j] = grid[i][j] + min_dp[i - 1][j]\n\t\t\t\tmax_dp[i][j] = grid[i][j] + max_dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tmin_dp[i][j] = grid[i][j] + min_dp[i][j - 1]\n\t\t\t\tmax_dp[i][j] = grid[i][j] + max_dp[i][j - 1]\n\tif min_dp[-1][-1] <= 0 <= max_dp[-1][-1]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "t = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\tarr = []\n\tfor i in range(n):\n\t\tl = list(map(int, input().split()))\n\t\tarr.append(l)\n\tpl = n + m - 1\n\tif pl % 2 != 0:\n\t\tprint('NO')\n\t\tcontinue\n\t(madp, midp) = ([[0 for j in range(m)] for i in range(n)], [[0 for j in range(m)] for i in range(n)])\n\t(madp[0][0], midp[0][0]) = (arr[0][0], arr[0][0])\n\tfor i in range(1, n):\n\t\t(madp[i][0], midp[i][0]) = (arr[i][0] + madp[i - 1][0], arr[i][0] + midp[i - 1][0])\n\tfor j in range(1, m):\n\t\t(madp[0][j], midp[0][j]) = (arr[0][j] + madp[0][j - 1], arr[0][j] + midp[0][j - 1])\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tmadp[i][j] = arr[i][j] + max(madp[i - 1][j], madp[i][j - 1])\n\t\t\tmidp[i][j] = arr[i][j] + min(midp[i - 1][j], midp[i][j - 1])\n\tif midp[-1][-1] <= 0 <= madp[-1][-1]:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "a = int(input())\nfor k in range(0, a):\n\t(n, m) = map(int, input().split())\n\tc = []\n\tfor i in range(0, n):\n\t\tc.append(list(map(int, input().split())))\n\td_min = [[] for _ in range(n)]\n\td_max = [[] for _ in range(n)]\n\tif (n + m - 1) % 2 == 0:\n\t\td_max[0].append(c[0][0])\n\t\td_min[0].append(c[0][0])\n\t\tfor j in range(1, m):\n\t\t\td_max[0].append(d_max[0][j - 1] + c[0][j])\n\t\t\td_min[0].append(d_min[0][j - 1] + c[0][j])\n\t\tfor j in range(1, n):\n\t\t\td_max[j].append(d_max[j - 1][0] + c[j][0])\n\t\t\td_min[j].append(d_min[j - 1][0] + c[j][0])\n\t\tfor i in range(1, n):\n\t\t\tfor j in range(1, m):\n\t\t\t\td_max[i].append(max(d_max[i - 1][j], d_max[i][j - 1]) + c[i][j])\n\t\t\t\td_min[i].append(min(d_min[i - 1][j], d_min[i][j - 1]) + c[i][j])\n\t\tif d_max[n - 1][m - 1] >= 0 and d_min[n - 1][m - 1] <= 0:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n\telse:\n\t\tprint('NO')\n",
      "from itertools import accumulate\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\ta = []\n\tfor __ in range(n):\n\t\ta.append(list(map(int, input().split())))\n\tif (n + m) % 2 == 0:\n\t\tprint('NO')\n\t\tcontinue\n\tdp_mn = list(accumulate(a[0]))\n\tfor i in range(1, n):\n\t\tfor j in range(m):\n\t\t\tif j > 0:\n\t\t\t\tdp_mn[j] = min(dp_mn[j - 1], dp_mn[j])\n\t\t\tdp_mn[j] += a[i][j]\n\tdp_mx = list(accumulate(a[0]))\n\tfor i in range(1, n):\n\t\tfor j in range(m):\n\t\t\tif j > 0:\n\t\t\t\tdp_mx[j] = max(dp_mx[j - 1], dp_mx[j])\n\t\t\tdp_mx[j] += a[i][j]\n\tif dp_mn[-1] <= 0 and dp_mx[-1] >= 0:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "t = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split(' '))\n\tboard = []\n\tminBoard = []\n\tmaxBoard = []\n\tfor i in range(n):\n\t\trow = list(map(int, input().split(' ')))\n\t\tminRow = [0 for _ in range(m)]\n\t\tmaxRow = [0 for _ in range(m)]\n\t\tboard.append(row)\n\t\tminBoard.append(minRow)\n\t\tmaxBoard.append(maxRow)\n\tif (m + n) % 2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tminBoard[0][0] = board[0][0]\n\t\tmaxBoard[0][0] = board[0][0]\n\t\tfor i in range(1, n):\n\t\t\tminBoard[i][0] = board[i][0] + minBoard[i - 1][0]\n\t\t\tmaxBoard[i][0] = board[i][0] + maxBoard[i - 1][0]\n\t\tfor i in range(1, m):\n\t\t\tminBoard[0][i] = board[0][i] + minBoard[0][i - 1]\n\t\t\tmaxBoard[0][i] = board[0][i] + maxBoard[0][i - 1]\n\t\tfor i in range(1, n):\n\t\t\tfor j in range(1, m):\n\t\t\t\tminBoard[i][j] = board[i][j] + min(minBoard[i - 1][j], minBoard[i][j - 1])\n\t\t\t\tmaxBoard[i][j] = board[i][j] + max(maxBoard[i - 1][j], maxBoard[i][j - 1])\n\t\tif minBoard[n - 1][m - 1] <= 0 <= maxBoard[n - 1][m - 1]:\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
      "t = int(input())\nfor i in range(t):\n\t(n, m) = map(int, input().split())\n\ta = []\n\tfor i in range(n):\n\t\tz = list(map(int, input().split()))\n\t\ta.append(z)\n\tmn = [[0 for i in range(m)] for j in range(n)]\n\tmx = [[0 for i in range(m)] for j in range(n)]\n\tmn[0][0] = mx[0][0] = a[0][0]\n\tfor i in range(n):\n\t\tfor j in range(m):\n\t\t\tif i > 0 and j > 0:\n\t\t\t\tmn[i][j] = min(mn[i - 1][j], mn[i][j - 1]) + a[i][j]\n\t\t\t\tmx[i][j] = max(mx[i - 1][j], mx[i][j - 1]) + a[i][j]\n\t\t\telif i > 0:\n\t\t\t\tmn[i][j] = mn[i - 1][j] + a[i][j]\n\t\t\t\tmx[i][j] = mx[i - 1][j] + a[i][j]\n\t\t\telif j > 0:\n\t\t\t\tmn[i][j] = mn[i][j - 1] + a[i][j]\n\t\t\t\tmx[i][j] = mx[i][j - 1] + a[i][j]\n\tif (m + n) % 2 == 1 and mn[n - 1][m - 1] <= 0 and (mx[n - 1][m - 1] >= 0):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "for _ in range(int(input())):\n\t(n, m) = list(map(int, input().split()))\n\tl = []\n\tfor x in range(n):\n\t\tl.append(list(map(int, input().split())))\n\tif False:\n\t\tprint('YES')\n\telse:\n\t\tdpmin = []\n\t\tdpmax = []\n\t\tmn = []\n\t\tmx = []\n\t\tfor i in range(0, n):\n\t\t\tfor j in range(0, m):\n\t\t\t\tmn.append(1000)\n\t\t\t\tmx.append(-1000)\n\t\t\tdpmin.append(mn)\n\t\t\tdpmax.append(mx)\n\t\t\tmn = []\n\t\t\tmx = []\n\t\tdpmin[0][0] = l[0][0]\n\t\tdpmax[0][0] = l[0][0]\n\t\tfor x in range(1, m):\n\t\t\tdpmin[0][x] = l[0][x] + dpmin[0][x - 1]\n\t\t\tdpmax[0][x] = l[0][x] + dpmax[0][x - 1]\n\t\tfor x in range(1, n):\n\t\t\tdpmin[x][0] = l[x][0] + dpmin[x - 1][0]\n\t\t\tdpmax[x][0] = l[x][0] + dpmax[x - 1][0]\n\t\tfor x in range(1, n):\n\t\t\tfor y in range(1, m):\n\t\t\t\tdpmin[x][y] = min(dpmin[x - 1][y], dpmin[x][y - 1]) + l[x][y]\n\t\t\t\tdpmax[x][y] = max(dpmax[x - 1][y], dpmax[x][y - 1]) + l[x][y]\n\t\tif dpmax[n - 1][m - 1] % 2 == 1 or dpmin[n - 1][m - 1] > 0 or dpmax[n - 1][m - 1] < 0:\n\t\t\tprint('NO')\n\t\telse:\n\t\t\tprint('YES')\n",
      "for q in range(int(input())):\n\t(n, m) = [int(x) for x in input().split()]\n\tarr = []\n\tfor i in range(n):\n\t\tarr.append([int(x) for x in input().split()])\n\tmn = [[arr[i][j] for j in range(m)] for i in range(n)]\n\tmx = [[arr[i][j] for j in range(m)] for i in range(n)]\n\tfor i in range(1, m):\n\t\tmn[0][i] += mn[0][i - 1]\n\t\tmx[0][i] += mx[0][i - 1]\n\tfor i in range(1, n):\n\t\tmn[i][0] += mn[i - 1][0]\n\t\tmx[i][0] += mx[i - 1][0]\n\tfor i in range(1, n):\n\t\tfor j in range(1, m):\n\t\t\tmn[i][j] = min(mn[i - 1][j], mn[i][j - 1]) + arr[i][j]\n\t\t\tmx[i][j] = max(mx[i - 1][j], mx[i][j - 1]) + arr[i][j]\n\tif mn[n - 1][m - 1] <= 0 and mx[n - 1][m - 1] >= 0 and ((m + n - 1) % 2 == 0):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
      "from os import error\nimport sys\ninput = sys.stdin.readline\nDEBUG = False\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\n\ndef solve():\n\t(n, m) = inlt()\n\t(mx, pmx) = ([0] * m, [0] * m)\n\tpmx[0] = 2 ** 1002\n\tfor i in range(n):\n\t\trow = inlt()\n\t\tfor j in range(0, m):\n\t\t\tif j > 0:\n\t\t\t\tif row[j] == 1:\n\t\t\t\t\tmx[j] = pmx[j] * 2 | mx[j - 1] * 2\n\t\t\t\telse:\n\t\t\t\t\tmx[j] = pmx[j] // 2 | mx[j - 1] // 2\n\t\t\telif row[j] == 1:\n\t\t\t\tmx[j] = pmx[j] * 2\n\t\t\telse:\n\t\t\t\tmx[j] = pmx[j] // 2\n\t\tpmx = mx\n\tif pmx[-1] & 2 ** 1002 > 0:\n\t\treturn 'YES'\n\treturn 'NO'\nq = inp()\nfor t in range(q):\n\tans = solve()\n\tprint(ans)\n",
      "n = int(input())\nfor i in range(n):\n\t(ROWS, COLS) = map(int, input().split())\n\tmatrix = []\n\tfor i in range(ROWS):\n\t\tmatrix.append([int(num) for num in input().split()])\n\tif (ROWS + COLS) % 2 == 0:\n\t\tprint('NO')\n\telse:\n\t\tmatrix[0][0] = (matrix[0][0], matrix[0][0])\n\t\tfor col in range(1, COLS):\n\t\t\tminAndMax = matrix[0][col - 1][0] + matrix[0][col]\n\t\t\tmatrix[0][col] = (minAndMax, minAndMax)\n\t\tfor row in range(1, ROWS):\n\t\t\tminAndMax = matrix[row - 1][0][0] + matrix[row][0]\n\t\t\tmatrix[row][0] = (minAndMax, minAndMax)\n\t\tfor row in range(1, ROWS):\n\t\t\tfor col in range(1, COLS):\n\t\t\t\tminn = min(matrix[row - 1][col][0], matrix[row][col - 1][0]) + matrix[row][col]\n\t\t\t\tmaxx = max(matrix[row - 1][col][1], matrix[row][col - 1][1]) + matrix[row][col]\n\t\t\t\tmatrix[row][col] = (minn, maxx)\n\t\tif 0 in range(matrix[-1][-1][0], matrix[-1][-1][1] + 1):\n\t\t\tprint('YES')\n\t\telse:\n\t\t\tprint('NO')\n",
      "def solve(mat):\n\tif (len(mat) + len(mat[0]) - 1) % 2:\n\t\treturn False\n\tdpmin = [[float('INF') for i in range(len(mat[0]))] for j in range(len(mat))]\n\tdpmax = [[-float('INF') for i in range(len(mat[0]))] for j in range(len(mat))]\n\tdpmin[0][0] = dpmax[0][0] = mat[0][0]\n\tfor i in range(1, len(mat)):\n\t\tdpmin[i][0] = dpmax[i][0] = dpmin[i - 1][0] + mat[i][0]\n\tfor i in range(1, len(mat[0])):\n\t\tdpmin[0][i] = dpmax[0][i] = dpmin[0][i - 1] + mat[0][i]\n\tfor i in range(1, len(mat)):\n\t\tfor j in range(1, len(mat[0])):\n\t\t\tdpmin[i][j] = min(dpmin[i - 1][j], dpmin[i][j - 1]) + mat[i][j]\n\t\t\tdpmax[i][j] = max(dpmax[i - 1][j], dpmax[i][j - 1]) + mat[i][j]\n\treturn dpmin[-1][-1] <= 0 <= dpmax[-1][-1]\nt = int(input())\nfor i in range(t):\n\t(n, m) = list(map(int, input().split()))\n\tmat = []\n\tfor i in range(n):\n\t\tmat.append(list(map(int, input().split())))\n\tif solve(mat):\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"5\\n1 1\\n1\\n1 2\\n1 -1\\n1 4\\n1 -1 1 -1\\n3 4\\n1 -1 -1 -1\\n-1 1 1 -1\\n1 1 1 -1\\n3 4\\n1 -1 1 1\\n-1 1 -1 1\\n1 -1 1 1\\n\", \"4\\n2 1\\n-1\\n-1\\n2 1\\n1\\n-1\\n2 1\\n-1\\n1\\n2 1\\n1\\n1\\n\", \"4\\n1 2\\n-1 -1\\n1 2\\n1 -1\\n1 2\\n-1 1\\n1 2\\n1 1\\n\", \"5\\n1 1\\n1\\n1 2\\n1 -1\\n1 4\\n1 -1 1 -1\\n3 4\\n1 -1 -1 -1\\n-1 1 1 -1\\n1 1 1 -1\\n3 4\\n1 -1 1 1\\n-1 1 -1 1\\n1 -1 1 1\\n\", \"4\\n2 1\\n-1\\n-1\\n2 1\\n1\\n-1\\n2 1\\n-1\\n1\\n2 1\\n1\\n1\\n\", \"2\\n2 2\\n1 1\\n1 1\\n2 2\\n-1 -1\\n-1 -1\\n\", \"2\\n2 2\\n-1 1\\n1 -1\\n2 2\\n1 -1\\n-1 1\\n\", \"2\\n3 3\\n1 1 1\\n1 1 1\\n1 1 1\\n3 3\\n-1 -1 -1\\n-1 -1 -1\\n-1 -1 -1\\n\", \"2\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n\", \"2\\n2 3\\n-1 1 -1\\n1 1 -1\\n2 3\\n1 -1 1\\n-1 1 -1\\n\", \"3\\n1 3\\n-1 -1 -1\\n1 2\\n-1 1\\n2 2\\n1 -1\\n-1 1\\n\", \"1\\n5 5\\n-1 -1 -1 -1 -1\\n1 1 1 1 1\\n-1 -1 -1 -1 -1\\n1 1 1 1 1\\n-1 -1 -1 -1 -1\\n\", \"2\\n4 1\\n1\\n-1\\n1\\n-1\\n4 1\\n-1\\n1\\n-1\\n1\\n\", \"2\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n\", \"2\\n1 5\\n-1 1 -1 1 -1\\n1 4\\n1 -1 1 -1\\n\", \"1\\n4 4\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n\", \"1\\n2 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n\", \"1\\n5 2\\n-1 1\\n1 -1\\n-1 1\\n1 -1\\n-1 1\\n\", \"2\\n2 2\\n1 -1\\n-1 1\\n2 2\\n-1 1\\n1 -1\\n\", \"1\\n3 3\\n1 1 1\\n1 1 1\\n1 1 1\\n\", \"3\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n3 3\\n1 1 1\\n-1 -1 -1\\n1 1 1\\n\", \"1\\n5 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n\", \"3\\n1 4\\n1 -1 1 -1\\n2 2\\n1 -1\\n-1 1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n\", \"3\\n1 1\\n1\\n1 2\\n-1 1\\n2 2\\n1 -1\\n-1 1\\n\", \"3\\n2 2\\n1 -1\\n-1 1\\n2 2\\n1 1\\n-1 -1\\n2 2\\n-1 1\\n1 -1\\n\", \"4\\n1 4\\n1 1 1 1\\n2 2\\n-1 1\\n1 -1\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n\", \"6\\n1 1\\n-1\\n1 1\\n1\\n2 2\\n-1 -1\\n-1 -1\\n2 2\\n1 1\\n-1 -1\\n2 3\\n1 -1 1\\n-1 1 -1\\n3 2\\n-1 1\\n1 -1\\n-1 1\\n\", \"4\\n1 5\\n1 -1 1 -1 1\\n5 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n2 3\\n-1 1 -1\\n1 -1 1\\n3 2\\n-1 1\\n1 -1\\n-1 1\\n\", \"2\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n3 3\\n-1 -1 1\\n1 1 1\\n-1 1 -1\\n\", \"2\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n4 4\\n-1 -1 -1 -1\\n1 -1 -1 -1\\n-1 1 -1 -1\\n-1 -1 1 -1\\n\", \"1\\n3 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n\", \"2\\n1 5\\n1 -1 1 -1 1\\n2 5\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n\", \"3\\n1 3\\n1 -1 1\\n2 2\\n-1 1\\n1 -1\\n3 1\\n1\\n-1\\n1\\n\", \"1\\n3 3\\n1 1 1\\n-1 -1 -1\\n1 1 1\\n\", \"5\\n1 1\\n-1\\n1 2\\n-1 -1\\n1 3\\n-1 -1 -1\\n1 4\\n-1 -1 -1 -1\\n1 5\\n-1 -1 -1 -1 -1\\n\", \"2\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n2 2\\n1 -1\\n-1 1\\n\", \"3\\n1 2\\n-1 1\\n1 3\\n-1 1 -1\\n1 1\\n1\\n\", \"1\\n3 3\\n-1 -1 -1\\n-1 -1 -1\\n-1 -1 -1\\n\", \"3\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n4 4\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n1 1\\n1\\n\", \"2\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n2 2\\n-1 -1\\n-1 1\\n\", \"3\\n5 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n2 2\\n-1 1\\n1 -1\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n\", \"3\\n3 2\\n1 -1\\n-1 1\\n1 -1\\n4 2\\n1 -1\\n-1 1\\n1 -1\\n-1 1\\n5 2\\n1 -1\\n-1 1\\n1 -1\\n-1 1\\n1 -1\\n\", \"4\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n2 2\\n1 -1\\n-1 1\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n1 1\\n1\\n\", \"2\\n2 2\\n1 1\\n-1 -1\\n5 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n\", \"3\\n1 1\\n-1\\n2 2\\n-1 -1\\n-1 -1\\n3 3\\n-1 -1 -1\\n-1 1 -1\\n-1 -1 -1\\n\", \"1\\n6 6\\n-1 -1 -1 -1 -1 -1\\n-1 1 1 1 1 -1\\n-1 1 -1 -1 1 -1\\n-1 1 1 -1 1 -1\\n-1 1 1 1 1 -1\\n-1 -1 -1 -1 -1 -1\\n\", \"2\\n3 3\\n-1 -1 -1\\n-1 1 -1\\n-1 -1 -1\\n3 3\\n1 1 1\\n1 -1 1\\n1 1 1\\n\", \"1\\n4 4\\n-1 -1 -1 -1\\n-1 1 1 -1\\n-1 1 -1 -1\\n-1 -1 -1 -1\\n\", \"1\\n6 6\\n1 -1 -1 1 1 -1\\n1 -1 1 1 -1 1\\n-1 1 -1 1 1 1\\n1 -1 1 -1 -1 -1\\n1 1 -1 1 1 -1\\n-1 -1 1 1 -1 1\\n\", \"1\\n2 2\\n1 -1\\n-1 1\\n\", \"1\\n2 2\\n1 1\\n-1 -1\\n\", \"1\\n3 3\\n1 -1 -1\\n-1 1 -1\\n-1 -1 1\\n\", \"1\\n3 3\\n-1 1 1\\n1 -1 1\\n1 1 -1\\n\", \"1\\n4 4\\n1 -1 -1 -1\\n-1 1 1 1\\n1 -1 -1 1\\n-1 1 -1 1\\n\", \"1\\n4 4\\n-1 1 1 1\\n1 -1 -1 -1\\n-1 1 1 -1\\n1 -1 -1 1\\n\", \"1\\n5 5\\n1 -1 -1 -1 -1\\n-1 1 1 1 1\\n1 -1 -1 -1 -1\\n1 1 1 1 1\\n-1 -1 -1 -1 -1\\n\", \"1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n\", \"1\\n7 7\\n1 -1 1 -1 1 -1 1\\n-1 1 -1 1 -1 1 -1\\n1 -1 1 -1 1 -1 1\\n-1 1 -1 1 -1 1 -1\\n1 -1 1 -1 1 -1 1\\n-1 1 -1 1 -1 1 -1\\n1 -1 1 -1 1 -1 1\\n\", \"1\\n4 1\\n-1\\n1\\n-1\\n1\\n\", \"1\\n1 4\\n1 -1 1 -1\\n\", \"1\\n6 6\\n1 -1 1 -1 1 -1\\n-1 1 -1 1 -1 1\\n1 -1 1 -1 1 -1\\n-1 1 -1 1 -1 1\\n1 -1 1 -1 1 -1\\n-1 1 -1 1 -1 1\\n\", \"2\\n1 1\\n1\\n1 1\\n-1\\n\", \"1\\n3 1\\n-1\\n1\\n-1\\n\", \"3\\n1 3\\n1 -1 1\\n2 2\\n1 -1\\n-1 1\\n2 2\\n-1 1\\n1 -1\\n\", \"2\\n4 4\\n1 -1 -1 1\\n-1 1 1 -1\\n1 -1 -1 1\\n-1 1 1 -1\\n4 4\\n-1 1 1 -1\\n1 -1 -1 1\\n-1 1 1 -1\\n1 -1 -1 1\\n\", \"3\\n3 1\\n1\\n-1\\n1\\n3 1\\n-1\\n1\\n-1\\n2 2\\n1 -1\\n1 -1\\n\", \"2\\n1 4\\n1 -1 1 -1\\n1 4\\n-1 1 -1 1\\n\", \"3\\n2 3\\n1 -1 1\\n-1 1 -1\\n2 3\\n-1 1 -1\\n1 -1 1\\n2 1\\n1\\n-1\\n\", \"1\\n4 4\\n1 -1 -1 1\\n-1 1 1 -1\\n1 -1 -1 1\\n-1 1 1 -1\\n\", \"5\\n1 3\\n1 -1 1\\n1 1\\n1\\n1 2\\n-1 -1\\n1 4\\n-1 1 -1 1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n\", \"2\\n2 3\\n1 -1 -1\\n-1 1 1\\n3 2\\n-1 1\\n1 -1\\n-1 1\\n\", \"1\\n5 4\\n1 -1 1 1\\n-1 1 -1 1\\n1 -1 1 1\\n-1 1 -1 1\\n1 -1 1 1\\n\", \"3\\n2 3\\n1 -1 1\\n-1 1 -1\\n3 2\\n-1 1\\n1 -1\\n-1 1\\n3 2\\n1 -1\\n-1 1\\n1 -1\\n\", \"2\\n5 5\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n5 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n\", \"1\\n2 2\\n-1 1\\n1 -1\\n\", \"1\\n4 4\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n\", \"4\\n4 4\\n-1 1 -1 1\\n1 -1 1 -1\\n-1 1 -1 1\\n1 -1 1 -1\\n1 1\\n1\\n4 2\\n-1 1\\n-1 1\\n-1 1\\n-1 1\\n1 4\\n1 -1 1 -1\\n\", \"1\\n5 5\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 1 -1\\n1 -1 1 -1 1\\n-1 1 -1 -1 -1\\n\", \"2\\n2 2\\n1 -1\\n-1 1\\n3 3\\n-1 1 -1\\n1 -1 1\\n-1 1 -1\\n\", \"3\\n1 4\\n-1 -1 1 1\\n3 1\\n-1\\n1\\n-1\\n3 3\\n1 -1 1\\n-1 1 -1\\n1 -1 1\\n\", \"4\\n2 3\\n1 1 -1\\n-1 -1 1\\n2 2\\n-1 1\\n1 -1\\n4 1\\n1\\n-1\\n1\\n-1\\n4 1\\n-1\\n1\\n-1\\n1\\n\", \"2\\n3 2\\n1 -1\\n-1 1\\n1 -1\\n2 2\\n-1 1\\n1 -1\\n\", \"3\\n5 1\\n-1\\n-1\\n1\\n1\\n-1\\n3 2\\n-1 1\\n1 -1\\n-1 1\\n2 3\\n1 -1 1\\n-1 1 -1\\n\", \"4\\n4 1\\n-1\\n1\\n-1\\n1\\n2 2\\n1 1\\n-1 -1\\n2 2\\n-1 -1\\n1 1\\n2 2\\n1 -1\\n-1 1\\n\", \"2\\n3 3\\n1 1 -1\\n1 -1 1\\n-1 1 1\\n3 3\\n-1 -1 1\\n-1 1 -1\\n1 -1 -1\\n\", \"3\\n4 4\\n1 -1 -1 1\\n-1 1 1 -1\\n1 -1 -1 1\\n-1 1 1 -1\\n3 4\\n1 -1 -1 1\\n-1 1 -1 -1\\n1 -1 -1 1\\n3 1\\n-1\\n1\\n-1\\n\", \"1\\n1 1\\n-1\\n\", \"2\\n2 2\\n1 1\\n-1 -1\\n2 2\\n-1 -1\\n1 1\\n\", \"1\\n3 3\\n1 1 1\\n1 1 1\\n1 1 -1\\n\", \"1\\n5 5\\n1 -1 -1 -1 1\\n-1 1 1 1 -1\\n1 -1 -1 -1 1\\n-1 1 1 1 -1\\n1 -1 -1 -1 1\\n\"], \"outputs\": [\"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\n\", \"YES\\nYES\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\n\", \"YES\\nYES\\n\", \"NO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\n\", \"YES\\n\", \"YES\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\nNO\\nNO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\nNO\\nNO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\nNO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\n\", \"YES\\n\", \"YES\\n\", \"NO\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nNO\\nNO\\n\", \"YES\\nYES\\n\", \"YES\\nYES\\nYES\\n\", \"NO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"YES\\nYES\\n\", \"NO\\n\", \"YES\\nYES\\nYES\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\nNO\\n\", \"NO\\nYES\\nYES\\nYES\\nNO\\n\", \"NO\\n\", \"NO\\nNO\\n\", \"NO\\n\", \"NO\\n\"]}",
    "difficulty": "MEDIUM_HARD",
    "raw_tags": "['data structures', 'greedy', 'shortest paths', 'dp', 'brute force', 'graphs']",
    "name": null,
    "source": "codeforces",
    "tags": "['Graph algorithms', 'Shortest paths', 'Complete search', 'Greedy algorithms', 'Dynamic programming', 'Data structures']",
    "skill_types": "['Dynamic programming', 'Data structures', 'Complete search', 'Greedy algorithms']",
    "url": "https://codeforces.com/problemset/problem/1695/C",
    "Expected Auxiliary Space": null,
    "time_limit": "2 seconds",
    "date": "2022-06-18",
    "picture_num": "1",
    "memory_limit": "256 megabytes",
    "Expected Time Complexity": null,
    "human_solution": "for case in range(int(input())):\n\t(n, m) = map(int, input().split())\n\ta = [list(map(int, input().split())) for _ in range(n)]\n\tif (n + m - 1) % 2:\n\t\tprint('NO')\n\t\tcontinue\n\tdp = [0] * (m + 1)\n\tfor i in range(n):\n\t\tdp[0] = int(not i)\n\t\tfor j in range(m):\n\t\t\tdp[j + 1] = (dp[j] | dp[j + 1]) << (a[i][j] == -1)\n\tif dp[-1] & 1 << (n + m - 1) // 2:\n\t\tprint('YES')\n\telse:\n\t\tprint('NO')\n",
    "claude_solution": "# Solution for Grid Path Sum Problem\n\nThis problem asks us to find if there's a path from (1,1) to (n,m) in a grid where we can only move right or down, such that the sum of values in the visited cells equals 0.\n\nLet's analyze this problem:\n\n1. We need to go from (1,1) to (n,m)\n2. We can only move right or down\n3. We need the sum of values to be 0\n\nThe key insight is that any path from (1,1) to (n,m) will visit exactly (n+m-1) cells, and the number of steps is fixed. This means all valid paths will have the same length.\n\nLet's use dynamic programming to solve this:\n\n```python\ndef solve():\n    t = int(input())\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        \n        for i in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # If there's only one cell, check if it's 0\n        if n == 1 and m == 1:\n            print(\"YES\" if grid[0][0] == 0 else \"NO\")\n            continue\n        \n        # Create DP array: dp[i][j][s] = can we reach cell (i,j) with sum s?\n        # Since sums can be negative, we'll offset by the maximum possible sum\n        max_sum = n + m - 1  # Maximum number of cells in any path\n        dp = [[[False for _ in range(2*max_sum+1)] for _ in range(m)] for _ in range(n)]\n        \n        # Base case: starting cell\n        dp[0][0][max_sum + grid[0][0]] = True\n        \n        # Fill the DP table\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue  # Skip the starting cell\n                \n                for s in range(2*max_sum+1):\n                    # Check if we can reach from above\n                    if i > 0 and s - grid[i][j] >= 0 and s - grid[i][j] < 2*max_sum+1:\n                        dp[i][j][s] |= dp[i-1][j][s - grid[i][j]]\n                    \n                    # Check if we can reach from left\n                    if j > 0 and s - grid[i][j] >= 0 and s - grid[i][j] < 2*max_sum+1:\n                        dp[i][j][s] |= dp[i][j-1][s - grid[i][j]]\n        \n        # Check if we can reach the destination with sum 0\n        print(\"YES\" if dp[n-1][m-1][max_sum] else \"NO\")\n\nsolve()\n```\n\nWait, I see an issue with the approach above. The DP array would be too large and inefficient. Let's optimize:\n\n```python\ndef solve():\n    t = int(input())\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        \n        for i in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Any path from (1,1) to (n,m) has exactly (n+m-1) cells\n        # The total number of +1s and -1s in the path must be such that they sum to 0\n        # This means we need an even number of cells in the path, and exactly half should be +1 and half should be -1\n        \n        total_cells = n + m - 1\n        \n        # If total_cells is odd, we can't have equal number of +1s and -1s\n        if total_cells % 2 != 0:\n            print(\"NO\")\n            continue\n        \n        # We need exactly total_cells/2 cells with +1 and total_cells/2 cells with -1\n        target_positive = total_cells // 2\n        \n        # Use DP to check if we can have exactly target_positive +1s in the path\n        # dp[i][j][k] = can we reach cell (i,j) with k positive cells in the path?\n        dp = [[set() for _ in range(m)] for _ in range(n)]\n        \n        # Base case\n        if grid[0][0] == 1:\n            dp[0][0].add(1)  # One positive cell\n        else:\n            dp[0][0].add(0)  # Zero positive cells\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                \n                # Coming from above\n                if i > 0:\n                    for pos_count in dp[i-1][j]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        if new_pos_count <= target_positive:\n                            dp[i][j].add(new_pos_count)\n                \n                # Coming from left\n                if j > 0:\n                    for pos_count in dp[i][j-1]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        if new_pos_count <= target_positive:\n                            dp[i][j].add(new_pos_count)\n        \n        # Check if we can reach the destination with exactly target_positive +1s\n        print(\"YES\" if target_positive in dp[n-1][m-1] else \"NO\")\n\nsolve()\n```\n\nActually, I think there's a simpler approach. Let's reconsider:\n\n```python\ndef solve():\n    t = int(input())\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        \n        for i in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Any path from (1,1) to (n,m) has exactly (n+m-1) cells\n        total_cells = n + m - 1\n        \n        # If the sum needs to be 0, and all values are +1 or -1,\n        # then we need an equal number of +1s and -1s in our path\n        \n        # If total_cells is odd, we can't have equal number of +1s and -1s\n        if total_cells % 2 != 0:\n            print(\"NO\")\n            continue\n        \n        # We need exactly total_cells/2 cells with +1 and total_cells/2 cells with -1\n        target_positive = total_cells // 2\n        \n        # Use DP to check if we can have exactly target_positive +1s in the path\n        dp = [[False for _ in range(target_positive + 1)] for _ in range(n*m)]\n        \n        # Base case\n        dp[0][1 if grid[0][0] == 1 else 0] = True\n        \n        idx = 0\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    idx += 1\n                    continue\n                \n                for pos_count in range(target_positive + 1):\n                    # Coming from above\n                    if i > 0:\n                        prev_idx = idx - m\n                        prev_pos = pos_count - (1 if grid[i][j] == 1 else 0)\n                        if 0 <= prev_pos <= target_positive and dp[prev_idx][prev_pos]:\n                            dp[idx][pos_count] = True\n                    \n                    # Coming from left\n                    if j > 0:\n                        prev_idx = idx - 1\n                        prev_pos = pos_count - (1 if grid[i][j] == 1 else 0)\n                        if 0 <= prev_pos <= target_positive and dp[prev_idx][prev_pos]:\n                            dp[idx][pos_count] = True\n                \n                idx += 1\n        \n        # Check if we can reach the destination with exactly target_positive +1s\n        print(\"YES\" if dp[n*m-1][target_positive] else \"NO\")\n```\n\nI'm still not satisfied with the solution. Let me simplify it further:\n\n```python\ndef solve():\n    t = int(input())\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        \n        for i in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Any path from (1,1) to (n,m) has exactly (n+m-1) cells\n        total_cells = n + m - 1\n        \n        # If the sum needs to be 0, and all values are +1 or -1,\n        # then we need an equal number of +1s and -1s in our path\n        \n        # If total_cells is odd, we can't have equal number of +1s and -1s\n        if total_cells % 2 != 0:\n            print(\"NO\")\n            continue\n        \n        # We need exactly total_cells/2 cells with +1 and total_cells/2 cells with -1\n        target_positive = total_cells // 2\n        \n        # Use DP to check if we can have exactly target_positive +1s in the path\n        dp = [[set() for _ in range(m)] for _ in range(n)]\n        \n        # Base case\n        dp[0][0].add(1 if grid[0][0] == 1 else 0)\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                \n                # Coming from above\n                if i > 0:\n                    for pos_count in dp[i-1][j]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        if new_pos_count <= target_positive:\n                            dp[i][j].add(new_pos_count)\n                \n                # Coming from left\n                if j > 0:\n                    for pos_count in dp[i][j-1]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        if new_pos_count <= target_positive:\n                            dp[i][j].add(new_pos_count)\n        \n        # Check if we can reach the destination with exactly target_positive +1s\n        print(\"YES\" if target_positive in dp[n-1][m-1] else \"NO\")\n\nsolve()\n```\n\nThis solution is still not optimal. Let me provide a cleaner, more efficient solution:\n\n```python\ndef solve():\n    t = int(input())\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        \n        for i in range(n):\n            row = list(map(int, input().split()))\n            grid.append(row)\n        \n        # Any path from (1,1) to (n,m) has exactly (n+m-1) cells\n        total_cells = n + m - 1\n        \n        # If the sum needs to be 0, and all values are +1 or -1,\n        # then we need an equal number of +1s and -1s in our path\n        \n        # If total_cells is odd, we can't have equal number of +1s and -1s\n        if total_cells % 2 != 0:\n            print(\"NO\")\n            continue\n        \n        # We need exactly total_cells/2 cells with +1 and total_cells/2 cells with -1\n        target_positive = total_cells // 2\n        \n        # Use DP to check if we can have exactly target_positive +1s in the path\n        # dp[i][j] = set of possible counts of +1s in paths to cell (i,j)\n        dp = [[set() for _ in range(m)] for _ in range(n)]\n        \n        # Base case\n        dp[0][0].add(1 if grid[0][0] == 1 else 0)\n        \n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j == 0:\n                    continue\n                \n                # Coming from above\n                if i > 0:\n                    for pos_count in dp[i-1][j]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        dp[i][j].add(new_pos_count)\n                \n                # Coming from left\n                if j > 0:\n                    for pos_count in dp[i][j-1]:\n                        new_pos_count = pos_count + (1 if grid[i][j] == 1 else 0)\n                        dp[i][j].add(new_pos_count)\n        \n        # Check if we can reach the destination with exactly target_positive +1s\n        print(\"YES\" if target_positive in dp[n-1][m-1] else \"NO\")\n\nsolve()\n```\n\nThis solution uses dynamic programming to track all possible counts of +1s in paths to each cell. If we can reach the destination with exactly half of the cells being +1, then the sum will be 0.",
    "problem": "You are given a grid with $n$ rows and $m$ columns. We denote the square on the $i$-th ($1\\le i\\le n$) row and $j$-th ($1\\le j\\le m$) column by $(i, j)$ and the number there by $a_{ij}$. All numbers are equal to $1$ or to $-1$.\n\nYou start from the square $(1, 1)$ and can move one square down or one square to the right at a time. In the end, you want to end up at the square $(n, m)$.\n\nIs it possible to move in such a way so that the sum of the values written in all the visited cells (including $a_{11}$ and $a_{nm}$) is $0$?\n\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^4$). Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 1000$)  \u2014 the size of the grid.\n\nEach of the following $n$ lines contains $m$ integers. The $j$-th integer on the $i$-th line is $a_{ij}$ ($a_{ij} = 1$ or $-1$)  \u2014 the element in the cell $(i, j)$.\n\nIt is guaranteed that the sum of $n\\cdot m$ over all test cases does not exceed $10^6$.\n\n\n-----Output-----\n\nFor each test case, print \"YES\" if there exists a path from the top left to the bottom right that adds up to $0$, and \"NO\" otherwise. You can output each letter in any case.\n\n\n-----Examples-----\n\nInput\n5\n1 1\n1\n1 2\n1 -1\n1 4\n1 -1 1 -1\n3 4\n1 -1 -1 -1\n-1 1 1 -1\n1 1 1 -1\n3 4\n1 -1 1 1\n-1 1 -1 1\n1 -1 1 1\nOutput\nNO\nYES\nYES\nYES\nNO\n\n\n-----Note-----\n\nOne possible path for the fourth test case is given in the picture in the statement."
  },
  {
    "solutions": [
      "for t in range(int(input())):\n\t(n, p, q) = map(int, input().split())\n\t(v1, v2) = (n, n)\n\twhile p != q:\n\t\tif p > q:\n\t\t\tif p & 1 == 1:\n\t\t\t\tv1 -= 1\n\t\t\tv1 //= 2\n\t\t\tp //= 2\n\t\telse:\n\t\t\tif q & 1 == 1:\n\t\t\t\tv2 -= 1\n\t\t\tv2 //= 2\n\t\t\tq //= 2\n\tprint(min(v1, v2))\n",
      "def main():\n\tn = int(input())\n\tfor i in range(n):\n\t\t(n, u, v) = map(int, input().split())\n\t\ts = solve(n, u, v)\n\t\tprint(s)\n\ndef solve(n, u, v):\n\t(ub, vb) = (bin(u)[2:], bin(v)[2:])\n\ti = 0\n\twhile i < len(ub) and i < len(vb) and (ub[i] == vb[i]):\n\t\ti += 1\n\treturn min(limit(n, ub[i:]), limit(n, vb[i:]))\n\ndef limit(n, sufix):\n\tif sufix == '':\n\t\treturn n\n\tnb = bin(n)[2:]\n\tk = len(sufix)\n\tns = nb[-k:]\n\tif sufix == ns or int(sufix, 2) < int(nb[-k:], 2):\n\t\treturn int(nb[:-k], base=2)\n\telse:\n\t\tlb = nb[:-k]\n\t\treturn int(lb, base=2) - 1\nmain()\n",
      "Q = int(input())\nwhile Q > 0:\n\tQ -= 1\n\t(N, u, v) = map(int, input().strip().split())\n\tif u > v:\n\t\t(u, v) = (v, u)\n\t(p, q) = (0, 1)\n\twhile u != v:\n\t\tif u > v:\n\t\t\tu >>= 1\n\t\t\tcontinue\n\t\tif v & 1:\n\t\t\tp += q\n\t\tv >>= 1\n\t\tq <<= 1\n\tans = (N - p) // q\n\tprint(ans)\n",
      "n = int(input())\nfor i in range(n):\n\tarr = input().split(' ')\n\tn = int(arr[0])\n\tu = int(arr[1])\n\tv = int(arr[2])\n\tif u > v:\n\t\t(u, v) = (v, u)\n\tpath = []\n\tup = u\n\tvp = v\n\twhile up != vp:\n\t\tif vp > up:\n\t\t\tif vp % 2 == 0:\n\t\t\t\tvp = vp // 2\n\t\t\t\tpath.append(0)\n\t\t\telse:\n\t\t\t\tvp = vp // 2\n\t\t\t\tpath.append(1)\n\t\telse:\n\t\t\tup = up // 2\n\tresult = n\n\tfor a in path:\n\t\tif a == 1:\n\t\t\tif result % 2 == 0:\n\t\t\t\tresult -= 1\n\t\telif result % 2 == 1:\n\t\t\tresult -= 1\n\t\tresult = result // 2\n\tprint(result)\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"3\\n11 9 11\\n10 2 2\\n8 1 8\", \"3\\n 11 9 11\\n 10 2 2\\n 8 1 8\", \"1\\n 1 1 1\", \"2\\n 5 3 2\\n 2 2 2\", \"10\\n 1000000 500000 1000000\\n 500000 250000 500000\\n 250000 125000 250000\\n 125000 62500 125000\\n 62500 31250 62500\\n 31250 15624 31250\\n 15622 7810 15622\\n 7810 3905 7810\\n 3905 1952 3905\\n 1952 976 1952\", \"5\\n 10 5 10\\n 8 2 8\\n 10 6 3\\n 9 5 2\\n 7 1 7\", \"3\\n 999999999 999999998 999999999\\n 500000000 250000000 500000000\\n 1000000000 999999999 1000000000\", \"1\\n 1000000000 999999999 1000000000\", \"5\\n 17 16 1\\n 14 2 3\\n 12 1 11\\n 19 10 5\\n 20 15 4\", \"7\\n 9 5 2\\n 10 5 4\\n 812 456 165\\n 653 134 100\\n 1095 789 321\\n 1507 872 267\\n 1563 765 654\", \"4\\n1000000000 500000000 500000001\\n2000000000 1000000000 1000000001\\n3000000000 1500000000 1500000001\\n4000000000 2000000000 2000000001\\n\", \"5\\n1 1 1\\n5 5 5\\n10 10 10\\n10000 10000 10000\\n999999999 999999999 999999999\\n\", \"2\\n1 1 1\\n2 2 2\\n\", \"3\\n1 1 1\\n1 1 2\\n1 1 3\\n\", \"4\\n1 1 1\\n1 1 3\\n100 100 100\\n100 100 250\\n\", \"5\\n1 1 1\\n1 2 3\\n500000000 500000000 500000001\\n500000000 500000001 500000002\\n1 1 10\\n\", \"1\\n10 3 4\\n\", \"2\\n9999999 4 7\\n9999999 8 15\\n\", \"5\\n50 1 5\\n50 2 4\\n50 3 6\\n50 8 12\\n50 11 17\\n\", \"1\\n1000000000 1 1000000000\\n\", \"3\\n200 1 200\\n150 2 3\\n100 10 50\\n\", \"3\\n20 18 1\\n20 1 19\\n20 2 4\\n\", \"1\\n1000 500 750\\n\", \"2\\n30 1 30\\n30 1 1\\n\", \"5\\n10000 1 2\\n10000 2 2\\n10000 9999 10000\\n10000 5000 5999\\n10000 4000 8000\\n\", \"3\\n500000000 1 500000000\\n50000000 250000000 500000000\\n5000000 1111111 2222222\\n\", \"4\\n40000 1 40000\\n40000 20000 40000\\n40000 19999 40000\\n40000 20001 40000\\n\", \"2\\n50 1 50\\n50 25 50\\n\", \"5\\n7 1 4\\n7 2 6\\n7 3 4\\n7 5 6\\n7 1 7\\n\", \"1\\n11 9 11\", \"1\\n10 2 2\", \"1\\n8 1 8\", \"5\\n10 2 2\\n12 4 6\\n9 5 7\\n6 1 2\\n7 3 5\", \"4\\n5 2 3\\n8 1 8\\n11 9 11\\n10 2 2\", \"2\\n11 9 11\\n10 2 2\", \"1\\n9 9 9\", \"3\\n11 9 11\\n10 2 2\\n9 9 9\", \"2\\n8 1 8\\n9 9 9\", \"4\\n10 2 2\\n8 1 8\\n9 9 9\\n8 1 8\", \"5\\n11 9 11\\n10 2 2\\n9 9 9\\n8 1 8\\n9 9 9\", \"3\\n8 1 8\\n9 9 9\\n10 2 2\", \"2\\n11 9 11\\n8 1 8\", \"5\\n11 9 11\\n10 2 2\\n8 1 8\\n6 3 4\\n7 1 7\\n\", \"1\\n15 5 10\\n\", \"2\\n20 10 15\\n25 5 20\\n\", \"4\\n100 50 75\\n200 100 150\\n300 150 225\\n400 200 300\\n\", \"3\\n512 256 384\\n1024 512 768\\n2048 1024 1536\\n\", \"5\\n999999999 500000000 750000000\\n999999999 250000000 500000000\\n999999999 125000000 250000000\\n999999999 62500000 125000000\\n999999999 31250000 62500000\\n\", \"1\\n1000000000 500000000 750000000\\n\", \"2\\n1000000 500000 750000\\n10000000 5000000 7500000\\n\", \"4\\n5000000 2500000 3750000\\n10000000 5000000 7500000\\n15000000 7500000 11250000\\n20000000 10000000 15000000\\n\", \"3\\n30000000 15000000 22500000\\n40000000 20000000 30000000\\n50000000 25000000 37500000\\n\", \"5\\n60000000 30000000 45000000\\n70000000 35000000 52500000\\n80000000 40000000 60000000\\n90000000 45000000 67500000\\n100000000 50000000 75000000\\n\", \"1\\n1100000000 550000000 825000000\\n\", \"3\\n11 9 11\\n10 2 2\\n8 1 8\", \"5\\n15 8 9\\n10 5 4\\n18 2 3\\n21 11 15\\n9 1 5\", \"4\\n1000 500 1000\\n100000 15000 75000\\n99999 99999 88888\\n20 10 5\", \"6\\n20 2 4\\n16 4 8\\n30 10 12\\n25 11 12\\n12 1 12\\n14 7 7\", \"7\\n10 3 1\\n16 6 2\\n20 6 1\\n24 6 3\\n55 10 6\\n45 9 4\\n15 7 3\", \"1\\n10 1 10\", \"5\\n20 5 20\\n15 3 15\\n30 7 30\\n35 17 18\\n40 8 8\", \"1\\n1000000000 500000000 500000001\", \"2\\n5 1 5\\n7 1 7\", \"4\\n16 1 16\\n11 1 11\\n18 2 9\\n6 1 6\", \"2\\n500000000 1 500000000\\n500000000 250000000 250000001\", \"1\\n999999999 1 999999999\", \"3\\n1000 1 1000\\n10000 1 10000\\n100000 1 100000\", \"4\\n125 17 18\\n13 1 13\\n5 1 5\\n7 1 7\", \"1\\n1000000000 1 1000000000\", \"1\\n10000 1 10000\", \"1\\n1000000000 1 2\", \"1\\n20 10 11\", \"3\\n11 9 11\\n10 2 2\\n8 1 8\\n\", \"1\\n9 4 5\\n\", \"2\\n15 7 8\\n10 1 2\\n\", \"4\\n20 10 20\\n30 15 30\\n40 20 40\\n50 25 50\\n\", \"1\\n1000000000 500000000 1000000000\\n\", \"3\\n10 5 6\\n15 8 9\\n20 10 11\\n\", \"3\\n25 13 14\\n35 19 20\\n45 24 25\\n\", \"5\\n99 50 51\\n88 45 46\\n77 40 41\\n66 35 36\\n55 30 31\\n\", \"1\\n10 5 5\\n\", \"2\\n20 10 15\\n30 15 20\\n\", \"2\\n100 50 51\\n200 100 101\\n\", \"2\\n200000000 100000000 200000000\\n400000000 200000000 400000000\\n\", \"4\\n300000000 150000000 300000000\\n500000000 250000000 500000000\\n600000000 300000000 600000000\\n700000000 350000000 700000000\\n\", \"3\\n1000000000 500000000 600000000\\n800000000 400000000 450000000\\n1500000000 750000000 800000000\\n\", \"5\\n15 7 15\\n10 2 2\\n8 1 8\\n7 3 7\\n14 7 14\", \"4\\n12 3 12\\n15 5 5\\n18 2 18\\n20 10 20\", \"3\\n11 1 11\\n9 9 9\\n7 1 7\", \"2\\n20 10 10\\n15 5 15\", \"5\\n50 25 50\\n100 2 100\\n200 1 200\\n75 35 35\\n80 40 80\", \"1\\n30 10 30\", \"3\\n9 2 2\\n8 1 8\\n14 7 7\", \"2\\n25 10 10\\n15 7 7\", \"2\\n10 5 10\\n15 15 15\", \"1\\n15 1 15\", \"4\\n11 9 11\\n10 2 2\\n4 1 4\\n7 2 7\", \"2\\n20 10 10\\n15 7 15\", \"3\\n50 50 50\\n100 1 100\\n200 200 200\", \"4\\n15 8 10\\n12 3 6\\n7 2 5\\n25 20 22\\n\", \"8\\n20 4 14\\n18 6 12\\n22 7 21\\n11 2 8\\n101 55 77\\n200 100 150\\n27 13 25\\n35 18 33\\n\", \"5\\n55 23 50\\n45 20 40\\n78 35 70\\n88 42 84\\n100 47 95\\n\", \"3\\n100 37 73\\n150 56 112\\n200 75 150\\n\", \"8\\n11 6 10\\n12 7 11\\n13 8 12\\n14 9 13\\n20 10 20\\n50 25 50\\n75 37 75\\n100 50 100\\n\", \"10\\n10 1 10\\n20 2 20\\n30 3 30\\n40 4 40\\n50 5 50\\n60 6 60\\n70 7 70\\n80 8 80\\n90 9 90\\n100 10 100\\n\", \"5\\n17 3 15\\n26 4 24\\n36 6 34\\n45 7 43\\n83 10 80\\n\", \"1\\n10 3 3\", \"2\\n12 3 5\\n10 6 8\", \"5\\n100 20 50\\n23 7 11\\n300 150 250\\n99 33 88\\n1000 500 900\", \"4\\n1000000000 500000000 600000000\\n999999999 333333333 444444444\\n888888888 222222222 333333333\\n777777777 111111111 222222222\", \"3\\n15 7 11\\n14 6 12\\n13 5 13\", \"2\\n17 9 15\\n19 9 17\", \"5\\n20 7 19\\n19 6 18\\n18 5 17\\n17 4 16\\n16 3 15\", \"3\\n10 5 5\\n9 4 4\\n8 3 3\", \"1\\n10 4 7\", \"3\\n15 3 9\\n17 7 15\\n12 2 8\", \"2\\n18 6 12\\n20 5 15\", \"4\\n25 6 18\\n30 12 24\\n35 5 20\\n40 8 16\", \"2\\n50 10 20\\n60 12 24\", \"3\\n70 14 28\\n90 3 15\\n99 4 16\", \"2\\n100 5 10\\n100 6 12\", \"1\\n1000 20 40\", \"5\\n500 10 20\\n600 12 24\\n700 14 28\\n800 16 32\\n900 5 10\", \"1\\n10000 30 60\", \"2\\n20000 40 80\\n30000 50 100\", \"4\\n40000 60 120\\n50000 70 140\\n60000 15 30\\n70000 20 40\", \"1\\n80000 25 50\", \"3\\n100000 3 5\\n100000 5 7\\n100000 7 9\", \"2\\n100000 10 12\\n100000 12 14\", \"1\\n1000000 100 200\", \"5\\n2000000 200 400\\n3000000 300 600\\n4000000 400 800\\n5000000 500 1000\\n6000000 600 1200\", \"1\\n7 1 2\", \"2\\n5 2 3\\n15 8 7\", \"4\\n20 4 5\\n30 15 20\\n40 20 25\\n50 25 30\", \"5\\n10 5 6\\n10 6 7\\n10 7 8\\n10 8 9\\n10 9 10\", \"1\\n8 2 3\", \"3\\n11 7 8\\n10 7 8\\n8 5 9\", \"2\\n4 3 1\\n5 2 4\\n\", \"3\\n20 10 10\\n15 7 9\\n12 6 8\\n\", \"4\\n7 1 7\\n6 3 2\\n5 5 3\\n9 8 4\\n\", \"1\\n25 12 8\\n\", \"2\\n15 7 5\\n20 10 5\\n\", \"1\\n1 1 1\\n\", \"2\\n50 35 40\\n40 30 35\\n\", \"3\\n30 15 3\\n10 5 2\\n20 10 4\\n\", \"4\\n100 50 25\\n200 100 50\\n300 150 75\\n400 200 100\\n\", \"3\\n1000000000 500000000 750000000\\n1000000000 250000000 750000000\\n1000000000 500000000 250000000\", \"5\\n10 1 10\\n10 1 9\\n10 1 8\\n10 1 7\\n10 1 6\", \"4\\n20 1 20\\n20 2 19\\n20 3 18\\n20 4 17\", \"2\\n1000000000 1 500000000\\n1000000000 500000000 1\", \"3\\n15 1 15\\n15 2 14\\n15 3 13\", \"5\\n30 1 30\\n30 2 29\\n30 3 28\\n30 4 27\\n30 5 26\", \"6\\n1000000000 1 2\\n1000000000 2 3\\n1000000000 3 4\\n1000000000 4 5\\n1000000000 5 6\\n1000000000 6 7\", \"7\\n14 1 14\\n14 2 13\\n14 3 12\\n14 4 11\\n14 5 10\\n14 6 9\\n14 7 8\", \"1\\n20 1 1\", \"2\\n20 1 10\\n20 1 5\", \"3\\n75 1 2\\n75 2 3\\n75 3 4\", \"4\\n40 1 40\\n40 2 39\\n40 3 38\\n40 4 37\", \"5\\n50 1 10\\n50 10 20\\n50 20 30\\n50 30 40\\n50 40 50\", \"3\\n11 9 11\\n10 4 2\\n8 1 8\", \"3\\n11 9 11\\n10 4 2\\n8 1 10\", \"3\\n9 9 11\\n10 4 2\\n6 1 10\", \"3\\n9 15 11\\n10 4 2\\n6 1 10\", \"3\\n9 15 11\\n10 4 2\\n10 1 10\", \"3\\n9 15 9\\n10 4 2\\n10 1 3\", \"3\\n9 15 9\\n10 2 2\\n10 1 3\", \"3\\n9 15 9\\n10 2 0\\n10 1 3\", \"3\\n9 15 9\\n10 2 0\\n10 2 0\", \"3\\n9 15 9\\n5 2 0\\n11 2 0\", \"3\\n9 11 9\\n5 2 0\\n11 2 0\", \"3\\n9 11 9\\n5 2 0\\n1 2 0\", \"3\\n9 3 18\\n5 2 0\\n1 2 0\", \"3\\n3 3 16\\n5 2 0\\n1 0 0\", \"3\\n11 9 11\\n7 2 2\\n8 1 8\", \"3\\n11 9 11\\n10 3 2\\n8 1 8\", \"3\\n11 9 11\\n10 0 2\\n6 1 10\", \"3\\n9 9 4\\n10 4 2\\n6 1 10\", \"3\\n9 15 9\\n10 8 2\\n10 1 10\", \"3\\n9 29 9\\n10 4 2\\n10 1 10\", \"3\\n9 18 9\\n10 2 2\\n10 1 3\", \"3\\n9 15 9\\n10 0 0\\n10 2 0\", \"3\\n9 11 9\\n5 1 0\\n11 2 0\", \"3\\n9 4 9\\n5 2 0\\n1 2 0\", \"3\\n9 3 16\\n5 2 0\\n1 2 1\", \"3\\n11 9 11\\n7 2 2\\n8 1 11\", \"3\\n11 9 11\\n10 3 0\\n8 1 8\", \"3\\n11 18 11\\n10 4 2\\n8 0 10\", \"3\\n9 9 4\\n10 4 2\\n6 0 10\", \"3\\n9 15 9\\n10 4 2\\n6 0 10\", \"3\\n9 15 9\\n19 8 2\\n10 1 10\", \"3\\n9 29 9\\n10 4 2\\n10 2 10\", \"3\\n9 26 9\\n10 2 2\\n10 1 3\", \"3\\n14 15 9\\n10 2 0\\n10 2 2\", \"3\\n9 24 9\\n10 2 0\\n16 2 0\", \"3\\n9 11 9\\n5 1 0\\n22 2 0\", \"3\\n9 3 9\\n4 2 0\\n1 2 1\", \"3\\n3 0 11\\n5 2 0\\n1 2 0\", \"3\\n11 9 11\\n10 3 0\\n8 1 12\", \"3\\n11 9 2\\n10 0 0\\n6 1 10\", \"3\\n9 9 4\\n10 6 2\\n6 0 10\", \"3\\n9 15 15\\n10 4 2\\n6 0 10\", \"3\\n4 15 9\\n19 8 2\\n10 1 10\", \"3\\n9 10 16\\n10 4 2\\n10 1 3\", \"3\\n9 24 9\\n14 2 0\\n16 2 0\", \"3\\n9 11 9\\n3 1 0\\n22 2 0\", \"3\\n9 3 9\\n4 2 0\\n1 2 2\", \"3\\n9 3 27\\n9 2 0\\n1 2 0\", \"3\\n11 9 11\\n10 2 2\\n8 2 11\", \"3\\n11 9 11\\n10 1 0\\n8 1 12\", \"3\\n19 9 2\\n10 0 0\\n6 1 10\", \"3\\n9 15 15\\n3 4 2\\n6 0 10\", \"3\\n9 44 9\\n20 2 2\\n10 1 3\", \"3\\n14 15 9\\n20 2 0\\n10 2 0\", \"3\\n6 24 9\\n14 2 0\\n16 2 0\", \"3\\n9 15 12\\n5 1 1\\n11 2 0\", \"3\\n9 11 9\\n3 1 0\\n22 4 0\", \"3\\n2 3 27\\n9 2 0\\n1 2 0\", \"3\\n2 3 3\\n5 2 0\\n1 0 0\", \"3\\n18 9 11\\n10 2 2\\n8 2 11\", \"3\\n16 9 11\\n10 1 0\\n8 1 12\", \"3\\n19 9 2\\n10 0 0\\n6 2 10\", \"3\\n9 9 4\\n10 6 0\\n12 0 10\", \"3\\n9 15 15\\n3 7 2\\n6 0 10\", \"3\\n4 22 9\\n19 8 2\\n5 1 10\", \"3\\n10 29 9\\n10 4 2\\n10 4 14\", \"3\\n9 10 8\\n10 4 2\\n10 0 3\", \"3\\n9 44 9\\n20 3 2\\n10 1 3\", \"3\\n14 13 9\\n20 2 0\\n10 2 0\", \"3\\n6 24 9\\n14 2 0\\n8 2 0\", \"3\\n27 9 11\\n10 1 0\\n8 1 12\", \"3\\n10 29 9\\n16 4 2\\n10 4 14\", \"3\\n9 44 9\\n20 3 2\\n10 1 4\", \"3\\n9 15 12\\n5 1 2\\n0 2 0\", \"3\\n11 11 9\\n3 1 0\\n22 5 0\", \"3\\n19 16 0\\n10 0 0\\n6 2 10\", \"3\\n10 29 9\\n14 4 2\\n10 4 14\", \"3\\n9 10 8\\n10 4 2\\n11 1 3\", \"3\\n17 44 9\\n20 3 2\\n10 1 4\", \"3\\n14 13 9\\n20 2 0\\n10 1 0\", \"3\\n11 11 9\\n3 0 0\\n22 5 0\", \"3\\n1 3 9\\n3 0 0\\n1 4 2\", \"3\\n2 2 3\\n2 2 1\\n1 0 0\", \"3\\n32 9 2\\n10 2 2\\n8 2 11\", \"3\\n9 10 8\\n10 4 2\\n16 1 3\", \"3\\n17 44 9\\n20 3 2\\n10 2 4\", \"3\\n6 24 9\\n19 2 1\\n8 3 0\", \"3\\n9 15 12\\n9 1 2\\n0 2 0\", \"3\\n1 11 9\\n3 0 0\\n22 5 0\", \"3\\n1 3 9\\n3 0 0\\n1 7 2\", \"3\\n27 5 30\\n10 1 0\\n8 1 12\", \"3\\n9 10 8\\n10 4 1\\n16 1 3\", \"3\\n17 44 9\\n20 3 2\\n1 2 4\", \"3\\n6 24 9\\n19 1 1\\n8 3 0\", \"3\\n32 12 2\\n10 2 2\\n1 2 11\", \"3\\n40 5 30\\n10 1 0\\n8 1 12\", \"3\\n17 44 9\\n20 3 2\\n2 2 4\", \"3\\n14 3 10\\n20 0 0\\n10 1 0\", \"3\\n6 24 9\\n19 1 1\\n8 1 0\", \"3\\n10 29 4\\n11 4 2\\n10 8 8\", \"3\\n11 9 11\\n10 2 2\\n8 1 8\"], \"outputs\": [\"2\\n10\\n1\", \"2\\n10\\n1\", \"1\\n\", \"2\\n2\\n\", \"500000\\n250000\\n125000\\n62500\\n31250\\n7812\\n3905\\n3905\\n1952\\n976\\n\", \"5\\n2\\n5\\n4\\n1\\n\", \"499999999\\n250000000\\n976562\\n\", \"976562\\n\", \"1\\n6\\n1\\n9\\n1\\n\", \"4\\n4\\n2\\n5\\n1\\n2\\n11\\n\", \"499999999\\n999999999\\n1499999999\\n1999999999\\n\", \"1\\n5\\n10\\n10000\\n999999999\\n\", \"1\\n2\\n\", \"1\\n0\\n0\\n\", \"1\\n0\\n100\\n0\\n\", \"1\\n0\\n249999999\\n124999999\\n-1\\n\", \"2\\n\", \"2499999\\n1249999\\n\", \"12\\n25\\n25\\n5\\n6\\n\", \"1\\n\", \"1\\n74\\n2\\n\", \"1\\n1\\n10\\n\", \"1\\n\", \"1\\n30\\n\", \"5000\\n10000\\n312\\n3\\n5000\\n\", \"1\\n25000000\\n2500000\\n\", \"1\\n20000\\n312\\n10000\\n\", \"1\\n25\\n\", \"1\\n1\\n1\\n1\\n1\\n\", \"2\\n\", \"10\\n\", \"1\\n\", \"10\\n2\\n1\\n3\\n1\\n\", \"2\\n1\\n2\\n10\\n\", \"2\\n10\\n\", \"9\\n\", \"2\\n10\\n9\\n\", \"1\\n9\\n\", \"10\\n1\\n9\\n1\\n\", \"2\\n10\\n9\\n1\\n9\\n\", \"1\\n9\\n10\\n\", \"2\\n1\\n\", \"2\\n10\\n1\\n1\\n1\\n\", \"7\\n\", \"1\\n6\\n\", \"1\\n1\\n1\\n1\\n\", \"1\\n1\\n1\\n\", \"1\\n499999999\\n499999999\\n499999999\\n499999999\\n\", \"1\\n\", \"1\\n1\\n\", \"1\\n1\\n1\\n1\\n\", \"1\\n1\\n2\\n\", \"1\\n1\\n1\\n2\\n2\\n\", \"1\\n\", \"2\\n10\\n1\", \"7\\n4\\n8\\n1\\n2\\n\", \"500\\n1\\n1\\n10\\n\", \"10\\n8\\n3\\n2\\n1\\n14\\n\", \"4\\n3\\n4\\n12\\n6\\n22\\n7\\n\", \"1\\n\", \"5\\n3\\n7\\n8\\n40\\n\", \"499999999\\n\", \"1\\n1\\n\", \"1\\n1\\n4\\n1\\n\", \"1\\n249999999\\n\", \"1\\n\", \"1\\n1\\n1\\n\", \"30\\n1\\n1\\n1\\n\", \"1\\n\", \"1\\n\", \"500000000\\n\", \"9\\n\", \"2\\n10\\n1\", \"4\\n\", \"1\\n5\\n\", \"10\\n15\\n20\\n25\\n\", \"500000000\\n\", \"2\\n7\\n9\\n\", \"5\\n3\\n22\\n\", \"49\\n21\\n38\\n7\\n27\\n\", \"10\\n\", \"1\\n1\\n\", \"49\\n99\\n\", \"100000000\\n200000000\\n\", \"150000000\\n250000000\\n300000000\\n350000000\\n\", \"1\\n2\\n21\\n\", \"7\\n10\\n1\\n3\\n7\\n\", \"3\\n15\\n2\\n10\\n\", \"1\\n9\\n1\\n\", \"20\\n1\\n\", \"25\\n1\\n1\\n75\\n40\\n\", \"1\\n\", \"9\\n1\\n14\\n\", \"25\\n15\\n\", \"5\\n15\\n\", \"1\\n\", \"2\\n10\\n1\\n1\\n\", \"20\\n7\\n\", \"50\\n1\\n200\\n\", \"3\\n6\\n3\\n5\\n\", \"1\\n9\\n1\\n2\\n1\\n1\\n6\\n4\\n\", \"1\\n22\\n39\\n44\\n49\\n\", \"24\\n75\\n100\\n\", \"1\\n1\\n1\\n1\\n10\\n25\\n37\\n50\\n\", \"1\\n2\\n3\\n2\\n1\\n3\\n1\\n2\\n2\\n1\\n\", \"3\\n1\\n1\\n1\\n10\\n\", \"10\\n\", \"2\\n1\\n\", \"2\\n2\\n1\\n2\\n7\\n\", \"1\\n3\\n3\\n388888888\\n\", \"1\\n7\\n1\\n\", \"1\\n4\\n\", \"1\\n1\\n2\\n4\\n3\\n\", \"10\\n9\\n8\\n\", \"1\\n\", \"1\\n8\\n3\\n\", \"9\\n1\\n\", \"1\\n15\\n8\\n20\\n\", \"25\\n30\\n\", \"35\\n21\\n24\\n\", \"50\\n50\\n\", \"500\\n\", \"250\\n300\\n350\\n400\\n450\\n\", \"5000\\n\", \"10000\\n15000\\n\", \"20000\\n25000\\n30000\\n35000\\n\", \"40000\\n\", \"24999\\n24999\\n12499\\n\", \"12499\\n24999\\n\", \"500000\\n\", \"1000000\\n1500000\\n2000000\\n2500000\\n3000000\\n\", \"3\\n\", \"2\\n1\\n\", \"9\\n1\\n1\\n5\\n\", \"2\\n4\\n1\\n4\\n2\\n\", \"3\\n\", \"1\\n1\\n1\\n\", \"1\\n2\\n\", \"20\\n1\\n1\\n\", \"1\\n2\\n1\\n4\\n\", \"2\\n\", \"3\\n10\\n\", \"1\\n\", \"2\\n1\\n\", \"6\\n4\\n4\\n\", \"50\\n100\\n150\\n200\\n\", \"1\\n1\\n500000000\\n\", \"1\\n1\\n1\\n1\\n2\\n\", \"1\\n2\\n1\\n4\\n\", \"2\\n2\\n\", \"1\\n1\\n3\\n\", \"1\\n1\\n3\\n1\\n1\\n\", \"500000000\\n499999999\\n250000000\\n499999999\\n249999999\\n499999999\\n\", \"1\\n1\\n3\\n2\\n7\\n1\\n1\\n\", \"20\\n\", \"2\\n4\\n\", \"37\\n37\\n18\\n\", \"1\\n2\\n1\\n4\\n\", \"6\\n25\\n2\\n1\\n1\\n\", \"2\\n5\\n1\\n\", \"2\\n5\\n0\\n\", \"1\\n5\\n0\\n\", \"0\\n5\\n0\\n\", \"0\\n5\\n1\\n\", \"0\\n5\\n4\\n\", \"0\\n10\\n4\\n\", \"0\\n2\\n4\\n\", \"0\\n2\\n2\\n\", \"0\\n0\\n2\\n\", \"1\\n0\\n2\\n\", \"1\\n0\\n-1\\n\", \"0\\n0\\n-1\\n\", \"0\\n0\\n1\\n\", \"2\\n7\\n1\\n\", \"2\\n4\\n1\\n\", \"2\\n2\\n0\\n\", \"4\\n5\\n0\\n\", \"0\\n2\\n1\\n\", \"-1\\n5\\n1\\n\", \"4\\n10\\n4\\n\", \"0\\n10\\n2\\n\", \"1\\n2\\n2\\n\", \"4\\n0\\n-1\\n\", \"0\\n0\\n0\\n\", \"2\\n7\\n0\\n\", \"2\\n1\\n1\\n\", \"1\\n5\\n-1\\n\", \"4\\n5\\n-1\\n\", \"0\\n5\\n-1\\n\", \"0\\n4\\n1\\n\", \"-1\\n5\\n2\\n\", \"-1\\n10\\n4\\n\", \"0\\n2\\n10\\n\", \"0\\n2\\n3\\n\", \"1\\n2\\n5\\n\", \"1\\n0\\n0\\n\", \"-1\\n0\\n-1\\n\", \"2\\n1\\n0\\n\", \"2\\n10\\n0\\n\", \"4\\n2\\n-1\\n\", \"9\\n5\\n-1\\n\", \"-1\\n4\\n1\\n\", \"1\\n5\\n4\\n\", \"0\\n3\\n3\\n\", \"1\\n1\\n5\\n\", \"1\\n0\\n1\\n\", \"0\\n1\\n-1\\n\", \"2\\n10\\n1\\n\", \"2\\n4\\n0\\n\", \"4\\n10\\n0\\n\", \"9\\n1\\n-1\\n\", \"-1\\n20\\n4\\n\", \"0\\n4\\n2\\n\", \"-1\\n3\\n3\\n\", \"1\\n5\\n2\\n\", \"1\\n1\\n2\\n\", \"-1\\n1\\n-1\\n\", \"2\\n0\\n1\\n\", \"3\\n10\\n1\\n\", \"3\\n4\\n0\\n\", \"4\\n10\\n1\\n\", \"4\\n0\\n0\\n\", \"9\\n0\\n-1\\n\", \"-1\\n4\\n0\\n\", \"-1\\n5\\n0\\n\", \"1\\n5\\n1\\n\", \"-1\\n9\\n4\\n\", \"1\\n4\\n2\\n\", \"-1\\n3\\n1\\n\", \"6\\n4\\n0\\n\", \"-1\\n8\\n0\\n\", \"-1\\n9\\n2\\n\", \"1\\n2\\n-1\\n\", \"2\\n1\\n2\\n\", \"0\\n10\\n1\\n\", \"-1\\n7\\n0\\n\", \"1\\n5\\n5\\n\", \"0\\n9\\n2\\n\", \"1\\n4\\n4\\n\", \"2\\n3\\n2\\n\", \"0\\n3\\n0\\n\", \"0\\n1\\n1\\n\", \"7\\n10\\n1\\n\", \"1\\n5\\n7\\n\", \"0\\n9\\n5\\n\", \"-1\\n9\\n1\\n\", \"1\\n4\\n-1\\n\", \"-1\\n3\\n2\\n\", \"0\\n3\\n-1\\n\", \"0\\n4\\n0\\n\", \"1\\n2\\n7\\n\", \"0\\n9\\n0\\n\", \"-1\\n19\\n1\\n\", \"3\\n10\\n-1\\n\", \"1\\n4\\n0\\n\", \"0\\n9\\n1\\n\", \"1\\n20\\n4\\n\", \"-1\\n19\\n3\\n\", \"-1\\n5\\n10\\n\", \"2\\n10\\n1\"]}",
    "difficulty": "HARD",
    "raw_tags": "['Mathematics', 'Binary Tree', 'Basic Maths', 'Algorithms', 'Searching', 'Tree Data Structure', 'Binary Search', 'Lowest Common Ancestor', 'Graph Algos', 'Data Structures']",
    "name": null,
    "source": "codechef",
    "tags": "['Graph algorithms', 'Sorting', 'Complete search', 'Tree algorithms', 'Mathematics', 'Data structures', 'Tree queries']",
    "skill_types": "['Sorting', 'Data structures', 'Complete search']",
    "url": "https://www.codechef.com/problems/BINTREEQ",
    "Expected Auxiliary Space": null,
    "time_limit": "1 seconds",
    "date": "2016-03-26",
    "picture_num": "1",
    "memory_limit": "50000 bytes",
    "Expected Time Complexity": null,
    "human_solution": "for t in range(int(input())):\n\t(n, p, q) = map(int, input().split())\n\t(v1, v2) = (n, n)\n\twhile p != q:\n\t\tif p > q:\n\t\t\tif p & 1 == 1:\n\t\t\t\tv1 -= 1\n\t\t\tv1 //= 2\n\t\t\tp //= 2\n\t\telse:\n\t\t\tif q & 1 == 1:\n\t\t\t\tv2 -= 1\n\t\t\tv2 //= 2\n\t\t\tq //= 2\n\tprint(min(v1, v2))\n",
    "claude_solution": "# Solution for Binary Tree Path Configuration Problem\n\nThis problem asks us to count pairs of nodes that have the same path configuration as a given pair (u, v) in an infinite binary tree.\n\nThe key insight is to understand what makes path configurations equivalent. Two pairs (u, v) and (w, t) have the same path configuration if the sequence of operations to go from u to v is the same as the sequence of operations to go from w to t.\n\nLet's analyze how to determine this path configuration:\n\n```python\ndef solve():\n    Q = int(input())\n    \n    for _ in range(Q):\n        n, u, v = map(int, input().split())\n        \n        # Find the path configuration from u to v\n        path = get_path_configuration(u, v)\n        \n        # Count pairs with the same path configuration\n        count = count_pairs_with_same_configuration(n, path)\n        \n        print(count)\n\ndef get_path_configuration(u, v):\n    \"\"\"\n    Determine the path configuration from node u to node v.\n    Returns a list of operations:\n    1: move to left child\n    2: move to right child\n    3: move to parent as left child\n    4: move to parent as right child\n    \"\"\"\n    # If u and v are the same, return empty path\n    if u == v:\n        return []\n    \n    # Find the lowest common ancestor (LCA)\n    lca, path_to_u, path_to_v = find_lca(u, v)\n    \n    # The path is: go up from u to LCA, then down from LCA to v\n    path = []\n    \n    # Going up from u to LCA (reverse the operations)\n    for op in reversed(path_to_u):\n        if op == 1:  # If we went left, we go up as left child\n            path.append(3)\n        else:  # If we went right, we go up as right child\n            path.append(4)\n    \n    # Going down from LCA to v\n    path.extend(path_to_v)\n    \n    return path\n\ndef find_lca(u, v):\n    \"\"\"\n    Find the lowest common ancestor of u and v.\n    Returns the LCA and the paths from LCA to u and from LCA to v.\n    \"\"\"\n    # Track the path from root to u and from root to v\n    path_u = []\n    path_v = []\n    \n    # Find path from root to u\n    temp_u = u\n    while temp_u > 1:\n        if temp_u % 2 == 0:  # u is a left child\n            path_u.append(1)\n            temp_u //= 2\n        else:  # u is a right child\n            path_u.append(2)\n            temp_u = (temp_u - 1) // 2\n    \n    path_u.reverse()  # Reverse to get path from root to u\n    \n    # Find path from root to v\n    temp_v = v\n    while temp_v > 1:\n        if temp_v % 2 == 0:  # v is a left child\n            path_v.append(1)\n            temp_v //= 2\n        else:  # v is a right child\n            path_v.append(2)\n            temp_v = (temp_v - 1) // 2\n    \n    path_v.reverse()  # Reverse to get path from root to v\n    \n    # Find the LCA by finding the point where paths diverge\n    lca = 1  # Start at the root\n    i = 0\n    while i < len(path_u) and i < len(path_v) and path_u[i] == path_v[i]:\n        if path_u[i] == 1:\n            lca = 2 * lca\n        else:\n            lca = 2 * lca + 1\n        i += 1\n    \n    # Return LCA and the paths from LCA to u and v\n    return lca, path_u[i:], path_v[i:]\n\ndef count_pairs_with_same_configuration(n, path):\n    \"\"\"\n    Count the number of pairs (w, t) where 1 \u2264 w, t \u2264 n that have the same path configuration.\n    \"\"\"\n    # If path is empty, it means u = v, so we count all pairs (w, w) where 1 \u2264 w \u2264 n\n    if not path:\n        return n\n    \n    # For non-empty paths, we need to count valid starting points\n    # A starting point w is valid if we can follow the path and end at a valid t \u2264 n\n    count = 0\n    \n    # We'll try each possible w from 1 to n\n    # But instead of checking each w individually (which would be too slow),\n    # we'll use mathematical properties to count valid w values\n    \n    # The key insight: for a given path, the relationship between w and t is fixed\n    # We can express t as a function of w: t = f(w)\n    # For a valid pair, we need both w \u2264 n and f(w) \u2264 n\n    \n    # Calculate the relationship between w and t based on the path\n    a, b = calculate_relationship(path)\n    \n    # Now t = a*w + b\n    # We need to count w such that 1 \u2264 w \u2264 n and 1 \u2264 a*w + b \u2264 n\n    \n    # This gives us: max(1, (1-b)/a) \u2264 w \u2264 min(n, (n-b)/a)\n    lower_bound = max(1, (1 - b + a - 1) // a)  # Ceiling division for lower bound\n    upper_bound = min(n, (n - b) // a)  # Floor division for upper bound\n    \n    # Count valid w values\n    if lower_bound <= upper_bound:\n        count = upper_bound - lower_bound + 1\n    \n    return count\n\ndef calculate_relationship(path):\n    \"\"\"\n    Calculate the relationship between w and t given a path configuration.\n    Returns (a, b) where t = a*w + b\n    \"\"\"\n    a = 1  # Multiplier\n    b = 0  # Constant term\n    \n    for op in path:\n        if op == 1:  # Move to left child\n            a *= 2\n            b *= 2\n        elif op == 2:  # Move to right child\n            a *= 2\n            b = b * 2 + 1\n        elif op == 3:  # Move to parent as left child\n            a //= 2\n            b //= 2\n        elif op == 4:  # Move to parent as right child\n            a //= 2\n            b = (b - 1) // 2\n    \n    return a, b\n\nif __name__ == \"__main__\":\n    solve()\n```\n\nThis solution efficiently calculates the path configuration between two nodes and then counts how many pairs have the same configuration. The key optimizations are:\n\n1. We find the path configuration by determining the lowest common ancestor (LCA) and the paths from the LCA to each node.\n2. Instead of checking each possible pair (which would be O(n\u00b2)), we derive a mathematical relationship between the start and end nodes for a given path configuration.\n3. We use this relationship to count valid pairs in O(1) time.\n\nThe time complexity is O(log n) per query, which is efficient enough for the given constraints.",
    "problem": "Read problems statements in Mandarin Chinese, Russian and Vietnamese as well.\n\nLet's consider a rooted binary tree with the following properties:\n\nThe number of nodes and edges in the tree is infinite\nThe tree root is labeled by $1$\nA node labeled by $v$ has two children: $2 \\cdot v$ (the left child of $v$), and $2 \\cdot v + 1$ (the right child of $v$).\n\nHere is an image of the first several layers of such a tree:\n\nLet's consider four operations that you are allowed to apply during the tree traversal:\n\nmove to the left child - move from $v$ to $2 \\cdot v$\nmove to the right child - move from $v$ to $2 \\cdot v + 1$\nmove to the parent as a left child - move from $v$ to $\\frac{v}{2}$ if $v$ is an even integer\nmove to the parent as a right child - move from $v$ to $\\frac{v - 1}{2}$ if $v$ is an odd integer\n\nIt can be proven, that for any pair of nodes $u$ and $v$, there is only one sequence of commands that moves from $u$ to $v$ and visits each node of the tree at most once. Let's call such a sequence of commands a path configuration for a pair of nodes $(u, v)$.\n\nYou are asked to process a series of the following queries: \n\nYou are given three integers $n$, $u$ and $v$ ($1 \u2264 u, v \u2264 n$). Count the pairs of nodes $(w, t)$ ($1 \u2264 w, t \u2264 n$) such that the path configuration for $(w, t)$ is the same with the path configuration for $(u, v)$.\n\n------  Input ------\nThe first line of input contains a single integer $Q$, denoting the number of queries to process.\nEach of the next $Q$ lines contains three space-separated integers $n$, $u$ and $v$ denoting a query.\n\n------  Output ------\nFor each query, print the answer on a separate line.\n\n------  Constraints ------\n$1 \u2264 Q \u2264 2 \\cdot 10^{4}$\n$1 \u2264 u, v \u2264 n \u2264 10^{9}$\n\n----- Sample Input 1 ------ \n3\n\n11 9 11\n\n10 2 2\n\n8 1 8\n----- Sample Output 1 ------ \n2\n\n10\n\n1\n----- explanation 1 ------ \nIn the first query from the example test case, you should count pairs $(5, 7)$ and $(9, 11)$.\n\nIn the second query from the example test case, you should count the following pairs: $(1, 1)$, $(2, 2)$, $(3, 3)$, $(4, 4)$, $(5, 5)$, $(6, 6)$, $(7, 7)$, $(8, 8)$, $(9, 9)$ and $(10, 10)$.\n\nIn the third query from the example test case, you should only count a pair $(1, 8)$."
  },
  {
    "solutions": [
      "from collections import deque\nn = int(input())\nq1 = deque()\nres = 1\n\ndef helper(left1, right1, left2, right2):\n\t(temp1, temp2) = (max(left1, left2), min(right1, right2))\n\tif temp1 > right1 or temp1 > right2 or temp2 < left1 or (temp2 < left2):\n\t\treturn None\n\treturn (temp1, temp2)\nfor i in range(n):\n\t(left, right) = map(int, input().split())\n\tq2 = deque()\n\twhile q1 and (q1[0][0][0] < left or q1[0][0][1] > right):\n\t\ttop = q1.pop()\n\t\t(temp1, temp2) = top[0]\n\t\twidth = top[0][1] - top[0][0] + 1\n\t\theight = i - 1 - top[1] + 1\n\t\tres = max(res, min(width, height))\n\t\tvalues = helper(left, right, temp1, temp2)\n\t\tif eval is not None:\n\t\t\tq2.append((values, top[1]))\n\twhile q2:\n\t\ttop = q2.pop()\n\t\tif top[0][1] - top[0][0] + 1 > res:\n\t\t\tq1.append(top)\n\tif not q1 or not (q1[-1][0][0] == left and q1[-1][0][1] == right):\n\t\tif right - left + 1 > res:\n\t\t\tq1.append(((left, right), i))\nwhile q1:\n\ttop = q1.pop()\n\t(temp1, temp2) = top[0]\n\t(height, width) = (n - top[1], temp2 - temp1 + 1)\n\tres = max(res, min(height, width))\nprint(res)\n",
      "from collections import deque\nrows = int(input())\nstk = deque()\nans = 1\n\ndef overlap(l1, r1, l2, r2):\n\t(x, y) = (max(l1, l2), min(r1, r2))\n\tif x > r1 or x > r2 or y < l1 or (y < l2):\n\t\treturn None\n\treturn (x, y)\nfor j in range(rows):\n\t(lt, rt) = map(int, input().split())\n\tstkb = deque()\n\twhile stk and (stk[-1][0][0] < lt or stk[-1][0][1] > rt):\n\t\ttop = stk.pop()\n\t\t(x, y) = top[0]\n\t\twidth = top[0][1] - top[0][0] + 1\n\t\theight = j - 1 - top[1] + 1\n\t\tans = max(ans, min(width, height))\n\t\teval = overlap(lt, rt, x, y)\n\t\tif eval is not None:\n\t\t\tstkb.append((eval, top[1]))\n\twhile stkb:\n\t\ttop = stkb.pop()\n\t\tif top[0][1] - top[0][0] + 1 > ans:\n\t\t\tstk.append(top)\n\tif not stk or not (stk[-1][0][0] == lt and stk[-1][0][1] == rt):\n\t\tif rt - lt + 1 > ans:\n\t\t\tstk.append(((lt, rt), j))\nwhile stk:\n\ttop = stk.pop()\n\t(x, y) = top[0]\n\t(height, width) = (rows - top[1], y - x + 1)\n\tans = max(ans, min(height, width))\nprint(ans)\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"3\\n1 1\\n0 2\\n1 2\\n\", \"8\\n2 4\\n2 4\\n1 4\\n0 7\\n0 3\\n1 2\\n1 2\\n1 1\", \"3\\n0 2\\n1 1\\n2 0\\n\", \"6\\n0 5\\n0 4\\n0 3\\n0 2\\n0 1\\n0 0\\n\", \"4\\n0 0\\n0 0\\n3 3\\n3 3\\n\", \"3\\n1 2\\n0 1\\n0 2\\n\", \"5\\n1 1\\n2 3\\n3 4\\n0 3\\n1 4\\n\", \"2\\n1 1\\n0 1\\n\", \"4\\n1 1\\n2 2\\n3 3\\n0 2\\n\", \"3\\n1 1\\n0 0\\n2 2\\n\", \"7\\n3 3\\n4 4\\n5 5\\n2 2\\n1 1\\n0 0\\n6 6\\n\", \"5\\n1 4\\n0 3\\n2 4\\n1 2\\n3 4\\n\", \"6\\n2 5\\n1 4\\n0 3\\n3 5\\n4 5\\n5 5\\n\", \"8\\n2 4\\n1 3\\n0 4\\n3 4\\n4 5\\n5 6\\n6 7\\n7 7\\n\", \"10\\n0 9\\n0 8\\n0 7\\n0 6\\n0 5\\n0 4\\n0 3\\n0 2\\n0 1\\n0 0\\n\", \"7\\n0 0\\n0 1\\n1 2\\n1 3\\n2 4\\n3 5\\n4 6\\n\", \"9\\n0 0\\n0 1\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\\n4 8\\n\", \"5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"4\\n0 1\\n0 1\\n0 1\\n0 1\\n\", \"6\\n0 5\\n1 5\\n2 4\\n3 3\\n3 3\\n2 2\\n\", \"7\\n0 6\\n1 5\\n2 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"4\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"3\\n0 2\\n1 2\\n2 2\\n\", \"5\\n3 4\\n1 4\\n0 4\\n1 3\\n2 2\\n\", \"6\\n1 2\\n1 2\\n1 2\\n1 2\\n1 2\\n1 2\\n\", \"4\\n0 0\\n0 0\\n0 0\\n0 0\", \"10\\n9 9\\n8 8\\n7 7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\", \"8\\n0 7\\n1 7\\n2 7\\n3 7\\n4 7\\n5 7\\n6 7\\n7 7\", \"5\\n0 4\\n1 3\\n2 2\\n3 1\\n4 0\", \"7\\n0 6\\n1 5\\n2 4\\n3 3\\n4 2\\n5 1\\n6 0\", \"6\\n0 5\\n1 4\\n2 3\\n3 2\\n4 1\\n5 0\", \"3\\n1 1\\n0 2\\n1 2\\n\", \"8\\n2 4\\n2 4\\n1 4\\n0 7\\n0 3\\n1 2\\n1 2\\n1 1\", \"4\\n0 1\\n0 2\\n1 2\\n1 3\\n\", \"5\\n0 1\\n1 2\\n2 3\\n3 4\\n4 4\\n\", \"3\\n0 0\\n1 1\\n2 2\\n\", \"5\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n\", \"6\\n0 1\\n1 2\\n2 3\\n3 4\\n4 5\\n5 5\\n\", \"3\\n0 0\\n0 1\\n0 2\\n\", \"6\\n0 2\\n1 3\\n2 4\\n3 5\\n4 5\\n5 5\\n\", \"7\\n0 5\\n1 6\\n2 5\\n3 4\\n4 3\\n5 2\\n6 1\\n\", \"6\\n0 3\\n1 4\\n2 5\\n3 5\\n4 4\\n5 3\\n\", \"4\\n0 0\\n0 1\\n0 2\\n0 3\\n\", \"2\\n0 0\\n1 1\\n\", \"6\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\", \"10\\n0 3\\n1 4\\n2 5\\n3 6\\n4 7\\n5 7\\n6 6\\n7 5\\n8 4\\n9 3\\n\", \"7\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n\", \"2\\n0 0\\n0 0\\n\", \"5\\n0 1\\n0 2\\n0 3\\n0 4\\n0 4\\n\", \"5\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n\", \"8\\n2 4\\n2 4\\n1 4\\n0 7\\n0 3\\n1 2\\n1 2\\n1 1\\n\", \"6\\n2 4\\n1 3\\n2 4\\n1 3\\n2 4\\n2 3\\n\", \"10\\n5 9\\n4 8\\n3 7\\n2 6\\n1 5\\n0 4\\n0 3\\n1 2\\n2 3\\n4 5\\n\", \"7\\n0 0\\n0 1\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n\", \"5\\n3 4\\n2 3\\n1 2\\n0 1\\n0 0\\n\", \"1\\n0 0\\n\", \"3\\n0 1\\n1 2\\n1 2\\n\", \"7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"5\\n0 0\\n0 1\\n1 2\\n2 3\\n3 4\\n\", \"6\\n2 5\\n1 4\\n0 3\\n0 2\\n1 3\\n2 4\\n\", \"8\\n7 7\\n6 6\\n5 5\\n4 6\\n3 5\\n2 4\\n1 3\\n0 2\\n\", \"9\\n8 8\\n7 7\\n6 6\\n5 5\\n4 5\\n3 4\\n2 3\\n1 2\\n0 1\\n\", \"4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"4\\n1 2\\n1 2\\n2 3\\n2 3\\n\", \"3\\n0 2\\n0 1\\n1 2\\n\", \"5\\n0 4\\n1 4\\n2 4\\n3 4\\n4 4\\n\", \"6\\n0 5\\n1 5\\n2 5\\n3 5\\n4 5\\n5 5\\n\", \"7\\n0 5\\n1 5\\n2 5\\n3 5\\n4 5\\n5 5\\n6 6\\n\", \"8\\n0 7\\n1 7\\n2 7\\n3 7\\n4 7\\n5 7\\n6 7\\n7 7\\n\", \"2\\n0 0\\n0 1\\n\", \"8\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n0 7\\n\", \"6\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n\", \"5\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n\", \"5\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n\", \"7\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n\", \"9\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8\\n\", \"3\\n0 1\\n1 2\\n2 3\\n\", \"6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n\", \"5\\n0 4\\n1 3\\n2 2\\n3 1\\n4 0\\n\", \"2\\n1 1\\n0 0\\n\", \"10\\n5 9\\n4 8\\n3 7\\n2 6\\n1 5\\n0 4\\n1 3\\n2 2\\n3 1\\n4 0\\n\", \"2\\n0 1\\n1 1\\n\", \"6\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n0 0\\n\", \"10\\n0 9\\n1 8\\n2 7\\n3 6\\n4 5\\n5 4\\n6 3\\n7 2\\n8 1\\n9 0\\n\", \"6\\n3 5\\n2 4\\n1 3\\n0 2\\n1 1\\n2 0\\n\", \"3\\n1 1\\n1 1\\n1 1\\n\", \"4\\n0 0\\n1 1\\n2 2\\n3 3\\n\", \"7\\n0 6\\n1 5\\n2 4\\n3 3\\n4 2\\n5 1\\n6 0\\n\", \"6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"9\\n8 8\\n7 7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"15\\n0 14\\n1 13\\n2 12\\n3 11\\n4 10\\n5 9\\n6 8\\n7 7\\n8 6\\n9 5\\n10 4\\n11 3\\n12 2\\n13 1\\n14 0\\n\", \"5\\n0 3\\n1 3\\n2 3\\n3 3\\n4 3\\n\", \"4\\n0 1\\n0 2\\n0 3\\n0 0\\n\", \"7\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n0 0\\n\", \"6\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n0 0\\n\", \"4\\n0 0\\n1 1\\n2 2\\n0 0\\n\", \"5\\n0 4\\n1 3\\n2 2\\n3 1\\n0 0\\n\", \"7\\n0 6\\n1 5\\n2 4\\n3 3\\n0 0\\n1 1\\n2 2\\n\", \"8\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n\", \"8\\n0 7\\n1 6\\n2 5\\n3 4\\n0 0\\n1 1\\n2 2\\n3 3\\n\", \"10\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8\\n9 9\\n\", \"8\\n0 7\\n1 6\\n2 5\\n3 4\\n4 3\\n5 2\\n6 1\\n7 0\\n\", \"10\\n0 9\\n1 8\\n2 7\\n3 6\\n4 5\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n\", \"2\\n1 1\\n1 1\\n\", \"2\\n0 1\\n0 1\\n\", \"5\\n0 2\\n1 2\\n2 2\\n0 2\\n0 0\\n\", \"7\\n0 0\\n0 2\\n0 2\\n0 4\\n0 4\\n0 4\\n0 6\\n\", \"10\\n0 9\\n0 8\\n0 7\\n0 6\\n0 5\\n1 9\\n1 8\\n1 7\\n1 6\\n1 5\\n\", \"6\\n0 3\\n1 4\\n2 5\\n1 5\\n0 5\\n0 5\\n\", \"4\\n0 3\\n0 3\\n1 2\\n3 3\\n\", \"5\\n0 2\\n1 2\\n2 2\\n3 3\\n4 4\\n\", \"5\\n4 4\\n3 4\\n2 4\\n1 4\\n0 4\\n\", \"14\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8\\n9 9\\n10 10\\n11 11\\n12 12\\n13 13\\n\", \"14\\n13 13\\n12 12\\n11 11\\n10 10\\n9 9\\n8 8\\n7 7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"5\\n0 0\\n0 0\\n1 1\\n1 1\\n2 2\\n\", \"5\\n2 3\\n2 3\\n2 3\\n2 3\\n2 3\\n\", \"6\\n0 5\\n1 4\\n2 3\\n3 2\\n4 1\\n5 0\\n\", \"10\\n9 9\\n8 8\\n7 7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"5\\n0 1\\n1 2\\n2 3\\n3 4\\n4 5\\n\", \"7\\n0 3\\n1 4\\n2 5\\n3 6\\n2 5\\n1 4\\n0 3\\n\", \"5\\n0 2\\n1 3\\n2 4\\n1 2\\n0 1\\n\", \"3\\n0 0\\n0 1\\n1 2\\n\", \"6\\n2 3\\n1 4\\n0 5\\n1 4\\n2 3\\n3 3\\n\", \"10\\n5 9\\n4 8\\n3 7\\n2 5\\n2 4\\n1 3\\n0 2\\n0 1\\n1 1\\n2 2\\n\", \"4\\n0 1\\n1 2\\n2 3\\n3 3\\n\", \"5\\n0 0\\n0 0\\n0 1\\n1 2\\n2 3\\n\", \"7\\n1 1\\n0 6\\n1 5\\n2 5\\n3 5\\n4 6\\n5 6\\n\", \"4\\n0 3\\n1 3\\n2 3\\n3 3\\n\", \"5\\n0 4\\n0 4\\n0 4\\n0 4\\n0 4\\n\", \"2\\n0 1\\n0 0\\n\", \"3\\n0 0\\n1 2\\n2 2\\n\", \"3\\n0 1\\n1 1\\n2 2\\n\", \"4\\n1 1\\n2 2\\n3 3\\n0 0\\n\", \"10\\n0 9\\n1 8\\n2 7\\n3 6\\n4 5\\n4 6\\n3 7\\n2 8\\n1 9\\n0 9\\n\", \"5\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"5\\n0 1\\n0 1\\n0 1\\n0 1\\n0 1\\n\", \"10\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"10\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 1\\n0 1\\n0 1\\n0 0\\n0 0\\n\", \"10\\n0 0\\n0 1\\n0 0\\n0 1\\n0 0\\n0 1\\n0 0\\n0 1\\n0 0\\n0 1\\n\", \"10\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n0 9\\n\", \"10\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n0 7\\n0 8\\n0 9\\n\", \"15\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n0 4\\n0 3\\n0 2\\n0 1\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"5\\n0 0\\n0 1\\n0 2\\n0 4\\n0 4\\n\", \"6\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\", \"4\\n0 1\\n0 0\\n0 3\\n0 0\\n\", \"4\\n0 2\\n0 2\\n2 2\\n2 2\\n\", \"7\\n0 2\\n1 3\\n2 4\\n3 5\\n4 6\\n5 6\\n6 6\\n\", \"6\\n0 2\\n0 2\\n0 2\\n2 2\\n2 2\\n2 2\\n\", \"2\\n0 1\\n1 2\\n\", \"4\\n0 3\\n1 2\\n2 3\\n3 4\\n\", \"9\\n0 9\\n1 8\\n2 7\\n3 6\\n4 4\\n3 3\\n2 2\\n1 1\\n0 0\\n\", \"1\\n0 1\\n\", \"10\\n0 10\\n1 9\\n2 8\\n3 7\\n4 6\\n5 5\\n6 4\\n7 3\\n8 2\\n9 1\\n\", \"12\\n0 11\\n1 9\\n2 7\\n3 5\\n4 3\\n5 1\\n6 1\\n7 3\\n8 5\\n9 6\\n10 8\\n11 11\\n\", \"6\\n0 3\\n1 3\\n2 3\\n3 3\\n4 3\\n5 3\\n\", \"7\\n0 2\\n1 3\\n2 4\\n3 5\\n4 6\\n5 7\\n6 7\\n\", \"11\\n0 10\\n1 9\\n2 8\\n3 7\\n4 6\\n5 5\\n6 4\\n7 3\\n8 2\\n9 1\\n10 0\\n\", \"8\\n0 1\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n7 8\\n\", \"3\\n0 3\\n1 2\\n2 2\\n\", \"4\\n0 2\\n1 2\\n2 2\\n3 2\\n\", \"6\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n0 1\\n\", \"3\\n1 1\\n1 2\\n1 3\\n\", \"8\\n0 1\\n1 2\\n1 4\\n0 4\\n1 2\\n0 1\\n2 3\\n1 1\\n\", \"4\\n0 3\\n0 2\\n0 1\\n0 0\\n\", \"3\\n0 0\\n0 0\\n2 2\\n\", \"4\\n0 0\\n0 0\\n0 0\\n3 3\\n\", \"9\\n0 0\\n0 0\\n0 0\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8\\n\", \"3\\n0 2\\n1 1\\n2 0\\n\"], \"outputs\": [\"2\", \"3\\n\", \"1\\n\", \"3\\n\", \"1\\n\", \"2\", \"2\", \"1\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"2\", \"5\\n\", \"2\", \"3\\n\", \"1\\n\", \"2\", \"3\\n\", \"3\\n\", \"1\\n\", \"2\", \"3\\n\", \"2\", \"1\\n\", \"1\\n\", \"4\\n\", \"2\", \"3\\n\", \"2\", \"2\", \"3\\n\", \"2\", \"1\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"3\\n\", \"2\", \"2\", \"1\\n\", \"1\\n\", \"2\", \"4\\n\", \"1\\n\", \"3\\n\", \"3\\n\", \"3\\n\", \"3\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"3\\n\", \"3\\n\", \"3\\n\", \"4\\n\", \"1\\n\", \"4\\n\", \"3\\n\", \"3\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"1\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"4\\n\", \"2\", \"1\\n\", \"1\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"5\\n\", \"2\", \"2\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"3\\n\", \"1\\n\", \"3\\n\", \"1\\n\", \"3\\n\", \"4\\n\", \"1\\n\", \"2\", \"2\", \"4\\n\", \"5\\n\", \"4\\n\", \"2\", \"2\", \"3\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"1\\n\", \"1\\n\", \"3\\n\", \"2\", \"1\\n\", \"4\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"3\\n\", \"2\", \"5\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"1\\n\", \"4\\n\", \"1\\n\", \"2\", \"1\\n\", \"2\", \"1\\n\", \"10\\n\", \"5\\n\", \"5\\n\", \"3\\n\", \"1\\n\", \"1\\n\", \"2\", \"2\", \"3\\n\", \"1\\n\", \"2\", \"4\\n\", \"1\\n\", \"4\\n\", \"3\\n\", \"2\", \"2\", \"4\\n\", \"1\\n\", \"2\", \"2\", \"4\\n\", \"2\", \"3\\n\", \"2\", \"1\\n\", \"1\\n\", \"1\\n\", \"1\\n\"]}",
    "difficulty": "HARD",
    "raw_tags": "['Algorithms', 'Queues', 'Searching', 'Segment Trees', 'Binary Search', 'Advanced Data Structures', 'Advanced Tree Structures', 'Data Structures']",
    "name": null,
    "source": "codechef",
    "tags": "['Sorting', 'Range queries', 'Segment trees revisited', 'Complete search', 'Data structures']",
    "skill_types": "['Sorting', 'Data structures', 'Range queries', 'Complete search']",
    "url": "https://www.codechef.com/problems/LARSQR31",
    "Expected Auxiliary Space": null,
    "time_limit": "1 - 1.5 seconds",
    "date": "2021-05-19",
    "picture_num": "2",
    "memory_limit": "50000 bytes",
    "Expected Time Complexity": null,
    "human_solution": "from collections import deque\nn = int(input())\nq1 = deque()\nres = 1\n\ndef helper(left1, right1, left2, right2):\n\t(temp1, temp2) = (max(left1, left2), min(right1, right2))\n\tif temp1 > right1 or temp1 > right2 or temp2 < left1 or (temp2 < left2):\n\t\treturn None\n\treturn (temp1, temp2)\nfor i in range(n):\n\t(left, right) = map(int, input().split())\n\tq2 = deque()\n\twhile q1 and (q1[0][0][0] < left or q1[0][0][1] > right):\n\t\ttop = q1.pop()\n\t\t(temp1, temp2) = top[0]\n\t\twidth = top[0][1] - top[0][0] + 1\n\t\theight = i - 1 - top[1] + 1\n\t\tres = max(res, min(width, height))\n\t\tvalues = helper(left, right, temp1, temp2)\n\t\tif eval is not None:\n\t\t\tq2.append((values, top[1]))\n\twhile q2:\n\t\ttop = q2.pop()\n\t\tif top[0][1] - top[0][0] + 1 > res:\n\t\t\tq1.append(top)\n\tif not q1 or not (q1[-1][0][0] == left and q1[-1][0][1] == right):\n\t\tif right - left + 1 > res:\n\t\t\tq1.append(((left, right), i))\nwhile q1:\n\ttop = q1.pop()\n\t(temp1, temp2) = top[0]\n\t(height, width) = (n - top[1], temp2 - temp1 + 1)\n\tres = max(res, min(height, width))\nprint(res)\n",
    "claude_solution": "# Solution: Largest Green Square\n\nThis problem asks us to find the largest square in a garden where all unit squares have plants (are \"green\"). The garden is represented as an N\u00d7N grid, and for each row, we know the range of columns that have plants.\n\n## Approach\n\nThe key insight is to use a dynamic programming approach similar to the \"Maximal Square\" problem. We'll maintain a 2D array `dp` where `dp[i][j]` represents the side length of the largest square ending at position (i, j).\n\nHowever, we need to adapt this approach to handle the specific input format where each row has a continuous range of green squares.\n\n## Implementation\n\n```python\ndef largest_green_square(N, rows):\n    # Create a 2D grid to represent the garden\n    # 1 means green (has plants), 0 means not green\n    grid = [[0] * N for _ in range(N)]\n    \n    # Fill the grid based on the input\n    for i, (a, b) in enumerate(rows):\n        for j in range(a, b + 1):\n            grid[i][j] = 1\n    \n    # Initialize dp array\n    dp = [[0] * N for _ in range(N)]\n    \n    # Initialize the first row and column of dp\n    for i in range(N):\n        dp[i][0] = grid[i][0]\n    for j in range(N):\n        dp[0][j] = grid[0][j]\n    \n    # Fill the dp array\n    for i in range(1, N):\n        for j in range(1, N):\n            if grid[i][j] == 1:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n    \n    # Find the maximum value in dp\n    max_side = 0\n    for i in range(N):\n        for j in range(N):\n            max_side = max(max_side, dp[i][j])\n    \n    return max_side\n\n# Read input\nN = int(input())\nrows = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    rows.append((a, b))\n\n# Solve and print the result\nprint(largest_green_square(N, rows))\n```\n\nHowever, this solution would be too slow for the given constraints (N up to 10^6), as it would require O(N^2) time and space.\n\nLet's optimize it:\n\n```python\ndef largest_green_square(N, rows):\n    # Initialize dp array - dp[i][j] represents the largest square ending at (i, j)\n    dp = [[0] * N for _ in range(N)]\n    \n    # Process the first row\n    a, b = rows[0]\n    for j in range(a, b + 1):\n        dp[0][j] = 1\n    \n    max_side = 1 if b >= a else 0  # Handle the case where the first row has no green squares\n    \n    # Process the remaining rows\n    for i in range(1, N):\n        a, b = rows[i]\n        \n        # Initialize the first column of the current row\n        if a == 0:\n            dp[i][0] = 1\n        \n        # Process the rest of the columns in the current row\n        for j in range(max(1, a), b + 1):\n            if j >= a:  # This position is green\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side\n```\n\nBut even this is still O(N^2) in the worst case. Let's optimize further by recognizing that we only need to process the green squares:\n\n```python\ndef largest_green_square(N, rows):\n    # For each position, we'll compute the largest square ending at that position\n    max_side = 0\n    \n    # We only need to store the previous row of dp values\n    prev_row = [0] * N\n    \n    for i in range(N):\n        a, b = rows[i]\n        curr_row = [0] * N\n        \n        for j in range(a, b + 1):\n            # This position is green\n            if j == 0 or i == 0:\n                curr_row[j] = 1\n            else:\n                curr_row[j] = min(prev_row[j], prev_row[j-1], curr_row[j-1]) + 1\n            \n            max_side = max(max_side, curr_row[j])\n        \n        prev_row = curr_row\n    \n    return max_side\n\n# Read input\nN = int(input())\nrows = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    rows.append((a, b))\n\n# Solve and print the result\nprint(largest_green_square(N, rows))\n```\n\nThis solution is more efficient as it:\n1. Only processes the green squares in each row\n2. Only keeps track of the previous row of dp values, reducing space complexity to O(N)\n\nThe time complexity is O(N^2) in the worst case (if all squares are green), but will be much better in practice when many squares are not green.",
    "problem": "Chef has a garden of size N \\times N. The garden is divided into N^{2} squares of size 1\\times 1 each.\n\nChef has plants in some unit squares of the garden, because of which, that part looks *green*.  \nFormally, for the i^{th} row (0 \u2264 i < N), Chef has plants in all the columns from A_{i} to B_{i}  (both inclusive) where 0 \u2264 A_{i} \u2264 B_{i} < N.\n\nHelp Chef find the length of the side of the largest square that is *green*.\n\n------ Input Format ------ \n\n- The first line contains an integer N, the size of the garden. \n- The next N lines contain two space-separated integers A_{i} and B_{i}, representing that plants are present in all the columns from A_{i} to B_{i} (both inclusive) of the i^{th} row.\n\n------ Output Format ------ \n\nOutput a single integer denoting the length of the side of the largest square that is *green*. In other words, output the length of the side of the square with maximum size, inside which all unit squares have plants.\n\n------ Constraints ------ \n\n$1 \u2264N \u226410^{6}$\n$0 \u2264A_{i} \u2264B_{i} < N$\n\n----- Sample Input 1 ------ \n3\n1 1\n0 2\n1 2\n\n----- Sample Output 1 ------ \n2\n----- explanation 1 ------ \n\n----- Sample Input 2 ------ \n8\n2 4\n2 4\n1 4\n0 7\n0 3\n1 2\n1 2\n1 1\n----- Sample Output 2 ------ \n3\n\n----- explanation 2 ------ \nSample Explanation $1$: The garden looks like:\n\n.png)\n\nThe largest green square has vertices $(1,1), (1,2), (2,2), (2,1)$. Thus, the length of the side of the largest *green* square is $2$.\n\nSample Explanation $2$: The garden looks like:\n\n.png)\n\nOne of the largest green squares has vertices $(0,2), (0,4), (2, 4), (2, 2)$. Thus, the length of the side of the largest *green* square is $3$.  \nThere may be other squares with same size but it can be proven that no square with length more than $3$ is green."
  },
  {
    "solutions": [
      "from bisect import *\ntable = [0, 1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\taa = bisect_left(table, a)\n\tbb = bisect_right(table, b)\n\tprint(bb - aa)\n",
      "from math import sqrt as S, ceil as upar, floor as neeche\n\ndef sahi(n):\n\tif str(n).count('0') + str(n).count('1') + str(n).count('4') + str(n).count('9') == len(str(n)):\n\t\treturn True\n\treturn False\np = 10 ** 5 + 9\npre = [0] * p\nfor i in range(1, p):\n\tcurr = i * i\n\tpre[i] = pre[i - 1] + sahi(curr)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tb = int(S(b))\n\ta = int(S(a - 1))\n\tprint(pre[b] - pre[a])\n",
      "n = int(input())\nx = ['2', '3', '5', '6', '7', '8']\nlm = []\nfor i in range(1, 10 ** 5 + 1):\n\tflag = 0\n\tfor j in x:\n\t\tif j in str(i ** 2):\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag == 0:\n\t\tlm.append(i ** 2)\nfor i in range(n):\n\t(a, b) = map(int, input().split())\n\tc = 0\n\tfor k in lm:\n\t\tif k >= a and k <= b:\n\t\t\tc += 1\n\tprint(c)\n",
      "def is_digit_square(n):\n\twhile n > 0:\n\t\tif n % 10 not in [0, 1, 4, 9]:\n\t\t\treturn False\n\t\tn //= 10\n\treturn True\n\ndef lower_bound(x):\n\tlow = 0\n\thigh = len(digit_squares)\n\twhile low < high:\n\t\tmid = (low + high) // 2\n\t\tif digit_squares[mid] < x:\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid\n\treturn low\ndigit_squares = []\nfor i in range(1, 10 ** 5):\n\tif is_digit_square(i ** 2):\n\t\tdigit_squares.append(i ** 2)\nt = int(input())\nfor _ in range(t):\n\t(a, b) = (int(i) for i in input().split())\n\tlb = lower_bound(a)\n\tub = lower_bound(b + 1)\n\tif ub == len(digit_squares):\n\t\tprint(ub - lb + 1)\n\telse:\n\t\tprint(ub - lb)\n",
      "IN = lambda : int(input())\nl1 = ['1', '0', '4', '9']\n\ndef fk(t):\n\ts = str(t)\n\tfor i in s:\n\t\tif i in l1:\n\t\t\tpass\n\t\telse:\n\t\t\treturn False\n\treturn True\nl = []\nfor i in range(100005):\n\tif fk(i * i):\n\t\tl.append(i * i)\nfor _ in range(IN()):\n\tc = 0\n\t(n, k) = map(int, input().split())\n\tfor j in l:\n\t\tif j >= n and j <= k:\n\t\t\tc += 1\n\tprint(c)\n",
      "a = [str(i * i) for i in range(1, 10 ** 5 + 1)]\ns = ['2', '3', '5', '6', '7', '8']\ng = []\nfor i in a:\n\tf = 0\n\tfor j in s:\n\t\tif j in i:\n\t\t\tf = 1\n\t\t\tbreak\n\tif f == 0:\n\t\tg.append(int(i))\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tprint(len([i for i in g if a <= i <= b]))\n",
      "import bisect\nt = int(input())\ntemp = {1: 1, 4: 2, 9: 3, 49: 4, 100: 5, 144: 6, 400: 7, 441: 8, 900: 9, 1444: 10, 4900: 11, 9409: 12, 10000: 13, 10404: 14, 11449: 15, 14400: 16, 19044: 17, 40000: 18, 40401: 19, 44100: 20, 44944: 21, 90000: 22, 144400: 23, 419904: 24, 490000: 25, 491401: 26, 904401: 27, 940900: 28, 994009: 29, 1000000: 30, 1004004: 31, 1014049: 32, 1040400: 33, 1100401: 34, 1144900: 35, 1440000: 36, 1904400: 37, 1940449: 38, 4000000: 39, 4004001: 40, 4040100: 41, 4410000: 42, 4494400: 43, 9000000: 44, 9909904: 45, 9941409: 46, 11909401: 47, 14010049: 48, 14040009: 49, 14440000: 50, 19909444: 51, 40411449: 52, 41990400: 53, 49000000: 54, 49014001: 55, 49140100: 56, 49999041: 57, 90440100: 58, 94090000: 59, 94109401: 60, 99400900: 61, 99940009: 62, 100000000: 63, 100040004: 64, 100140049: 65, 100400400: 66, 101404900: 67, 101949409: 68, 104040000: 69, 104919049: 70, 110040100: 71, 111049444: 72, 114041041: 73, 114490000: 74, 144000000: 75, 190440000: 76, 194044900: 77, 400000000: 78, 400040001: 79, 400400100: 80, 404010000: 81, 404090404: 82, 409941009: 83, 414000409: 84, 414041104: 85, 441000000: 86, 449440000: 87, 490091044: 88, 900000000: 89, 990990400: 90, 991494144: 91, 994140900: 92, 1190940100: 93, 1401004900: 94, 1404000900: 95, 1409101444: 96, 1444000000: 97, 1449401041: 98, 1490114404: 99, 1990944400: 100, 4014109449: 101, 4019940409: 102, 4041144900: 103, 4199040000: 104, 4900000000: 105, 4900140001: 106, 4901400100: 107, 4914010000: 108, 4914991449: 109, 4941949401: 110, 4999904100: 111, 9044010000: 112, 9409000000: 113, 9409194001: 114, 9410940100: 115, 9900449001: 116, 9940090000: 117, 9994000900: 118, 9999400009: 119, 10000000000: 120}\narr = [1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nfor _ in range(t):\n\t(a, b) = map(int, input().split())\n\tflag1 = 0\n\tflag2 = 0\n\tif a in temp and b in temp:\n\t\tans = temp[b] - temp[a]\n\telif a in temp:\n\t\tlb2 = arr[bisect.bisect_left(arr, b, 0, len(arr)) - 1]\n\t\tans = temp[lb2] - temp[a]\n\telif b in temp:\n\t\tlb1 = arr[bisect.bisect_left(arr, a, 0, len(arr))]\n\t\tans = temp[b] - temp[lb1]\n\telse:\n\t\tlb1 = arr[bisect.bisect_left(arr, a, 0, len(arr))]\n\t\tlb2 = arr[bisect.bisect_left(arr, b, 0, len(arr)) - 1]\n\t\tans = temp[lb2] - temp[lb1]\n\tans += 1\n\tprint(ans)\n",
      "import math\n\ndef verifyPerfectDigit(n):\n\tn = int(n)\n\twhile n > 0:\n\t\tx = int(n % 10)\n\t\tif x != 0 and x != 1 and (x != 4) and (x != 9):\n\t\t\treturn 0\n\t\tn = int(n / 10)\n\treturn 1\n\ndef createArray():\n\tarr = []\n\tfor i in range(1, 100001):\n\t\tif verifyPerfectDigit(i * i) == 1:\n\t\t\tarr.append(i * i)\n\treturn arr\n\ndef main():\n\tt = int(input())\n\tarr = createArray()\n\twhile t:\n\t\tstr = input()\n\t\ta = 0\n\t\tb = 0\n\t\tcount = 0\n\t\t(str1, str2) = str.split(' ')\n\t\tfor i in range(0, len(str1)):\n\t\t\ta = a * 10 + int(str1[i])\n\t\tfor i in range(0, len(str2)):\n\t\t\tb = b * 10 + int(str2[i])\n\t\tfor i in range(0, len(arr)):\n\t\t\tif arr[i] >= a and arr[i] <= b:\n\t\t\t\tcount += 1\n\t\tprint(count)\n\t\tt -= 1\nmain()\n",
      "l = []\ns = {'0', '1', '4', '9'}\nfor i in range(0, 100001):\n\tans = i * i\n\tif set(str(ans)).issubset(s):\n\t\tl.append(ans)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tn = len(l)\n\ts = 0\n\tfor i in l:\n\t\tif a <= i <= b:\n\t\t\ts += 1\n\tprint(s)\n",
      "t = int(input())\nans = []\nfor j in range(10 ** 5 + 1):\n\tflag = 0\n\tnum = str(j * j)\n\tfor i in range(len(num)):\n\t\tif num[i] != '0' and num[i] != '1' and (num[i] != '4') and (num[i] != '9'):\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag == 0:\n\t\tans.append(j * j)\nfor I in range(t):\n\t(a, b) = [int(i) for i in input().split()]\n\tcount = 0\n\tfor i in range(len(ans)):\n\t\tif ans[i] >= a and ans[i] <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "import math\nn = 10 ** 10\narr = []\nfor i in range(1, 1 + int(math.ceil(math.sqrt(n)))):\n\ts = str(i * i)\n\tflag = True\n\tif '2' in s or '3' in s or '5' in s or ('6' in s) or ('7' in s) or ('8' in s):\n\t\tflag = False\n\tif flag:\n\t\tarr.append(int(s))\nt = int(input())\nwhile t:\n\tt -= 1\n\t(a, b) = map(int, input().split())\n\tc = 0\n\tfor i in arr:\n\t\tif i >= a and i <= b:\n\t\t\tc += 1\n\tprint(c)\n",
      "from math import *\ncount = []\nfor i in range(10 ** 5 + 5):\n\tq = 0\n\tfor j in str(i ** 2):\n\t\tif j not in ['0', '1', '4', '9']:\n\t\t\tq = 1\n\t\t\tbreak\n\tif q == 0:\n\t\tcount.append(i ** 2)\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tc = 0\n\tfor i in count:\n\t\tif i >= n and i <= m:\n\t\t\tc += 1\n\t\telif i > m:\n\t\t\tbreak\n\tprint(c)\n",
      "n = 0\narr = []\nwhile n * n <= 10000000000:\n\tz = n * n\n\tflag = 0\n\twhile z > 0:\n\t\tk = int(z % 10)\n\t\tif k != 0 and k != 1 and (k != 4) and (k != 9):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tz //= 10\n\tif flag == 0:\n\t\tarr.append(n * n)\n\tn += 1\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tcount = 0\n\tfor i in range(len(arr)):\n\t\tif a <= arr[i] <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "import math\nimport sys\n\ndef _int():\n\treturn int(sys.stdin.readline())\n\ndef _ints():\n\treturn map(int, sys.stdin.readline().split())\n\ndef _intarr():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef _str():\n\treturn sys.stdin.readline()\n\ndef _strarr():\n\treturn sys.stdin.readline().split()\n\ndef is_perfect(n):\n\tperfect = True\n\twhile n != 0:\n\t\tr = n % 10\n\t\tif r not in [0, 1, 4, 9]:\n\t\t\tperfect = False\n\t\t\tbreak\n\t\tn = n // 10\n\treturn perfect\nmem = [0] * 100001\nc = 0\nfor i in range(1, len(mem)):\n\tif is_perfect(i * i):\n\t\tc += 1\n\tmem[i] = c\nt = _int()\nfor _ in range(t):\n\t(a, b) = _ints()\n\tra = int(math.ceil(math.sqrt(a)))\n\trb = int(math.floor(math.sqrt(b)))\n\tprint(mem[rb] - mem[ra - 1])\n",
      "try:\n\tt = int(input())\n\tl = ['0', '1', '4', '9']\n\tm = []\n\tc = 0\n\ts = 0\n\tj = 0\n\twhile j <= 1000002:\n\t\ts = str(j * j)\n\t\tfor k in s:\n\t\t\tif k not in l:\n\t\t\t\tc = 0\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tc = 1\n\t\tif c == 1:\n\t\t\tm.append(s)\n\t\tj = j + 1\n\tfor _ in range(t):\n\t\tcount = 0\n\t\t(a, b) = map(int, input().split())\n\t\tfor i in m:\n\t\t\tif int(i) >= a and int(i) <= b:\n\t\t\t\tcount += 1\n\t\tprint(count)\nexcept:\n\tpass\n",
      "import math\n\ndef fun(n):\n\tl = ['0', '1', '4', '9']\n\ts = str(n)\n\tfor k in range(len(s)):\n\t\tif s[k] not in l:\n\t\t\treturn False\n\treturn True\nl1 = []\nfor i in range(1000000):\n\tif fun(i ** 2) == True:\n\t\tl1.append(i ** 2)\nfor it in range(int(input())):\n\tcount = 0\n\tlst = list(map(int, input().split()))\n\ta = lst[0]\n\tb = lst[1]\n\tfor j in l1:\n\t\tif j >= a and j <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "noOfTestCases = int(input())\nresult = [0, 1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nwhile noOfTestCases != 0:\n\t(lower, upper) = list(map(int, input().split()))\n\tres = 0\n\tfor i in result:\n\t\tif i >= lower and i <= upper:\n\t\t\tres += 1\n\t\telif i > upper:\n\t\t\tbreak\n\tprint(res)\n\tnoOfTestCases -= 1\n",
      "t = int(input())\nl = ['2', '3', '5', '6', '7', '8']\nk = []\nfor j in range(1, 10 ** 5 + 1):\n\tflag = 0\n\tfor c in l:\n\t\tif c in str(j ** 2):\n\t\t\tflag = 1\n\t\t\tbreak\n\tif flag == 0:\n\t\tk.append(j ** 2)\nfor i in range(t):\n\t(a, b) = list(map(int, input().split()))\n\tcount = 0\n\tfor m in k:\n\t\tif a <= m <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "import math\nimport collections\nlst = ['0', '1', '4', '9']\nfor i in range(4, 100001):\n\tn = str(i * i)\n\tl = len(n)\n\td = collections.Counter(n)\n\tk = d['0'] + d['1'] + d['4'] + d['9']\n\tif k == l:\n\t\tlst.append(n)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tcount = 0\n\tfor num in lst:\n\t\tif int(num) >= a and int(num) <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "def check(n):\n\tfor j in str(n):\n\t\tif j not in ['1', '0', '4', '9']:\n\t\t\treturn False\n\treturn True\nt = int(input())\nmaxi = 100001\nsq = []\nfor i in range(maxi):\n\ts = i * i\n\tif check(s):\n\t\tsq.append(s)\nfor _ in range(t):\n\t(l, u) = map(int, input().split())\n\tcount = 0\n\tfor i in sq:\n\t\tif l <= i and i <= u:\n\t\t\tcount += 1\n\tprint(count)\n",
      "def main():\n\timport math\n\tT = int(input())\n\toutput = list()\n\tsquaredigits = {'0', '1', '4', '9'}\n\tsqrt_beginning = 1\n\tsqrt_end = math.ceil(math.sqrt(10000000000))\n\tx = 0\n\tcounter = 0\n\tlistcounter = list()\n\twhile x <= sqrt_end:\n\t\tsquare = x * x\n\t\tstring_square = str(square)\n\t\tflag = -1\n\t\tfor digit in string_square:\n\t\t\tif digit not in squaredigits:\n\t\t\t\tflag = 0\n\t\t\t\tbreak\n\t\tif flag == -1:\n\t\t\tcounter = counter + 1\n\t\tlistcounter.append(counter)\n\t\tx = x + 1\n\tfor i in range(0, T):\n\t\tline = input()\n\t\tlinelist = line.split()\n\t\ta = int(linelist[0])\n\t\tb = int(linelist[1])\n\t\tsqrt_a = math.ceil(math.sqrt(a))\n\t\tsqrt_b = math.ceil(math.sqrt(b))\n\t\toutput.append(listcounter[sqrt_b] - listcounter[sqrt_a - 1])\n\tfor x in output:\n\t\tprint(x)\nmain()\n",
      "import math\nans = [0] * 100001\nfor i in range(1, 100001):\n\ts = str(i ** 2)\n\tans[i] = ans[i - 1]\n\tfor j in s:\n\t\tif j not in {'0', '1', '4', '9'}:\n\t\t\tbreak\n\telse:\n\t\tans[i] += 1\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\t(a, b) = (math.ceil(a ** 0.5), math.floor(b ** 0.5))\n\tprint(ans[b] - ans[a - 1])\n",
      "from math import sqrt\nlst = []\n\ndef perfectsquarelst():\n\taa = 1\n\tbb = 100000\n\tfor i in range(aa, bb + 1):\n\t\tnum = str(i * i)\n\t\tperfect = True\n\t\tfor d in num:\n\t\t\tif d in ['2', '3', '5', '6', '7', '8']:\n\t\t\t\tperfect = False\n\t\tif perfect:\n\t\t\tlst.append(i * i)\nT = int(input())\nperfectsquarelst()\nwhile T > 0:\n\tT -= 1\n\tcount = 0\n\t(a, b) = map(int, input().split(' '))\n\tfor k in lst:\n\t\tif k >= a and k <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "import bisect\n\ndef is_digit_square(n):\n\twhile n > 0:\n\t\tif n % 10 not in [0, 1, 4, 9]:\n\t\t\treturn False\n\t\tn //= 10\n\treturn True\ndigit_squares = []\nfor i in range(1, 10 ** 5):\n\tif is_digit_square(i ** 2):\n\t\tdigit_squares.append(i ** 2)\nt = int(input())\nfor _ in range(t):\n\t(a, b) = (int(i) for i in input().split())\n\tlower_bound = bisect.bisect_left(digit_squares, a)\n\tupper_bound = bisect.bisect_right(digit_squares, b)\n\tif upper_bound == len(digit_squares):\n\t\tprint(upper_bound - lower_bound + 1)\n\telse:\n\t\tprint(upper_bound - lower_bound)\n",
      "def lower_bound(aux, x):\n\tl = 0\n\tr = len(aux) - 1\n\twhile l < r:\n\t\tmid = l + (r - l) // 2\n\t\tif aux[mid] >= x:\n\t\t\tr = mid\n\t\telse:\n\t\t\tl = mid + 1\n\treturn l\naux = []\nfor i in range(1, 100000 + 1):\n\tt = str(i * i)\n\tif t.count('0') + t.count('1') + t.count('4') + t.count('9') == len(t):\n\t\taux.append(int(t))\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tans = lower_bound(aux, b) - 1 - lower_bound(aux, a) + 1\n\tif b in aux:\n\t\tans += 1\n\tprint(ans)\n",
      "import math\nl = []\nfor i in range(1, 100001):\n\tm = i * i\n\ttemp = 1\n\twhile m:\n\t\tif m % 10 != 0 and m % 10 != 1 and (m % 10 != 4) and (m % 10 != 9):\n\t\t\ttemp = 0\n\t\t\tbreak\n\t\tm = m // 10\n\tif temp == 1:\n\t\tl.append(i)\nfor i in range(int(input())):\n\t(a, b) = map(int, input().split())\n\ts = 0\n\ta1 = math.ceil(a ** 0.5)\n\tb1 = int(b ** 0.5)\n\tm = 0\n\tn = -1\n\tfor j in range(len(l)):\n\t\tif l[j] <= b1:\n\t\t\tm = j\n\t\tif l[j] < a1:\n\t\t\tn = j\n\tprint(m - n)\n",
      "import math\nt = int(input())\nl = [0] * 1000001\nfor i in range(1, 1000001):\n\tx = str(i * i)\n\tif x.count('1') + x.count('0') + x.count('4') + x.count('9') == len(x):\n\t\tl[i] = l[i - 1] + 1\n\telse:\n\t\tl[i] = l[i - 1]\nfor i in range(t):\n\t(a, b) = map(int, input().split())\n\t(a, b) = (math.ceil(pow(a, 0.5)), math.ceil(pow(b, 0.5)))\n\tprint(l[b] - l[a - 1])\n",
      "n = 10 ** 5 + 1\nl = []\nfor i in range(1, n):\n\tx = i ** 2\n\ts = str(x)\n\tq = 0\n\tfor j in s:\n\t\tif j != '0' and j != '1' and (j != '4') and (j != '9'):\n\t\t\tq = 1\n\t\t\tbreak\n\tif q == 0:\n\t\tl.append(x)\nt = int(input())\nwhile t > 0:\n\t(a, b) = map(int, input().split())\n\tx = y = 0\n\tfor i in range(120):\n\t\tif l[i] >= b:\n\t\t\tx = i\n\t\t\tbreak\n\tif l[i] > b:\n\t\tx -= 1\n\tfor j in range(120):\n\t\tif l[j] >= a:\n\t\t\ty = j\n\t\t\tbreak\n\tprint(x - y + 1)\n\tt -= 1\n",
      "from math import ceil, floor, sqrt\n\ndef solve(n):\n\tx = [0, 1, 4, 9]\n\twhile n != 0:\n\t\tif n % 10 in x:\n\t\t\tn //= 10\n\t\telse:\n\t\t\treturn 0\n\treturn 1\nans = [0] * 100001\nfor i in range(1, 100001):\n\tans[i] = solve(i * i)\nfor i in range(1, 100001):\n\tans[i] += ans[i - 1]\nt = int(input())\nfor _ in range(t):\n\t(l, r) = map(int, input().split())\n\tl = ceil(sqrt(l))\n\tr = floor(sqrt(r))\n\tprint(ans[r] - ans[l - 1])\n",
      "t = int(input())\nlst = []\nj = 0\nwhile j * j <= 10000000000:\n\tz = j * j\n\tflag = 0\n\twhile z > 0:\n\t\tk = int(z % 10)\n\t\tif k != 0 and k != 1 and (k != 4) and (k != 9):\n\t\t\tflag = 1\n\t\t\tbreak\n\t\tz = z / 10\n\tif flag == 0:\n\t\tlst.append(j * j)\n\tj = j + 1\nwhile t > 0:\n\tt -= 1\n\t(a, b) = map(int, input().split())\n\tcount = 0\n\tfor i in range(len(lst)):\n\t\tif lst[i] >= a and lst[i] <= b:\n\t\t\tcount += 1\n\tprint(count)\n",
      "from sys import stdin\nawsSquares = [1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nT = int(stdin.readline().strip())\nwhile T > 0:\n\t[l, r] = [int(n) for n in stdin.readline().strip().split()]\n\tlow = 0\n\thigh = len(awsSquares) - 1\n\twhile low < high:\n\t\tmid = int((low + high) / 2)\n\t\tif awsSquares[mid] < l:\n\t\t\tlow = mid + 1\n\t\telse:\n\t\t\thigh = mid\n\tstart = low\n\tlow = 0\n\thigh = len(awsSquares) - 1\n\twhile low < high:\n\t\tmid = int((low + high + 1) / 2)\n\t\tif awsSquares[mid] > r:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid\n\tend = low\n\tif start <= end:\n\t\tprint(end - start + 1)\n\telse:\n\t\tprint('0')\n\tT -= 1\n",
      "def check(i):\n\ts = str(i)\n\tfor x in s:\n\t\tif x == '1' or x == '0' or x == '4' or (x == '9'):\n\t\t\tpass\n\t\telse:\n\t\t\treturn False\n\treturn True\nprecompute = list()\nfor i in range(100002):\n\tif check(i ** 2):\n\t\tprecompute.append(i ** 2)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tcnt = 0\n\tfor x in precompute:\n\t\tif x >= a and x <= b:\n\t\t\tcnt += 1\n\tprint(cnt)\n",
      "op = [0]\ncount = 0\nfor j in range(1, 100001):\n\tz = str(j * j)\n\tif len(z) == z.count('0') + z.count('1') + z.count('4') + z.count('9'):\n\t\tcount += 1\n\top.append(count)\nt = int(input())\nfor i in range(0, t):\n\t(a, b) = input().strip().split()\n\ta = int(a)\n\tb = int(b)\n\tif pow(a, 1 / 2) == int(pow(a, 1 / 2)):\n\t\ta = int(pow(a, 1 / 2))\n\telse:\n\t\ta = int(pow(a, 1 / 2)) + 1\n\tb = int(pow(b, 1 / 2))\n\tprint(op[b] - op[a - 1])\n",
      "perfect_sqaures = []\nperfect_nums = {'0', '1', '4', '9'}\n\ndef is_perfect_square(num):\n\tnum = set(str(num))\n\tif len(num - perfect_nums) == 0:\n\t\treturn True\n\treturn False\nfor i in range(10 ** 5 + 1):\n\tnum = i * i\n\tif is_perfect_square(num):\n\t\tperfect_sqaures.append(num)\nperfect_sqaures_len = len(perfect_sqaures)\n\ndef find_perfect_squares_count(num):\n\tstart = 0\n\tend = perfect_sqaures_len - 1\n\twhile start <= end:\n\t\tmiddle = (start + end) // 2\n\t\tif perfect_sqaures[middle] == num or (perfect_sqaures[middle] < num and (middle + 1 == perfect_sqaures_len or perfect_sqaures[middle + 1] > num)):\n\t\t\treturn middle + 1\n\t\telif perfect_sqaures[middle] < num:\n\t\t\tstart = middle + 1\n\t\telse:\n\t\t\tend = middle - 1\nimport math\ntests = int(input())\nfor i in range(tests):\n\t(a, b) = map(int, input().split())\n\tremove = find_perfect_squares_count(a - 1)\n\ttotal = find_perfect_squares_count(b)\n\tprint(total - remove)\n",
      "perf = []\n\ndef findvalid():\n\tfor i in range(1, 10 ** 5 + 1):\n\t\tsquare = i ** 2\n\t\ts = set(str(square))\n\t\tfor digit in s:\n\t\t\tif digit == '1' or digit == '0' or digit == '4' or (digit == '9'):\n\t\t\t\tcool = True\n\t\t\telse:\n\t\t\t\tcool = False\n\t\t\t\tbreak\n\t\tif cool:\n\t\t\tperf.append(square)\nfindvalid()\nfrom bisect import bisect_left as bl\nfor i in range(int(input())):\n\tallowed = [0, 1, 4, 9]\n\t(a, b) = [int(x) for x in input().split()]\n\tleft = bl(perf, a)\n\tright = bl(perf, b)\n\tif perf[right] == b:\n\t\tright += 1\n\tprint(right - left)\n",
      "from bisect import bisect_left, bisect_right\n\ndef prfsqr(a, b):\n\tsqr = []\n\tchk = [0, 1, 4, 9]\n\tfor i in range(a, b, 1):\n\t\tk = i ** 2\n\t\tif k <= b:\n\t\t\tprf = True\n\t\t\tk = str(k)\n\t\t\tfor j in k:\n\t\t\t\tif int(j) not in chk:\n\t\t\t\t\tprf = False\n\t\t\t\t\tbreak\n\t\t\tif prf:\n\t\t\t\tsqr.append(int(k))\n\t\telse:\n\t\t\tbreak\n\treturn sqr\nsqr = prfsqr(1, 10 ** 10)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tleftind = bisect_left(sqr, a)\n\trightind = bisect_right(sqr, b)\n\tprint(rightind - leftind)\n",
      "import os\nimport math\n\ndef checknum(num):\n\twhile num > 0:\n\t\ttemp = num % 10\n\t\tif temp != 1 and temp != 4 and (temp != 9) and (temp != 0):\n\t\t\treturn 0\n\t\tnum = num // 10\n\treturn 1\nt = int(input())\navalues = []\nbvalues = []\nfor i in range(t):\n\t(a, b) = input().strip().split()\n\ta = int(a)\n\tb = int(b)\n\tavalues.append(a)\n\tbvalues.append(b)\namin = min(avalues)\nbmax = max(bvalues)\nsquares = []\nbegin = math.ceil(math.sqrt(amin))\nend = math.floor(math.sqrt(bmax))\nfor j in range(begin, end + 1):\n\tnum = j * j\n\tif checknum(num) == 1:\n\t\tsquares.append(num)\nfor i in range(t):\n\tcount = 0\n\tfor j in range(len(squares)):\n\t\tif squares[j] >= avalues[i]:\n\t\t\tm = j\n\t\t\twhile m < len(squares) and squares[m] <= bvalues[i]:\n\t\t\t\tcount += 1\n\t\t\t\tm += 1\n\t\t\tbreak\n\tprint(count)\n",
      "import sys\nimport math\nfrom time import time\nfrom itertools import permutations, combinations\nimport collections\nimport functools\nfrom fractions import gcd, Fraction\nimport string\nimport operator\nimport bisect\n\nclass timed(object):\n\n\tdef __init__(self, func):\n\t\tself.func = func\n\n\tdef __call__(self, *args):\n\t\tt1 = time()\n\t\tret = self.func(*args)\n\t\tdif_time = time() - t1\n\t\tprint('%s: returned %s in %f seconds' % (self.func.__name__, ret, dif_time))\n\t\treturn ret\n\ndef comp(f1, f2, *args):\n\tt1 = time()\n\tr1 = f1(*args) if f1 is not None else None\n\tt2 = time()\n\tr2 = f2(*args) if f2 is not None else None\n\tt3 = time()\n\tres = '%5s: %s in %f\\n%5s: %s in %f' % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)\n\tif r1 != r2:\n\t\tdr = '!! DIFFERENT RESULTS !!'\n\t\tres = dr + '\\n' + res + '\\n' + dr\n\tprint(res)\n\ndef alg(start, end):\n\troot_start = int(math.sqrt(start))\n\troot_end = int(math.sqrt(end))\n\tcount = 0\n\tfor root in range(root_start, root_end + 1):\n\t\tsq = root * root\n\t\tif all([int(a) in [0, 1, 4, 9] for a in str(sq)]):\n\t\t\tcount += 1\n\treturn count\n\ndef alg2(start, end):\n\tperfect_squares = [1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\n\tres = filter(lambda x: start <= x and end >= x, perfect_squares)\n\treturn len(list(res))\n\ndef main():\n\tdata = sys.stdin\n\tnb = int(data.readline())\n\tfor icase in range(nb):\n\t\t(start, end) = map(int, data.readline().split())\n\t\tres = alg2(start, end)\n\t\tprint(res)\nmain()\n",
      "def fun(argc):\n\tfor i in range(4, 100001):\n\t\tk = i * i\n\t\ts = str(k)\n\t\tflag = True\n\t\tfor j in range(len(s)):\n\t\t\tif s[j] in argc:\n\t\t\t\tpass\n\t\t\telse:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\t\tif flag == True:\n\t\t\targc.append(s)\nt = int(input())\nlst = ['0', '1', '4', '9']\nfun(lst)\nfor i in range(t):\n\t(n, m) = map(int, input().split())\n\tflag1 = True\n\tflag2 = True\n\tj = 0\n\tk = 0\n\tfor i in range(len(lst)):\n\t\tif flag1 == False and flag2 == False:\n\t\t\tbreak\n\t\tif int(lst[i]) >= n and flag1 == True:\n\t\t\tj = i\n\t\t\tflag1 = False\n\t\tif int(lst[i]) >= m and flag2 == True:\n\t\t\tif int(lst[i]) == m:\n\t\t\t\tk = i\n\t\t\telse:\n\t\t\t\tk = i - 1\n\t\t\tflag2 = False\n\tprint(k - j + 1)\n",
      "def lucky_check(n):\n\tfor i in range(len(n)):\n\t\tif n[i] not in '1049':\n\t\t\treturn False\n\treturn True\narray = []\nfor i in range(1, 100001):\n\tif lucky_check(str(i * i)):\n\t\tarray.append(i * i)\nfinal = []\nfor i in range(len(array) - 1):\n\tfinal.append([array[i], array[i + 1] - 1])\n\ndef find(a):\n\tif a == 10000000000:\n\t\treturn 120\n\telif a == 0:\n\t\treturn 0\n\telse:\n\t\ti = 0\n\t\tfound = False\n\t\twhile not found:\n\t\t\tp = final[i]\n\t\t\tif a <= p[1] and a >= p[0]:\n\t\t\t\tfound = True\n\t\t\ti += 1\n\t\treturn i\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tprint(find(b) - find(a - 1))\n",
      "import math\npower_list = []\nfor i in range(1, 100001):\n\tcurr = i * i\n\tis_valid = True\n\twhile curr:\n\t\tif curr % 10 in [0, 1, 4, 9]:\n\t\t\tcurr //= 10\n\t\telse:\n\t\t\tis_valid = False\n\t\t\tbreak\n\tif is_valid:\n\t\tpower_list.append(i)\nfor _ in range(int(input())):\n\t(left, rite) = [int(x) for x in input().split()]\n\tcnts = 0\n\tleft = math.ceil(left ** 0.5)\n\trite = int(rite ** 0.5)\n\tm = 0\n\tn = -1\n\tfor j in range(len(power_list)):\n\t\tif power_list[j] <= rite:\n\t\t\tm = j\n\t\tif power_list[j] < left:\n\t\t\tn = j\n\tprint(m - n)\n",
      "import os, sys, io, math\nfrom array import *\nfrom math import *\nfrom bisect import *\nfrom heapq import *\nfrom functools import *\nfrom itertools import *\nfrom collections import *\nI = lambda : [*map(int, sys.stdin.readline().split())]\nIS = lambda : input()\nIN = lambda : int(input())\nIF = lambda : float(input())\nl = ['1', '0', '4', '9']\n\ndef f(t):\n\ts = str(t)\n\tfor i in s:\n\t\tif i in l:\n\t\t\tpass\n\t\telse:\n\t\t\treturn False\n\treturn True\nr = []\nfor i in range(100002):\n\tif f(i * i):\n\t\tr.append(i * i)\nfor _ in range(IN()):\n\t(a, b) = map(int, input().split())\n\tc = 0\n\tfor i in r:\n\t\tif i >= a and i <= b:\n\t\t\tc += 1\n\tprint(c)\n",
      "l = []\nl1 = ['0', '1', '4', '9']\nfor i in range(1, 100001):\n\ts = str(i * i)\n\tif any((j not in l1 for j in s)):\n\t\tc = 1\n\telse:\n\t\tl.append(i * i)\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\tans = 0\n\tfor i in l:\n\t\tif i >= a and i <= b:\n\t\t\tans += 1\n\tprint(ans)\n",
      "maximum = int(10000000000 ** 0.5)\nperfect = {'0', '1', '4', '9'}\npn = []\nfor i in range(1, maximum + 1):\n\tif set(str(i * i)).union(perfect) == perfect:\n\t\tpn.append(i * i)\nt = int(input())\nfor u in range(t):\n\t(a, b) = map(int, input().split())\n\tcount = 0\n\tfor i in range(len(pn)):\n\t\tif pn[i] > b:\n\t\t\tbreak\n\t\telif pn[i] >= a:\n\t\t\tcount += 1\n\tprint(count)\n\tprint()\n",
      "import bisect\n\ndef perfect_digit(n):\n\tar = [2, 3, 5, 6, 7, 8]\n\twhile n > 0:\n\t\tif n % 10 in ar:\n\t\t\treturn False\n\t\tn //= 10\n\treturn True\nar = []\nfor i in range(1, 10 ** 5 + 1):\n\tcur = i * i\n\tif perfect_digit(cur):\n\t\tar.append(cur)\nfor _ in range(int(input())):\n\t(x, y) = map(int, input().split())\n\t(right, left) = (bisect.bisect_left(ar, y), bisect.bisect_left(ar, x))\n\tif ar[right] > y:\n\t\tright -= 1\n\tif ar[left] < x:\n\t\tleft += 1\n\tprint(right - left + 1)\n",
      "t = int(input())\narr = []\nfor i in range(10 ** 5 + 5):\n\tte = str(i * i)\n\tst = 0\n\tfor j in range(len(te)):\n\t\tif te[j] != '1' and te[j] != '4' and (te[j] != '9') and (te[j] != '0'):\n\t\t\tst = 1\n\t\t\tbreak\n\tif st == 0:\n\t\tarr.append(i * i)\nlength = len(arr)\nwhile t:\n\tt -= 1\n\t(a, b) = map(int, input().split())\n\tans = 0\n\tfor i in range(length):\n\t\tif arr[i] >= a and arr[i] <= b:\n\t\t\tans += 1\n\tprint(ans)\n",
      "def consists_of_perfect_digits(number):\n\twhile number != 0:\n\t\tdigit = number % 10\n\t\tif digit not in [0, 1, 4, 9]:\n\t\t\treturn False\n\t\tnumber //= 10\n\treturn True\n\ndef count_perfect_squares(perfect_digits, a, b):\n\tnum_perf_sq = 0\n\ti = 0\n\twhile i < len(perfect_digits) and perfect_digits[i] <= b:\n\t\tif perfect_squares[i] >= a and perfect_squares[i] <= b:\n\t\t\tnum_perf_sq += 1\n\t\ti += 1\n\treturn num_perf_sq\nperfect_squares = []\nfor i in range(100000 + 1):\n\tperf_sq = i * i\n\tif consists_of_perfect_digits(perf_sq):\n\t\tperfect_squares.append(perf_sq)\nT = int(input())\nfor t in range(T):\n\t(a, b) = map(int, input().split())\n\tprint(count_perfect_squares(perfect_squares, a, b))\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"2\\n1 10\\n100 10000\", \"3\\n1 4\\n4 9\\n9 16\\n\", \"2\\n1 100\\n1 10000\\n\", \"2\\n1 1000000000\\n1 10000000000\\n\", \"2\\n1 25\\n25 100\", \"1\\n81 81\\n\", \"3\\n81 100\\n1 16\\n16 4\\n\", \"1\\n1000 10000\", \"1\\n10000 100000\", \"1\\n16 16\", \"1\\n81 100\", \"1\\n1 9\\n\", \"2\\n1 16\\n4 81\\n\", \"3\\n1 4\\n16 256\\n81 6561\\n\", \"1\\n16 256\\n\", \"1\\n256 6561\\n\", \"1\\n4 9\\n\", \"1\\n36 49\\n\", \"2\\n4 9\\n81 100\\n\", \"4\\n1 16\\n16 256\\n256 6561\\n6561 100000000\\n\", \"2\\n1 4\\n16 81\\n\", \"1\\n64 81\\n\", \"2\\n9 81\\n4 16\\n\", \"3\\n1 10\\n100 1000\\n5000 6000\", \"5\\n10000 20000\\n30000 40000\\n50000 60000\\n70000 80000\\n90000 100000\", \"2\\n10000000 20000000\\n30000000 40000000\", \"5\\n100 500\\n1000 5000\\n10000 50000\\n100000 500000\\n1000000 5000000\", \"3\\n1 5\\n10 15\\n20 25\", \"2\\n1000000000 2000000000\\n3000000000 4000000000\", \"5\\n10 20\\n30 40\\n50 60\\n70 80\\n90 100\", \"2\\n5000000000 10000000000\\n1 5000000000\", \"1\\n1 100\", \"1\\n1 10000\", \"3\\n1 10\\n100 10000\\n500 1000\", \"2\\n50 60\\n70 80\", \"2\\n90 100\\n110 200\", \"2\\n210 300\\n310 400\", \"2\\n410 500\\n500 600\", \"2\\n610 700\\n710 800\", \"2\\n810 900\\n1000 2000\", \"2\\n3000 4000\\n5000 6000\", \"2\\n7000 8000\\n9000 10000\", \"1\\n10000 20000\", \"1\\n30000 40000\", \"1\\n50000 60000\", \"1\\n70000 80000\", \"1\\n90000 100000\", \"1\\n100 200\", \"1\\n300 400\", \"1\\n500 600\", \"1\\n700 800\", \"1\\n900 1000\", \"1\\n1 1\", \"3\\n5 10\\n20 30\\n15 25\", \"5\\n10000 20000\\n500000 600000\\n700000 800000\\n900000 1000000\\n1 100\", \"1\\n1000000000 10000000000\", \"2\\n1 9\\n100 200\", \"5\\n1 10000\\n100000 200000\\n300000 400000\\n500000 600000\\n700000 800000\", \"3\\n1 100\\n10000000 20000000\\n500 1000\", \"5\\n5000000 6000000\\n7000000 8000000\\n9000000 10000000\\n1 20\\n100000000 200000000\", \"5\\n1 10\\n10 100\\n100 1000\\n1000 10000\\n10000 100000\", \"2\\n112 78788\\n87687 8977\", \"1\\n54745 904570\", \"3\\n12342 43322\\n94832 6734723\\n337732 989898\", \"4\\n0 10\\n10 100\\n100 1000\\n1000 10000\", \"3\\n576 900\\n400 900\\n100 400\", \"4\\n500 10000\\n400 8000\\n3000 9000\\n1345 2345\", \"5\\n111111 999999\\n123321 547880\\n1234567890 9999999999\\n777 888\\n999999999 10000000000\", \"2\\n1 10\\n100 10000\\n\", \"1\\n1 10000000000\\n\", \"3\\n1 1000\\n1 10000\\n1 1000000\\n\", \"2\\n50 500\\n100000 1000000\\n\", \"1\\n123456789 9876543210\\n\", \"4\\n10000 20000\\n1234567 2345678\\n4567890 5678901\\n7890123 8901234\\n\", \"1\\n1000 10000\\n\", \"2\\n1 5\\n6 10\\n\", \"5\\n10 15\\n20 25\\n30 35\\n40 45\\n50 55\\n\", \"2\\n99 999\\n999 9999\\n\", \"1\\n1 10\\n\", \"5\\n1 50\\n100 200\\n500 1000\\n1 5000\\n50000 100000\\n\", \"3\\n100 200\\n500 1000\\n10000 50000\\n\", \"4\\n1 1\\n2 2\\n3 3\\n4 4\\n\", \"3\\n1 100000000\\n10 100000000\\n100 100000000\\n\", \"2\\n10000000 50000000\\n50000000 100000000\\n\", \"3\\n1 100\\n2 200\\n3 300\\n\", \"4\\n1 4000\\n2 5000\\n3 6000\\n4 7000\\n\", \"5\\n1 10\\n2 20\\n3 30\\n4 40\\n5 50\\n\", \"1\\n1 500\\n\", \"2\\n1 10000\\n10 100000\\n\", \"1\\n1111 222222\\n\", \"1\\n4 49\\n\", \"1\\n100000000 10000000000\\n\", \"1\\n10000000000 100000000000\\n\", \"5\\n1 10\\n1 100\\n1 1000\\n1 10000\\n1 100000\\n\", \"2\\n50 100\\n200 500\\n\", \"3\\n1 10\\n100 1000\\n10000 100000\\n\", \"2\\n1 49\\n100 10000\\n\", \"1\\n123456 123456789\\n\", \"3\\n1 49\\n49 10000\\n10000 10000000\\n\", \"1\\n9999999999 10000000000\\n\", \"1\\n1000000 10000000\\n\", \"5\\n10 100\\n100 1000\\n1000 10000\\n10000 100000\\n100000 1000000\\n\", \"10\\n1 10\\n10 100\\n100 1000\\n1000 10000\\n10000 100000\\n100000 1000000\\n1000000 10000000\\n10000000 100000000\\n100000000 1000000000\\n1000000000 10000000000\\n\", \"2\\n1 10\\n100 10000\", \"4\\n1 15\\n20 30\\n100 500\\n5000 50000\", \"3\\n45 200\\n300 5000\\n6000 100000\", \"5\\n1 25\\n35 50\\n100 1000\\n1200 3000\\n4000 50000\", \"3\\n1 50\\n50 250\\n500 5000\", \"1\\n1 500\", \"2\\n500 1000\\n1200 5000\", \"4\\n2 200\\n300 1000\\n1500 5000\\n6000 100000\", \"3\\n4 25\\n35 50\\n500 750\", \"1\\n1 750\", \"5\\n1 50\\n70 150\\n200 1000\\n1200 3000\\n4000 50000\", \"3\\n1 40\\n60 300\\n500 5000\", \"1\\n1 600\", \"2\\n600 1000\\n1200 5000\", \"4\\n3 200\\n300 1000\\n1500 5000\\n6000 100000\", \"1\\n1 800\", \"3\\n1 30\\n70 250\\n300 1000\", \"1\\n1 1000\", \"2\\n1000 5000\\n6000 100000\", \"1\\n1 2000\", \"3\\n1 25\\n75 300\\n350 750\", \"1\\n1 3000\", \"2\\n3000 5000\\n6000 9000\", \"3\\n4 25\\n35 50\\n500 1500\", \"3\\n7 49\\n10 100\\n1000 10000\\n\", \"1\\n1 100\\n\", \"4\\n100 200\\n300 400\\n500 600\\n700 800\\n\", \"2\\n1 10000\\n100000 1000000\\n\", \"5\\n1000 10000\\n10000 100000\\n100000 1000000\\n1000000 10000000\\n10000000 100000000\\n\", \"3\\n150 159\\n40096 68024448\\n666 888888\\n\", \"2\\n123456789 9876543210\\n1020304050 5060708090\\n\", \"1\\n50 70\\n\", \"2\\n69 69\\n420 420\\n\", \"2\\n0 5000\\n5000 10000\\n\", \"3\\n1 4\\n8 20\\n30 50\\n\", \"4\\n1 9\\n10 20\\n25 36\\n49 64\\n\", \"3\\n1 1\\n2 2\\n3 3\\n\", \"5\\n1 25\\n26 50\\n51 75\\n76 100\\n101 125\\n\", \"3\\n1 16\\n17 256\\n257 4096\\n\", \"2\\n100 200\\n200 300\\n\", \"2\\n300 400\\n400 500\\n\", \"2\\n500 600\\n600 700\\n\", \"2\\n700 800\\n800 900\\n\", \"5\\n1 1000\\n1001 2000\\n2001 3000\\n3001 4000\\n4001 5000\\n\", \"4\\n5001 6000\\n6001 7000\\n7001 8000\\n8001 9000\\n\", \"3\\n9001 9500\\n9501 9900\\n9901 10000\\n\", \"1\\n100 500\\n\", \"1\\n500 1000\\n\", \"2\\n1000 5000\\n5000 8000\\n\", \"2\\n8000 10000\\n10000 20000\\n\", \"1\\n20000 50000\\n\", \"1\\n1 1000\\n\", \"2\\n4 400\\n900 9000\\n\", \"4\\n1 10\\n10 100\\n100 1000\\n1000 10000\\n\", \"3\\n25 625\\n49 2401\\n81 6561\\n\", \"5\\n1 1\\n4 4\\n9 9\\n16 16\\n25 25\\n\", \"3\\n1 100\\n100 10000\\n10000 100000000\\n\", \"2\\n16 256\\n36 1296\\n\", \"1\\n81 100\\n\", \"2\\n25 225\\n36 324\\n\", \"1\\n49 4900\\n\", \"2\\n9 729\\n4 256\\n\", \"2\\n81 8100\\n16 1600\\n\", \"3\\n4 144\\n9 361\\n25 625\\n\", \"2\\n36 3600\\n64 6400\\n\", \"1\\n16 1600\\n\", \"3\\n64 6400\\n81 8100\\n100 10000\\n\", \"1\\n36 3600\\n\", \"2\\n9 441\\n25 2500\\n\", \"3\\n15 30\\n250 500\\n10000 20000\", \"1\\n1 10000000000\", \"4\\n10 20\\n30 40\\n50 60\\n70 80\", \"5\\n100 200\\n300 400\\n500 600\\n700 800\\n900 1000\", \"2\\n5000 10000\\n200000 500000\", \"1\\n1000 2000\", \"4\\n99999999 1000000000\\n99999999 1000000000\\n99999999 1000000000\\n99999999 1000000000\", \"5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\", \"1\\n500000 1000000\", \"1\\n1 1\\n\", \"3\\n1 10\\n10 100\\n100 1000\\n\", \"1\\n10 10\\n\", \"3\\n2 20\\n50 5000\\n10000 1000000\\n\", \"1\\n5000000000 10000000000\\n\", \"2\\n1000000000 1000000000\\n2000000000 2000000000\\n\", \"5\\n1 10\\n10 100\\n100 1000\\n1000 10000\\n10000 100000\\n\", \"1\\n9 16\\n\", \"1\\n1000000000 2000000000\\n\", \"1\\n1 20\", \"2\\n30 50\\n2000 3000\", \"3\\n90 120\\n130 150\\n160 190\", \"1\\n5 15\", \"2\\n22 33\\n44 55\", \"1\\n10000000000 10000000000\", \"4\\n1 2\\n2 3\\n3 4\\n4 5\", \"2\\n10 20\\n30 40\", \"5\\n9 10\\n19 20\\n29 30\\n39 40\\n49 50\", \"2\\n156 2835\\n5423 8765\", \"1\\n123456 7891011\", \"3\\n100 200\\n300 400\\n500 600\", \"1\\n6867 982452\", \"1\\n1323 56565\", \"3\\n44444 55555\\n666666 7777777\\n88888888 999999999\", \"5\\n1 5\\n5 10\\n10 15\\n15 20\\n20 25\", \"4\\n1000 2000\\n3000 4000\\n5000 6000\\n7000 8000\", \"2\\n29875 642387\\n23765 234987\", \"4\\n15 30\\n75 80\\n90 100\\n120 150\", \"2\\n1 10\\n100 11000\", \"2\\n1 10\\n100 01100\", \"2\\n1 10\\n110 10000\", \"2\\n1 10\\n110 11000\", \"2\\n2 10\\n100 11100\", \"2\\n2 12\\n110 11100\", \"2\\n1 1\\n010 10001\", \"2\\n1 6\\n110 10000\", \"2\\n2 10\\n100 01000\", \"2\\n1 3\\n110 10101\", \"2\\n2 20\\n110 01100\", \"2\\n1 10\\n101 01010\", \"2\\n2 32\\n110 00100\", \"2\\n1 18\\n100 00110\", \"2\\n1 6\\n001 10000\", \"2\\n1 3\\n100 01000\", \"2\\n1 3\\n110 01000\", \"2\\n3 39\\n010 11000\", \"2\\n3 76\\n010 11000\", \"2\\n3 76\\n010 01000\", \"2\\n6 76\\n010 01000\", \"2\\n10 76\\n011 01000\", \"2\\n10 76\\n001 01000\", \"2\\n1 18\\n101 00110\", \"2\\n2 6\\n001 10000\", \"2\\n2 3\\n110 01000\", \"2\\n3 2\\n110 11000\", \"2\\n1 10\\n001 10100\", \"2\\n1 3\\n011 11101\", \"2\\n2 8\\n110 00100\", \"2\\n2 1\\n001 10000\", \"2\\n3 113\\n001 01000\", \"2\\n1 16\\n001 11100\", \"2\\n1 29\\n010 00101\", \"2\\n2 3\\n010 11101\", \"2\\n2 8\\n010 00100\", \"2\\n2 29\\n010 00101\", \"2\\n2 3\\n011 10110\", \"2\\n5 6\\n010 01010\", \"2\\n4 205\\n001 01000\", \"2\\n4 144\\n010 11000\", \"2\\n4 205\\n011 01000\", \"2\\n7 5\\n111 10111\", \"2\\n2 3\\n100 01010\", \"2\\n5 205\\n011 01100\", \"2\\n3 14\\n001 11100\", \"2\\n3 3\\n011 00110\", \"2\\n3 120\\n001 11000\", \"2\\n4 144\\n011 00100\", \"2\\n5 241\\n011 00100\", \"2\\n5 15\\n001 11011\", \"2\\n4 132\\n011 10001\", \"2\\n30 10\\n111 00111\", \"2\\n2 17\\n100 00100\", \"2\\n1 10\\n100 11100\", \"2\\n1 10\\n110 10001\", \"2\\n2 12\\n100 11100\", \"2\\n1 10\\n010 10001\", \"2\\n2 12\\n110 11101\", \"2\\n1 10\\n100 01000\", \"2\\n1 10\\n100 11001\", \"2\\n1 10\\n100 10100\", \"2\\n1 10\\n100 01101\", \"2\\n1 6\\n110 11000\", \"2\\n2 10\\n100 11000\", \"2\\n1 10\\n110 10101\", \"2\\n2 18\\n100 11100\", \"2\\n1 20\\n010 10001\", \"2\\n2 20\\n110 11100\", \"2\\n1 12\\n110 11101\", \"2\\n1 10\\n100 01010\", \"2\\n1 15\\n100 01101\", \"2\\n2 18\\n100 11110\", \"2\\n1 20\\n011 10001\", \"2\\n1 12\\n110 11111\", \"2\\n1 15\\n101 01101\", \"2\\n1 6\\n111 10000\", \"2\\n2 10\\n100 01010\", \"2\\n1 3\\n111 10101\", \"2\\n1 18\\n100 11110\", \"2\\n1 20\\n011 10011\", \"2\\n2 32\\n110 01100\", \"2\\n1 10\\n101 01000\", \"2\\n1 15\\n101 01001\", \"2\\n1 6\\n011 10000\", \"2\\n1 18\\n100 01110\", \"2\\n1 4\\n101 01000\", \"2\\n1 18\\n101 01001\", \"2\\n1 6\\n011 10001\", \"2\\n2 32\\n110 10100\", \"2\\n1 4\\n100 01000\", \"2\\n1 18\\n100 01001\", \"2\\n2 32\\n100 10100\", \"2\\n1 18\\n101 11001\", \"2\\n1 10\\n011 10000\", \"2\\n2 37\\n100 10100\", \"2\\n1 18\\n101 01011\", \"2\\n2 10\\n011 10000\", \"2\\n2 37\\n100 10110\", \"2\\n1 3\\n110 01010\", \"2\\n1 10\\n100 10000\"], \"outputs\": [\"3\\n9\", \"2\\n2\\n1\\n\", \"5\\n13\\n\", \"92\\n120\\n\", \"3\\n2\\n\", \"0\\n\", \"1\\n3\\n-1\\n\", \"4\\n\", \"10\\n\", \"0\\n\", \"1\\n\", \"3\\n\", \"3\\n3\\n\", \"2\\n3\\n7\\n\", \"3\\n\", \"5\\n\", \"2\\n\", \"1\\n\", \"2\\n1\\n\", \"3\\n3\\n5\\n52\\n\", \"2\\n1\\n\", \"0\\n\", \"2\\n2\\n\", \"3\\n5\\n0\\n\", \"5\\n1\\n0\\n0\\n1\\n\", \"5\\n0\\n\", \"4\\n2\\n9\\n4\\n14\\n\", \"2\\n0\\n0\\n\", \"8\\n0\\n\", \"0\\n0\\n0\\n0\\n1\\n\", \"9\\n111\\n\", \"5\\n\", \"13\\n\", \"3\\n9\\n1\\n\", \"0\\n0\\n\", \"1\\n1\\n\", \"0\\n1\\n\", \"1\\n0\\n\", \"0\\n0\\n\", \"1\\n1\\n\", \"0\\n0\\n\", \"0\\n2\\n\", \"5\\n\", \"1\\n\", \"0\\n\", \"0\\n\", \"1\\n\", \"2\\n\", \"1\\n\", \"0\\n\", \"0\\n\", \"1\\n\", \"1\\n\", \"1\\n0\\n0\\n\", \"5\\n0\\n0\\n4\\n5\\n\", \"28\\n\", \"3\\n2\\n\", \"13\\n1\\n0\\n0\\n0\\n\", \"5\\n5\\n1\\n\", \"0\\n0\\n3\\n3\\n15\\n\", \"3\\n2\\n5\\n4\\n10\\n\", \"16\\n-10\\n\", \"6\\n\", \"4\\n21\\n5\\n\", \"4\\n2\\n5\\n4\\n\", \"1\\n3\\n3\\n\", \"5\\n5\\n1\\n1\\n\", \"7\\n4\\n26\\n0\\n28\\n\", \"3\\n9\", \"120\\n\", \"9\\n13\\n30\\n\", \"4\\n8\\n\", \"41\\n\", \"5\\n3\\n0\\n0\\n\", \"4\\n\", \"2\\n1\\n\", \"0\\n0\\n0\\n0\\n0\\n\", \"5\\n3\\n\", \"3\\n\", \"4\\n2\\n1\\n11\\n1\\n\", \"2\\n1\\n9\\n\", \"1\\n0\\n0\\n1\\n\", \"63\\n60\\n59\\n\", \"11\\n6\\n\", \"5\\n5\\n5\\n\", \"10\\n10\\n10\\n10\\n\", \"3\\n2\\n2\\n2\\n2\\n\", \"8\\n\", \"13\\n19\\n\", \"14\\n\", \"3\\n\", \"58\\n\", \"1\\n\", \"3\\n5\\n9\\n13\\n22\\n\", \"1\\n2\\n\", \"3\\n5\\n10\\n\", \"4\\n9\\n\", \"52\\n\", \"4\\n10\\n34\\n\", \"1\\n\", \"17\\n\", \"2\\n5\\n4\\n10\\n8\\n\", \"3\\n2\\n5\\n4\\n10\\n8\\n17\\n17\\n30\\n28\\n\", \"3\\n9\", \"3\\n0\\n4\\n10\\n\", \"3\\n5\\n11\\n\", \"3\\n1\\n5\\n1\\n11\\n\", \"4\\n2\\n3\\n\", \"8\\n\", \"1\\n2\\n\", \"5\\n3\\n1\\n11\\n\", \"2\\n1\\n0\\n\", \"8\\n\", \"4\\n2\\n3\\n1\\n11\\n\", \"3\\n2\\n3\\n\", \"8\\n\", \"1\\n2\\n\", \"5\\n3\\n1\\n11\\n\", \"8\\n\", \"3\\n2\\n3\\n\", \"9\\n\", \"2\\n11\\n\", \"10\\n\", \"3\\n2\\n2\\n\", \"10\\n\", \"1\\n0\\n\", \"2\\n1\\n2\\n\", \"2\\n2\\n4\\n\", \"5\\n\", \"2\\n1\\n0\\n0\\n\", \"13\\n8\\n\", \"4\\n10\\n8\\n17\\n17\\n\", \"0\\n39\\n18\\n\", \"41\\n19\\n\", \"0\\n\", \"0\\n0\\n\", \"12\\n2\\n\", \"2\\n1\\n1\\n\", \"3\\n0\\n0\\n1\\n\", \"1\\n0\\n0\\n\", \"3\\n1\\n0\\n1\\n0\\n\", \"3\\n3\\n4\\n\", \"2\\n0\\n\", \"1\\n2\\n\", \"0\\n0\\n\", \"0\\n1\\n\", \"9\\n1\\n0\\n0\\n1\\n\", \"0\\n0\\n0\\n0\\n\", \"1\\n0\\n1\\n\", \"4\\n\", \"1\\n\", \"2\\n0\\n\", \"2\\n5\\n\", \"4\\n\", \"9\\n\", \"6\\n3\\n\", \"3\\n2\\n5\\n4\\n\", \"5\\n7\\n7\\n\", \"1\\n1\\n1\\n0\\n0\\n\", \"5\\n9\\n51\\n\", \"3\\n6\\n\", \"1\\n\", \"3\\n3\\n\", \"8\\n\", \"6\\n5\\n\", \"7\\n7\\n\", \"5\\n4\\n5\\n\", \"7\\n7\\n\", \"7\\n\", \"7\\n7\\n9\\n\", \"7\\n\", \"6\\n7\\n\", \"0\\n2\\n5\\n\", \"120\\n\", \"0\\n0\\n0\\n0\\n\", \"2\\n1\\n0\\n0\\n1\\n\", \"2\\n3\\n\", \"1\\n\", \"30\\n30\\n30\\n30\\n\", \"1\\n0\\n1\\n1\\n0\\n\", \"4\\n\", \"1\\n\", \"3\\n2\\n5\\n\", \"0\\n\", \"2\\n7\\n18\\n\", \"9\\n\", \"0\\n0\\n\", \"3\\n2\\n5\\n4\\n10\\n\", \"1\\n\", \"8\\n\", \"3\\n\", \"1\\n0\\n\", \"1\\n1\\n0\\n\", \"1\\n\", \"0\\n1\\n\", \"1\\n\", \"1\\n0\\n1\\n1\\n\", \"0\\n0\\n\", \"1\\n0\\n0\\n0\\n1\\n\", \"4\\n0\\n\", \"21\\n\", \"2\\n1\\n0\\n\", \"17\\n\", \"12\\n\", \"1\\n17\\n35\\n\", \"2\\n1\\n0\\n0\\n0\\n\", \"1\\n0\\n0\\n0\\n\", \"9\\n6\\n\", \"0\\n0\\n1\\n1\\n\", \"3\\n10\\n\", \"3\\n5\\n\", \"3\\n8\\n\", \"3\\n9\\n\", \"2\\n10\\n\", \"2\\n9\\n\", \"1\\n10\\n\", \"2\\n8\\n\", \"2\\n5\\n\", \"1\\n8\\n\", \"2\\n4\\n\", \"3\\n4\\n\", \"2\\n0\\n\", \"3\\n1\\n\", \"2\\n13\\n\", \"1\\n5\\n\", \"1\\n4\\n\", \"2\\n11\\n\", \"3\\n11\\n\", \"3\\n6\\n\", \"2\\n6\\n\", \"1\\n6\\n\", \"1\\n9\\n\", \"3\\n0\\n\", \"1\\n13\\n\", \"0\\n4\\n\", \"0\\n9\\n\", \"3\\n13\\n\", \"1\\n11\\n\", \"1\\n0\\n\", \"0\\n13\\n\", \"4\\n9\\n\", \"3\\n14\\n\", \"3\\n2\\n\", \"0\\n11\\n\", \"1\\n2\\n\", \"2\\n2\\n\", \"0\\n10\\n\", \"0\\n6\\n\", \"5\\n9\\n\", \"5\\n11\\n\", \"5\\n6\\n\", \"0\\n8\\n\", \"0\\n5\\n\", \"4\\n6\\n\", \"2\\n14\\n\", \"0\\n2\\n\", \"4\\n14\\n\", \"5\\n2\\n\", \"4\\n2\\n\", \"1\\n14\\n\", \"4\\n10\\n\", \"0\\n0\\n\", \"2\\n1\\n\", \"3\\n10\\n\", \"3\\n8\\n\", \"2\\n10\\n\", \"3\\n10\\n\", \"2\\n9\\n\", \"3\\n5\\n\", \"3\\n10\\n\", \"3\\n9\\n\", \"3\\n5\\n\", \"2\\n9\\n\", \"2\\n10\\n\", \"3\\n8\\n\", \"2\\n10\\n\", \"3\\n10\\n\", \"2\\n9\\n\", \"3\\n9\\n\", \"3\\n5\\n\", \"3\\n5\\n\", \"2\\n10\\n\", \"3\\n10\\n\", \"3\\n9\\n\", \"3\\n4\\n\", \"2\\n8\\n\", \"2\\n5\\n\", \"1\\n8\\n\", \"3\\n10\\n\", \"3\\n10\\n\", \"2\\n4\\n\", \"3\\n4\\n\", \"3\\n4\\n\", \"2\\n10\\n\", \"3\\n5\\n\", \"2\\n4\\n\", \"3\\n4\\n\", \"2\\n10\\n\", \"2\\n8\\n\", \"2\\n5\\n\", \"3\\n5\\n\", \"2\\n9\\n\", \"3\\n9\\n\", \"3\\n10\\n\", \"2\\n9\\n\", \"3\\n4\\n\", \"2\\n10\\n\", \"2\\n9\\n\", \"1\\n4\\n\", \"3\\n9\\n\"]}",
    "difficulty": "MEDIUM",
    "raw_tags": "['Algorithms', 'Pre processing', 'Brute Force', 'Advanced Algorithms']",
    "name": null,
    "source": "codechef",
    "tags": "['Preprocessing', 'Complete search']",
    "skill_types": "['Complete search']",
    "url": "https://www.codechef.com/problems/SDSQUARE",
    "Expected Auxiliary Space": null,
    "time_limit": "0.262128 seconds",
    "date": "2013-10-04",
    "picture_num": "0",
    "memory_limit": "50000 bytes",
    "Expected Time Complexity": null,
    "human_solution": "from bisect import *\ntable = [0, 1, 4, 9, 49, 100, 144, 400, 441, 900, 1444, 4900, 9409, 10000, 10404, 11449, 14400, 19044, 40000, 40401, 44100, 44944, 90000, 144400, 419904, 490000, 491401, 904401, 940900, 994009, 1000000, 1004004, 1014049, 1040400, 1100401, 1144900, 1440000, 1904400, 1940449, 4000000, 4004001, 4040100, 4410000, 4494400, 9000000, 9909904, 9941409, 11909401, 14010049, 14040009, 14440000, 19909444, 40411449, 41990400, 49000000, 49014001, 49140100, 49999041, 90440100, 94090000, 94109401, 99400900, 99940009, 100000000, 100040004, 100140049, 100400400, 101404900, 101949409, 104040000, 104919049, 110040100, 111049444, 114041041, 114490000, 144000000, 190440000, 194044900, 400000000, 400040001, 400400100, 404010000, 404090404, 409941009, 414000409, 414041104, 441000000, 449440000, 490091044, 900000000, 990990400, 991494144, 994140900, 1190940100, 1401004900, 1404000900, 1409101444, 1444000000, 1449401041, 1490114404, 1990944400, 4014109449, 4019940409, 4041144900, 4199040000, 4900000000, 4900140001, 4901400100, 4914010000, 4914991449, 4941949401, 4999904100, 9044010000, 9409000000, 9409194001, 9410940100, 9900449001, 9940090000, 9994000900, 9999400009, 10000000000]\nfor _ in range(int(input())):\n\t(a, b) = map(int, input().split())\n\taa = bisect_left(table, a)\n\tbb = bisect_right(table, b)\n\tprint(bb - aa)\n",
    "claude_solution": "# Perfect Digit Squares Solution\n\nThis problem asks us to count perfect squares between two numbers that contain only the digits 0, 1, 4, and 9 (which are themselves perfect squares).\n\n## Approach\nSince the range can be large (up to 10^10), we need an efficient approach:\n1. Generate all numbers with only perfect digits (0, 1, 4, 9) up to a certain limit\n2. Square these numbers to get perfect squares with only perfect digits\n3. Count how many of these squares fall within the given range [a, b]\n\n```python\ndef solve():\n    # Read number of test cases\n    t = int(input())\n    \n    # Pre-compute all perfect digit squares up to sqrt(10^10)\n    perfect_digit_squares = []\n    \n    # Generate all numbers with only perfect digits (0, 1, 4, 9)\n    def generate_perfect_digit_numbers(limit):\n        # Queue for BFS\n        queue = [1, 4, 9]  # Start with single-digit perfect squares (excluding 0)\n        result = []\n        \n        while queue:\n            num = queue.pop(0)\n            if num > limit:\n                continue\n                \n            result.append(num)\n            \n            # Generate next level numbers by appending perfect digits\n            for digit in [0, 1, 4, 9]:\n                next_num = num * 10 + digit\n                if next_num <= limit:\n                    queue.append(next_num)\n        \n        return result\n    \n    # Generate numbers with perfect digits up to sqrt(10^10)\n    limit = int(10**10 ** 0.5) + 1\n    perfect_digit_numbers = generate_perfect_digit_numbers(limit)\n    \n    # Square these numbers to get perfect digit squares\n    for num in perfect_digit_numbers:\n        square = num * num\n        # Check if the square has only perfect digits\n        if all(digit in '0149' for digit in str(square)):\n            perfect_digit_squares.append(square)\n    \n    # Sort the list for binary search\n    perfect_digit_squares.sort()\n    \n    # Process each test case\n    for _ in range(t):\n        a, b = map(int, input().split())\n        \n        # Count perfect digit squares in range [a, b]\n        count = 0\n        for square in perfect_digit_squares:\n            if a <= square <= b:\n                count += 1\n        \n        print(count)\n\nsolve()\n```\n\nWait, there's an issue with the above approach. When we square a number with perfect digits, the result might not have only perfect digits. Let me correct this:\n\n```python\ndef solve():\n    # Read number of test cases\n    t = int(input())\n    \n    # Pre-compute all perfect squares up to 10^10\n    perfect_digit_squares = []\n    \n    # Check if a number contains only perfect digits (0, 1, 4, 9)\n    def has_only_perfect_digits(num):\n        return all(digit in '0149' for digit in str(num))\n    \n    # Generate perfect squares up to 10^10\n    limit = 10**10\n    i = 1\n    while i*i <= limit:\n        square = i*i\n        if has_only_perfect_digits(square):\n            perfect_digit_squares.append(square)\n        i += 1\n    \n    # Process each test case\n    for _ in range(t):\n        a, b = map(int, input().split())\n        \n        # Count perfect digit squares in range [a, b]\n        count = 0\n        for square in perfect_digit_squares:\n            if a <= square <= b:\n                count += 1\n        \n        print(count)\n\nsolve()\n```\n\nActually, we can optimize further. Instead of checking all squares up to 10^10, we can generate only numbers with perfect digits and then check if they are perfect squares:\n\n```python\ndef solve():\n    # Read number of test cases\n    t = int(input())\n    \n    # Pre-compute all perfect digit squares up to 10^10\n    perfect_digit_squares = []\n    \n    # Generate all numbers with only perfect digits (0, 1, 4, 9) up to 10^10\n    def generate_perfect_digit_numbers(current, limit, result):\n        if current > limit:\n            return\n        \n        # Check if current is a perfect square\n        sqrt_current = int(current ** 0.5)\n        if sqrt_current * sqrt_current == current:\n            result.append(current)\n        \n        # Generate next level numbers by appending perfect digits\n        for digit in [0, 1, 4, 9]:\n            next_num = current * 10 + digit\n            if next_num <= limit:\n                generate_perfect_digit_numbers(next_num, limit, result)\n    \n    # Start with empty string and generate all numbers\n    result = []\n    for digit in [1, 4, 9]:  # Start with non-zero digits\n        generate_perfect_digit_numbers(digit, 10**10, result)\n    \n    # Sort the results\n    perfect_digit_squares = sorted(result)\n    \n    # Process each test case\n    for _ in range(t):\n        a, b = map(int, input().split())\n        \n        # Binary search to find the range\n        left = 0\n        while left < len(perfect_digit_squares) and perfect_digit_squares[left] < a:\n            left += 1\n        \n        right = left\n        while right < len(perfect_digit_squares) and perfect_digit_squares[right] <= b:\n            right += 1\n        \n        print(right - left)\n\nsolve()\n```\n\nThe recursive approach might lead to stack overflow for large numbers. Let's use an iterative approach:\n\n```python\ndef solve():\n    # Read number of test cases\n    t = int(input())\n    \n    # Pre-compute all perfect digit squares up to 10^10\n    perfect_digit_squares = []\n    \n    # Generate all numbers with only perfect digits (0, 1, 4, 9) up to 10^10\n    def generate_perfect_digit_squares(limit):\n        result = []\n        queue = [0, 1, 4, 9]  # Start with single digits\n        \n        while queue:\n            num = queue.pop(0)\n            \n            # Check if num is a perfect square\n            if num > 0:  # Skip 0 as it's not a positive perfect square\n                sqrt_num = int(num ** 0.5)\n                if sqrt_num * sqrt_num == num:\n                    result.append(num)\n            \n            # Generate next numbers by appending perfect digits\n            for digit in [0, 1, 4, 9]:\n                next_num = num * 10 + digit\n                if next_num <= limit and (next_num > 0 or digit > 0):  # Avoid leading zeros\n                    queue.append(next_num)\n        \n        return sorted(result)\n    \n    # Generate all perfect digit squares up to 10^10\n    perfect_digit_squares = generate_perfect_digit_squares(10**10)\n    \n    # Process each test case\n    for _ in range(t):\n        a, b = map(int, input().split())\n        \n        # Count perfect digit squares in range [a, b]\n        count = sum(1 for square in perfect_digit_squares if a <= square <= b)\n        print(count)\n\nsolve()\n```\n\nThis approach still has issues with memory for large numbers. Let's optimize by directly checking if a number is a perfect square and has only perfect digits:\n\n```python\ndef solve():\n    # Read number of test cases\n    t = int(input())\n    \n    # Check if a number contains only perfect digits (0, 1, 4, 9)\n    def has_only_perfect_digits(num):\n        return all(digit in '0149' for digit in str(num))\n    \n    # Process each test case\n    for _ in range(t):\n        a, b = map(int, input().split())\n        \n        # Find the range of perfect squares within [a, b]\n        start = int(a ** 0.5)\n        if start * start < a:\n            start += 1\n        \n        end = int(b ** 0.5)\n        \n        # Count perfect digit squares in range\n        count = 0\n        for i in range(start, end + 1):\n            square = i * i\n            if has_only_perfect_digits(square):\n                count += 1\n        \n        print(count)\n\nsolve()\n```\n\nThis solution should be efficient for the given constraints.",
    "problem": "Read problems statements in  Mandarin Chinese  and  Russian. \nRecently Chef become very much interested in perfect squares. We all know Chef and his weird interests. Anyways Chef will be soon writing his masters thesis on perfect squares revealing what-not-known properties of perfect squares.\nWhile doing his research, he happened to be confronted with some interesting perfect squares. These prefect squares consists only of digits which are themselves perfect squares. 0, 1, 4 and 9 are such digits. These are called perfect digits.\nAs we all know Chef also has habit of asking too many questions, he is asking- given two numbers a and b, how many perfect squares exists between these two numbers inclusive, that contains only perfect digits.\u00a0\nInput:\nFirst line of input will contains T, number of test cases. Then T lines follows, each containing two positive integers a and b.\nConstraints:\nT \u2264 500\n1\u2264 a \u2264 b \u2264 10000000000\u00a0\nOutput:\nFor each input, output number of perfect digit squares between given numbers.\u00a0\nSample\n\n----- Sample Input 1 ------ \n2\n1 10\n100 10000\n----- Sample Output 1 ------ \n3\n9"
  }
]