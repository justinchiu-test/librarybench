[
  {
    "solutions": [
      "(n, k) = map(int, input().split())\ntuk = n - k\nhell = 998244353\nif tuk <= 0:\n\tprint(0)\n\texit(0)\nfact = [1] * 200005\nfor i in range(2, 200005):\n\tfact[i] = i * fact[i - 1] % hell\n\ndef C(n, r):\n\tans = 1\n\tans = fact[r] * fact[n - r] % hell\n\tans = fact[n] * pow(ans, hell - 2, hell) % hell\n\treturn ans\nans = C(n, tuk)\nif k != 0:\n\tans *= 2\nres = 0\nfor i in range(tuk):\n\tt = C(tuk, i) * pow(tuk - i, n, hell) % hell\n\tif i % 2:\n\t\tres = (res - t + hell) % hell\n\telse:\n\t\tres = (res + t) % hell\nans = ans * res % hell\nprint(ans)\n",
      "MOD = 998244353\nlist_size = 200001\nf_list = [1] * list_size\nf_r_list = [1] * list_size\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int(f_list[i] * (i + 2) % MOD)\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int(f_r_list[-i + 1] * (list_size + 2 - i) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn f_list[n - 1] * f_r_list[n - r - 1] % MOD * f_r_list[r - 1] % MOD\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\nelif k == 0:\n\tprint(f_list[n - 1])\nelse:\n\tans = 0\n\tm = n - k\n\tfor i in range(1, m + 1):\n\t\tans += (-1) ** ((m - i) % 2) * pow(i, n, MOD) * comb(m, i)\n\t\tans %= MOD\n\tans *= f_r_list[m - 1] * f_list[n - 1] * f_r_list[k - 1]\n\tans *= 2\n\tprint(ans % MOD)\n",
      "(n, k) = map(int, input().split())\n\ndef cmb(n, r, mod):\n\tif r < 0 or r > n:\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn g1[n] * g2[r] * g2[n - r] % mod\nmod = 998244353\nN = 200000\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, N + 1):\n\tg1.append(g1[-1] * i % mod)\n\tinverse.append(-inverse[mod % i] * (mod // i) % mod)\n\tg2.append(g2[-1] * inverse[-1] % mod)\nif k == 0:\n\tans = 1\n\tfor i in range(1, n + 1):\n\t\tans *= i\n\t\tans %= mod\n\tprint(ans)\nelif k >= n:\n\tprint(0)\nelse:\n\tans = 0\n\tK = n - k\n\tfor i in range(K + 1):\n\t\tans += (-1) ** ((K - i) % 2) * cmb(K, i, mod) * pow(i, n, mod)\n\tans %= mod\n\tans *= cmb(n, n - k, mod)\n\tans *= 2\n\tans %= mod\n\tprint(ans)\n",
      "def prepare(n, MOD):\n\tf = 1\n\tfactorials = [1]\n\tfor m in range(1, n + 1):\n\t\tf *= m\n\t\tf %= MOD\n\t\tfactorials.append(f)\n\tinv = pow(f, MOD - 2, MOD)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor m in range(n, 1, -1):\n\t\tinv *= m\n\t\tinv %= MOD\n\t\tinvs[m - 1] = inv\n\treturn (factorials, invs)\n\ndef solve(n, k):\n\tMOD = 998244353\n\tif k == 0:\n\t\tans = 1\n\t\tfor i in range(2, n + 1):\n\t\t\tans = ans * i % MOD\n\t\treturn ans\n\tif k > n - 1:\n\t\treturn 0\n\t(facts, invs) = prepare(n, MOD)\n\tuse_row = n - k\n\tt = 1\n\tans = 0\n\tfor r in range(use_row, 0, -1):\n\t\tans = (ans + t * facts[use_row] * invs[r] * invs[use_row - r] * pow(r, n, MOD)) % MOD\n\t\tt *= -1\n\treturn ans * 2 * facts[n] * invs[use_row] * invs[n - use_row] % MOD\n(n, k) = list(map(int, input().split()))\nprint(solve(n, k))\n",
      "import sys\nfrom functools import reduce\nints = (int(x) for x in sys.stdin.read().split())\nmod = 998244353\n\ndef mod_pow(a, k):\n\tr = 1\n\twhile k and r:\n\t\tif k % 2:\n\t\t\tr = r * a % mod\n\t\t(k, a) = (k >> 1, a * a % mod)\n\treturn r\n\ndef main():\n\tmul = lambda a, b: a * b % mod\n\n\tdef nCk(n, k):\n\t\tassert 0 <= k <= n\n\t\treturn mul(fact[n], mod_pow(mul(fact[k], fact[n - k]), mod - 2))\n\t(n, k) = (next(ints), next(ints))\n\tif 0 <= k < n:\n\t\tfact = [1] * (n + 1)\n\t\tfor i in range(1, n + 1):\n\t\t\tfact[i] = mul(fact[i - 1], i)\n\t\t(m, ans) = (n - k, 0)\n\t\tfor i in range(m):\n\t\t\tsign = 1 if i % 2 == 0 else -1\n\t\t\tans += sign * mul(nCk(m, i), mod_pow(m - i, n))\n\t\t\tans %= mod\n\t\tans = mul(ans, nCk(n, k))\n\t\tans = mul(ans, 1 + (k > 0))\n\telse:\n\t\tans = 0\n\tprint(ans)\n\treturn\nmain()\n",
      "from sys import stdin\nfrom sys import stdout\nm = 998244353\nfactorial = [1]\nfor i in range(1, 200001):\n\tfactorial.append(factorial[i - 1] * i % m)\n\ndef quick_power(a, n):\n\tif n == 0:\n\t\treturn 1\n\tx = quick_power(a, n // 2) % m\n\tx = x * x % m\n\tif n % 2 == 1:\n\t\tx = x * a % m\n\treturn x\n\ndef inv(b):\n\treturn quick_power(b, m - 2)\n\ndef combinatoria(a, b):\n\tx = factorial[a] * inv(factorial[b]) % m * inv(factorial[a - b]) % m\n\treturn x\n\ndef PlacingRooks(n, k):\n\tif k == 0:\n\t\treturn factorial[n]\n\telif k >= n:\n\t\treturn 0\n\telse:\n\t\tc = n - k\n\t\tresult = 0\n\t\tfor i in range(0, c):\n\t\t\taux = quick_power(-1, i) * combinatoria(c, i) * quick_power(c - i, n) % m\n\t\t\tresult = (result + aux) % m\n\t\tresult = result * combinatoria(n, c) % m * 2 % m\n\t\treturn result\ninput = list(map(int, stdin.readline().split()))\nn = input[0]\nk = input[1]\nstdout.write(str(PlacingRooks(n, k)) + '\\n')\n",
      "MOD = 998244353\n(n, k) = map(int, input().split())\nx = n - k\nnum = 1\nden = 1\ns = 0\ntden = 1\nfor i in range(x):\n\tv = pow(x - i, n, MOD) * num\n\ts = (s * den + (-1) ** i * v * tden) % MOD\n\ttden = tden * den % MOD\n\tnum = num * (x - i) % MOD\n\tden = den * (i + 1) % MOD\nnum = 1\nden = 1\nfor i in range(x):\n\tnum = num * (n - i) % MOD\n\tden = den * (i + 1) % MOD\ns = (1 + (k != 0)) * s * num * pow(den * tden, MOD - 2, MOD) % MOD\nprint(s)\n",
      "fact = [1]\nmod = 998244353\nfor i in range(1, 200001):\n\tfact.append(fact[-1] * i % mod)\n(n, k) = map(int, input().split())\nsame = k\n\ndef choose(n, r):\n\treturn fact[n] * pow(fact[r], mod - 2, mod) * pow(fact[n - r], mod - 2, mod) % mod\n\ndef sterling(n, m):\n\tresult = 0\n\tfor i in range(n):\n\t\tif i % 2 == 0:\n\t\t\tresult = (result + choose(n, i) * pow(n - i, m, mod)) % mod\n\t\telse:\n\t\t\tresult = (result - choose(n, i) * pow(n - i, m, mod)) % mod\n\treturn result % mod\nif k > n - 1:\n\tprint(0)\nelif k == 0:\n\tprint(fact[n])\nelse:\n\tprint(2 * choose(n, n - k) * sterling(n - k, n) % mod)\n",
      "MOD = 998244353\n\ndef inv(x):\n\treturn pow(x, MOD - 2, MOD)\n(n, k) = list(map(int, input().split()))\nif k >= n:\n\tprint(0)\nelse:\n\tout = 0\n\tcol = n - k\n\tbinom = 1\n\tmult = 1\n\tfor i in range(n, col, -1):\n\t\tmult *= i\n\t\tmult *= inv(n + 1 - i)\n\t\tmult %= MOD\n\tfor i in range(col, 0, -1):\n\t\tout += binom * pow(i, n, MOD)\n\t\tout %= MOD\n\t\tbinom *= i\n\t\tbinom *= inv(col + 1 - i)\n\t\tbinom *= -1\n\t\tbinom %= MOD\n\tout *= mult\n\tif k > 0:\n\t\tout *= 2\n\tprint(out % MOD)\n",
      "import sys\ninput = sys.stdin.buffer.readline\n\ndef print(val):\n\tsys.stdout.write(str(val) + '\\n')\n\ndef inverse(n, primemod):\n\treturn pow(n, primemod - 2, primemod)\n\ndef choose(n, k, mod, factorials, inverses):\n\treturn factorials[n] * inverses[k] * inverses[n - k] % mod\n\ndef factorial_creator(n, mod):\n\tfactorials = [1]\n\tcurr = 1\n\tfor i in range(1, n + 1):\n\t\tcurr = curr * i % mod\n\t\tfactorials.append(curr)\n\treturn factorials\n\ndef inverse_creator(n, k, mod, factorials):\n\tinverses = [1 for i in range(n - k + 1)]\n\tcurrent = inverse(factorials[n - k], mod)\n\tinverses[n - k] = current\n\tfor i in range(n - k, 0, -1):\n\t\tcurrent = current * i % mod\n\t\tinverses[i - 1] = current\n\treturn inverses\n\ndef place_rooks(n, k, mod):\n\tif k >= n:\n\t\treturn 0\n\tfactorials = factorial_creator(n, 998244353)\n\tinverses = inverse_creator(n, k, 998244353, factorials)\n\tfilled = n - k\n\tplacements_per_filled = 0\n\tfor i in range(filled):\n\t\tplacements_per_filled += (-1) ** i * choose(filled, i, mod, factorials, inverses) * pow(filled - i, n, mod) % mod\n\t\tplacements_per_filled %= mod\n\tif k == 0:\n\t\ttotal = factorials[n] * inverses[n - k] * inverse(factorials[k], mod) % mod * placements_per_filled % mod\n\t\treturn total\n\ttotal = 2 * (factorials[n] * inverses[n - k] * inverse(factorials[k], mod)) % mod * placements_per_filled % mod\n\treturn total\n(n, k) = map(int, input().split())\nprint(place_rooks(n, k, 998244353))\n",
      "import sys\ninput = sys.stdin.readline\nmod = 998244353\n\ndef cmb(n, r):\n\tif r < 0 or r > n:\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn g1[n] * g2[r] * g2[n - r] % mod\nNNN = 2 * 10 ** 5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, NNN + 1):\n\tg1.append(g1[-1] * i % mod)\n\tinverse.append(-inverse[mod % i] * (mod // i) % mod)\n\tg2.append(g2[-1] * inverse[-1] % mod)\n(N, K) = map(int, input().split())\nif K > N:\n\tprint(0)\nelse:\n\tM = N - K\n\tR = 0\n\tfor i in range(1, M + 1):\n\t\tR += (-1 if (M - i) % 2 else 1) * cmb(M, i) * pow(i, N, mod) % mod\n\tR = R * cmb(N, M) % mod\n\tif K != 0:\n\t\tR = R * 2 % mod\n\tprint(R)\n",
      "MAX = 2 * 10 ** 5 + 100\nMOD = 998244353\nfact = [0] * MAX\ninv = [0] * MAX\nfinv = [0] * MAX\nfact[0] = 1\nfact[1] = 1\nfinv[0] = 1\nfinv[1] = 1\ninv[1] = 1\nfor i in range(2, MAX):\n\tfact[i] = fact[i - 1] * i % MOD\n\tinv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\tfinv[i] = finv[i - 1] * inv[i] % MOD\n\ndef C(n, r):\n\tif n < r:\n\t\treturn 0\n\tif n < 0 or r < 0:\n\t\treturn 0\n\treturn fact[n] * (finv[r] * finv[n - r] % MOD) % MOD\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\n\texit()\nif k == 0:\n\tprint(fact[n])\n\texit()\nans = 0\nfor i in range(n - k + 1):\n\tif i % 2 == 0:\n\t\tans += C(n - k, i) * pow(n - k - i, n, MOD)\n\t\tans %= MOD\n\telse:\n\t\tans -= C(n - k, i) * pow(n - k - i, n, MOD)\n\t\tans %= MOD\nans *= 2 * C(n, k)\nans %= MOD\nprint(ans)\n",
      "import sys\ninput = sys.stdin.readline\n(fact, inv_fact) = ([0] * (2 * 10 ** 5 + 1), [0] * (2 * 10 ** 5 + 1))\nfact[0] = 1\nmod = 998244353\n\ndef make_nCr_mod(max_n=2 * 10 ** 5, mod=998244353):\n\tglobal fact\n\tglobal inv_fact\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\nmake_nCr_mod()\n\ndef nCr_mod(n, r):\n\tres = 1\n\twhile n or r:\n\t\t(a, b) = (n % mod, r % mod)\n\t\tif a < b:\n\t\t\treturn 0\n\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\tn //= mod\n\t\tr //= mod\n\treturn res\n(n, k) = map(int, input().split())\nif k == 0:\n\tprint(fact[n])\nelif k >= n:\n\tprint(0)\nelse:\n\tans = 0\n\tfor i in range(1, n - k + 1):\n\t\tans += 2 * nCr_mod(n, k) * pow(-1, n - k - i) * nCr_mod(n - k, i) * pow(i, n, mod) % mod\n\tprint(ans % mod)\n",
      "def inverse(n, primemod):\n\treturn pow(n, primemod - 2, primemod)\n\ndef choose(n, k, mod, factorials, inverses):\n\treturn factorials[n] * inverses[k] * inverses[n - k] % mod\n\ndef factorial_creator(n, mod):\n\tfactorials = [1]\n\tcurr = 1\n\tfor i in range(1, n + 1):\n\t\tcurr = curr * i % mod\n\t\tfactorials.append(curr)\n\treturn factorials\n\ndef inverse_creator(n, k, mod, factorials):\n\tinverses = [1 for i in range(n - k + 1)]\n\tcurrent = inverse(factorials[n - k], mod)\n\tinverses[n - k] = current\n\tfor i in range(n - k, 0, -1):\n\t\tcurrent = current * i % mod\n\t\tinverses[i - 1] = current\n\treturn inverses\n\ndef place_rooks(n, k, mod):\n\tif k >= n:\n\t\treturn 0\n\tfactorials = factorial_creator(n, 998244353)\n\tinverses = inverse_creator(n, k, 998244353, factorials)\n\tfilled = n - k\n\tplacements_per_filled = 0\n\tfor i in range(filled):\n\t\tplacements_per_filled += (-1) ** i * choose(filled, i, mod, factorials, inverses) * pow(filled - i, n, mod) % mod\n\t\tplacements_per_filled %= mod\n\tif k == 0:\n\t\ttotal = factorials[n] * inverses[n - k] * inverse(factorials[k], mod) % mod * placements_per_filled % mod\n\t\treturn total\n\ttotal = 2 * (factorials[n] * inverses[n - k] * inverse(factorials[k], mod)) % mod * placements_per_filled % mod\n\treturn total\n(n, k) = map(int, input().split())\nprint(place_rooks(n, k, 998244353))\n",
      "from sys import stdin, stdout\nMOD = 998244353\nf_a = []\n\ndef build_fac(n):\n\tf_a.append(1)\n\tfor i in range(1, n + 1):\n\t\tr = i * f_a[-1]\n\t\tr %= MOD\n\t\tf_a.append(r)\n\ndef fac(n):\n\treturn f_a[n]\n\ndef inv(n):\n\treturn bpow(n, MOD - 2)\n\ndef bpow(a, b):\n\tif b == 0:\n\t\treturn 1\n\tr = bpow(a, b // 2)\n\tr *= r\n\tr %= MOD\n\tif b % 2 == 1:\n\t\tr *= a\n\t\tr %= MOD\n\treturn r\n\ndef C(n, c):\n\tr1 = fac(n)\n\tr2 = inv(fac(c))\n\tr3 = inv(fac(n - c))\n\tr = r1 * r2\n\tr %= MOD\n\tr *= r3\n\tr %= MOD\n\treturn r\n\ndef placing_rooks(n, k):\n\tif k > n:\n\t\treturn 0\n\tr = 0\n\tfor i in range(n - k):\n\t\tr1 = bpow(n - k - i, n)\n\t\tr1 *= C(n - k, i)\n\t\tr1 %= MOD\n\t\tif i % 2 == 0:\n\t\t\tr += r1\n\t\telse:\n\t\t\tr -= r1\n\t\tr %= MOD\n\tr *= C(n, n - k)\n\tr %= MOD\n\tif k > 0:\n\t\tr *= 2\n\t\tr %= MOD\n\treturn r\n(n, k) = map(int, stdin.readline().split())\nbuild_fac(n)\nr = placing_rooks(n, k)\nstdout.write(str(r) + '\\n')\n",
      "def comb(n, k):\n\treturn L[n] * pow(L[n - k] * L[k], m - 2, m) % m\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\nelse:\n\tm = 998244353\n\tL = [1]\n\tfor i in range(1, n + 1):\n\t\tL.append(L[-1] * i % m)\n\tc = 0\n\tfor i in range(n - k):\n\t\tc += (-1) ** i * pow(n - k - i, n, m) * comb(n - k, n - k - i) % m\n\tc %= m\n\tc *= comb(n, n - k)\n\tif k == 0:\n\t\tprint(c % m)\n\telse:\n\t\tprint(c * 2 % m)\n",
      "MOD = 998244353\nfac = [1] * (2 * 10 ** 5 + 10)\n\ndef comb(n, k):\n\treturn fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nfor i in range(len(fac) - 1):\n\tfac[i + 1] = fac[i] * (i + 1) % MOD\n(n, k) = list(map(int, input().split()))\nif k == 0:\n\tprint(fac[n])\nelse:\n\tk = n - k\n\tif k <= 0:\n\t\tprint(0)\n\t\treturn\n\tans = 0\n\tfor i in range(k + 1):\n\t\tt = comb(k, i) * pow(k - i, n, MOD) % MOD\n\t\tif i % 2:\n\t\t\tans -= t\n\t\telse:\n\t\t\tans += t\n\tprint(2 * ans * comb(n, k) % MOD)\n",
      "nn = 200200\nP = 998244353\nfa = [1] * (nn + 1)\nfainv = [1] * (nn + 1)\nfor i in range(nn):\n\tfa[i + 1] = fa[i] * (i + 1) % P\nfainv[-1] = pow(fa[-1], P - 2, P)\nfor i in range(nn)[::-1]:\n\tfainv[i] = fainv[i + 1] * (i + 1) % P\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a - b] % P if 0 <= b <= a else 0\n(N, K) = map(int, input().split())\nif K == 0:\n\tprint(fa[N])\n\texit()\nif K >= N:\n\tprint(0)\n\texit()\na = N - K\nans = 0\nfor i in range(a + 1):\n\tans = (ans + pow(a - i, N, P) * C(a, i) * (-1 if i & 1 else 1)) % P\nans = ans * 2 * C(N, a) % P\nprint(ans)\n",
      "import io, os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport sys\n\ndef solve(n, k):\n\tmod = 998244353\n\tif k == 0:\n\t\tans = 1\n\t\tfor i in range(1, n + 1):\n\t\t\tans *= i\n\t\t\tans %= mod\n\t\treturn ans\n\tif k >= n:\n\t\treturn 0\n\tinv = lambda x: pow(x, mod - 2, mod)\n\tFact = [1]\n\tfor i in range(1, n + 1):\n\t\tFact.append(Fact[i - 1] * i % mod)\n\tFinv = [0] * (n + 1)\n\tFinv[-1] = inv(Fact[-1])\n\tfor i in range(n - 1, -1, -1):\n\t\tFinv[i] = Finv[i + 1] * (i + 1) % mod\n\n\tdef comb(n, r):\n\t\tif n < r:\n\t\t\treturn 0\n\t\treturn Fact[n] * Finv[r] * Finv[n - r] % mod\n\tm = n - k\n\tt = 1\n\tans = 0\n\tfor r in range(m, 0, -1):\n\t\tans += t * comb(m, r) * pow(r, n, mod)\n\t\tans %= mod\n\t\tt *= -1\n\tans *= comb(n, m) * 2\n\tans %= mod\n\treturn ans\n\ndef main():\n\t(n, k) = map(int, input().split())\n\tans = solve(n, k)\n\tsys.stdout.write(str(ans) + '\\n')\nmain()\n",
      "MOD = 998244353\nN = 200007\nfac = [1] * N\nfor i in range(1, N):\n\tfac[i] = i * fac[i - 1] % MOD\n\ndef inv(n):\n\treturn pow(n, MOD - 2, MOD)\n\ndef nCk(n, k):\n\treturn fac[n] * inv(fac[k] * fac[n - k] % MOD) % MOD\n\ndef nSk(n, k):\n\tres = 0\n\tfor i in range(1, k + 1):\n\t\tres = (res + pow(-1, k - i) * nCk(k, i) * pow(i, n, MOD)) % MOD\n\treturn res\n(n, k) = map(int, input().split())\nres = None\nif k == 0:\n\tres = fac[n]\nelif k >= n:\n\tres = 0\nelse:\n\tres = 2 * nCk(n, k) * nSk(n, n - k) % MOD\nprint(res)\n",
      "def read_int():\n\treturn int(input())\n\ndef read_ints():\n\treturn list(map(int, input().split(' ')))\nfac = [1]\nrev = []\nmod = 998244353\n\ndef fexp(x, y):\n\tans = 1\n\twhile y > 0:\n\t\tif y % 2 == 1:\n\t\t\tans = ans * x % mod\n\t\tx = x * x % mod\n\t\ty //= 2\n\treturn ans\n\ndef comb(n, k):\n\treturn fac[n] * rev[k] * rev[n - k] % mod\n(n, k) = read_ints()\nif k >= n:\n\tprint(0)\nelse:\n\tfor i in range(1, n + 5):\n\t\tfac.append(fac[-1] * i % mod)\n\tfor i in range(n + 5):\n\t\trev.append(fexp(fac[i], mod - 2))\n\tif k == 0:\n\t\tprint(fac[n])\n\telse:\n\t\tways = comb(n, k)\n\t\tcol = 0\n\t\tfor i in range(n - k):\n\t\t\tsign = 1 if i % 2 == 0 else -1\n\t\t\tcol += sign * comb(n - k, i) * fexp(n - k - i, n)\n\t\t\tcol %= mod\n\t\t\tif col < 0:\n\t\t\t\tcol += mod\n\t\tprint(ways * col * 2 % mod)\n",
      "class Combination:\n\n\tdef __init__(self, n_max, mod=10 ** 9 + 7):\n\t\tself.mod = mod\n\t\tf = 1\n\t\tself.fac = fac = [f]\n\t\tfor i in range(1, n_max + 1):\n\t\t\tf = f * i % mod\n\t\t\tfac.append(f)\n\t\tf = pow(f, mod - 2, mod)\n\t\tself.facinv = facinv = [f]\n\t\tfor i in range(n_max, 0, -1):\n\t\t\tf = f * i % mod\n\t\t\tfacinv.append(f)\n\t\tfacinv.reverse()\n\n\tdef __call__(self, n, r):\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef C(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef P(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[n - r] % self.mod\n\n\tdef H(self, n, r):\n\t\tif n == 0 and r > 0 or r < 0:\n\t\t\treturn 0\n\t\treturn self.fac[n + r - 1] * self.facinv[r] % self.mod * self.facinv[n - 1] % self.mod\n\n\tdef rising_factorial(self, n, r):\n\t\treturn self.fac[n + r - 1] * self.facinv[n - 1] % self.mod\n\n\tdef stirling_first(self, n, k):\n\t\tif n == k:\n\t\t\treturn 1\n\t\tif k == 0:\n\t\t\treturn 0\n\t\treturn (self.stirling_first(n - 1, k - 1) + (n - 1) * self.stirling_first(n - 1, k)) % self.mod\n\n\tdef stirling_second(self, n, k):\n\t\tif n == k:\n\t\t\treturn 1\n\t\treturn self.facinv[k] * sum(((-1) ** (k - m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k + 1))) % self.mod\n\n\tdef balls_and_boxes_3(self, n, k):\n\t\treturn sum(((-1) ** (k - m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k + 1))) % self.mod\n\n\tdef bernoulli(self, n):\n\t\tif n == 0:\n\t\t\treturn 1\n\t\tif n % 2 and n >= 3:\n\t\t\treturn 0\n\t\treturn -pow(n + 1, self.mod - 2, self.mod) * sum((self.C(n + 1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n\tdef faulhaber(self, k, n):\n\t\treturn pow(k + 1, self.mod - 2, self.mod) * sum((self.C(k + 1, j) * self.bernoulli(j) % self.mod * pow(n, k - j + 1, self.mod) % self.mod for j in range(k + 1))) % self.mod\n\n\tdef lah(self, n, k):\n\t\treturn self.C(n - 1, k - 1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n\tdef bell(self, n, k):\n\t\treturn sum((self.stirling_second(n, j) for j in range(1, k + 1))) % self.mod\n(N, K) = map(int, input().split())\nmod = 998244353\nif K == 0:\n\tans = 1\n\tfor i in range(1, N + 1):\n\t\tans = ans * i % mod\n\tprint(ans)\n\texit()\nif K >= N:\n\tprint(0)\n\texit()\ncomb = Combination(200002, mod=mod)\nprint(comb.balls_and_boxes_3(N, N - K) * comb(N, K) * 2 % mod)\n",
      "def modpow(b, e, mod):\n\tret = 1\n\tpw = b\n\twhile e > 0:\n\t\tif e % 2 == 1:\n\t\t\tret = ret * pw % mod\n\t\te = e >> 1\n\t\tpw = pw * pw % mod\n\treturn ret\n(n, k) = list(map(int, input().split()))\nmod = 998244353\ninv = [0 for _ in range(n + 1)]\nfac = [0 for _ in range(n + 1)]\nfac[0] = inv[0] = 1\nfor i in range(n):\n\tfac[i + 1] = fac[i] * (i + 1) % mod\n\tinv[i + 1] = modpow(fac[i + 1], mod - 2, mod)\n\ndef nCr(n, r):\n\tnum = fac[n]\n\tden = inv[r] * inv[n - r] % mod\n\treturn num * den % mod\nrow = n - k\nif row < 0 or row > n:\n\tprint('0')\nelse:\n\tans = 0\n\tfor i in range(row):\n\t\tadd = nCr(row, i) * modpow(row - i, n, mod) % mod\n\t\tif i % 2 == 0:\n\t\t\tans = ans + add\n\t\telse:\n\t\t\tans = ans - add\n\tans = mod + ans % mod\n\tmult = 2\n\tif row == n:\n\t\tmult = 1\n\tprint(mult * nCr(n, row) * ans % mod)\n",
      "def modfac(n, MOD):\n\tf = 1\n\tfactorials = [1]\n\tfor m in range(1, n + 1):\n\t\tf *= m\n\t\tf %= MOD\n\t\tfactorials.append(f)\n\tinv = pow(f, MOD - 2, MOD)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor m in range(n, 1, -1):\n\t\tinv *= m\n\t\tinv %= MOD\n\t\tinvs[m - 1] = inv\n\treturn (factorials, invs)\n\ndef modnCr(n, r, mod, fac, inv):\n\treturn fac[n] * inv[n - r] * inv[r] % mod\n(n, k) = map(int, input().split())\nmod = 998244353\nN = n\nif k >= N:\n\tprint(0)\nelif k == 0:\n\tans = 1\n\tfor i in range(1, N + 1):\n\t\tans *= i\n\t\tans %= mod\n\tprint(ans)\nelse:\n\t(fac, inv) = modfac(n * 2 + 10, mod)\n\tans = modnCr(n, k, mod, fac, inv)\n\tr = N - k\n\tp = N\n\tna = 0\n\tfor i in range(r):\n\t\tnow = modnCr(r, i, mod, fac, inv) * pow(r - i, p, mod)\n\t\tif i % 2 == 0:\n\t\t\tna += now\n\t\telse:\n\t\t\tna -= now\n\t\tna %= mod\n\tprint(ans * na * 2 % mod)\n",
      "from bisect import *\nfrom collections import *\nfrom math import gcd, ceil, sqrt, floor, inf\nfrom heapq import *\nfrom itertools import *\nfrom functools import *\nfrom collections import deque\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\nfarr = [1]\nifa = []\n\ndef fact(x, mod=0):\n\tif mod:\n\t\twhile x >= len(farr):\n\t\t\tfarr.append(farr[-1] * len(farr) % mod)\n\telse:\n\t\twhile x >= len(farr):\n\t\t\tfarr.append(farr[-1] * len(farr))\n\treturn farr[x]\n\ndef ifact(x, mod):\n\tglobal ifa\n\tfact(x, mod)\n\tifa.append(pow(farr[-1], mod - 2, mod))\n\tfor i in range(x, 0, -1):\n\t\tifa.append(ifa[-1] * i % mod)\n\tifa.reverse()\n\ndef per(i, j, mod=0):\n\tif i < j:\n\t\treturn 0\n\tif not mod:\n\t\treturn fact(i) // fact(i - j)\n\treturn farr[i] * ifa[i - j] % mod\n\ndef com(i, j, mod=0):\n\tif i < j:\n\t\treturn 0\n\tif not mod:\n\t\treturn per(i, j) // fact(j)\n\treturn per(i, j, mod) * ifa[j] % mod\n\ndef catalan(n):\n\treturn com(2 * n, n) // (n + 1)\n\ndef isprime(n):\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef lowbit(n):\n\treturn n & -n\n\ndef inverse(a, m):\n\ta %= m\n\tif a <= 1:\n\t\treturn a\n\treturn (1 - inverse(m, a) * m) // a % m\n\nclass BIT:\n\n\tdef __init__(self, arr):\n\t\tself.arr = arr\n\t\tself.n = len(arr) - 1\n\n\tdef update(self, x, v):\n\t\twhile x <= self.n:\n\t\t\tself.arr[x] += v\n\t\t\tx += x & -x\n\n\tdef query(self, x):\n\t\tans = 0\n\t\twhile x:\n\t\t\tans += self.arr[x]\n\t\t\tx &= x - 1\n\t\treturn ans\n\nclass DSU:\n\n\tdef __init__(self, n):\n\t\tself.c = [-1] * n\n\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef find(self, x):\n\t\tif self.c[x] < 0:\n\t\t\treturn x\n\t\tself.c[x] = self.find(self.c[x])\n\t\treturn self.c[x]\n\n\tdef union(self, u, v):\n\t\t(u, v) = (self.find(u), self.find(v))\n\t\tif u == v:\n\t\t\treturn False\n\t\tif self.c[u] > self.c[v]:\n\t\t\t(u, v) = (v, u)\n\t\tself.c[u] += self.c[v]\n\t\tself.c[v] = u\n\t\treturn True\n\n\tdef size(self, x):\n\t\treturn -self.c[self.find(x)]\n\nclass UFS:\n\n\tdef __init__(self, n):\n\t\tself.parent = [i for i in range(n)]\n\t\tself.ranks = [0] * n\n\n\tdef find(self, x):\n\t\tif x != self.parent[x]:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, u, v):\n\t\t(pu, pv) = (self.find(u), self.find(v))\n\t\tif pu == pv:\n\t\t\treturn False\n\t\tif self.ranks[pu] >= self.ranks[pv]:\n\t\t\tself.parent[pv] = pu\n\t\t\tif self.ranks[pv] == self.ranks[pu]:\n\t\t\t\tself.ranks[pu] += 1\n\t\telse:\n\t\t\tself.parent[pu] = pv\n\ndef Prime(n):\n\tc = 0\n\tprime = []\n\tflag = [0] * (n + 1)\n\tfor i in range(2, n + 1):\n\t\tif not flag[i]:\n\t\t\tprime.append(i)\n\t\t\tc += 1\n\t\tfor j in range(c):\n\t\t\tif i * prime[j] > n:\n\t\t\t\tbreak\n\t\t\tflag[i * prime[j]] = prime[j]\n\t\t\tif i % prime[j] == 0:\n\t\t\t\tbreak\n\treturn prime\n\ndef dij(s, graph):\n\td = {}\n\td[s] = 0\n\theap = [(0, s)]\n\tseen = set()\n\twhile heap:\n\t\t(dis, u) = heappop(heap)\n\t\tif u in seen:\n\t\t\tcontinue\n\t\tseen.add(u)\n\t\tfor (v, w) in graph[u]:\n\t\t\tif v not in d or d[v] > d[u] + w:\n\t\t\t\td[v] = d[u] + w\n\t\t\t\theappush(heap, (d[v], v))\n\treturn d\n\ndef GP(it):\n\treturn [[ch, len(list(g))] for (ch, g) in groupby(it)]\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\nclass DLN:\n\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.pre = None\n\t\tself.next = None\n\ndef nb(i, j):\n\tfor (ni, nj) in [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]]:\n\t\tif 0 <= ni < n and 0 <= nj < m:\n\t\t\tyield (ni, nj)\n\n@bootstrap\ndef gdfs(r, p):\n\tif len(g[r]) == 1 and p != -1:\n\t\tyield None\n\tfor ch in g[r]:\n\t\tif ch != p:\n\t\t\tyield gdfs(ch, r)\n\tyield None\n\ndef topo(n):\n\tq = deque()\n\tres = []\n\tfor i in range(1, n + 1):\n\t\tif ind[i] == 0:\n\t\t\tq.append(i)\n\t\t\tres.append(i)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor v in g[u]:\n\t\t\tind[v] -= 1\n\t\t\tif ind[v] == 0:\n\t\t\t\tq.append(v)\n\t\t\t\tres.append(v)\n\treturn res\n\ndef cal(x):\n\t(d, m) = divmod(x, p)\n\tans = d * b\n\tif m:\n\t\tif m < b:\n\t\t\tans += m\n\t\telse:\n\t\t\tans += b - 1\n\treturn ans\nt = 1\nfor i in range(t):\n\t(n, k) = RL()\n\tans = 0\n\tmod = 998244353\n\tifact(n, mod)\n\tif k == 0:\n\t\tans = fact(n, mod)\n\telif k >= n:\n\t\tans = 0\n\telse:\n\t\tc = n - k\n\t\tans = 0\n\t\tfor i in range(c):\n\t\t\tif not i & 1:\n\t\t\t\tans += com(c, i, mod) * pow(c - i, n, mod) % mod\n\t\t\telse:\n\t\t\t\tans -= com(c, i, mod) * pow(c - i, n, mod) % mod\n\t\t\tans %= mod\n\t\tans = ans * 2 * com(n, c, mod) % mod\n\tprint(ans)\n",
      "class Combination:\n\n\tdef __init__(self, n, MOD):\n\t\tself.fact = [1]\n\t\tfor i in range(1, n + 1):\n\t\t\tself.fact.append(self.fact[-1] * i % MOD)\n\t\tself.inv_fact = [0] * (n + 1)\n\t\tself.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n\t\tfor i in reversed(range(n)):\n\t\t\tself.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n\t\tself.MOD = MOD\n\n\tdef factorial(self, k):\n\t\treturn self.fact[k]\n\n\tdef inverse_factorial(self, k):\n\t\treturn self.inv_fact[k]\n\n\tdef permutation(self, k, r):\n\t\tif k < r:\n\t\t\treturn 0\n\t\treturn self.fact[k] * self.inv_fact[k - r] % self.MOD\n\n\tdef combination(self, k, r):\n\t\tif k < r:\n\t\t\treturn 0\n\t\treturn self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r] % self.MOD\n(n, k) = map(int, input().split())\nMOD = 998244353\ncomb = Combination(10 ** 6, MOD)\nball = n\nbox = n - k\nif box <= 0:\n\tprint(0)\n\treturn\nans = 0\nfor i in range(box + 1):\n\tans += pow(-1, i, MOD) * comb.combination(box, i) * pow(box - i, ball, MOD)\n\tans %= MOD\nif k == 0:\n\tprint(ans * comb.combination(n, box) % MOD)\nelse:\n\tprint(ans * comb.combination(n, box) * 2 % MOD)\n",
      "mod = 998244353\neps = 10 ** (-9)\n\ndef main():\n\timport sys\n\tinput = sys.stdin.readline\n\tnmax = 2 * 10 ** 5 + 10\n\tfac = [0] * nmax\n\tfinv = [0] * nmax\n\tinv = [0] * nmax\n\tfac[0] = 1\n\tfac[1] = 1\n\tfinv[0] = 1\n\tfinv[1] = 1\n\tinv[1] = 1\n\tfor i in range(2, nmax):\n\t\tfac[i] = fac[i - 1] * i % mod\n\t\tinv[i] = mod - inv[mod % i] * (mod // i) % mod\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod\n\n\tdef comb(n, r):\n\t\tif n < r:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\t(N, K) = map(int, input().split())\n\tif K >= N:\n\t\tprint(0)\n\t\texit()\n\tans = 0\n\tflg = 1\n\tfor i in range(N - K, 0, -1):\n\t\tans = (ans + flg * comb(N - K, i) * pow(i, N, mod)) % mod\n\t\tflg *= -1\n\tans = ans * comb(N, N - K) % mod\n\tif K:\n\t\tans = ans * 2 % mod\n\tprint(ans)\nmain()\n",
      "mod = 998244353\n(n, k) = map(int, input().split())\nfact = [1]\nfor i in range(1, n + 1):\n\tfact.append(fact[-1] * i % mod)\nrevfact = [1]\nfor i in range(1, n + 1):\n\trevfact.append(pow(fact[i], mod - 2, mod))\nif k >= n:\n\tprint(0)\nelif k == 0:\n\tprint(fact[n])\nelse:\n\tans = 0\n\tfor i in range(n - k + 1):\n\t\tif i % 2 == 0:\n\t\t\tans += pow(n - k - i, n, mod) * fact[n - k] * revfact[i] * revfact[n - k - i]\n\t\t\tans %= mod\n\t\telse:\n\t\t\tans -= pow(n - k - i, n, mod) * fact[n - k] * revfact[i] * revfact[n - k - i]\n\t\t\tans %= mod\n\tprint(ans * fact[n] * revfact[k] * revfact[n - k] * 2 % mod)\n",
      "import sys\nreadline = sys.stdin.readline\nMOD = 998244353\n\ndef frac(limit):\n\tfrac = [1] * limit\n\tfor i in range(2, limit):\n\t\tfrac[i] = i * frac[i - 1] % MOD\n\tfraci = [None] * limit\n\tfraci[-1] = pow(frac[-1], MOD - 2, MOD)\n\tfor i in range(-2, -limit - 1, -1):\n\t\tfraci[i] = fraci[i + 1] * (limit + i + 1) % MOD\n\treturn (frac, fraci)\n(frac, fraci) = frac(1341398)\n\ndef comb(a, b):\n\tif not a >= b >= 0:\n\t\treturn 0\n\treturn frac[a] * fraci[b] * fraci[a - b] % MOD\n(N, K) = map(int, readline().split())\nif K == 0:\n\tprint(frac[N])\nelif K >= N:\n\tprint(0)\nelse:\n\tres = 0\n\tfor i in range(N - K, 0, -1):\n\t\tres = (res + comb(N - K, i) * (-1) ** ((N - K - i) % 2) * pow(i, N, MOD)) % MOD\n\tprint(2 * comb(N, N - K) * res % MOD)\n"
    ],
    "starter_code": "",
    "input_output": "{\"inputs\": [\"3 2\\n\", \"3 3\\n\", \"4 0\\n\", \"1337 42\\n\", \"1 0\\n\", \"2 0\\n\", \"2 1\\n\", \"3 0\\n\", \"3 1\\n\", \"4 1\\n\", \"4 2\\n\", \"4 3\\n\", \"4 4\\n\", \"4 5\\n\", \"4 6\\n\", \"3000 0\\n\", \"3000 42\\n\", \"3000 1337\\n\", \"3000 3713\\n\", \"3000 2999\\n\", \"3000 3000\\n\", \"1500 1000\\n\", \"3000 4498500\\n\", \"200000 0\\n\", \"200000 1\\n\", \"200000 100\\n\", \"200000 1000\\n\", \"200000 100000\\n\", \"200000 199999\\n\", \"200000 199998\\n\", \"200000 200000\\n\", \"200000 800000\\n\", \"200000 19999900000\\n\", \"200000 3393\\n\", \"4 5\\n\", \"4 3\\n\", \"3000 3000\\n\", \"200000 200000\\n\", \"200000 1000\\n\", \"3000 0\\n\", \"2 1\\n\", \"3 0\\n\", \"4 4\\n\", \"3000 42\\n\", \"4 1\\n\", \"200000 199999\\n\", \"4 6\\n\", \"200000 199998\\n\", \"200000 3393\\n\", \"1 0\\n\", \"3 1\\n\", \"1500 1000\\n\", \"2 0\\n\", \"200000 19999900000\\n\", \"3000 4498500\\n\", \"4 2\\n\", \"3000 3713\\n\", \"3000 2999\\n\", \"200000 0\\n\", \"200000 800000\\n\", \"3000 1337\\n\", \"200000 100000\\n\", \"200000 1\\n\", \"200000 100\\n\", \"3 2\\n\", \"3 3\\n\", \"4 0\\n\", \"1337 42\\n\", \"1 0\\n\", \"5 5\\n\", \"3 1\\n\", \"10 45\\n\", \"200000 19999900000\\n\", \"6 3\\n\", \"7 0\\n\", \"2 0\\n\", \"5 2\\n\", \"100 4950\\n\", \"9 36\\n\", \"50 1225\\n\", \"4 6\\n\", \"200000 1\\n\", \"50000 0\\n\", \"12345 23456\\n\", \"67890 98765\\n\", \"7 4\\n\", \"9 6\\n\", \"1 1\\n\", \"1000 10\\n\", \"7000 15\\n\", \"8888 3333\\n\", \"99999 55555\\n\", \"5 3\\n\", \"6 2\\n\", \"2000 250\\n\", \"90000 1000\\n\", \"6 15\\n\", \"7 21\\n\", \"8 28\\n\", \"20 100\\n\", \"100 100\\n\", \"200 400\\n\", \"300 900\\n\", \"400 1600\\n\", \"500 2500\\n\", \"600 3600\\n\", \"700 4900\\n\", \"800 6400\\n\", \"900 8100\\n\", \"1000 10000\\n\", \"1100 12100\\n\", \"1200 14400\\n\", \"1300 16900\\n\", \"1400 19600\\n\", \"1500 22500\\n\", \"1600 25600\\n\", \"1700 28900\\n\", \"1800 32400\\n\", \"1900 36100\\n\", \"2000 40000\\n\", \"2100 44100\\n\", \"2200 48400\\n\", \"2300 52900\\n\", \"2400 57600\\n\", \"2500 62500\\n\", \"2600 67600\\n\", \"2700 72900\\n\", \"2800 78400\\n\", \"2900 84100\\n\", \"3000 90000\\n\", \"6 10\\n\", \"7 10\\n\", \"8 10\\n\", \"9 40\\n\", \"11 55\\n\", \"12 66\\n\", \"13 78\\n\", \"14 91\\n\", \"15 105\\n\", \"16 120\\n\", \"17 136\\n\", \"18 153\\n\", \"19 171\\n\", \"20 190\\n\", \"21 210\\n\", \"22 231\\n\", \"23 253\\n\", \"24 276\\n\", \"25 300\\n\", \"26 325\\n\", \"27 351\\n\", \"28 378\\n\", \"29 406\\n\", \"30 435\\n\", \"2 1\\n\", \"5 0\\n\", \"6 12\\n\", \"10 0\\n\", \"50 100\\n\", \"10 2\\n\", \"15 5\\n\", \"10 10\\n\", \"20 15\\n\", \"200 150\\n\", \"1000 500\\n\", \"1500 500\\n\", \"900 60\\n\", \"850 160\\n\", \"1999 150\\n\", \"10000 5000\\n\", \"100 50\\n\", \"25000 12500\\n\", \"123456 65432\\n\", \"199999 99999\\n\", \"200000 100000\\n\", \"3000 1500\\n\", \"15000 7500\\n\", \"100000 50000\\n\", \"170000 85000\\n\", \"180000 90000\\n\", \"12345 1234\\n\", \"56789 28394\\n\", \"159753 79876\\n\", \"30000 15000\\n\", \"5 10\\n\", \"200000 0\\n\", \"99999 4999850001\\n\", \"15000 112447500\\n\", \"5000 12497500\\n\", \"10000 49995000\\n\", \"30000 449955000\\n\", \"100000 4999950000\\n\", \"200000 2\\n\", \"200000 199999\\n\", \"200000 200000\\n\", \"50 45\\n\", \"5000 2500\\n\", \"20000 10000\\n\", \"35000 17500\\n\", \"40000 20000\\n\", \"45000 22500\\n\", \"50000 25000\\n\", \"50000 1249975000\\n\", \"2000 1999000\\n\", \"199999 19999800001\\n\", \"1000 499500\\n\", \"6843 23407436\\n\", \"2222 2465631\\n\", \"54321 1475341540\\n\", \"77777 3025166528\\n\", \"200000 19999800004\\n\", \"14883 110731204\\n\", \"31415 493896357\\n\", \"27182 369492831\\n\", \"199999 19999700003\\n\", \"199998 19999400006\\n\", \"123456 7620784906\\n\", \"5 4\\n\", \"6 6\\n\", \"1001 501500\\n\", \"49876 1243802500\\n\", \"17654 155830330\\n\", \"913 416416\\n\", \"342 58383\\n\", \"45321 1026801400\\n\", \"34789 603547296\\n\", \"4 7\\n\", \"200000 132521\\n\", \"30875 1000\\n\", \"2094 0\\n\", \"6 0\\n\", \"7 4\\n\", \"3000 78\\n\", \"5 0\\n\", \"200000 89177\\n\", \"200000 3093\\n\", \"7 0\\n\", \"5764 3713\\n\", \"4632 2999\\n\", \"2591 1337\\n\", \"200000 110\\n\", \"6 1\\n\", \"2488 42\\n\", \"8 7\\n\", \"4307 1000\\n\", \"4001 0\\n\", \"11 4\\n\", \"3000 92\\n\", \"10 0\\n\", \"124271 89177\\n\", \"200000 3883\\n\", \"9 0\\n\", \"4632 4364\\n\", \"2591 2525\\n\", \"11 1\\n\", \"3543 42\\n\", \"8 2\\n\", \"4307 0000\\n\", \"945 0\\n\", \"15 4\\n\", \"5213 92\\n\", \"42569 3883\\n\", \"12 0\\n\", \"2591 1733\\n\", \"436 3000\\n\", \"49226 199999\\n\", \"3 4\\n\", \"354 1000\\n\", \"200000 26492691161\\n\", \"1179 4498500\\n\", \"200000 666153\\n\", \"3 6\\n\", \"436 4882\\n\", \"114218 132521\\n\", \"49226 334171\\n\", \"354 1100\\n\", \"1179 2209383\\n\", \"1097 3713\\n\", \"200000 1275699\\n\", \"0 2\\n\", \"230 4882\\n\", \"71056 132521\\n\", \"6365 334171\\n\", \"36980 89177\\n\", \"99 1100\\n\", \"1179 1231488\\n\", \"404 3713\\n\", \"4632 5442\\n\", \"4 0\\n\", \"3 2\\n\", \"1337 42\\n\", \"3 3\\n\"], \"outputs\": [\"6\\n\", \"0\\n\", \"24\\n\", \"807905441\\n\", \"1\\n\", \"2\\n\", \"4\\n\", \"6\\n\", \"36\\n\", \"288\\n\", \"168\\n\", \"8\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"201761277\\n\", \"281860640\\n\", \"729468301\\n\", \"0\\n\", \"6000\\n\", \"0\\n\", \"229881914\\n\", \"0\\n\", \"638474417\\n\", \"466559115\\n\", \"431967939\\n\", \"13181387\\n\", \"668585001\\n\", \"400000\\n\", \"508670650\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"259194802\\n\", \"0\\n\", \"8\\n\", \"0\\n\", \"0\\n\", \"13181387\\n\", \"201761277\\n\", \"4\\n\", \"6\\n\", \"0\\n\", \"281860640\\n\", \"288\\n\", \"400000\\n\", \"0\\n\", \"508670650\\n\", \"259194802\\n\", \"1\\n\", \"36\\n\", \"229881914\\n\", \"2\\n\", \"0\\n\", \"0\\n\", \"168\\n\", \"0\\n\", \"6000\\n\", \"638474417\\n\", \"0\\n\", \"729468301\\n\", \"668585001\\n\", \"466559115\\n\", \"431967939\\n\", \"6\\n\", \"0\\n\", \"24\\n\", \"807905441\\n\", \"1\\n\", \"0\\n\", \"36\\n\", \"0\\n\", \"0\\n\", \"21600\\n\", \"5040\\n\", \"2\\n\", \"3000\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"466559115\\n\", \"734256002\\n\", \"0\\n\", \"0\\n\", \"126420\\n\", \"3049200\\n\", \"0\\n\", \"841194342\\n\", \"566250587\\n\", \"522006524\\n\", \"815917837\\n\", \"600\\n\", \"46800\\n\", \"33742983\\n\", \"506283791\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"4\\n\", \"120\\n\", \"0\\n\", \"3628800\\n\", \"0\\n\", \"725111294\\n\", \"678938799\\n\", \"0\\n\", \"169041245\\n\", \"706962750\\n\", \"946281262\\n\", \"949578520\\n\", \"490875818\\n\", \"937942228\\n\", \"538710057\\n\", \"103365073\\n\", \"62383071\\n\", \"765091459\\n\", \"467379903\\n\", \"146639259\\n\", \"668585001\\n\", \"583522940\\n\", \"734261527\\n\", \"734134301\\n\", \"950064703\\n\", \"886293851\\n\", \"178021388\\n\", \"621742867\\n\", \"612051691\\n\", \"276868098\\n\", \"0\\n\", \"638474417\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"373972043\\n\", \"400000\\n\", \"0\\n\", \"729952322\\n\", \"906728515\\n\", \"339719186\\n\", \"425701748\\n\", \"357364325\\n\", \"289818629\\n\", \"364374510\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"10\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"660798392\\n\", \"45848221\\n\", \"552437276\\n\", \"720\\n\", \"126420\\n\", \"784900207\\n\", \"120\\n\", \"773611800\\n\", \"395522989\\n\", \"5040\\n\", \"709890387\\n\", \"654932331\\n\", \"320382228\\n\", \"824308468\\n\", \"21600\\n\", \"329482299\\n\", \"16\\n\", \"261523254\\n\", \"846183233\\n\", \"220309611\\n\", \"748741394\\n\", \"3628800\\n\", \"535280058\\n\", \"959684298\\n\", \"362880\\n\", \"39004266\\n\", \"536532666\\n\", \"397870588\\n\", \"128587371\\n\", \"10725120\\n\", \"406193428\\n\", \"32030240\\n\", \"292464441\\n\", \"728186961\\n\", \"175008997\\n\", \"479001600\\n\", \"865597061\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"0\\n\", \"24\\n\", \"6\\n\", \"807905441\\n\", \"0\\n\"]}",
    "difficulty": "HARD",
    "raw_tags": "['combinatorics', 'fft', 'math']",
    "name": null,
    "source": "codeforces",
    "tags": "['Polynomials and generating functions', 'Combinatorics', 'Mathematics']",
    "skill_types": "[]",
    "url": "https://codeforces.com/problemset/problem/1342/E",
    "Expected Auxiliary Space": null,
    "time_limit": "2 seconds",
    "date": "2020-04-26",
    "picture_num": "1",
    "memory_limit": "512 megabytes",
    "Expected Time Complexity": null,
    "human_solution": "(n, k) = map(int, input().split())\ntuk = n - k\nhell = 998244353\nif tuk <= 0:\n\tprint(0)\n\texit(0)\nfact = [1] * 200005\nfor i in range(2, 200005):\n\tfact[i] = i * fact[i - 1] % hell\n\ndef C(n, r):\n\tans = 1\n\tans = fact[r] * fact[n - r] % hell\n\tans = fact[n] * pow(ans, hell - 2, hell) % hell\n\treturn ans\nans = C(n, tuk)\nif k != 0:\n\tans *= 2\nres = 0\nfor i in range(tuk):\n\tt = C(tuk, i) * pow(tuk - i, n, hell) % hell\n\tif i % 2:\n\t\tres = (res - t + hell) % hell\n\telse:\n\t\tres = (res + t) % hell\nans = ans * res % hell\nprint(ans)\n",
    "o3_mini_solution": "#!/usr/bin/env python3\nMOD = 998244353\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    # In any placement of n rooks in an n\u00d7n board,\n    # an empty cell at (i,j) is under attack if there is at least one rook in its row or in its column.\n    #\n    # One may check that in any valid configuration (where every empty cell is attacked)\n    # it must be that either every row has a rook or every column has a rook.\n    # With exactly n rooks, these two families are described as:\n    #  \u2022 Row-based assignments: each row gets exactly one rook (but columns may repeat).\n    #  \u2022 Column-based assignments: each column gets exactly one rook (but rows may repeat).\n    # Note that the intersection of these two families are the permutation placements\n    # (where each row and each column gets exactly one rook).\n    #\n    # Two rooks attack each other if they are consecutive in a row or column line.\n    # In a row-based assignment (one rook per row), the only attacking pairs come from columns.\n    # Namely, if column j is chosen by r_j rows then the rooks there contribute (r_j - 1) pairs.\n    # The total pairs from columns equal:\n    #    sum_{j with r_j>=1} (r_j \u2013 1) = (sum_j r_j) - (# of columns that appear)\n    #                           = n - (# of distinct columns used).\n    # Thus for a row-based placement, if the number of distinct columns used is d,\n    # the number of attacking pairs is n - d.\n    # We want it to equal k so that d = n - k.\n    #\n    # Counting row-based placements with exactly one rook per row:\n    #  For each row, we choose one column. A function f : [n] -> [n] has\n    #  exactly d distinct values if and only if its image is some d-element subset S of {1,\u2026,n} and\n    #  f is onto S.\n    # The number of choices for S is C(n, d),\n    # and the number of onto functions from [n] onto S is d! * S(n, d)\n    # where S(n, d) is the Stirling number of the second kind.\n    #\n    # There is a well\u2013known formula for S(n,d):\n    #    S(n,d) = (1/d!) * sum_{i=0}^d (-1)^(d-i) * C(d, i) * i^n.\n    # Thus the number of onto functions is:\n    #    d! * S(n,d) = sum_{i=0}^d (-1)^(d-i) * C(d, i) * i^n.\n    #\n    # Let d = n - k.\n    # Then the number of row\u2013based placements with exactly k attacking pairs is:\n    #    Count_R = C(n, d) * sum_{i=0}^{d} (-1)^(d-i) * C(d, i) * i^n.\n    # (Note: the term for i=0 is 0^n=0 since n>=1.)\n    #\n    # Similarly, we can count column\u2013based placements.\n    # Their count is the same:\n    #    Count_C = Count_R.\n    #\n    # However, placements that are both row-based and column-based are exactly the n! permutation placements.\n    # In a permutation placement each row and each column has exactly one rook so there are 0 attacking pairs.\n    # Hence these permutation placements are only valid for k == 0.\n    #\n    # By inclusion\u2013exclusion the total answer is:\n    #    Answer = Count_R + Count_C - (n! if k == 0 else 0).\n    #\n    # Note: For a row-based assignment the number of attacking pairs equals n - (# distinct columns).\n    # So clearly we can only have k <= n-1.\n    # If k > n-1 then the answer is 0.\n    \n    if k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    d = n - k  # the number of distinct columns used (for row-based) must equal n-k.\n    \n    # Precompute factorials and inverse factorials up to n.\n    maxN = n\n    fact = [1]*(maxN+1)\n    invfact = [1]*(maxN+1)\n    for i in range(2, maxN+1):\n        fact[i] = fact[i-1]*i % MOD\n    invfact[maxN] = pow(fact[maxN], MOD-2, MOD)\n    for i in range(maxN, 0, -1):\n        invfact[i-1] = invfact[i]*i % MOD\n\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * invfact[b] % MOD * invfact[a-b] % MOD\n\n    # Compute S = sum_{i=0}^{d} (-1)^(d-i) * C(d, i) * i^n mod MOD.\n    # For i = 0 the term is 0 (since n>=1) so we can start at 1.\n    ssum = 0\n    for i in range(1, d+1):\n        # Compute sign = (-1)^(d-i). We use: if (d-i) is odd, sign = -1, else sign = 1.\n        if ((d - i) & 1):\n            sign = MOD - 1\n        else:\n            sign = 1\n        comb = nCr(d, i)\n        power = pow(i, n, MOD)\n        term = sign * comb % MOD * power % MOD\n        ssum = (ssum + term) % MOD\n    \n    count_R = nCr(n, d) * ssum % MOD\n    count_C = count_R  # symmetric\n    \n    inter = fact[n] if k == 0 else 0  # permutation placements (double\u2013counted) appear only when k==0.\n    \n    ans = (count_R + count_C - inter) % MOD\n    sys.stdout.write(str(ans))\n    \nif __name__ == '__main__':\n    main()",
    "prompt": "\nYou are an expert programming problem solver. Please solve the following problem with a complete, runnable solution.\n\nProblem:\nCalculate the number of ways to place $n$ rooks on $n \\times n$ chessboard so that both following conditions are met:\n\n  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. \n\nAn empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:\n\n [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ \n\nTwo ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.\n\nThe answer might be large, so print it modulo $998244353$.\n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 200000$; $0 \\le k \\le \\frac{n(n - 1)}{2}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of ways to place the rooks, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\nInput\n3 3\n\nOutput\n0\n\nInput\n4 0\n\nOutput\n24\n\nInput\n1337 42\n\nOutput\n807905441\n\n## Example Test Cases\n\n### Test Case 1\n**Input:**\n```\n3 2\n\n```\n\n**Expected Output:**\n```\n6\n\n```\n\n### Test Case 2\n**Input:**\n```\n3 3\n\n```\n\n**Expected Output:**\n```\n0\n\n```\n\n### Test Case 3\n**Input:**\n```\n4 0\n\n```\n\n**Expected Output:**\n```\n24\n\n```\n\n\n## Requirements\n1. Your solution MUST read all input from standard input (stdin) and write to standard output (stdout)\n2. Include ALL necessary code to parse input and format output correctly\n3. Your solution must pass ALL test cases and handle edge cases\n4. Provide a fully executable solution - this code will be run as-is without modification\n5. Do not include explanatory text or comments outside of your code block\n\n## Solution\nPlease write your complete solution below:\n\n```python\n# Your solution code here\n```\n",
    "problem": "Calculate the number of ways to place $n$ rooks on $n \\times n$ chessboard so that both following conditions are met:\n\n  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. \n\nAn empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:\n\n [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ \n\nTwo ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.\n\nThe answer might be large, so print it modulo $998244353$.\n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 200000$; $0 \\le k \\le \\frac{n(n - 1)}{2}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of ways to place the rooks, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\nInput\n3 3\n\nOutput\n0\n\nInput\n4 0\n\nOutput\n24\n\nInput\n1337 42\n\nOutput\n807905441",
    "improved_claude_solution": "```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n    # As explained, valid configurations exist only when 0 <= k <= n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n    # Let d = n - k be the number of distinct columns used in the setting \"all rows nonempty\"\n    d = n - k\n\n    # Precompute factorials and inverse factorials up to n.\n    maxN = n\n    fact = [1] * (maxN + 1)\n    invfact = [1] * (maxN + 1)\n    for i in range(2, maxN + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[maxN] = pow(fact[maxN], mod - 2, mod)\n    for i in range(maxN, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n\n    # binom(n, d) = fact[n] * invfact[d] * invfact[n-d]\n    binom_nd = fact[n] * invfact[d] % mod * invfact[n - d] % mod\n\n    # Compute number of surjections from an n-set to a d-set.\n    # This equals: sum_{j=0}^{d} (-1)^j * C(d, j) * (d-j)^n\n    surj = 0\n    for j in range(d + 1):\n        # C(d, j)\n        c = fact[d] * invfact[j] % mod * invfact[d - j] % mod\n        term = c * pow(d - j, n, mod) % mod\n        if j & 1:\n            surj = (surj - term) % mod\n        else:\n            surj = (surj + term) % mod\n\n    # A(n, d): number of functions from rows to columns that use exactly d distinct columns\n    A_nd = binom_nd * surj % mod\n\n    # By symmetry, our answer is:\n    # ans = 2 * A(n, d), but if k==0 the configurations with both all rows and all columns nonempty (permutation matrices)\n    # are counted twice; there are n! of these.\n    ans = (2 * A_nd) % mod\n    if k == 0:\n        ans = (ans - fact[n]) % mod\n\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()\n```"
  }
]