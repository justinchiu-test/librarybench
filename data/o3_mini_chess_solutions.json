[
  {
    "problem": {
      "problem_id": 0,
      "question": "Calculate the number of ways to place $n$ rooks on $n \\times n$ chessboard so that both following conditions are met:\n\n  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. \n\nAn empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:\n\n [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ \n\nTwo ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.\n\nThe answer might be large, so print it modulo $998244353$.\n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 200000$; $0 \\le k \\le \\frac{n(n - 1)}{2}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of ways to place the rooks, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\nInput\n3 3\n\nOutput\n0\n\nInput\n4 0\n\nOutput\n24\n\nInput\n1337 42\n\nOutput\n807905441",
      "tests": [
        {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        {
          "stdin": "3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        {
          "stdin": "3 0\n",
          "stdout": "6\n"
        },
        {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        {
          "stdin": "4 1\n",
          "stdout": "288\n"
        },
        {
          "stdin": "4 2\n",
          "stdout": "168\n"
        },
        {
          "stdin": "4 3\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 0\n",
          "stdout": "201761277\n"
        },
        {
          "stdin": "3000 42\n",
          "stdout": "281860640\n"
        },
        {
          "stdin": "3000 1337\n",
          "stdout": "729468301\n"
        },
        {
          "stdin": "3000 3713\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 2999\n",
          "stdout": "6000\n"
        },
        {
          "stdin": "3000 3000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1500 1000\n",
          "stdout": "229881914\n"
        },
        {
          "stdin": "3000 4498500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        {
          "stdin": "200000 100\n",
          "stdout": "431967939\n"
        },
        {
          "stdin": "200000 1000\n",
          "stdout": "13181387\n"
        },
        {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        {
          "stdin": "200000 199998\n",
          "stdout": "508670650\n"
        },
        {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 800000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 3393\n",
          "stdout": "259194802\n"
        },
        {
          "stdin": "4 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 3\n",
          "stdout": "8\n"
        },
        {
          "stdin": "3000 3000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 1000\n",
          "stdout": "13181387\n"
        },
        {
          "stdin": "3000 0\n",
          "stdout": "201761277\n"
        },
        {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        {
          "stdin": "3 0\n",
          "stdout": "6\n"
        },
        {
          "stdin": "4 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 42\n",
          "stdout": "281860640\n"
        },
        {
          "stdin": "4 1\n",
          "stdout": "288\n"
        },
        {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 199998\n",
          "stdout": "508670650\n"
        },
        {
          "stdin": "200000 3393\n",
          "stdout": "259194802\n"
        },
        {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        {
          "stdin": "1500 1000\n",
          "stdout": "229881914\n"
        },
        {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 4498500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 2\n",
          "stdout": "168\n"
        },
        {
          "stdin": "3000 3713\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 2999\n",
          "stdout": "6000\n"
        },
        {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        {
          "stdin": "200000 800000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 1337\n",
          "stdout": "729468301\n"
        },
        {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        {
          "stdin": "200000 100\n",
          "stdout": "431967939\n"
        },
        {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        {
          "stdin": "3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        {
          "stdin": "5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        {
          "stdin": "10 45\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "6 3\n",
          "stdout": "21600\n"
        },
        {
          "stdin": "7 0\n",
          "stdout": "5040\n"
        },
        {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        {
          "stdin": "5 2\n",
          "stdout": "3000\n"
        },
        {
          "stdin": "100 4950\n",
          "stdout": "0\n"
        },
        {
          "stdin": "9 36\n",
          "stdout": "0\n"
        },
        {
          "stdin": "50 1225\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        {
          "stdin": "50000 0\n",
          "stdout": "734256002\n"
        },
        {
          "stdin": "12345 23456\n",
          "stdout": "0\n"
        },
        {
          "stdin": "67890 98765\n",
          "stdout": "0\n"
        },
        {
          "stdin": "7 4\n",
          "stdout": "126420\n"
        },
        {
          "stdin": "9 6\n",
          "stdout": "3049200\n"
        },
        {
          "stdin": "1 1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1000 10\n",
          "stdout": "841194342\n"
        },
        {
          "stdin": "7000 15\n",
          "stdout": "566250587\n"
        },
        {
          "stdin": "8888 3333\n",
          "stdout": "522006524\n"
        },
        {
          "stdin": "99999 55555\n",
          "stdout": "815917837\n"
        },
        {
          "stdin": "5 3\n",
          "stdout": "600\n"
        },
        {
          "stdin": "6 2\n",
          "stdout": "46800\n"
        },
        {
          "stdin": "2000 250\n",
          "stdout": "33742983\n"
        },
        {
          "stdin": "90000 1000\n",
          "stdout": "506283791\n"
        },
        {
          "stdin": "6 15\n",
          "stdout": "0\n"
        },
        {
          "stdin": "7 21\n",
          "stdout": "0\n"
        },
        {
          "stdin": "8 28\n",
          "stdout": "0\n"
        },
        {
          "stdin": "20 100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "100 100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200 400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "300 900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "400 1600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "500 2500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "600 3600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "700 4900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "800 6400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "900 8100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1000 10000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1100 12100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1200 14400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1300 16900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1400 19600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1500 22500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1600 25600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1700 28900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1800 32400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1900 36100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2000 40000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2100 44100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2200 48400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2300 52900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2400 57600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2500 62500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2600 67600\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2700 72900\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2800 78400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2900 84100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3000 90000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "6 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "7 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "8 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "9 40\n",
          "stdout": "0\n"
        },
        {
          "stdin": "11 55\n",
          "stdout": "0\n"
        },
        {
          "stdin": "12 66\n",
          "stdout": "0\n"
        },
        {
          "stdin": "13 78\n",
          "stdout": "0\n"
        },
        {
          "stdin": "14 91\n",
          "stdout": "0\n"
        },
        {
          "stdin": "15 105\n",
          "stdout": "0\n"
        },
        {
          "stdin": "16 120\n",
          "stdout": "0\n"
        },
        {
          "stdin": "17 136\n",
          "stdout": "0\n"
        },
        {
          "stdin": "18 153\n",
          "stdout": "0\n"
        },
        {
          "stdin": "19 171\n",
          "stdout": "0\n"
        },
        {
          "stdin": "20 190\n",
          "stdout": "0\n"
        },
        {
          "stdin": "21 210\n",
          "stdout": "0\n"
        },
        {
          "stdin": "22 231\n",
          "stdout": "0\n"
        },
        {
          "stdin": "23 253\n",
          "stdout": "0\n"
        },
        {
          "stdin": "24 276\n",
          "stdout": "0\n"
        },
        {
          "stdin": "25 300\n",
          "stdout": "0\n"
        },
        {
          "stdin": "26 325\n",
          "stdout": "0\n"
        },
        {
          "stdin": "27 351\n",
          "stdout": "0\n"
        },
        {
          "stdin": "28 378\n",
          "stdout": "0\n"
        },
        {
          "stdin": "29 406\n",
          "stdout": "0\n"
        },
        {
          "stdin": "30 435\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        {
          "stdin": "5 0\n",
          "stdout": "120\n"
        },
        {
          "stdin": "6 12\n",
          "stdout": "0\n"
        },
        {
          "stdin": "10 0\n",
          "stdout": "3628800\n"
        },
        {
          "stdin": "50 100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "10 2\n",
          "stdout": "725111294\n"
        },
        {
          "stdin": "15 5\n",
          "stdout": "678938799\n"
        },
        {
          "stdin": "10 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "20 15\n",
          "stdout": "169041245\n"
        },
        {
          "stdin": "200 150\n",
          "stdout": "706962750\n"
        },
        {
          "stdin": "1000 500\n",
          "stdout": "946281262\n"
        },
        {
          "stdin": "1500 500\n",
          "stdout": "949578520\n"
        },
        {
          "stdin": "900 60\n",
          "stdout": "490875818\n"
        },
        {
          "stdin": "850 160\n",
          "stdout": "937942228\n"
        },
        {
          "stdin": "1999 150\n",
          "stdout": "538710057\n"
        },
        {
          "stdin": "10000 5000\n",
          "stdout": "103365073\n"
        },
        {
          "stdin": "100 50\n",
          "stdout": "62383071\n"
        },
        {
          "stdin": "25000 12500\n",
          "stdout": "765091459\n"
        },
        {
          "stdin": "123456 65432\n",
          "stdout": "467379903\n"
        },
        {
          "stdin": "199999 99999\n",
          "stdout": "146639259\n"
        },
        {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        {
          "stdin": "3000 1500\n",
          "stdout": "583522940\n"
        },
        {
          "stdin": "15000 7500\n",
          "stdout": "734261527\n"
        },
        {
          "stdin": "100000 50000\n",
          "stdout": "734134301\n"
        },
        {
          "stdin": "170000 85000\n",
          "stdout": "950064703\n"
        },
        {
          "stdin": "180000 90000\n",
          "stdout": "886293851\n"
        },
        {
          "stdin": "12345 1234\n",
          "stdout": "178021388\n"
        },
        {
          "stdin": "56789 28394\n",
          "stdout": "621742867\n"
        },
        {
          "stdin": "159753 79876\n",
          "stdout": "612051691\n"
        },
        {
          "stdin": "30000 15000\n",
          "stdout": "276868098\n"
        },
        {
          "stdin": "5 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        {
          "stdin": "99999 4999850001\n",
          "stdout": "0\n"
        },
        {
          "stdin": "15000 112447500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "5000 12497500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "10000 49995000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "30000 449955000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "100000 4999950000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 2\n",
          "stdout": "373972043\n"
        },
        {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "50 45\n",
          "stdout": "729952322\n"
        },
        {
          "stdin": "5000 2500\n",
          "stdout": "906728515\n"
        },
        {
          "stdin": "20000 10000\n",
          "stdout": "339719186\n"
        },
        {
          "stdin": "35000 17500\n",
          "stdout": "425701748\n"
        },
        {
          "stdin": "40000 20000\n",
          "stdout": "357364325\n"
        },
        {
          "stdin": "45000 22500\n",
          "stdout": "289818629\n"
        },
        {
          "stdin": "50000 25000\n",
          "stdout": "364374510\n"
        },
        {
          "stdin": "50000 1249975000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2000 1999000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "199999 19999800001\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1000 499500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "6843 23407436\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2222 2465631\n",
          "stdout": "0\n"
        },
        {
          "stdin": "54321 1475341540\n",
          "stdout": "0\n"
        },
        {
          "stdin": "77777 3025166528\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 19999800004\n",
          "stdout": "0\n"
        },
        {
          "stdin": "14883 110731204\n",
          "stdout": "0\n"
        },
        {
          "stdin": "31415 493896357\n",
          "stdout": "0\n"
        },
        {
          "stdin": "27182 369492831\n",
          "stdout": "0\n"
        },
        {
          "stdin": "199999 19999700003\n",
          "stdout": "0\n"
        },
        {
          "stdin": "199998 19999400006\n",
          "stdout": "0\n"
        },
        {
          "stdin": "123456 7620784906\n",
          "stdout": "0\n"
        },
        {
          "stdin": "5 4\n",
          "stdout": "10\n"
        },
        {
          "stdin": "6 6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1001 501500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "49876 1243802500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "17654 155830330\n",
          "stdout": "0\n"
        },
        {
          "stdin": "913 416416\n",
          "stdout": "0\n"
        },
        {
          "stdin": "342 58383\n",
          "stdout": "0\n"
        },
        {
          "stdin": "45321 1026801400\n",
          "stdout": "0\n"
        },
        {
          "stdin": "34789 603547296\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 132521\n",
          "stdout": "660798392\n"
        },
        {
          "stdin": "30875 1000\n",
          "stdout": "45848221\n"
        },
        {
          "stdin": "2094 0\n",
          "stdout": "552437276\n"
        },
        {
          "stdin": "6 0\n",
          "stdout": "720\n"
        },
        {
          "stdin": "7 4\n",
          "stdout": "126420\n"
        },
        {
          "stdin": "3000 78\n",
          "stdout": "784900207\n"
        },
        {
          "stdin": "5 0\n",
          "stdout": "120\n"
        },
        {
          "stdin": "200000 89177\n",
          "stdout": "773611800\n"
        },
        {
          "stdin": "200000 3093\n",
          "stdout": "395522989\n"
        },
        {
          "stdin": "7 0\n",
          "stdout": "5040\n"
        },
        {
          "stdin": "5764 3713\n",
          "stdout": "709890387\n"
        },
        {
          "stdin": "4632 2999\n",
          "stdout": "654932331\n"
        },
        {
          "stdin": "2591 1337\n",
          "stdout": "320382228\n"
        },
        {
          "stdin": "200000 110\n",
          "stdout": "824308468\n"
        },
        {
          "stdin": "6 1\n",
          "stdout": "21600\n"
        },
        {
          "stdin": "2488 42\n",
          "stdout": "329482299\n"
        },
        {
          "stdin": "8 7\n",
          "stdout": "16\n"
        },
        {
          "stdin": "4307 1000\n",
          "stdout": "261523254\n"
        },
        {
          "stdin": "4001 0\n",
          "stdout": "846183233\n"
        },
        {
          "stdin": "11 4\n",
          "stdout": "220309611\n"
        },
        {
          "stdin": "3000 92\n",
          "stdout": "748741394\n"
        },
        {
          "stdin": "10 0\n",
          "stdout": "3628800\n"
        },
        {
          "stdin": "124271 89177\n",
          "stdout": "535280058\n"
        },
        {
          "stdin": "200000 3883\n",
          "stdout": "959684298\n"
        },
        {
          "stdin": "9 0\n",
          "stdout": "362880\n"
        },
        {
          "stdin": "4632 4364\n",
          "stdout": "39004266\n"
        },
        {
          "stdin": "2591 2525\n",
          "stdout": "536532666\n"
        },
        {
          "stdin": "11 1\n",
          "stdout": "397870588\n"
        },
        {
          "stdin": "3543 42\n",
          "stdout": "128587371\n"
        },
        {
          "stdin": "8 2\n",
          "stdout": "10725120\n"
        },
        {
          "stdin": "4307 0000\n",
          "stdout": "406193428\n"
        },
        {
          "stdin": "945 0\n",
          "stdout": "32030240\n"
        },
        {
          "stdin": "15 4\n",
          "stdout": "292464441\n"
        },
        {
          "stdin": "5213 92\n",
          "stdout": "728186961\n"
        },
        {
          "stdin": "42569 3883\n",
          "stdout": "175008997\n"
        },
        {
          "stdin": "12 0\n",
          "stdout": "479001600\n"
        },
        {
          "stdin": "2591 1733\n",
          "stdout": "865597061\n"
        },
        {
          "stdin": "436 3000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "49226 199999\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "354 1000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 26492691161\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1179 4498500\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 666153\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3 6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "436 4882\n",
          "stdout": "0\n"
        },
        {
          "stdin": "114218 132521\n",
          "stdout": "0\n"
        },
        {
          "stdin": "49226 334171\n",
          "stdout": "0\n"
        },
        {
          "stdin": "354 1100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1179 2209383\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1097 3713\n",
          "stdout": "0\n"
        },
        {
          "stdin": "200000 1275699\n",
          "stdout": "0\n"
        },
        {
          "stdin": "0 2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "230 4882\n",
          "stdout": "0\n"
        },
        {
          "stdin": "71056 132521\n",
          "stdout": "0\n"
        },
        {
          "stdin": "6365 334171\n",
          "stdout": "0\n"
        },
        {
          "stdin": "36980 89177\n",
          "stdout": "0\n"
        },
        {
          "stdin": "99 1100\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1179 1231488\n",
          "stdout": "0\n"
        },
        {
          "stdin": "404 3713\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4632 5442\n",
          "stdout": "0\n"
        },
        {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        {
          "stdin": "3 3\n",
          "stdout": "0\n"
        }
      ],
      "source": "codeforces",
      "difficulty": "HARD",
      "human_solutions": [
        "(n, k) = map(int, input().split())\ntuk = n - k\nhell = 998244353\nif tuk <= 0:\n\tprint(0)\n\texit(0)\nfact = [1] * 200005\nfor i in range(2, 200005):\n\tfact[i] = i * fact[i - 1] % hell\n\ndef C(n, r):\n\tans = 1\n\tans = fact[r] * fact[n - r] % hell\n\tans = fact[n] * pow(ans, hell - 2, hell) % hell\n\treturn ans\nans = C(n, tuk)\nif k != 0:\n\tans *= 2\nres = 0\nfor i in range(tuk):\n\tt = C(tuk, i) * pow(tuk - i, n, hell) % hell\n\tif i % 2:\n\t\tres = (res - t + hell) % hell\n\telse:\n\t\tres = (res + t) % hell\nans = ans * res % hell\nprint(ans)\n",
        "MOD = 998244353\nlist_size = 200001\nf_list = [1] * list_size\nf_r_list = [1] * list_size\nfor i in range(list_size - 1):\n\tf_list[i + 1] = int(f_list[i] * (i + 2) % MOD)\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = int(f_r_list[-i + 1] * (list_size + 2 - i) % MOD)\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn f_list[n - 1] * f_r_list[n - r - 1] % MOD * f_r_list[r - 1] % MOD\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\nelif k == 0:\n\tprint(f_list[n - 1])\nelse:\n\tans = 0\n\tm = n - k\n\tfor i in range(1, m + 1):\n\t\tans += (-1) ** ((m - i) % 2) * pow(i, n, MOD) * comb(m, i)\n\t\tans %= MOD\n\tans *= f_r_list[m - 1] * f_list[n - 1] * f_r_list[k - 1]\n\tans *= 2\n\tprint(ans % MOD)\n",
        "(n, k) = map(int, input().split())\n\ndef cmb(n, r, mod):\n\tif r < 0 or r > n:\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn g1[n] * g2[r] * g2[n - r] % mod\nmod = 998244353\nN = 200000\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, N + 1):\n\tg1.append(g1[-1] * i % mod)\n\tinverse.append(-inverse[mod % i] * (mod // i) % mod)\n\tg2.append(g2[-1] * inverse[-1] % mod)\nif k == 0:\n\tans = 1\n\tfor i in range(1, n + 1):\n\t\tans *= i\n\t\tans %= mod\n\tprint(ans)\nelif k >= n:\n\tprint(0)\nelse:\n\tans = 0\n\tK = n - k\n\tfor i in range(K + 1):\n\t\tans += (-1) ** ((K - i) % 2) * cmb(K, i, mod) * pow(i, n, mod)\n\tans %= mod\n\tans *= cmb(n, n - k, mod)\n\tans *= 2\n\tans %= mod\n\tprint(ans)\n",
        "def prepare(n, MOD):\n\tf = 1\n\tfactorials = [1]\n\tfor m in range(1, n + 1):\n\t\tf *= m\n\t\tf %= MOD\n\t\tfactorials.append(f)\n\tinv = pow(f, MOD - 2, MOD)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor m in range(n, 1, -1):\n\t\tinv *= m\n\t\tinv %= MOD\n\t\tinvs[m - 1] = inv\n\treturn (factorials, invs)\n\ndef solve(n, k):\n\tMOD = 998244353\n\tif k == 0:\n\t\tans = 1\n\t\tfor i in range(2, n + 1):\n\t\t\tans = ans * i % MOD\n\t\treturn ans\n\tif k > n - 1:\n\t\treturn 0\n\t(facts, invs) = prepare(n, MOD)\n\tuse_row = n - k\n\tt = 1\n\tans = 0\n\tfor r in range(use_row, 0, -1):\n\t\tans = (ans + t * facts[use_row] * invs[r] * invs[use_row - r] * pow(r, n, MOD)) % MOD\n\t\tt *= -1\n\treturn ans * 2 * facts[n] * invs[use_row] * invs[n - use_row] % MOD\n(n, k) = list(map(int, input().split()))\nprint(solve(n, k))\n",
        "import sys\nfrom functools import reduce\nints = (int(x) for x in sys.stdin.read().split())\nmod = 998244353\n\ndef mod_pow(a, k):\n\tr = 1\n\twhile k and r:\n\t\tif k % 2:\n\t\t\tr = r * a % mod\n\t\t(k, a) = (k >> 1, a * a % mod)\n\treturn r\n\ndef main():\n\tmul = lambda a, b: a * b % mod\n\n\tdef nCk(n, k):\n\t\tassert 0 <= k <= n\n\t\treturn mul(fact[n], mod_pow(mul(fact[k], fact[n - k]), mod - 2))\n\t(n, k) = (next(ints), next(ints))\n\tif 0 <= k < n:\n\t\tfact = [1] * (n + 1)\n\t\tfor i in range(1, n + 1):\n\t\t\tfact[i] = mul(fact[i - 1], i)\n\t\t(m, ans) = (n - k, 0)\n\t\tfor i in range(m):\n\t\t\tsign = 1 if i % 2 == 0 else -1\n\t\t\tans += sign * mul(nCk(m, i), mod_pow(m - i, n))\n\t\t\tans %= mod\n\t\tans = mul(ans, nCk(n, k))\n\t\tans = mul(ans, 1 + (k > 0))\n\telse:\n\t\tans = 0\n\tprint(ans)\n\treturn\nmain()\n",
        "from sys import stdin\nfrom sys import stdout\nm = 998244353\nfactorial = [1]\nfor i in range(1, 200001):\n\tfactorial.append(factorial[i - 1] * i % m)\n\ndef quick_power(a, n):\n\tif n == 0:\n\t\treturn 1\n\tx = quick_power(a, n // 2) % m\n\tx = x * x % m\n\tif n % 2 == 1:\n\t\tx = x * a % m\n\treturn x\n\ndef inv(b):\n\treturn quick_power(b, m - 2)\n\ndef combinatoria(a, b):\n\tx = factorial[a] * inv(factorial[b]) % m * inv(factorial[a - b]) % m\n\treturn x\n\ndef PlacingRooks(n, k):\n\tif k == 0:\n\t\treturn factorial[n]\n\telif k >= n:\n\t\treturn 0\n\telse:\n\t\tc = n - k\n\t\tresult = 0\n\t\tfor i in range(0, c):\n\t\t\taux = quick_power(-1, i) * combinatoria(c, i) * quick_power(c - i, n) % m\n\t\t\tresult = (result + aux) % m\n\t\tresult = result * combinatoria(n, c) % m * 2 % m\n\t\treturn result\ninput = list(map(int, stdin.readline().split()))\nn = input[0]\nk = input[1]\nstdout.write(str(PlacingRooks(n, k)) + '\\n')\n",
        "MOD = 998244353\n(n, k) = map(int, input().split())\nx = n - k\nnum = 1\nden = 1\ns = 0\ntden = 1\nfor i in range(x):\n\tv = pow(x - i, n, MOD) * num\n\ts = (s * den + (-1) ** i * v * tden) % MOD\n\ttden = tden * den % MOD\n\tnum = num * (x - i) % MOD\n\tden = den * (i + 1) % MOD\nnum = 1\nden = 1\nfor i in range(x):\n\tnum = num * (n - i) % MOD\n\tden = den * (i + 1) % MOD\ns = (1 + (k != 0)) * s * num * pow(den * tden, MOD - 2, MOD) % MOD\nprint(s)\n",
        "fact = [1]\nmod = 998244353\nfor i in range(1, 200001):\n\tfact.append(fact[-1] * i % mod)\n(n, k) = map(int, input().split())\nsame = k\n\ndef choose(n, r):\n\treturn fact[n] * pow(fact[r], mod - 2, mod) * pow(fact[n - r], mod - 2, mod) % mod\n\ndef sterling(n, m):\n\tresult = 0\n\tfor i in range(n):\n\t\tif i % 2 == 0:\n\t\t\tresult = (result + choose(n, i) * pow(n - i, m, mod)) % mod\n\t\telse:\n\t\t\tresult = (result - choose(n, i) * pow(n - i, m, mod)) % mod\n\treturn result % mod\nif k > n - 1:\n\tprint(0)\nelif k == 0:\n\tprint(fact[n])\nelse:\n\tprint(2 * choose(n, n - k) * sterling(n - k, n) % mod)\n",
        "MOD = 998244353\n\ndef inv(x):\n\treturn pow(x, MOD - 2, MOD)\n(n, k) = list(map(int, input().split()))\nif k >= n:\n\tprint(0)\nelse:\n\tout = 0\n\tcol = n - k\n\tbinom = 1\n\tmult = 1\n\tfor i in range(n, col, -1):\n\t\tmult *= i\n\t\tmult *= inv(n + 1 - i)\n\t\tmult %= MOD\n\tfor i in range(col, 0, -1):\n\t\tout += binom * pow(i, n, MOD)\n\t\tout %= MOD\n\t\tbinom *= i\n\t\tbinom *= inv(col + 1 - i)\n\t\tbinom *= -1\n\t\tbinom %= MOD\n\tout *= mult\n\tif k > 0:\n\t\tout *= 2\n\tprint(out % MOD)\n",
        "import sys\ninput = sys.stdin.buffer.readline\n\ndef print(val):\n\tsys.stdout.write(str(val) + '\\n')\n\ndef inverse(n, primemod):\n\treturn pow(n, primemod - 2, primemod)\n\ndef choose(n, k, mod, factorials, inverses):\n\treturn factorials[n] * inverses[k] * inverses[n - k] % mod\n\ndef factorial_creator(n, mod):\n\tfactorials = [1]\n\tcurr = 1\n\tfor i in range(1, n + 1):\n\t\tcurr = curr * i % mod\n\t\tfactorials.append(curr)\n\treturn factorials\n\ndef inverse_creator(n, k, mod, factorials):\n\tinverses = [1 for i in range(n - k + 1)]\n\tcurrent = inverse(factorials[n - k], mod)\n\tinverses[n - k] = current\n\tfor i in range(n - k, 0, -1):\n\t\tcurrent = current * i % mod\n\t\tinverses[i - 1] = current\n\treturn inverses\n\ndef place_rooks(n, k, mod):\n\tif k >= n:\n\t\treturn 0\n\tfactorials = factorial_creator(n, 998244353)\n\tinverses = inverse_creator(n, k, 998244353, factorials)\n\tfilled = n - k\n\tplacements_per_filled = 0\n\tfor i in range(filled):\n\t\tplacements_per_filled += (-1) ** i * choose(filled, i, mod, factorials, inverses) * pow(filled - i, n, mod) % mod\n\t\tplacements_per_filled %= mod\n\tif k == 0:\n\t\ttotal = factorials[n] * inverses[n - k] * inverse(factorials[k], mod) % mod * placements_per_filled % mod\n\t\treturn total\n\ttotal = 2 * (factorials[n] * inverses[n - k] * inverse(factorials[k], mod)) % mod * placements_per_filled % mod\n\treturn total\n(n, k) = map(int, input().split())\nprint(place_rooks(n, k, 998244353))\n",
        "import sys\ninput = sys.stdin.readline\nmod = 998244353\n\ndef cmb(n, r):\n\tif r < 0 or r > n:\n\t\treturn 0\n\tr = min(r, n - r)\n\treturn g1[n] * g2[r] * g2[n - r] % mod\nNNN = 2 * 10 ** 5\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nfor i in range(2, NNN + 1):\n\tg1.append(g1[-1] * i % mod)\n\tinverse.append(-inverse[mod % i] * (mod // i) % mod)\n\tg2.append(g2[-1] * inverse[-1] % mod)\n(N, K) = map(int, input().split())\nif K > N:\n\tprint(0)\nelse:\n\tM = N - K\n\tR = 0\n\tfor i in range(1, M + 1):\n\t\tR += (-1 if (M - i) % 2 else 1) * cmb(M, i) * pow(i, N, mod) % mod\n\tR = R * cmb(N, M) % mod\n\tif K != 0:\n\t\tR = R * 2 % mod\n\tprint(R)\n",
        "MAX = 2 * 10 ** 5 + 100\nMOD = 998244353\nfact = [0] * MAX\ninv = [0] * MAX\nfinv = [0] * MAX\nfact[0] = 1\nfact[1] = 1\nfinv[0] = 1\nfinv[1] = 1\ninv[1] = 1\nfor i in range(2, MAX):\n\tfact[i] = fact[i - 1] * i % MOD\n\tinv[i] = MOD - inv[MOD % i] * (MOD // i) % MOD\n\tfinv[i] = finv[i - 1] * inv[i] % MOD\n\ndef C(n, r):\n\tif n < r:\n\t\treturn 0\n\tif n < 0 or r < 0:\n\t\treturn 0\n\treturn fact[n] * (finv[r] * finv[n - r] % MOD) % MOD\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\n\texit()\nif k == 0:\n\tprint(fact[n])\n\texit()\nans = 0\nfor i in range(n - k + 1):\n\tif i % 2 == 0:\n\t\tans += C(n - k, i) * pow(n - k - i, n, MOD)\n\t\tans %= MOD\n\telse:\n\t\tans -= C(n - k, i) * pow(n - k - i, n, MOD)\n\t\tans %= MOD\nans *= 2 * C(n, k)\nans %= MOD\nprint(ans)\n",
        "import sys\ninput = sys.stdin.readline\n(fact, inv_fact) = ([0] * (2 * 10 ** 5 + 1), [0] * (2 * 10 ** 5 + 1))\nfact[0] = 1\nmod = 998244353\n\ndef make_nCr_mod(max_n=2 * 10 ** 5, mod=998244353):\n\tglobal fact\n\tglobal inv_fact\n\tfor i in range(max_n):\n\t\tfact[i + 1] = fact[i] * (i + 1) % mod\n\tinv_fact[-1] = pow(fact[-1], mod - 2, mod)\n\tfor i in reversed(range(max_n)):\n\t\tinv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\nmake_nCr_mod()\n\ndef nCr_mod(n, r):\n\tres = 1\n\twhile n or r:\n\t\t(a, b) = (n % mod, r % mod)\n\t\tif a < b:\n\t\t\treturn 0\n\t\tres = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod\n\t\tn //= mod\n\t\tr //= mod\n\treturn res\n(n, k) = map(int, input().split())\nif k == 0:\n\tprint(fact[n])\nelif k >= n:\n\tprint(0)\nelse:\n\tans = 0\n\tfor i in range(1, n - k + 1):\n\t\tans += 2 * nCr_mod(n, k) * pow(-1, n - k - i) * nCr_mod(n - k, i) * pow(i, n, mod) % mod\n\tprint(ans % mod)\n",
        "def inverse(n, primemod):\n\treturn pow(n, primemod - 2, primemod)\n\ndef choose(n, k, mod, factorials, inverses):\n\treturn factorials[n] * inverses[k] * inverses[n - k] % mod\n\ndef factorial_creator(n, mod):\n\tfactorials = [1]\n\tcurr = 1\n\tfor i in range(1, n + 1):\n\t\tcurr = curr * i % mod\n\t\tfactorials.append(curr)\n\treturn factorials\n\ndef inverse_creator(n, k, mod, factorials):\n\tinverses = [1 for i in range(n - k + 1)]\n\tcurrent = inverse(factorials[n - k], mod)\n\tinverses[n - k] = current\n\tfor i in range(n - k, 0, -1):\n\t\tcurrent = current * i % mod\n\t\tinverses[i - 1] = current\n\treturn inverses\n\ndef place_rooks(n, k, mod):\n\tif k >= n:\n\t\treturn 0\n\tfactorials = factorial_creator(n, 998244353)\n\tinverses = inverse_creator(n, k, 998244353, factorials)\n\tfilled = n - k\n\tplacements_per_filled = 0\n\tfor i in range(filled):\n\t\tplacements_per_filled += (-1) ** i * choose(filled, i, mod, factorials, inverses) * pow(filled - i, n, mod) % mod\n\t\tplacements_per_filled %= mod\n\tif k == 0:\n\t\ttotal = factorials[n] * inverses[n - k] * inverse(factorials[k], mod) % mod * placements_per_filled % mod\n\t\treturn total\n\ttotal = 2 * (factorials[n] * inverses[n - k] * inverse(factorials[k], mod)) % mod * placements_per_filled % mod\n\treturn total\n(n, k) = map(int, input().split())\nprint(place_rooks(n, k, 998244353))\n",
        "from sys import stdin, stdout\nMOD = 998244353\nf_a = []\n\ndef build_fac(n):\n\tf_a.append(1)\n\tfor i in range(1, n + 1):\n\t\tr = i * f_a[-1]\n\t\tr %= MOD\n\t\tf_a.append(r)\n\ndef fac(n):\n\treturn f_a[n]\n\ndef inv(n):\n\treturn bpow(n, MOD - 2)\n\ndef bpow(a, b):\n\tif b == 0:\n\t\treturn 1\n\tr = bpow(a, b // 2)\n\tr *= r\n\tr %= MOD\n\tif b % 2 == 1:\n\t\tr *= a\n\t\tr %= MOD\n\treturn r\n\ndef C(n, c):\n\tr1 = fac(n)\n\tr2 = inv(fac(c))\n\tr3 = inv(fac(n - c))\n\tr = r1 * r2\n\tr %= MOD\n\tr *= r3\n\tr %= MOD\n\treturn r\n\ndef placing_rooks(n, k):\n\tif k > n:\n\t\treturn 0\n\tr = 0\n\tfor i in range(n - k):\n\t\tr1 = bpow(n - k - i, n)\n\t\tr1 *= C(n - k, i)\n\t\tr1 %= MOD\n\t\tif i % 2 == 0:\n\t\t\tr += r1\n\t\telse:\n\t\t\tr -= r1\n\t\tr %= MOD\n\tr *= C(n, n - k)\n\tr %= MOD\n\tif k > 0:\n\t\tr *= 2\n\t\tr %= MOD\n\treturn r\n(n, k) = map(int, stdin.readline().split())\nbuild_fac(n)\nr = placing_rooks(n, k)\nstdout.write(str(r) + '\\n')\n",
        "def comb(n, k):\n\treturn L[n] * pow(L[n - k] * L[k], m - 2, m) % m\n(n, k) = map(int, input().split())\nif k >= n:\n\tprint(0)\nelse:\n\tm = 998244353\n\tL = [1]\n\tfor i in range(1, n + 1):\n\t\tL.append(L[-1] * i % m)\n\tc = 0\n\tfor i in range(n - k):\n\t\tc += (-1) ** i * pow(n - k - i, n, m) * comb(n - k, n - k - i) % m\n\tc %= m\n\tc *= comb(n, n - k)\n\tif k == 0:\n\t\tprint(c % m)\n\telse:\n\t\tprint(c * 2 % m)\n",
        "MOD = 998244353\nfac = [1] * (2 * 10 ** 5 + 10)\n\ndef comb(n, k):\n\treturn fac[n] * pow(fac[n - k], MOD - 2, MOD) * pow(fac[k], MOD - 2, MOD) % MOD\nfor i in range(len(fac) - 1):\n\tfac[i + 1] = fac[i] * (i + 1) % MOD\n(n, k) = list(map(int, input().split()))\nif k == 0:\n\tprint(fac[n])\nelse:\n\tk = n - k\n\tif k <= 0:\n\t\tprint(0)\n\t\treturn\n\tans = 0\n\tfor i in range(k + 1):\n\t\tt = comb(k, i) * pow(k - i, n, MOD) % MOD\n\t\tif i % 2:\n\t\t\tans -= t\n\t\telse:\n\t\t\tans += t\n\tprint(2 * ans * comb(n, k) % MOD)\n",
        "nn = 200200\nP = 998244353\nfa = [1] * (nn + 1)\nfainv = [1] * (nn + 1)\nfor i in range(nn):\n\tfa[i + 1] = fa[i] * (i + 1) % P\nfainv[-1] = pow(fa[-1], P - 2, P)\nfor i in range(nn)[::-1]:\n\tfainv[i] = fainv[i + 1] * (i + 1) % P\nC = lambda a, b: fa[a] * fainv[b] % P * fainv[a - b] % P if 0 <= b <= a else 0\n(N, K) = map(int, input().split())\nif K == 0:\n\tprint(fa[N])\n\texit()\nif K >= N:\n\tprint(0)\n\texit()\na = N - K\nans = 0\nfor i in range(a + 1):\n\tans = (ans + pow(a - i, N, P) * C(a, i) * (-1 if i & 1 else 1)) % P\nans = ans * 2 * C(N, a) % P\nprint(ans)\n",
        "import io, os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nimport sys\n\ndef solve(n, k):\n\tmod = 998244353\n\tif k == 0:\n\t\tans = 1\n\t\tfor i in range(1, n + 1):\n\t\t\tans *= i\n\t\t\tans %= mod\n\t\treturn ans\n\tif k >= n:\n\t\treturn 0\n\tinv = lambda x: pow(x, mod - 2, mod)\n\tFact = [1]\n\tfor i in range(1, n + 1):\n\t\tFact.append(Fact[i - 1] * i % mod)\n\tFinv = [0] * (n + 1)\n\tFinv[-1] = inv(Fact[-1])\n\tfor i in range(n - 1, -1, -1):\n\t\tFinv[i] = Finv[i + 1] * (i + 1) % mod\n\n\tdef comb(n, r):\n\t\tif n < r:\n\t\t\treturn 0\n\t\treturn Fact[n] * Finv[r] * Finv[n - r] % mod\n\tm = n - k\n\tt = 1\n\tans = 0\n\tfor r in range(m, 0, -1):\n\t\tans += t * comb(m, r) * pow(r, n, mod)\n\t\tans %= mod\n\t\tt *= -1\n\tans *= comb(n, m) * 2\n\tans %= mod\n\treturn ans\n\ndef main():\n\t(n, k) = map(int, input().split())\n\tans = solve(n, k)\n\tsys.stdout.write(str(ans) + '\\n')\nmain()\n",
        "MOD = 998244353\nN = 200007\nfac = [1] * N\nfor i in range(1, N):\n\tfac[i] = i * fac[i - 1] % MOD\n\ndef inv(n):\n\treturn pow(n, MOD - 2, MOD)\n\ndef nCk(n, k):\n\treturn fac[n] * inv(fac[k] * fac[n - k] % MOD) % MOD\n\ndef nSk(n, k):\n\tres = 0\n\tfor i in range(1, k + 1):\n\t\tres = (res + pow(-1, k - i) * nCk(k, i) * pow(i, n, MOD)) % MOD\n\treturn res\n(n, k) = map(int, input().split())\nres = None\nif k == 0:\n\tres = fac[n]\nelif k >= n:\n\tres = 0\nelse:\n\tres = 2 * nCk(n, k) * nSk(n, n - k) % MOD\nprint(res)\n",
        "def read_int():\n\treturn int(input())\n\ndef read_ints():\n\treturn list(map(int, input().split(' ')))\nfac = [1]\nrev = []\nmod = 998244353\n\ndef fexp(x, y):\n\tans = 1\n\twhile y > 0:\n\t\tif y % 2 == 1:\n\t\t\tans = ans * x % mod\n\t\tx = x * x % mod\n\t\ty //= 2\n\treturn ans\n\ndef comb(n, k):\n\treturn fac[n] * rev[k] * rev[n - k] % mod\n(n, k) = read_ints()\nif k >= n:\n\tprint(0)\nelse:\n\tfor i in range(1, n + 5):\n\t\tfac.append(fac[-1] * i % mod)\n\tfor i in range(n + 5):\n\t\trev.append(fexp(fac[i], mod - 2))\n\tif k == 0:\n\t\tprint(fac[n])\n\telse:\n\t\tways = comb(n, k)\n\t\tcol = 0\n\t\tfor i in range(n - k):\n\t\t\tsign = 1 if i % 2 == 0 else -1\n\t\t\tcol += sign * comb(n - k, i) * fexp(n - k - i, n)\n\t\t\tcol %= mod\n\t\t\tif col < 0:\n\t\t\t\tcol += mod\n\t\tprint(ways * col * 2 % mod)\n",
        "class Combination:\n\n\tdef __init__(self, n_max, mod=10 ** 9 + 7):\n\t\tself.mod = mod\n\t\tf = 1\n\t\tself.fac = fac = [f]\n\t\tfor i in range(1, n_max + 1):\n\t\t\tf = f * i % mod\n\t\t\tfac.append(f)\n\t\tf = pow(f, mod - 2, mod)\n\t\tself.facinv = facinv = [f]\n\t\tfor i in range(n_max, 0, -1):\n\t\t\tf = f * i % mod\n\t\t\tfacinv.append(f)\n\t\tfacinv.reverse()\n\n\tdef __call__(self, n, r):\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef C(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef P(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[n - r] % self.mod\n\n\tdef H(self, n, r):\n\t\tif n == 0 and r > 0 or r < 0:\n\t\t\treturn 0\n\t\treturn self.fac[n + r - 1] * self.facinv[r] % self.mod * self.facinv[n - 1] % self.mod\n\n\tdef rising_factorial(self, n, r):\n\t\treturn self.fac[n + r - 1] * self.facinv[n - 1] % self.mod\n\n\tdef stirling_first(self, n, k):\n\t\tif n == k:\n\t\t\treturn 1\n\t\tif k == 0:\n\t\t\treturn 0\n\t\treturn (self.stirling_first(n - 1, k - 1) + (n - 1) * self.stirling_first(n - 1, k)) % self.mod\n\n\tdef stirling_second(self, n, k):\n\t\tif n == k:\n\t\t\treturn 1\n\t\treturn self.facinv[k] * sum(((-1) ** (k - m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k + 1))) % self.mod\n\n\tdef balls_and_boxes_3(self, n, k):\n\t\treturn sum(((-1) ** (k - m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k + 1))) % self.mod\n\n\tdef bernoulli(self, n):\n\t\tif n == 0:\n\t\t\treturn 1\n\t\tif n % 2 and n >= 3:\n\t\t\treturn 0\n\t\treturn -pow(n + 1, self.mod - 2, self.mod) * sum((self.C(n + 1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n\tdef faulhaber(self, k, n):\n\t\treturn pow(k + 1, self.mod - 2, self.mod) * sum((self.C(k + 1, j) * self.bernoulli(j) % self.mod * pow(n, k - j + 1, self.mod) % self.mod for j in range(k + 1))) % self.mod\n\n\tdef lah(self, n, k):\n\t\treturn self.C(n - 1, k - 1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n\tdef bell(self, n, k):\n\t\treturn sum((self.stirling_second(n, j) for j in range(1, k + 1))) % self.mod\n(N, K) = map(int, input().split())\nmod = 998244353\nif K == 0:\n\tans = 1\n\tfor i in range(1, N + 1):\n\t\tans = ans * i % mod\n\tprint(ans)\n\texit()\nif K >= N:\n\tprint(0)\n\texit()\ncomb = Combination(200002, mod=mod)\nprint(comb.balls_and_boxes_3(N, N - K) * comb(N, K) * 2 % mod)\n",
        "def modpow(b, e, mod):\n\tret = 1\n\tpw = b\n\twhile e > 0:\n\t\tif e % 2 == 1:\n\t\t\tret = ret * pw % mod\n\t\te = e >> 1\n\t\tpw = pw * pw % mod\n\treturn ret\n(n, k) = list(map(int, input().split()))\nmod = 998244353\ninv = [0 for _ in range(n + 1)]\nfac = [0 for _ in range(n + 1)]\nfac[0] = inv[0] = 1\nfor i in range(n):\n\tfac[i + 1] = fac[i] * (i + 1) % mod\n\tinv[i + 1] = modpow(fac[i + 1], mod - 2, mod)\n\ndef nCr(n, r):\n\tnum = fac[n]\n\tden = inv[r] * inv[n - r] % mod\n\treturn num * den % mod\nrow = n - k\nif row < 0 or row > n:\n\tprint('0')\nelse:\n\tans = 0\n\tfor i in range(row):\n\t\tadd = nCr(row, i) * modpow(row - i, n, mod) % mod\n\t\tif i % 2 == 0:\n\t\t\tans = ans + add\n\t\telse:\n\t\t\tans = ans - add\n\tans = mod + ans % mod\n\tmult = 2\n\tif row == n:\n\t\tmult = 1\n\tprint(mult * nCr(n, row) * ans % mod)\n",
        "def modfac(n, MOD):\n\tf = 1\n\tfactorials = [1]\n\tfor m in range(1, n + 1):\n\t\tf *= m\n\t\tf %= MOD\n\t\tfactorials.append(f)\n\tinv = pow(f, MOD - 2, MOD)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor m in range(n, 1, -1):\n\t\tinv *= m\n\t\tinv %= MOD\n\t\tinvs[m - 1] = inv\n\treturn (factorials, invs)\n\ndef modnCr(n, r, mod, fac, inv):\n\treturn fac[n] * inv[n - r] * inv[r] % mod\n(n, k) = map(int, input().split())\nmod = 998244353\nN = n\nif k >= N:\n\tprint(0)\nelif k == 0:\n\tans = 1\n\tfor i in range(1, N + 1):\n\t\tans *= i\n\t\tans %= mod\n\tprint(ans)\nelse:\n\t(fac, inv) = modfac(n * 2 + 10, mod)\n\tans = modnCr(n, k, mod, fac, inv)\n\tr = N - k\n\tp = N\n\tna = 0\n\tfor i in range(r):\n\t\tnow = modnCr(r, i, mod, fac, inv) * pow(r - i, p, mod)\n\t\tif i % 2 == 0:\n\t\t\tna += now\n\t\telse:\n\t\t\tna -= now\n\t\tna %= mod\n\tprint(ans * na * 2 % mod)\n",
        "from bisect import *\nfrom collections import *\nfrom math import gcd, ceil, sqrt, floor, inf\nfrom heapq import *\nfrom itertools import *\nfrom functools import *\nfrom collections import deque\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef RL():\n\treturn map(int, sys.stdin.readline().rstrip().split())\n\ndef RLL():\n\treturn list(map(int, sys.stdin.readline().rstrip().split()))\n\ndef N():\n\treturn int(input())\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n\n\tdef wrappedfunc(*args, **kwargs):\n\t\tif stack:\n\t\t\treturn f(*args, **kwargs)\n\t\telse:\n\t\t\tto = f(*args, **kwargs)\n\t\t\twhile True:\n\t\t\t\tif type(to) is GeneratorType:\n\t\t\t\t\tstack.append(to)\n\t\t\t\t\tto = next(to)\n\t\t\t\telse:\n\t\t\t\t\tstack.pop()\n\t\t\t\t\tif not stack:\n\t\t\t\t\t\tbreak\n\t\t\t\t\tto = stack[-1].send(to)\n\t\t\treturn to\n\treturn wrappedfunc\nfarr = [1]\nifa = []\n\ndef fact(x, mod=0):\n\tif mod:\n\t\twhile x >= len(farr):\n\t\t\tfarr.append(farr[-1] * len(farr) % mod)\n\telse:\n\t\twhile x >= len(farr):\n\t\t\tfarr.append(farr[-1] * len(farr))\n\treturn farr[x]\n\ndef ifact(x, mod):\n\tglobal ifa\n\tfact(x, mod)\n\tifa.append(pow(farr[-1], mod - 2, mod))\n\tfor i in range(x, 0, -1):\n\t\tifa.append(ifa[-1] * i % mod)\n\tifa.reverse()\n\ndef per(i, j, mod=0):\n\tif i < j:\n\t\treturn 0\n\tif not mod:\n\t\treturn fact(i) // fact(i - j)\n\treturn farr[i] * ifa[i - j] % mod\n\ndef com(i, j, mod=0):\n\tif i < j:\n\t\treturn 0\n\tif not mod:\n\t\treturn per(i, j) // fact(j)\n\treturn per(i, j, mod) * ifa[j] % mod\n\ndef catalan(n):\n\treturn com(2 * n, n) // (n + 1)\n\ndef isprime(n):\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef lowbit(n):\n\treturn n & -n\n\ndef inverse(a, m):\n\ta %= m\n\tif a <= 1:\n\t\treturn a\n\treturn (1 - inverse(m, a) * m) // a % m\n\nclass BIT:\n\n\tdef __init__(self, arr):\n\t\tself.arr = arr\n\t\tself.n = len(arr) - 1\n\n\tdef update(self, x, v):\n\t\twhile x <= self.n:\n\t\t\tself.arr[x] += v\n\t\t\tx += x & -x\n\n\tdef query(self, x):\n\t\tans = 0\n\t\twhile x:\n\t\t\tans += self.arr[x]\n\t\t\tx &= x - 1\n\t\treturn ans\n\nclass DSU:\n\n\tdef __init__(self, n):\n\t\tself.c = [-1] * n\n\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef find(self, x):\n\t\tif self.c[x] < 0:\n\t\t\treturn x\n\t\tself.c[x] = self.find(self.c[x])\n\t\treturn self.c[x]\n\n\tdef union(self, u, v):\n\t\t(u, v) = (self.find(u), self.find(v))\n\t\tif u == v:\n\t\t\treturn False\n\t\tif self.c[u] > self.c[v]:\n\t\t\t(u, v) = (v, u)\n\t\tself.c[u] += self.c[v]\n\t\tself.c[v] = u\n\t\treturn True\n\n\tdef size(self, x):\n\t\treturn -self.c[self.find(x)]\n\nclass UFS:\n\n\tdef __init__(self, n):\n\t\tself.parent = [i for i in range(n)]\n\t\tself.ranks = [0] * n\n\n\tdef find(self, x):\n\t\tif x != self.parent[x]:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, u, v):\n\t\t(pu, pv) = (self.find(u), self.find(v))\n\t\tif pu == pv:\n\t\t\treturn False\n\t\tif self.ranks[pu] >= self.ranks[pv]:\n\t\t\tself.parent[pv] = pu\n\t\t\tif self.ranks[pv] == self.ranks[pu]:\n\t\t\t\tself.ranks[pu] += 1\n\t\telse:\n\t\t\tself.parent[pu] = pv\n\ndef Prime(n):\n\tc = 0\n\tprime = []\n\tflag = [0] * (n + 1)\n\tfor i in range(2, n + 1):\n\t\tif not flag[i]:\n\t\t\tprime.append(i)\n\t\t\tc += 1\n\t\tfor j in range(c):\n\t\t\tif i * prime[j] > n:\n\t\t\t\tbreak\n\t\t\tflag[i * prime[j]] = prime[j]\n\t\t\tif i % prime[j] == 0:\n\t\t\t\tbreak\n\treturn prime\n\ndef dij(s, graph):\n\td = {}\n\td[s] = 0\n\theap = [(0, s)]\n\tseen = set()\n\twhile heap:\n\t\t(dis, u) = heappop(heap)\n\t\tif u in seen:\n\t\t\tcontinue\n\t\tseen.add(u)\n\t\tfor (v, w) in graph[u]:\n\t\t\tif v not in d or d[v] > d[u] + w:\n\t\t\t\td[v] = d[u] + w\n\t\t\t\theappush(heap, (d[v], v))\n\treturn d\n\ndef GP(it):\n\treturn [[ch, len(list(g))] for (ch, g) in groupby(it)]\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\nclass DLN:\n\n\tdef __init__(self, val):\n\t\tself.val = val\n\t\tself.pre = None\n\t\tself.next = None\n\ndef nb(i, j):\n\tfor (ni, nj) in [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]]:\n\t\tif 0 <= ni < n and 0 <= nj < m:\n\t\t\tyield (ni, nj)\n\n@bootstrap\ndef gdfs(r, p):\n\tif len(g[r]) == 1 and p != -1:\n\t\tyield None\n\tfor ch in g[r]:\n\t\tif ch != p:\n\t\t\tyield gdfs(ch, r)\n\tyield None\n\ndef topo(n):\n\tq = deque()\n\tres = []\n\tfor i in range(1, n + 1):\n\t\tif ind[i] == 0:\n\t\t\tq.append(i)\n\t\t\tres.append(i)\n\twhile q:\n\t\tu = q.popleft()\n\t\tfor v in g[u]:\n\t\t\tind[v] -= 1\n\t\t\tif ind[v] == 0:\n\t\t\t\tq.append(v)\n\t\t\t\tres.append(v)\n\treturn res\n\ndef cal(x):\n\t(d, m) = divmod(x, p)\n\tans = d * b\n\tif m:\n\t\tif m < b:\n\t\t\tans += m\n\t\telse:\n\t\t\tans += b - 1\n\treturn ans\nt = 1\nfor i in range(t):\n\t(n, k) = RL()\n\tans = 0\n\tmod = 998244353\n\tifact(n, mod)\n\tif k == 0:\n\t\tans = fact(n, mod)\n\telif k >= n:\n\t\tans = 0\n\telse:\n\t\tc = n - k\n\t\tans = 0\n\t\tfor i in range(c):\n\t\t\tif not i & 1:\n\t\t\t\tans += com(c, i, mod) * pow(c - i, n, mod) % mod\n\t\t\telse:\n\t\t\t\tans -= com(c, i, mod) * pow(c - i, n, mod) % mod\n\t\t\tans %= mod\n\t\tans = ans * 2 * com(n, c, mod) % mod\n\tprint(ans)\n",
        "class Combination:\n\n\tdef __init__(self, n, MOD):\n\t\tself.fact = [1]\n\t\tfor i in range(1, n + 1):\n\t\t\tself.fact.append(self.fact[-1] * i % MOD)\n\t\tself.inv_fact = [0] * (n + 1)\n\t\tself.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n\t\tfor i in reversed(range(n)):\n\t\t\tself.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n\t\tself.MOD = MOD\n\n\tdef factorial(self, k):\n\t\treturn self.fact[k]\n\n\tdef inverse_factorial(self, k):\n\t\treturn self.inv_fact[k]\n\n\tdef permutation(self, k, r):\n\t\tif k < r:\n\t\t\treturn 0\n\t\treturn self.fact[k] * self.inv_fact[k - r] % self.MOD\n\n\tdef combination(self, k, r):\n\t\tif k < r:\n\t\t\treturn 0\n\t\treturn self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r] % self.MOD\n(n, k) = map(int, input().split())\nMOD = 998244353\ncomb = Combination(10 ** 6, MOD)\nball = n\nbox = n - k\nif box <= 0:\n\tprint(0)\n\treturn\nans = 0\nfor i in range(box + 1):\n\tans += pow(-1, i, MOD) * comb.combination(box, i) * pow(box - i, ball, MOD)\n\tans %= MOD\nif k == 0:\n\tprint(ans * comb.combination(n, box) % MOD)\nelse:\n\tprint(ans * comb.combination(n, box) * 2 % MOD)\n",
        "mod = 998244353\neps = 10 ** (-9)\n\ndef main():\n\timport sys\n\tinput = sys.stdin.readline\n\tnmax = 2 * 10 ** 5 + 10\n\tfac = [0] * nmax\n\tfinv = [0] * nmax\n\tinv = [0] * nmax\n\tfac[0] = 1\n\tfac[1] = 1\n\tfinv[0] = 1\n\tfinv[1] = 1\n\tinv[1] = 1\n\tfor i in range(2, nmax):\n\t\tfac[i] = fac[i - 1] * i % mod\n\t\tinv[i] = mod - inv[mod % i] * (mod // i) % mod\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod\n\n\tdef comb(n, r):\n\t\tif n < r:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\t(N, K) = map(int, input().split())\n\tif K >= N:\n\t\tprint(0)\n\t\texit()\n\tans = 0\n\tflg = 1\n\tfor i in range(N - K, 0, -1):\n\t\tans = (ans + flg * comb(N - K, i) * pow(i, N, mod)) % mod\n\t\tflg *= -1\n\tans = ans * comb(N, N - K) % mod\n\tif K:\n\t\tans = ans * 2 % mod\n\tprint(ans)\nmain()\n",
        "mod = 998244353\n(n, k) = map(int, input().split())\nfact = [1]\nfor i in range(1, n + 1):\n\tfact.append(fact[-1] * i % mod)\nrevfact = [1]\nfor i in range(1, n + 1):\n\trevfact.append(pow(fact[i], mod - 2, mod))\nif k >= n:\n\tprint(0)\nelif k == 0:\n\tprint(fact[n])\nelse:\n\tans = 0\n\tfor i in range(n - k + 1):\n\t\tif i % 2 == 0:\n\t\t\tans += pow(n - k - i, n, mod) * fact[n - k] * revfact[i] * revfact[n - k - i]\n\t\t\tans %= mod\n\t\telse:\n\t\t\tans -= pow(n - k - i, n, mod) * fact[n - k] * revfact[i] * revfact[n - k - i]\n\t\t\tans %= mod\n\tprint(ans * fact[n] * revfact[k] * revfact[n - k] * 2 % mod)\n",
        "import sys\nreadline = sys.stdin.readline\nMOD = 998244353\n\ndef frac(limit):\n\tfrac = [1] * limit\n\tfor i in range(2, limit):\n\t\tfrac[i] = i * frac[i - 1] % MOD\n\tfraci = [None] * limit\n\tfraci[-1] = pow(frac[-1], MOD - 2, MOD)\n\tfor i in range(-2, -limit - 1, -1):\n\t\tfraci[i] = fraci[i + 1] * (limit + i + 1) % MOD\n\treturn (frac, fraci)\n(frac, fraci) = frac(1341398)\n\ndef comb(a, b):\n\tif not a >= b >= 0:\n\t\treturn 0\n\treturn frac[a] * fraci[b] * fraci[a - b] % MOD\n(N, K) = map(int, readline().split())\nif K == 0:\n\tprint(frac[N])\nelif K >= N:\n\tprint(0)\nelse:\n\tres = 0\n\tfor i in range(N - K, 0, -1):\n\t\tres = (res + comb(N - K, i) * (-1) ** ((N - K - i) % 2) * pow(i, N, MOD)) % MOD\n\tprint(2 * comb(N, N - K) * res % MOD)\n"
      ],
      "original_code": null
    },
    "status": "success",
    "code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n    # In any valid configuration, the empty cell condition forces that either \n    # every row or every column is non-empty. A short counting shows that \n    # the maximum number of attacking pairs possible is n-1.\n    if k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # Precompute factorials and inverse factorials up to n.\n    max_val = n\n    fact = [1] * (max_val + 1)\n    invfact = [1] * (max_val + 1)\n    for i in range(2, max_val + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod - 2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n\n    def nC(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * invfact[b] % mod * invfact[a - b] % mod\n\n    # Explanation of the count:\n    # \u2022 When k = 0, the condition forces a permutation placement (one rook per row),\n    #   whose count is n!.\n    # \u2022 For k > 0 one must have one family of lines \"full\" and the other not.\n    #   Without loss of generality, one may insist that every column has a rook.\n    #   Then there is an onto map from the n columns to some set A of rows (the nonempty rows).\n    #   If we denote m = |A| then the number of attacking pairs equals (n - m).\n    #   To have exactly k attacking pairs we need m = n - k.\n    #   In that case, the number of onto functions (i.e. surjections) from [n] (columns)\n    #   to an (n-k)-element set is (n \u2013 k)!\u00b7S(n, n \u2013 k).\n    #   Also, one must choose which rows form A (in C(n, n-k) ways)\n    #   and then multiply by 2 because a symmetric counting (forcing rows full)\n    #   gives the same number. (Note that in the k = 0 case the two types overlap\n    #    so one copy is subtracted and one gets n! overall.)\n    #\n    # With the standard formula for Stirling numbers,\n    #   S(n, m) = (1/m!) * sum_{j=0}^{m} (-1)^(m - j) * C(m, j) * j^n,\n    # we obtain for k > 0 (with m = n - k):\n    #\n    #   answer = 2 * C(n, k) * (n \u2013 k)! * S(n, n \u2013 k)\n    #          = 2 * C(n, k) * Sum_{j=0}^{n-k} (-1)^(n-k - j) * C(n-k, j) * j^n.\n    \n    if k == 0:\n        sys.stdout.write(str(fact[n] % mod))\n        return\n    \n    m = n - k  # the number of nonempty rows in a configuration where every column is used.\n    F = 0\n    # Compute F(n, m) = \u03a3_{j=0}^{m} [(-1)^(m-j) * C(m, j) * j^n]  mod mod.\n    for j in range(m + 1):\n        # Compute the sign: if (m - j) is odd, use -1 mod mod.\n        if (m - j) & 1:\n            sign = mod - 1\n        else:\n            sign = 1\n        comb = (fact[m] * invfact[j] % mod) * invfact[m - j] % mod\n        term = sign * comb % mod\n        term = term * pow(j, n, mod) % mod\n        F = (F + term) % mod\n    ans = 2 * nC(n, k) % mod * F % mod\n    sys.stdout.write(str(ans % mod))\n\nif __name__ == '__main__':\n    solve()",
    "pass_ratio": 1.0,
    "tests_passed": 292,
    "tests_total": 292,
    "iterations": 1,
    "history": [
      {
        "iteration": 1,
        "code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n    # In any valid configuration, the empty cell condition forces that either \n    # every row or every column is non-empty. A short counting shows that \n    # the maximum number of attacking pairs possible is n-1.\n    if k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # Precompute factorials and inverse factorials up to n.\n    max_val = n\n    fact = [1] * (max_val + 1)\n    invfact = [1] * (max_val + 1)\n    for i in range(2, max_val + 1):\n        fact[i] = fact[i - 1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod - 2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i - 1] = invfact[i] * i % mod\n\n    def nC(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * invfact[b] % mod * invfact[a - b] % mod\n\n    # Explanation of the count:\n    # \u2022 When k = 0, the condition forces a permutation placement (one rook per row),\n    #   whose count is n!.\n    # \u2022 For k > 0 one must have one family of lines \"full\" and the other not.\n    #   Without loss of generality, one may insist that every column has a rook.\n    #   Then there is an onto map from the n columns to some set A of rows (the nonempty rows).\n    #   If we denote m = |A| then the number of attacking pairs equals (n - m).\n    #   To have exactly k attacking pairs we need m = n - k.\n    #   In that case, the number of onto functions (i.e. surjections) from [n] (columns)\n    #   to an (n-k)-element set is (n \u2013 k)!\u00b7S(n, n \u2013 k).\n    #   Also, one must choose which rows form A (in C(n, n-k) ways)\n    #   and then multiply by 2 because a symmetric counting (forcing rows full)\n    #   gives the same number. (Note that in the k = 0 case the two types overlap\n    #    so one copy is subtracted and one gets n! overall.)\n    #\n    # With the standard formula for Stirling numbers,\n    #   S(n, m) = (1/m!) * sum_{j=0}^{m} (-1)^(m - j) * C(m, j) * j^n,\n    # we obtain for k > 0 (with m = n - k):\n    #\n    #   answer = 2 * C(n, k) * (n \u2013 k)! * S(n, n \u2013 k)\n    #          = 2 * C(n, k) * Sum_{j=0}^{n-k} (-1)^(n-k - j) * C(n-k, j) * j^n.\n    \n    if k == 0:\n        sys.stdout.write(str(fact[n] % mod))\n        return\n    \n    m = n - k  # the number of nonempty rows in a configuration where every column is used.\n    F = 0\n    # Compute F(n, m) = \u03a3_{j=0}^{m} [(-1)^(m-j) * C(m, j) * j^n]  mod mod.\n    for j in range(m + 1):\n        # Compute the sign: if (m - j) is odd, use -1 mod mod.\n        if (m - j) & 1:\n            sign = mod - 1\n        else:\n            sign = 1\n        comb = (fact[m] * invfact[j] % mod) * invfact[m - j] % mod\n        term = sign * comb % mod\n        term = term * pow(j, n, mod) % mod\n        F = (F + term) % mod\n    ans = 2 * nC(n, k) % mod * F % mod\n    sys.stdout.write(str(ans % mod))\n\nif __name__ == '__main__':\n    solve()",
        "pass_ratio": 1.0,
        "tests_passed": 292,
        "tests_total": 292
      }
    ],
    "model_type": "openai",
    "model_name": "o3_mini"
  },
  {
    "problem": {
      "problem_id": 1,
      "question": "There is a chessboard of size $n$ by $n$. The square in the $i$-th row from top and $j$-th column from the left is labelled $(i,j)$.\n\nCurrently, Gregor has some pawns in the $n$-th row. There are also enemy pawns in the $1$-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from $(i,j)$ to $(i-1,j)$) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $(i,j)$ to either $(i-1,j-1)$ or $(i-1,j+1)$) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.\n\nGregor wants to know what is the maximum number of his pawns that can reach row $1$?\n\nNote that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row $1$, it is stuck and cannot make any further moves.\n\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1\\le t\\le 2\\cdot 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n\nEach test case consists of three lines. The first line contains a single integer $n$ ($2\\le n\\le 2\\cdot{10}^{5}$) \u2014 the size of the chessboard.\n\nThe second line consists of a string of binary digits of length $n$, where a $1$ in the $i$-th position corresponds to an enemy pawn in the $i$-th cell from the left, and $0$ corresponds to an empty cell.\n\nThe third line consists of a string of binary digits of length $n$, where a $1$ in the $i$-th position corresponds to a Gregor's pawn in the $i$-th cell from the left, and $0$ corresponds to an empty cell.\n\nIt is guaranteed that the sum of $n$ across all test cases is less than $2\\cdot{10}^{5}$.\n\n\n-----Output-----\n\nFor each test case, print one integer: the maximum number of Gregor's pawns which can reach the $1$-st row.\n\n\n-----Examples-----\n\nInput\n4\n3\n000\n111\n4\n1111\n1111\n3\n010\n010\n5\n11001\n00000\nOutput\n3\n4\n0\n0\n\n\n-----Note-----\n\nIn the first example, Gregor can simply advance all $3$ of his pawns forward. Thus, the answer is $3$.\n\nIn the second example, Gregor can guarantee that all $4$ of his pawns reach the enemy row, by following the colored paths as demonstrated in the diagram below. Remember, only Gregor takes turns in this \"game\"!\n\nIn the third example, Gregor's only pawn is stuck behind the enemy pawn, and cannot reach the end.\n\nIn the fourth example, Gregor has no pawns, so the answer is clearly $0$.",
      "tests": [
        {
          "stdin": "4\n3\n000\n111\n4\n1111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n4\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01001100111111000100\n00101100011010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "1\n20\n01001100111111000100\n00101100011010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n4\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01001100111111000100\n00101100011010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "2\n3\n101\n101\n5\n11000\n00000\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n4\n1111\n1100\n",
          "stdout": "2\n"
        },
        {
          "stdin": "3\n4\n1010\n0101\n3\n100\n100\n2\n10\n101010\n101010\n",
          "stdout": "2\n0\n0\n"
        },
        {
          "stdin": "4\n4\n1101\n1011\n6\n101010\n010101\n4\n1110\n1011\n5\n10101\n01010\n",
          "stdout": "2\n3\n2\n2\n"
        },
        {
          "stdin": "1\n6\n111000\n000111\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n7\n1001101\n0011101\n5\n11111\n11111\n",
          "stdout": "3\n4\n"
        },
        {
          "stdin": "1\n8\n11111100\n00110011\n",
          "stdout": "4\n"
        },
        {
          "stdin": "5\n4\n1100\n0110\n3\n110\n011\n2\n11\n11\n2\n10\n01\n2\n01\n01\n",
          "stdout": "2\n2\n2\n1\n0\n"
        },
        {
          "stdin": "1\n10\n1010010100\n0101010110\n",
          "stdout": "3\n"
        },
        {
          "stdin": "1\n2\n10\n01\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n4\n1110\n1111\n3\n001\n100\n",
          "stdout": "3\n1\n"
        },
        {
          "stdin": "3\n6\n011001\n001001\n5\n10101\n10001\n2\n11\n10\n",
          "stdout": "1\n0\n1\n"
        },
        {
          "stdin": "1\n7\n1010101\n0101010\n",
          "stdout": "3\n"
        },
        {
          "stdin": "4\n5\n11000\n10000\n6\n101010\n010101\n2\n10\n01\n3\n111\n011\n",
          "stdout": "1\n3\n1\n2\n"
        },
        {
          "stdin": "1\n3\n001\n100\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n4\n0111\n1110\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n4\n1010\n1001\n2\n100\n011\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n5\n11110\n01111\n",
          "stdout": "4\n"
        },
        {
          "stdin": "1\n10\n1111111111\n0111111111\n",
          "stdout": "9\n"
        },
        {
          "stdin": "2\n6\n100001\n011110\n4\n1000\n0111\n",
          "stdout": "4\n3\n"
        },
        {
          "stdin": "1\n7\n1110110\n1000011\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n5\n10000\n01111\n5\n00000\n11111\n",
          "stdout": "4\n5\n"
        },
        {
          "stdin": "1\n10\n1010101010\n0101010101\n",
          "stdout": "5\n"
        },
        {
          "stdin": "1\n2\n11\n10\n",
          "stdout": "1\n"
        },
        {
          "stdin": "4\n3\n001\n110\n3\n110\n001\n2\n10\n01\n2\n01\n10\n",
          "stdout": "2\n1\n1\n1\n"
        },
        {
          "stdin": "1\n8\n11110000\n00001111\n",
          "stdout": "4\n"
        },
        {
          "stdin": "5\n5\n10000\n00001\n5\n01000\n00010\n5\n00100\n00100\n5\n00010\n00001\n5\n00001\n00010\n",
          "stdout": "1\n1\n0\n1\n1\n"
        },
        {
          "stdin": "1\n3\n000\n111\n",
          "stdout": "3\n"
        },
        {
          "stdin": "1\n5\n10101\n11111\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n3\n101\n010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n3\n111\n000\n4\n0000\n1111\n",
          "stdout": "0\n4\n"
        },
        {
          "stdin": "1\n6\n000100\n110101\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n3\n010\n101\n3\n101\n111\n",
          "stdout": "2\n1\n"
        },
        {
          "stdin": "1\n4\n0110\n0000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n7\n1111110\n1111000\n",
          "stdout": "4\n"
        },
        {
          "stdin": "2\n2\n11\n00\n4\n1010\n0000\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n6\n110011\n110111\n",
          "stdout": "5\n"
        },
        {
          "stdin": "1\n5\n10000\n10000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n9\n100000000\n100000000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n8\n01101100\n11111110\n5\n10000\n11111\n",
          "stdout": "7\n4\n"
        },
        {
          "stdin": "1\n4\n1001\n1000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n12\n110011001100\n111111111111\n",
          "stdout": "12\n"
        },
        {
          "stdin": "2\n2\n10\n01\n3\n110\n001\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n7\n0110000\n1010101\n",
          "stdout": "4\n"
        },
        {
          "stdin": "2\n4\n1010\n1101\n5\n01110\n10101\n",
          "stdout": "2\n3\n"
        },
        {
          "stdin": "1\n4\n1111\n1010\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n3\n011\n110\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n2\n00\n00\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5\n11111\n10101\n",
          "stdout": "2\n"
        },
        {
          "stdin": "2\n2\n10\n01\n2\n01\n10\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "2\n3\n100\n001\n4\n1111\n0000\n",
          "stdout": "1\n0\n"
        },
        {
          "stdin": "3\n3\n001\n100\n4\n0001\n1000\n3\n111\n111\n",
          "stdout": "1\n1\n2\n"
        },
        {
          "stdin": "1\n3\n010\n010\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n3\n100\n010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n6\n111111\n000000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5\n10101\n01010\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n5\n11100\n00111\n",
          "stdout": "3\n"
        },
        {
          "stdin": "1\n4\n0101\n1010\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n3\n000\n000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n3\n111\n011\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n3\n111\n111\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n5\n10101\n00000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n3\n001\n100\n3\n111\n000\n",
          "stdout": "1\n0\n"
        },
        {
          "stdin": "2\n2\n11\n00\n3\n111\n000\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "2\n4\n1111\n1000\n4\n0000\n1111\n",
          "stdout": "1\n4\n"
        },
        {
          "stdin": "1\n6\n101010\n101010\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5\n11111\n11111\n",
          "stdout": "4\n"
        },
        {
          "stdin": "1\n5\n00000\n00000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5\n11111\n00000\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5\n00000\n11111\n",
          "stdout": "5\n"
        },
        {
          "stdin": "1\n5\n010101\n010101\n",
          "stdout": "0\n"
        },
        {
          "stdin": "5\n5\n10111\n10101\n5\n10101\n11111\n5\n01010\n10011\n5\n11011\n00100\n5\n01101\n11010\n",
          "stdout": "1\n2\n2\n1\n3\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n1110\n0001\n3\n010\n100\n5\n11001\n00100\n",
          "stdout": "2\n1\n1\n1\n"
        },
        {
          "stdin": "2\n4\n1001\n0110\n4\n1101\n1010\n",
          "stdout": "2\n2\n"
        },
        {
          "stdin": "5\n3\n110\n101\n3\n101\n010\n3\n011\n100\n3\n100\n111\n3\n001\n010\n",
          "stdout": "2\n1\n1\n2\n1\n"
        },
        {
          "stdin": "1\n10\n1110001110\n1010110101\n",
          "stdout": "5\n"
        },
        {
          "stdin": "5\n6\n101011\n110110\n6\n100101\n011011\n6\n110110\n101101\n6\n101011\n011110\n6\n001001\n100111\n",
          "stdout": "3\n3\n4\n3\n3\n"
        },
        {
          "stdin": "3\n4\n0101\n1010\n4\n1100\n0011\n4\n1110\n0111\n",
          "stdout": "2\n2\n3\n"
        },
        {
          "stdin": "1\n8\n11011011\n10110110\n",
          "stdout": "5\n"
        },
        {
          "stdin": "2\n5\n11111\n10001\n5\n00000\n11111\n",
          "stdout": "2\n5\n"
        },
        {
          "stdin": "2\n6\n111111\n111111\n6\n000000\n000000\n",
          "stdout": "6\n0\n"
        },
        {
          "stdin": "1\n9\n111111111\n111100000\n",
          "stdout": "4\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1011\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01001100111111000110\n00101100011010001110\n",
          "stdout": "9\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "3\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n110\n5\n11011\n00000\n",
          "stdout": "3\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "2\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "2\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "3\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "3\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "2\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0011\n1010\n3\n010\n111\n5\n11010\n00100\n",
          "stdout": "2\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "1\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1011\n3\n010\n010\n5\n11001\n00010\n",
          "stdout": "2\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n010\n5\n11011\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0111\n1111\n3\n010\n011\n5\n11001\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "1\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00000\n",
          "stdout": "1\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n010\n110\n5\n11010\n01100\n",
          "stdout": "2\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0001\n1010\n3\n000\n110\n5\n11010\n00100\n",
          "stdout": "3\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1001\n3\n010\n010\n5\n11001\n00010\n",
          "stdout": "2\n2\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01101100110111000110\n00101100011010000110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0111\n1111\n3\n010\n011\n5\n11001\n01000\n",
          "stdout": "2\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n1011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "1\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n0001\n1010\n3\n010\n110\n5\n11010\n01100\n",
          "stdout": "1\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0001\n1010\n3\n000\n110\n5\n11010\n01100\n",
          "stdout": "3\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n010\n010\n5\n11001\n00010\n",
          "stdout": "3\n2\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01101100010111000110\n00101100011010000110\n",
          "stdout": "7\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0001\n1110\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "1\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n100\n110\n4\n0011\n1011\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "1\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n0111\n3\n011\n010\n5\n01001\n00000\n",
          "stdout": "3\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0001\n1110\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "3\n3\n2\n2\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n010\n110\n5\n11110\n01101\n",
          "stdout": "2\n2\n1\n3\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0111\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "2\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n110\n110\n4\n1001\n1110\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "2\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0111\n1101\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n2\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1111\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "1\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n010\n010\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "0\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1011\n3\n010\n010\n5\n11001\n00110\n",
          "stdout": "2\n3\n0\n2\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1110\n3\n000\n011\n5\n11000\n00000\n",
          "stdout": "2\n3\n2\n0\n"
        },
        {
          "stdin": "4\n3\n010\n010\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00000\n",
          "stdout": "0\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n011\n111\n4\n0001\n1010\n3\n010\n110\n5\n11010\n01100\n",
          "stdout": "3\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1001\n3\n010\n010\n5\n11001\n01010\n",
          "stdout": "2\n2\n0\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n0111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n2\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n1011\n1111\n3\n010\n010\n5\n01000\n10000\n",
          "stdout": "1\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n1111\n3\n011\n011\n5\n01001\n00000\n",
          "stdout": "3\n3\n2\n0\n"
        },
        {
          "stdin": "1\n20\n01101100010110000110\n00001100011010000110\n",
          "stdout": "6\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n000\n110\n5\n11110\n01101\n",
          "stdout": "2\n2\n2\n3\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0101\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "2\n1\n1\n0\n"
        },
        {
          "stdin": "4\n3\n001\n011\n4\n0001\n0011\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "1\n1\n1\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n0011\n1000\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "1\n1\n1\n1\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0011\n1010\n3\n011\n111\n5\n11010\n00100\n",
          "stdout": "3\n2\n3\n1\n"
        },
        {
          "stdin": "4\n3\n010\n010\n4\n0011\n1010\n3\n011\n110\n5\n11010\n00100\n",
          "stdout": "0\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0001\n1010\n3\n011\n110\n5\n11010\n00100\n",
          "stdout": "1\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n001\n101\n4\n0011\n1001\n3\n010\n010\n5\n11001\n01010\n",
          "stdout": "1\n2\n0\n2\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0011\n1111\n3\n010\n010\n5\n11001\n01000\n",
          "stdout": "2\n4\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n010\n010\n5\n11001\n01010\n",
          "stdout": "3\n2\n0\n2\n"
        },
        {
          "stdin": "4\n3\n101\n110\n4\n0011\n1011\n3\n010\n100\n5\n11010\n01100\n",
          "stdout": "1\n3\n1\n2\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0001\n0111\n3\n011\n011\n5\n01001\n00000\n",
          "stdout": "2\n2\n2\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1111\n3\n110\n011\n5\n10000\n00000\n",
          "stdout": "1\n4\n2\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n100\n011\n5\n11000\n00000\n",
          "stdout": "2\n4\n2\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n1011\n1000\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "1\n0\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n1111\n3\n010\n111\n5\n10000\n00001\n",
          "stdout": "3\n3\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1111\n3\n110\n111\n5\n10000\n00000\n",
          "stdout": "1\n4\n3\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n100\n011\n5\n11000\n10000\n",
          "stdout": "2\n4\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n1011\n1000\n3\n010\n010\n5\n11010\n00100\n",
          "stdout": "1\n0\n0\n1\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0010\n1010\n3\n001\n110\n5\n11010\n00100\n",
          "stdout": "1\n1\n2\n1\n"
        },
        {
          "stdin": "1\n20\n01101100000111000000\n00101110011010001110\n",
          "stdout": "10\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0010\n0010\n3\n001\n110\n5\n11010\n00100\n",
          "stdout": "1\n0\n2\n1\n"
        },
        {
          "stdin": "4\n3\n001\n111\n4\n0010\n1111\n3\n010\n101\n5\n11000\n00001\n",
          "stdout": "2\n3\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0010\n0011\n3\n011\n111\n5\n11010\n00100\n",
          "stdout": "1\n1\n3\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0110\n1111\n3\n010\n101\n5\n11001\n00010\n",
          "stdout": "3\n4\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n011\n011\n5\n10000\n00000\n",
          "stdout": "3\n4\n2\n0\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n0010\n3\n010\n110\n5\n11110\n01101\n",
          "stdout": "2\n1\n1\n3\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n0001\n3\n011\n000\n5\n01001\n00010\n",
          "stdout": "3\n1\n0\n1\n"
        },
        {
          "stdin": "4\n3\n110\n110\n4\n1001\n1010\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "2\n1\n2\n2\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0011\n3\n011\n010\n5\n01011\n00010\n",
          "stdout": "2\n1\n1\n1\n"
        },
        {
          "stdin": "4\n3\n001\n101\n4\n0111\n1101\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "1\n2\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n1010\n1111\n3\n010\n010\n5\n01000\n10000\n",
          "stdout": "1\n2\n0\n1\n"
        },
        {
          "stdin": "4\n3\n011\n110\n4\n0001\n1000\n3\n010\n110\n5\n11010\n01100\n",
          "stdout": "2\n1\n1\n2\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n1001\n1101\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n1\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0011\n1011\n3\n010\n110\n5\n11110\n01100\n",
          "stdout": "2\n3\n1\n2\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0001\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "2\n0\n1\n0\n"
        },
        {
          "stdin": "4\n3\n110\n110\n4\n0000\n1110\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "2\n3\n2\n2\n"
        },
        {
          "stdin": "4\n3\n010\n010\n4\n0011\n1111\n3\n010\n011\n5\n10000\n00000\n",
          "stdout": "0\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0011\n1111\n3\n110\n010\n5\n11001\n01000\n",
          "stdout": "2\n4\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0001\n0111\n3\n011\n111\n5\n01001\n00000\n",
          "stdout": "2\n2\n3\n0\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0001\n1010\n3\n011\n111\n5\n10010\n00100\n",
          "stdout": "1\n2\n3\n1\n"
        },
        {
          "stdin": "4\n3\n010\n001\n4\n0011\n1011\n3\n010\n010\n5\n11001\n00111\n",
          "stdout": "1\n3\n0\n2\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1011\n3\n110\n111\n5\n10000\n00000\n",
          "stdout": "1\n3\n3\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n100\n011\n5\n11000\n10001\n",
          "stdout": "2\n4\n2\n2\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0011\n1011\n3\n001\n110\n5\n11010\n00100\n",
          "stdout": "1\n3\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n101\n4\n0010\n1010\n3\n010\n010\n5\n11001\n00111\n",
          "stdout": "2\n1\n0\n2\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0010\n1010\n3\n001\n110\n5\n11010\n10100\n",
          "stdout": "1\n1\n2\n2\n"
        },
        {
          "stdin": "1\n20\n01101100000111000000\n01101110011010001110\n",
          "stdout": "11\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n0111\n3\n010\n101\n5\n11000\n00000\n",
          "stdout": "3\n2\n2\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0010\n0011\n3\n001\n111\n5\n11010\n00100\n",
          "stdout": "2\n1\n2\n1\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0101\n1000\n3\n000\n110\n5\n11010\n00100\n",
          "stdout": "3\n1\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1000\n3\n011\n010\n5\n01001\n01010\n",
          "stdout": "3\n1\n1\n1\n"
        },
        {
          "stdin": "4\n3\n001\n001\n4\n0001\n0111\n3\n011\n110\n5\n01011\n00000\n",
          "stdout": "0\n2\n2\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1011\n1001\n3\n010\n110\n5\n11111\n00000\n",
          "stdout": "3\n1\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n110\n5\n11011\n01010\n",
          "stdout": "3\n3\n1\n2\n"
        },
        {
          "stdin": "4\n3\n011\n100\n4\n0111\n1111\n3\n011\n011\n5\n11001\n00001\n",
          "stdout": "1\n3\n2\n0\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0101\n1100\n3\n000\n110\n5\n10010\n11100\n",
          "stdout": "3\n1\n2\n2\n"
        },
        {
          "stdin": "4\n3\n011\n001\n4\n0011\n1111\n3\n110\n010\n5\n11001\n01000\n",
          "stdout": "1\n4\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0001\n0111\n3\n011\n111\n5\n01001\n00100\n",
          "stdout": "2\n2\n3\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n011\n000\n5\n01011\n00010\n",
          "stdout": "3\n4\n0\n1\n"
        },
        {
          "stdin": "4\n3\n010\n010\n4\n0011\n1111\n3\n111\n011\n5\n10000\n00000\n",
          "stdout": "0\n4\n2\n0\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0011\n1011\n3\n110\n111\n5\n10000\n00100\n",
          "stdout": "1\n3\n3\n1\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0011\n1111\n3\n001\n110\n5\n11010\n00100\n",
          "stdout": "1\n4\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n100\n4\n0111\n1100\n3\n001\n111\n5\n11001\n00000\n",
          "stdout": "1\n2\n2\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n1011\n1000\n3\n010\n110\n5\n11010\n00111\n",
          "stdout": "1\n0\n1\n2\n"
        },
        {
          "stdin": "4\n3\n010\n011\n4\n0010\n1110\n3\n001\n110\n5\n11010\n10100\n",
          "stdout": "1\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0101\n1000\n3\n000\n111\n5\n11010\n00100\n",
          "stdout": "3\n1\n3\n1\n"
        },
        {
          "stdin": "1\n20\n01101000110111000110\n00101100011000000010\n",
          "stdout": "5\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n010\n5\n11011\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01101100111111000110\n00101100011010001110\n",
          "stdout": "9\n"
        },
        {
          "stdin": "4\n3\n010\n101\n4\n0111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n110\n5\n11010\n00000\n",
          "stdout": "3\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "2\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0001\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "3\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "2\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1110\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01101100110111000110\n00101100011010001110\n",
          "stdout": "9\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n1111\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "3\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1110\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "3\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n000\n5\n11011\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n1111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n1110\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n110\n4\n0011\n1011\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "2\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n1111\n3\n011\n010\n5\n01000\n00000\n",
          "stdout": "3\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n1111\n3\n010\n010\n5\n11000\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n1011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n1111\n3\n011\n010\n5\n01001\n00000\n",
          "stdout": "3\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n0001\n1010\n3\n010\n110\n5\n11110\n01100\n",
          "stdout": "1\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0001\n1010\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "3\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n010\n010\n5\n01001\n00010\n",
          "stdout": "3\n2\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01101100010110000110\n00101100011010000110\n",
          "stdout": "7\n"
        },
        {
          "stdin": "4\n3\n000\n100\n4\n0011\n1011\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "1\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n1011\n0111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n010\n110\n5\n11110\n01100\n",
          "stdout": "2\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n011\n010\n5\n01001\n00010\n",
          "stdout": "3\n2\n1\n1\n"
        },
        {
          "stdin": "1\n20\n01001100010110000110\n00101100011010000110\n",
          "stdout": "7\n"
        },
        {
          "stdin": "4\n3\n000\n100\n4\n0011\n1010\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "1\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n1011\n0111\n3\n011\n010\n5\n01000\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n0111\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "3\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n1001\n1110\n3\n000\n110\n5\n10010\n01100\n",
          "stdout": "3\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n011\n000\n5\n01001\n00010\n",
          "stdout": "3\n2\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1101\n3\n011\n000\n5\n01001\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n001\n011\n4\n0001\n0111\n3\n011\n010\n5\n01011\n00000\n",
          "stdout": "1\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n110\n110\n4\n1001\n1110\n3\n000\n110\n5\n11010\n01100\n",
          "stdout": "2\n2\n2\n2\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1101\n3\n001\n000\n5\n01001\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n001\n011\n4\n0001\n0111\n3\n011\n010\n5\n01011\n00010\n",
          "stdout": "1\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0111\n3\n011\n010\n5\n01011\n00010\n",
          "stdout": "2\n2\n1\n1\n"
        },
        {
          "stdin": "1\n20\n01001101111111000100\n00101100011010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1111\n1110\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1011\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0011\n1011\n3\n010\n010\n5\n11001\n10000\n",
          "stdout": "2\n3\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01001100111111000111\n00101100011010001110\n",
          "stdout": "9\n"
        },
        {
          "stdin": "4\n3\n000\n101\n4\n0111\n1111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "2\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1011\n1111\n3\n010\n010\n5\n11000\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "1\n20\n01101100111111000110\n00101100010010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n010\n101\n4\n0111\n1111\n3\n000\n010\n5\n11001\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n010\n011\n5\n10000\n00000\n",
          "stdout": "3\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1011\n1011\n3\n010\n110\n5\n11011\n00000\n",
          "stdout": "3\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1001\n3\n010\n110\n5\n11010\n00000\n",
          "stdout": "3\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0011\n1111\n3\n110\n010\n5\n11000\n00000\n",
          "stdout": "2\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n100\n011\n4\n0011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n1111\n3\n010\n010\n5\n01000\n00100\n",
          "stdout": "2\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n0011\n1010\n3\n010\n110\n5\n11010\n00100\n",
          "stdout": "1\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n110\n111\n4\n0011\n1010\n3\n010\n111\n5\n11010\n00100\n",
          "stdout": "3\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n010\n111\n4\n0001\n1010\n3\n011\n110\n5\n11010\n00100\n",
          "stdout": "2\n2\n2\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n0011\n3\n010\n010\n5\n11011\n00010\n",
          "stdout": "3\n2\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01101100110111000100\n00101100011010001110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n100\n111\n4\n0010\n1111\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "2\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n011\n100\n4\n0111\n1111\n3\n010\n011\n5\n11001\n00000\n",
          "stdout": "1\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n001\n010\n4\n0011\n1111\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "1\n4\n0\n0\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0001\n1111\n3\n010\n010\n5\n01010\n00000\n",
          "stdout": "3\n3\n0\n0\n"
        },
        {
          "stdin": "4\n3\n100\n111\n4\n0011\n1011\n3\n010\n000\n5\n11011\n00010\n",
          "stdout": "2\n3\n0\n1\n"
        },
        {
          "stdin": "1\n20\n01101100110110000110\n00101100011010000110\n",
          "stdout": "8\n"
        },
        {
          "stdin": "4\n3\n011\n101\n4\n0111\n1111\n3\n010\n010\n5\n11001\n01000\n",
          "stdout": "2\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n0001\n0110\n3\n010\n011\n5\n11000\n00000\n",
          "stdout": "2\n2\n1\n0\n"
        },
        {
          "stdin": "4\n3\n000\n110\n4\n0011\n1011\n3\n010\n100\n5\n10010\n00100\n",
          "stdout": "2\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1111\n3\n011\n010\n5\n01000\n00000\n",
          "stdout": "3\n4\n1\n0\n"
        },
        {
          "stdin": "4\n3\n011\n110\n4\n0001\n1010\n3\n010\n110\n5\n11010\n01100\n",
          "stdout": "2\n2\n1\n2\n"
        },
        {
          "stdin": "4\n3\n001\n111\n4\n0011\n1001\n3\n010\n010\n5\n11001\n00010\n",
          "stdout": "2\n2\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0010\n1111\n3\n010\n010\n5\n01000\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n010\n4\n0001\n1110\n3\n010\n011\n0\n11000\n00000\n",
          "stdout": "1\n3\n1\n0\n"
        },
        {
          "stdin": "4\n3\n101\n110\n4\n0011\n1011\n3\n010\n100\n5\n11010\n00100\n",
          "stdout": "1\n3\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n011\n4\n1011\n1101\n3\n010\n010\n5\n01000\n00000\n",
          "stdout": "2\n2\n0\n0\n"
        },
        {
          "stdin": "4\n3\n010\n110\n4\n0001\n1010\n3\n010\n110\n5\n11110\n01000\n",
          "stdout": "1\n2\n1\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n0011\n1101\n3\n010\n010\n5\n01001\n00010\n",
          "stdout": "3\n3\n0\n1\n"
        },
        {
          "stdin": "4\n3\n000\n111\n4\n1111\n1111\n3\n010\n010\n5\n11001\n00000\n",
          "stdout": "3\n4\n0\n0\n"
        }
      ],
      "source": "codeforces",
      "difficulty": "EASY",
      "human_solutions": [
        "entrada = int(input())\nfor i in range(entrada):\n\tn = int(input())\n\ts = list(input())\n\tl = list(input())\n\tcount = 0\n\tfor i in range(n):\n\t\tif l[i] == '1':\n\t\t\tif s[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif i != 0 and s[i - 1] == '1':\n\t\t\t\ts[i - 1] = '0'\n\t\t\t\tcount += 1\n\t\t\telif i != n - 1 and s[i + 1] == '1':\n\t\t\t\ts[i + 1] = '0'\n\t\t\t\tcount += 1\n\tprint(count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tenemey = list(input())\n\tgregor = list(input())\n\tpawns = 0\n\tfor i in range(n):\n\t\tif gregor[i] == '1':\n\t\t\tif enemey[i] == '0':\n\t\t\t\tenemey[i] = '2'\n\t\t\t\tpawns += 1\n\t\t\telif i == 0 and enemey[i + 1] == '1':\n\t\t\t\tenemey[i + 1] = '2'\n\t\t\t\tpawns += 1\n\t\t\t\tcontinue\n\t\t\telif i == n - 1 and enemey[i - 1] == '1':\n\t\t\t\tenemey[i - 1] = '2'\n\t\t\t\tpawns += 1\n\t\t\t\tcontinue\n\t\t\telif i != 0 and i != n - 1:\n\t\t\t\tif enemey[i - 1] == '1':\n\t\t\t\t\tenemey[i - 1] = '2'\n\t\t\t\t\tpawns += 1\n\t\t\t\t\tcontinue\n\t\t\t\telif enemey[i + 1] == '1':\n\t\t\t\t\tenemey[i + 1] = '2'\n\t\t\t\t\tpawns += 1\n\tprint(pawns)\n",
        "res = ''\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tans = 0\n\tfor (i, pawn) in enumerate(b):\n\t\tif pawn == '0':\n\t\t\tcontinue\n\t\tif a[i] == '0':\n\t\t\tans += 1\n\t\t\ta[i] = '1m'\n\t\t\tb[i] = '0'\n\t\telif n == 1:\n\t\t\tbreak\n\t\telif i == 0:\n\t\t\tif a[1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tb[i] = '0'\n\t\t\t\ta[1] = '1m'\n\t\telif i == n - 1:\n\t\t\tif a[n - 2] == '1':\n\t\t\t\tans += 1\n\t\t\t\tb[n - 1] = '0'\n\t\t\t\ta[n - 1] = '1m'\n\t\telif a[i - 1] == '1':\n\t\t\tb[i] = '0'\n\t\t\tans += 1\n\t\t\ta[i - 1] = '1m'\n\t\telif a[i + 1] == '1':\n\t\t\tb[i] = '0'\n\t\t\ta[i + 1] = '1m'\n\t\t\tans += 1\n\tres += '%d\\n' % ans\nprint(res)\n",
        "import os, sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfrom math import ceil\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n\tn = int(input())\n\tenemy = list(input())\n\tme = list(input())\n\tcount = 0\n\ti = 0\n\twhile i < n:\n\t\tif i == 0:\n\t\t\tif me[i] == '1':\n\t\t\t\tif enemy[i] == '0':\n\t\t\t\t\tenemy[i] = 'X'\n\t\t\t\t\tcount += 1\n\t\t\t\telif i + 1 < n and enemy[i + 1] == '1':\n\t\t\t\t\tenemy[i + 1] = 'X'\n\t\t\t\t\tcount += 1\n\t\telif me[i] == '1':\n\t\t\tif i - 1 >= 0 and enemy[i - 1] == '1':\n\t\t\t\tenemy[i - 1] = 'X'\n\t\t\t\tcount += 1\n\t\t\telif enemy[i] == '0':\n\t\t\t\tenemy[i] = 'X'\n\t\t\t\tcount += 1\n\t\t\telif i + 1 < n and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = 'X'\n\t\t\t\tcount += 1\n\t\ti += 1\n\tprint(count)\n",
        "from typing import Counter\nt = int(input())\nfor j in range(t):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tcount = 0\n\tfor position in range(n):\n\t\tif b[position] == '1':\n\t\t\tif a[position] == '0':\n\t\t\t\tcount += 1\n\t\t\telif position != 0 and position != n - 1:\n\t\t\t\tif a[position - 1] == '1':\n\t\t\t\t\ta[position - 1] = '0'\n\t\t\t\t\tcount += 1\n\t\t\t\telif a[position + 1] == '1':\n\t\t\t\t\ta[position + 1] = '0'\n\t\t\t\t\tcount += 1\n\t\t\telif position == 0:\n\t\t\t\tif a[position + 1] == '1':\n\t\t\t\t\ta[position + 1] = '0'\n\t\t\t\t\tcount += 1\n\t\t\telif a[position - 1] == '1':\n\t\t\t\ta[position - 1] = '0'\n\t\t\t\tcount += 1\n\tprint(count)\n",
        "test_num = int(input())\ntests = []\nanswers = []\nfor i in range(test_num):\n\ttests.append((int(input()), list(input()), list(input())))\n\ndef find_answer(n, enemy, army):\n\tdemand = []\n\tfor i in range(n):\n\t\tdemand.append(0)\n\tfor i in range(n):\n\t\tif army[i] != '0':\n\t\t\tif i - 1 >= 0 and enemy[i - 1] == '1':\n\t\t\t\tdemand[i - 1] += 2\n\t\t\t\tenemy[i - 1] = '2'\n\t\t\telif enemy[i] == '0':\n\t\t\t\tdemand[i] += 2\n\t\t\t\tenemy[i] = '2'\n\t\t\telif i + 1 < n and enemy[i + 1] == '1':\n\t\t\t\tdemand[i + 1] += 2\n\t\t\t\tenemy[i + 1] = '2'\n\treturn demand.count(2)\nfor i in range(test_num):\n\tanswers.append(find_answer(tests[i][0], tests[i][1], tests[i][2]))\nfor i in range(test_num):\n\tprint(answers[i])\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tfirst = input()\n\tlast = input()\n\tvisited = [True] * n\n\tcount = 0\n\tfor i in range(n):\n\t\tif last[i] == '1':\n\t\t\tif first[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tvisited[i] = True\n\t\t\telif first[i] == '1':\n\t\t\t\tif i > 0 and first[i - 1] == '1' and visited[i - 1]:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i - 1] = False\n\t\t\t\telif i < n - 1 and first[i + 1] == '1' and visited[i + 1]:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i + 1] = False\n\tprint(count)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tenemy = list(input().strip())\n\tfriend = list(input().strip())\n\tk = 0\n\tfor i in range(n):\n\t\tif friend[i] == '1':\n\t\t\tif enemy[i] != '1':\n\t\t\t\tk += 1\n\t\t\telif i != 0 and enemy[i - 1] == '1':\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\t\tk += 1\n\t\t\telif i != n - 1 and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = '0'\n\t\t\t\tk += 1\n\tprint(k)\n",
        "t = int(input())\nfor tc in range(t):\n\tn = int(input())\n\tr1 = list(input())\n\trn = list(input())\n\tif '1' not in rn:\n\t\tprint(0)\n\t\tcontinue\n\tif '1' not in r1:\n\t\tprint(rn.count('1'))\n\t\tcontinue\n\tres = 0\n\tfor i in range(n):\n\t\tif rn[i] == '1':\n\t\t\tif i != 0 and i != n - 1:\n\t\t\t\tif r1[i - 1] == '1':\n\t\t\t\t\tres += 1\n\t\t\t\t\tr1[i - 1] = '2'\n\t\t\t\telif r1[i] == '0':\n\t\t\t\t\tres += 1\n\t\t\t\telif r1[i + 1] == '1':\n\t\t\t\t\tres += 1\n\t\t\t\t\tr1[i + 1] = '2'\n\t\t\telif i == 0:\n\t\t\t\tif r1[i] == '0':\n\t\t\t\t\tres += 1\n\t\t\t\telif r1[i + 1] == '1':\n\t\t\t\t\tres += 1\n\t\t\t\t\tr1[i + 1] = '2'\n\t\t\telif i == n - 1:\n\t\t\t\tif r1[i - 1] == '1':\n\t\t\t\t\tres += 1\n\t\t\t\t\tr1[i - 1] = '2'\n\t\t\t\telif r1[i] == '0':\n\t\t\t\t\tres += 1\n\tprint(res)\n",
        "import sys\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\n\ndef output_list(l):\n\tprint(' '.join(list(map(str, l))))\n\nclass Node:\n\n\tdef __init__(self, i, next):\n\t\tself.i = i\n\t\tself.next = next\n\n\tdef __str__(self):\n\t\treturn str(self.i)\n\ndef test_case():\n\tn = inp()\n\tenemy = list(input().strip())\n\tgregor = list(input().strip())\n\tmax_advances = 0\n\tfor i in range(n):\n\t\tif int(gregor[i]) == 1:\n\t\t\tif int(enemy[i]) == 0:\n\t\t\t\tmax_advances += 1\n\t\t\t\tenemy[i] == '2'\n\t\t\telif i - 1 >= 0 and int(enemy[i - 1]) == 1:\n\t\t\t\tmax_advances += 1\n\t\t\t\tenemy[i - 1] = '2'\n\t\t\telif i + 1 < n and int(enemy[i + 1]) == 1:\n\t\t\t\tmax_advances += 1\n\t\t\t\tenemy[i + 1] = '2'\n\tprint(max_advances)\nn_cases = inp()\nfor i in range(n_cases):\n\ttest_case()\n",
        "import sys\ninput = lambda : sys.stdin.readline().rstrip()\n\ndef solve_tc():\n\tn = int(input())\n\ts2 = [-1] + list(map(int, list(input())))\n\ts1 = list(map(int, list(input())))\n\ts2.append(-1)\n\tans = 0\n\tfor i in range(len(s1)):\n\t\tif s1[i] == 1:\n\t\t\tif s2[i] == 1:\n\t\t\t\tans += 1\n\t\t\telif s2[i + 1] == 0:\n\t\t\t\ts2[i + 1] = -1\n\t\t\t\tans += 1\n\t\t\telif s2[i + 2] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts2[i + 2] = -1\n\treturn ans\nt = int(input())\nfor _ in range(t):\n\tsys.stdout.write(str(solve_tc()) + '\\n')\n",
        "t = int(input())\n\ndef greedy(enemy: list, me: list):\n\tans = 0\n\tfor i in range(len(me)):\n\t\tif me[i] == '1' and enemy[i] == '0':\n\t\t\tme[i] = '0'\n\t\t\tenemy[i] = '2'\n\t\t\tans += 1\n\tfor i in range(len(me)):\n\t\tif me[i] == '0':\n\t\t\tcontinue\n\t\tif i - 1 >= 0 and enemy[i - 1] == '1':\n\t\t\tenemy[i - 1] = '2'\n\t\t\tme[i] = '0'\n\t\t\tans += 1\n\t\telif i + 1 < len(me) and enemy[i + 1] == '1':\n\t\t\tenemy[i + 1] = '2'\n\t\t\tme[i] = '0'\n\t\t\tans += 1\n\treturn ans\nfor _ in range(t):\n\tsz = int(input())\n\tenemy = input()\n\tme = input()\n\tprint(greedy(list(enemy), list(me)))\n",
        "import collections\nfrom collections import defaultdict\nimport math\nfrom math import factorial\nfrom math import gcd\nfrom collections import Counter\nfor t in range(int(input())):\n\tn = int(input())\n\topp = ['o' if x == '1' else '0' for x in input()]\n\tpawn = ['p' if x == '1' else '0' for x in input()]\n\tans = 0\n\tfor i in range(n):\n\t\tif pawn[i] == 'p':\n\t\t\tif opp[i] == '0':\n\t\t\t\topp[i] = 'p'\n\t\t\t\tans += 1\n\t\t\telif i > 0 and opp[i - 1] == 'o':\n\t\t\t\topp[i - 1] = 'p'\n\t\t\telif i < n - 1 and opp[i + 1] == 'o':\n\t\t\t\topp[i + 1] = 'p'\n\tprint(opp.count('p'))\n",
        "def solve(n, enemy, gregory):\n\tdestination = [e for e in enemy]\n\tpieces_that_can_pass = 0\n\tfor i in range(n):\n\t\tif gregory[i] == '0':\n\t\t\tcontinue\n\t\tif destination[i] == '0':\n\t\t\tpieces_that_can_pass += 1\n\t\t\tdestination[i] = '2'\n\t\t\tcontinue\n\t\tnext_indices = []\n\t\tif i > 0:\n\t\t\tnext_indices.append(i - 1)\n\t\tif i + 1 < n:\n\t\t\tnext_indices.append(i + 1)\n\t\tfor j in next_indices:\n\t\t\tif destination[j] == '1':\n\t\t\t\tpieces_that_can_pass += 1\n\t\t\t\tdestination[j] = '2'\n\t\t\t\tbreak\n\treturn pieces_that_can_pass\n\ndef main():\n\ttest_cases = int(input())\n\tfor t in range(test_cases):\n\t\tn = int(input())\n\t\tenemy = input()\n\t\tgregory = input()\n\t\ta = solve(n, enemy, gregory)\n\t\tprint(a)\nmain()\n",
        "from collections import Counter, deque\nfrom math import *\nmod = 1000000007\n\ndef isPrime(n):\n\tif n < 2:\n\t\treturn False\n\tif n == 2 or n == 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\tfor i in range(5, int(sqrt(n) + 1), 6):\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\treturn True\n\ndef solve():\n\tn = int(input())\n\tenemy = list(input())\n\tmy = list(input())\n\tcount = 0\n\tfor i in range(n):\n\t\tif my[i] != '0':\n\t\t\tif enemy[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif i == 0:\n\t\t\t\tif enemy[i + 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i + 1] = '0'\n\t\t\telif i == n - 1:\n\t\t\t\tif enemy[i - 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i - 1] = '0'\n\t\t\telif enemy[i - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\telif enemy[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = '0'\n\tprint(count)\nt = int(input())\nfor _ in range(t):\n\tsolve()\n",
        "t = int(input())\nwhile t > 0:\n\tn = int(input())\n\tenemys = str(input())\n\tours = str(input())\n\tenemy = []\n\tour = []\n\tfor i in range(n):\n\t\tenemy.append(int(enemys[i]))\n\t\tour.append(int(ours[i]))\n\tep = 0\n\top = 0\n\tans = 0\n\tfor i in enemy:\n\t\tif i == 1:\n\t\t\tep += 1\n\tfor i in our:\n\t\tif i == 1:\n\t\t\top += 1\n\tif ep == 0:\n\t\tprint(op)\n\telif op == 0:\n\t\tprint(0)\n\telse:\n\t\tfor i in range(n):\n\t\t\tif enemy[i] == 0 and our[i] == 1:\n\t\t\t\tans += 1\n\t\t\t\tour[i] = 0\n\t\tfor i in range(n):\n\t\t\tif our[i] == 1:\n\t\t\t\tif i > 0 and enemy[i - 1] == 1:\n\t\t\t\t\tans += 1\n\t\t\t\t\tenemy[i - 1] = 0\n\t\t\t\telif i < n - 1 and enemy[i + 1] == 1:\n\t\t\t\t\tans += 1\n\t\t\t\t\tenemy[i + 1] = 0\n\t\tprint(ans)\n\tt = t - 1\n",
        "def solve(n, a, b):\n\tans = 0\n\tmarked = set()\n\tfor i in range(n):\n\t\tif a[i] == '1':\n\t\t\tif i > 0 and b[i - 1] == '1' and (i - 1 not in marked):\n\t\t\t\tans += 1\n\t\t\telif b[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i < n - 1 and b[i + 1] == '1' and (i + 1 not in marked):\n\t\t\t\tans += 1\n\t\t\t\tmarked.add(i + 1)\n\treturn ans\nfor t in range(int(input())):\n\tn = int(input())\n\tb = input()\n\ta = input()\n\tprint(solve(n, a, b))\n",
        "def main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\ts = input()\n\t\ts = list(s)\n\t\tt = input()\n\t\tans = 0\n\t\tfor i in range(n):\n\t\t\tif t[i] == '0':\n\t\t\t\tcontinue\n\t\t\tif s[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\ts[i] = 'x'\n\t\t\telif i > 0 and s[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ts[i - 1] = 'x'\n\t\t\telif i < n - 1 and s[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ts[i + 1] = 'x'\n\t\tprint(ans)\nmain()\n",
        "def solve(n, a, b):\n\tif b.count('1') == 0:\n\t\treturn 0\n\tfor i in range(n):\n\t\ta[i] = [a[i], 0]\n\t\tb[i] = [b[i], 1]\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i][0] == '1':\n\t\t\tif i > 0 and a[i - 1] == ['1', 0]:\n\t\t\t\tans += 1\n\t\t\t\ta[i - 1] = ['1', 1]\n\t\t\telif a[i] == ['0', 0]:\n\t\t\t\tans += 1\n\t\t\t\ta[i] = ['1', 1]\n\t\t\telif i < n - 1 and a[i + 1] == ['1', 0]:\n\t\t\t\tans += 1\n\t\t\t\ta[i + 1] = ['1', 1]\n\treturn ans\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tprint(solve(n, a, b))\n",
        "from os import sep\nl = []\nfor __ in range(int(input())):\n\tn = int(input())\n\ts = list(input())\n\tt = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif t[i] == '1':\n\t\t\tif s[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\ts[i] = '2'\n\t\t\telif i > 0 and s[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\telif i < n - 1 and s[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ts[i + 1] = '2'\n\tl.append(ans)\nprint(*l, sep='\\n')\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tt = list(input())\n\tour = input()\n\tmx = 0\n\tfor i in range(n):\n\t\tif our[i] == '1':\n\t\t\tif t[i] == '0':\n\t\t\t\tt[i] = '2'\n\t\t\t\tmx += 1\n\t\t\telse:\n\t\t\t\tshift = 0\n\t\t\t\tif i + 1 < n:\n\t\t\t\t\tif t[i + 1] == '1':\n\t\t\t\t\t\tshift = 1\n\t\t\t\tif i - 1 >= 0:\n\t\t\t\t\tif t[i - 1] == '1':\n\t\t\t\t\t\tshift = -1\n\t\t\t\tif shift:\n\t\t\t\t\tt[i + shift] = '2'\n\t\t\t\t\tmx += 1\n\tprint(mx)\n",
        "def solve(a, l):\n\tocc = [0] * len(a)\n\tans = 0\n\tn = len(a)\n\tif n == 1:\n\t\tif a[0] == 0:\n\t\t\treturn 0\n\t\tif l[i] == 1:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 1\n\tfor i in range(len(a)):\n\t\tif a[i] == 1:\n\t\t\tif l[i] == 0:\n\t\t\t\tans += 1\n\t\t\t\tocc[i] = 1\n\t\t\telif i != 0 and i != n - 1:\n\t\t\t\tif l[i - 1] == 1 and occ[i - 1] == 0:\n\t\t\t\t\tans += 1\n\t\t\t\t\tocc[i - 1] = 1\n\t\t\t\telif l[i + 1] == 1 and occ[i + 1] == 0:\n\t\t\t\t\tans += 1\n\t\t\t\t\tocc[i + 1] = 1\n\t\t\telif i == 0:\n\t\t\t\tif l[i + 1] == 1:\n\t\t\t\t\tans += 1\n\t\t\t\t\tocc[i + 1] = 1\n\t\t\telif i == n - 1:\n\t\t\t\tif l[i - 1] == 1 and occ[i - 1] == 0:\n\t\t\t\t\tans += 1\n\t\t\t\t\tocc[i - 1] = 1\n\treturn ans\nfor _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input()))\n\ta = list(map(int, input()))\n\tprint(solve(a, l))\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\ta = list(s1)\n\tb = list(s2)\n\tc = 0\n\tfor j in range(n):\n\t\tif b[j] == '1':\n\t\t\tif a[j] == '0':\n\t\t\t\tc = c + 1\n\t\t\telif j > 0 and a[j - 1] == '1':\n\t\t\t\tc = c + 1\n\t\t\t\ta[j - 1] = '!'\n\t\t\telif j < n - 1 and a[j + 1] == '1':\n\t\t\t\tc = c + 1\n\t\t\t\ta[j + 1] = '!'\n\tprint(c)\n",
        "mod = 1000000007\nfrom sys import stdin, stdout\nfrom collections import defaultdict, Counter, deque\nfor _ in range(int(stdin.readline())):\n\tn = int(stdin.readline())\n\ts1 = list(stdin.readline().strip('\\n'))\n\ts2 = list(stdin.readline().strip('\\n'))\n\tcount = 0\n\tfor i in range(n):\n\t\tif s2[i] == '1' and s1[i] == '0':\n\t\t\tcount += 1\n\t\telif s2[i] == '1':\n\t\t\tif i > 0 and s1[i - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\ts1[i - 1] = '-1'\n\t\t\telif i < n - 1 and s1[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\ts1[i + 1] = '-1'\n\tprint(count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tcaptured = [False] * n\n\topp = input()\n\tme = input()\n\tresult = 0\n\tfor index in range(n):\n\t\tif me[index] == '1':\n\t\t\tif index > 0 and opp[index - 1] == '1' and (not captured[index - 1]):\n\t\t\t\tresult += 1\n\t\t\telif opp[index] == '0':\n\t\t\t\tresult += 1\n\t\t\telif index < n - 1 and opp[index + 1] == '1':\n\t\t\t\tresult += 1\n\t\t\t\tcaptured[index + 1] = True\n\tprint(result)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\ta.append('0')\n\tb.append('0')\n\tc = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif a[i - 1] == '1':\n\t\t\t\ta[i - 1] = '0'\n\t\t\t\tc += 1\n\t\t\telif a[i + 1] == '1':\n\t\t\t\ta[i + 1] = '0'\n\t\t\t\tc += 1\n\tprint(c)\n",
        "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\t(A, B) = (list(map(int, list(input()[:-1]))), list(map(int, list(input()[:-1]))))\n\tans = 0\n\tfor (i, b) in enumerate(B):\n\t\tif not b:\n\t\t\tcontinue\n\t\tif i and A[i - 1] == 1:\n\t\t\tA[i - 1] = 2\n\t\t\tans += 1\n\t\telif not A[i]:\n\t\t\tA[i] = 2\n\t\t\tans += 1\n\t\telif i < n - 1 and A[i + 1] == 1:\n\t\t\tA[i + 1] = 2\n\t\t\tans += 1\n\tprint(ans)\n",
        "for T in range(int(input())):\n\tN = int(input())\n\topponent = list(input())\n\tplayer = list(input())\n\tcount = 0\n\tif player[0] == '1':\n\t\tif opponent[0] == '0':\n\t\t\topponent[0] = '-1'\n\t\t\tcount += 1\n\t\telif opponent[1] == '1':\n\t\t\topponent[1] = '-1'\n\t\t\tcount += 1\n\tfor i in range(1, N - 1):\n\t\tif player[i] == '1':\n\t\t\tif opponent[i - 1] == '1':\n\t\t\t\topponent[i - 1] = '-1'\n\t\t\t\tcount += 1\n\t\t\telif opponent[i] == '0':\n\t\t\t\topponent[i] = '-1'\n\t\t\t\tcount += 1\n\t\t\telif opponent[i + 1] == '1':\n\t\t\t\topponent[i + 1] = '-1'\n\t\t\t\tcount += 1\n\tif player[N - 1] == '1':\n\t\tif opponent[N - 2] == '1' or opponent[N - 1] == '0':\n\t\t\tcount += 1\n\tprint(count)\n",
        "import io\nimport os\n\ndef solve():\n\tn = int(input())\n\tenemy = list(map(int, input()))\n\tgreg = list(map(int, input()))\n\ttaken = [False] * n\n\tcount = 0\n\tfor (i, (e, g)) in enumerate(zip(enemy, greg)):\n\t\tif not g:\n\t\t\tcontinue\n\t\tif not e:\n\t\t\tcount += 1\n\t\t\tcontinue\n\t\tif i > 0 and enemy[i - 1] and (not taken[i - 1]):\n\t\t\tcount += 1\n\t\telif i < n - 1 and enemy[i + 1]:\n\t\t\tcount += 1\n\t\t\ttaken[i + 1] = True\n\tprint(count)\nt = int(input())\nfor _ in range(t):\n\tsolve()\n",
        "t = int(input())\nlan = []\nfor _ in range(t):\n\tn = int(input())\n\tup = list(input())\n\tdown = input()\n\tctr = 0\n\tfor indx in range(n):\n\t\tif indx == 0 and down[indx] == '1':\n\t\t\tif up[indx] == '0':\n\t\t\t\tup[indx] = '2'\n\t\t\t\tctr += 1\n\t\t\telif up[indx + 1] == '1':\n\t\t\t\tup[indx + 1] = '2'\n\t\t\t\tctr += 1\n\t\telif indx == n - 1 and down[indx] == '1':\n\t\t\tif up[indx] == '0':\n\t\t\t\tup[indx] = '2'\n\t\t\t\tctr += 1\n\t\t\telif up[indx - 1] == '1':\n\t\t\t\tup[indx - 1] = '2'\n\t\t\t\tctr += 1\n\t\telif indx > 0 and indx < n - 1 and (down[indx] == '1'):\n\t\t\tif up[indx - 1] == '1':\n\t\t\t\tup[indx - 1] = '2'\n\t\t\t\tctr += 1\n\t\t\telif up[indx] == '0':\n\t\t\t\tup[indx] = '2'\n\t\t\t\tctr += 1\n\t\t\telif up[indx + 1] == '1':\n\t\t\t\tup[indx + 1] = '2'\n\t\t\t\tctr += 1\n\tlan.append(ctr)\nprint(*lan, sep='\\n')\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tb = list(map(int, input()))\n\tw = list(map(int, input()))\n\tc = 0\n\tif w[0]:\n\t\tif b[0] == 0:\n\t\t\tb[0] = 2\n\t\telif b[1] == 1:\n\t\t\tb[1] = 2\n\tfor i in range(1, n - 1):\n\t\tif w[i] == 0:\n\t\t\tcontinue\n\t\tif b[i] == 0:\n\t\t\tb[i] = 2\n\t\telif b[i - 1] == 1:\n\t\t\tb[i - 1] = 2\n\t\telif b[i + 1] == 1:\n\t\t\tb[i + 1] = 2\n\tif w[n - 1]:\n\t\tif b[n - 1] == 0:\n\t\t\tb[n - 1] = 2\n\t\telif b[n - 2] == 1:\n\t\t\tb[n - 2] = 2\n\tprint(b.count(2))\n",
        "for i in range(int(input())):\n\tn = int(input())\n\ts1 = list(input())\n\ts2 = list(input())\n\tans = 0\n\toccupied = [0] * n\n\tfor i in range(n):\n\t\tif s2[i] == '0':\n\t\t\tcontinue\n\t\tif s1[i] == '0':\n\t\t\toccupied[i] = 1\n\t\t\tans += 1\n\t\telif i > 0 and s1[i - 1] == '1' and (occupied[i - 1] == 0):\n\t\t\toccupied[i - 1] = 1\n\t\t\tans += 1\n\t\telif i < n - 1 and s1[i + 1] == '1' and (occupied[i + 1] == 0):\n\t\t\toccupied[i + 1] = 1\n\t\t\tans += 1\n\tprint(ans)\n",
        "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\tl1 = list(input())\n\tl1.append(2)\n\tl2 = list(input())\n\tc = 0\n\tfor i in range(len(l2)):\n\t\tif l2[i] == '1':\n\t\t\tif l1[i] == '0':\n\t\t\t\tl1[i] = '2'\n\t\t\t\tl2[i] = '0'\n\t\t\t\tc = c + 1\n\tfor i in range(len(l2)):\n\t\tif l2[i] == '1':\n\t\t\tif l1[i - 1] == '1':\n\t\t\t\tl1[i - 1] = '2'\n\t\t\t\tl2[i] = '0'\n\t\t\t\tc = c + 1\n\t\t\telif l1[i + 1] == '1':\n\t\t\t\tl1[i + 1] = '2'\n\t\t\t\tl2[i] = '0'\n\t\t\t\tc = c + 1\n\tprint(c)\n",
        "from math import inf\n\ndef pro(a, b):\n\tn = len(a)\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\ta[i] = -1\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tif i - 1 >= 0 and a[i - 1] == '1':\n\t\t\t\t\ta[i - 1] = -1\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif i + 1 < n and a[i + 1] == '1':\n\t\t\t\t\ta[i + 1] = -1\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\tprint(ans)\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\ta = input()\n\tarr = input()\n\tpro(list(a), list(arr))\n",
        "import collections\nimport itertools\nfrom collections import defaultdict\nimport sys\np2D = lambda x: print(*x, sep='\\n')\n\ndef II():\n\treturn int(sys.stdin.buffer.readline())\n\ndef MI():\n\treturn map(int, sys.stdin.buffer.readline().split())\n\ndef LI():\n\treturn list(map(int, sys.stdin.buffer.readline().split()))\n\ndef LLI(rows_number):\n\treturn [LI() for _ in range(rows_number)]\n\ndef BI():\n\treturn sys.stdin.buffer.readline().rstrip()\n\ndef SI():\n\treturn sys.stdin.buffer.readline().rstrip().decode()\n\ndef li():\n\treturn [int(i) for i in input().split()]\n\ndef lli(rows):\n\treturn [li() for _ in range(rows)]\n\ndef si():\n\treturn input()\n\ndef ii():\n\treturn int(input())\n\ndef ins():\n\treturn input().split()\n\ndef solve():\n\tn = II()\n\tpe = []\n\tge = []\n\tans = 0\n\tfor i in SI():\n\t\tpe.append(i)\n\tfor i in SI():\n\t\tge.append(i)\n\tfor i in range(n):\n\t\tif pe[i] == '0' and ge[i] == '1':\n\t\t\tans += 1\n\t\t\tge[i] = '0'\n\t\telif pe[i] == '1':\n\t\t\tif i > 0 and ge[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tge[i - 1] = '0'\n\t\t\telif i < n - 1 and ge[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tge[i + 1] = '0'\n\treturn ans\n\ndef main():\n\tfor _ in range(II()):\n\t\tsys.stdout.write(str(solve()) + '\\n')\nmain()\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\ts1 = list('0' + input() + '0')\n\ts2 = input()\n\tk = 0\n\tfor i in range(n):\n\t\tif s2[i] != '1':\n\t\t\tcontinue\n\t\tif s1[i + 1] == '0':\n\t\t\ts1[i + 1] = '2'\n\t\t\tk += 1\n\t\telif s1[i] == '1':\n\t\t\ts1[i] = '2'\n\t\t\tk += 1\n\t\telif s1[i + 2] == '1':\n\t\t\ts1[i + 2] = '2'\n\t\t\tk += 1\n\tprint(k)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tc = 0\n\tl = list(input())\n\tk = list(input())\n\tfor i in range(n):\n\t\tif k[i] == '0':\n\t\t\tcontinue\n\t\tif l[i] == '0':\n\t\t\tc += 1\n\t\telif i and l[i - 1] == '1':\n\t\t\tc += 1\n\t\telif i + 1 < n and l[i + 1] == '1':\n\t\t\tl[i + 1] = '0'\n\t\t\tc += 1\n\tprint(c)\n",
        "t = int(input())\nwhile t > 0:\n\tn = int(input())\n\tenemy = input()\n\tmy = input()\n\tenemy_arr = []\n\tmy_arr = []\n\tresult = 0\n\tfor i in range(0, n, 1):\n\t\tenemy_arr.append(int(enemy[i]))\n\t\tmy_arr.append(int(my[i]))\n\tfor i in range(0, n, 1):\n\t\tif my_arr[i] == 1 and enemy_arr[i] == 0:\n\t\t\tenemy_arr[i] = -1\n\t\t\tresult = result + 1\n\t\telif my_arr[i] == 1 and enemy_arr[i] != 0:\n\t\t\tif i < n - 1 and i > 0:\n\t\t\t\tif enemy_arr[i - 1] == 1:\n\t\t\t\t\tenemy_arr[i - 1] = -1\n\t\t\t\t\tresult = result + 1\n\t\t\t\telif enemy_arr[i + 1] == 1:\n\t\t\t\t\tenemy_arr[i + 1] = -1\n\t\t\t\t\tresult = result + 1\n\t\t\tif i == 0:\n\t\t\t\tif enemy_arr[i + 1] == 1:\n\t\t\t\t\tenemy_arr[i + 1] = -1\n\t\t\t\t\tresult = result + 1\n\t\t\tif i == n - 1:\n\t\t\t\tif enemy_arr[i - 1] == 1:\n\t\t\t\t\tenemy_arr[i - 1] = -1\n\t\t\t\t\tresult = result + 1\n\tprint(result)\n\tt = t - 1\n",
        "def result(first, second, length):\n\tresult = list(first)\n\tcount = 0\n\tfor i in range(length):\n\t\tif second[i] == '1':\n\t\t\tif first[i] == '0':\n\t\t\t\tresult[i] = '2'\n\t\t\t\tcount += 1\n\t\t\telif first[i] == '1' and i - 1 >= 0 and (result[i - 1] == '1') and (first[i - 1] == '1'):\n\t\t\t\tresult[i - 1] = '2'\n\t\t\t\tcount += 1\n\t\t\telif first[i] == '1' and i + 1 < length and (result[i + 1] == '1') and (first[i + 1] == '1'):\n\t\t\t\tresult[i + 1] = '2'\n\t\t\t\tcount += 1\n\tprint(count)\nfor i in range(int(input())):\n\tlength = int(input())\n\ta = input()\n\tb = input()\n\tresult(a, b, length)\n",
        "from sys import stdin\ninput = stdin.readline\nfor i in range(int(input())):\n\tn = int(input())\n\ts1 = list(input())\n\ts2 = list(input())\n\tans = 0\n\toccupied = [0] * n\n\tfor i in range(n):\n\t\tif s2[i] == '0':\n\t\t\tcontinue\n\t\tif s1[i] == '0':\n\t\t\toccupied[i] = 1\n\t\t\tans += 1\n\t\telif i > 0 and s1[i - 1] == '1' and (occupied[i - 1] == 0):\n\t\t\toccupied[i - 1] = 1\n\t\t\tans += 1\n\t\telif i < n - 1 and s1[i + 1] == '1' and (occupied[i + 1] == 0):\n\t\t\toccupied[i + 1] = 1\n\t\t\tans += 1\n\tprint(ans)\n",
        "for t in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i >= 1 and a[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ta[i - 1] = '0'\n\t\t\telif i < n - 1 and a[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ta[i + 1] = '0'\n\tprint(ans)\n",
        "import math, os, io, sys\nfrom collections import Counter\nimport heapq\nfrom collections import deque\n\ndef getList(method=int):\n\treturn list(map(method, input().split()))\n\ndef getInt():\n\treturn int(input())\n\ndef solve():\n\tn = getInt()\n\te = input()\n\tg = input()\n\tocc = set()\n\tans = 0\n\tfor i in range(n):\n\t\tif g[i] == '1':\n\t\t\tif e[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i - 1 > -1 and e[i - 1] == '1' and (i - 1 not in occ):\n\t\t\t\tans += 1\n\t\t\telif i + 1 < n and e[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tocc.add(i + 1)\n\treturn ans\nfor _ in range(getInt()):\n\tprint(solve())\n",
        "t = int(input())\nfor i in range(t):\n\tsz = int(input())\n\tenemy = input()\n\tenemy = list(enemy)\n\tgregor = input()\n\tgregor = list(gregor)\n\tret = 0\n\tfor (idx, item) in enumerate(gregor):\n\t\tif item == '1' and idx - 1 >= 0 and (enemy[idx - 1] == '1'):\n\t\t\tenemy[idx - 1] = '2'\n\t\t\tret += 1\n\t\telif item == '1' and enemy[idx] == '0':\n\t\t\tenemy[idx] = '2'\n\t\t\tret += 1\n\t\telif item == '1' and enemy[idx] == '1' and (idx + 1 < sz) and (enemy[idx + 1] == '1'):\n\t\t\tenemy[idx + 1] = '2'\n\t\t\tret += 1\n\tprint(ret)\n",
        "t = int(input())\ntestcases = [(int(input()), list(map(int, input())), list(map(int, input()))) for _ in range(t)]\nfor (n, enemy, gregor) in testcases:\n\tif gregor.count(1) == 0:\n\t\tprint(0)\n\t\tcontinue\n\tcount = 0\n\tfor i in range(n):\n\t\tif gregor[i] == 1:\n\t\t\tif enemy[i] == 0:\n\t\t\t\tcount += 1\n\t\t\telif i > 0 and enemy[i - 1] == 1:\n\t\t\t\tcount += 1\n\t\t\telif i < n - 1 and enemy[i + 1] == 1:\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = 0\n\tprint(count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\t(lst1, lst2) = (list(), list())\n\tres = 0\n\tlst1 += input()\n\tlst2 += input()\n\tfor i in range(n):\n\t\tif lst2[i] == '1':\n\t\t\tif lst1[i] == '0':\n\t\t\t\tres += 1\n\t\t\t\tlst1[i] = 'X'\n\t\t\telif i == 0 and lst1[i + 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\tlst1[i + 1] = 'X'\n\t\t\telif i == n - 1 and lst1[i - 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\tlst1[i - 1] = 'X'\n\t\t\telif (i != 0 and i != n - 1) and lst1[i - 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\tlst1[i - 1] = 'X'\n\t\t\telif (i != 0 and i != n - 1) and lst1[i + 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\tlst1[i + 1] = 'X'\n\tprint(res)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tfirst = input()\n\tsecond = input()\n\tli = [False] * n\n\tfor i in range(n):\n\t\tif second[i] == '1':\n\t\t\tif first[i] == '0':\n\t\t\t\tli[i] = True\n\t\t\telif i - 1 >= 0 and first[i - 1] == '1' and (li[i - 1] == False):\n\t\t\t\tli[i - 1] = True\n\t\t\telif i + 1 < n and first[i + 1] == '1' and (li[i + 1] == False):\n\t\t\t\tli[i + 1] = True\n\tprint(li.count(True))\n",
        "import sys, os, io\ninput = sys.stdin.readline\nPI = 3.141592653589793\nINF = float('inf')\nMOD = 1000000007\n\ndef bin32(num):\n\treturn '{0:032b}'.format(num)\n\ndef add(x, y):\n\treturn (x + y) % MOD\n\ndef sub(x, y):\n\treturn (x - y + MOD) % MOD\n\ndef mul(x, y):\n\treturn x * y % MOD\n\ndef gcd(x, y):\n\tif y == 0:\n\t\treturn x\n\treturn gcd(y, x % y)\n\ndef lcm(x, y):\n\treturn x * y // gcd(x, y)\n\ndef power(x, y):\n\tres = 1\n\tx %= MOD\n\twhile y != 0:\n\t\tif y & 1:\n\t\t\tres = mul(res, x)\n\t\ty >>= 1\n\t\tx = mul(x, x)\n\treturn res\n\ndef mod_inv(n):\n\treturn power(n, MOD - 2)\n\ndef prob(p, q):\n\treturn mul(p, power(q, MOD - 2))\n\ndef ii():\n\treturn int(input())\n\ndef li():\n\treturn [int(i) for i in input().split()]\n\ndef ls():\n\treturn [i for i in input().split()]\nfor t in range(ii()):\n\tt += 1\n\tn = ii()\n\ta = input()\n\tb = input()\n\ta = list(a)\n\tb = list(b)\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tif i != 0:\n\t\t\t\t\tif a[i - 1] == '1':\n\t\t\t\t\t\tans += 1\n\t\t\t\t\t\tcontinue\n\t\t\t\tif i != n - 1:\n\t\t\t\t\tif a[i + 1] == '1':\n\t\t\t\t\t\tans += 1\n\t\t\t\t\t\ta[i + 1] = '-1'\n\tprint(ans)\n",
        "T = int(input())\nfor _ in range(T):\n\tn = int(input())\n\tstr1 = input()\n\tstr2 = input()\n\tarr1 = list(str1)\n\tarr2 = list(str2)\n\tans = 0\n\tif arr2[0] == '1':\n\t\tif arr1[0] == '0':\n\t\t\tans += 1\n\t\telif arr1[1] == '1':\n\t\t\tarr1[1] = '0'\n\t\t\tans += 1\n\tfor i in range(1, n - 1):\n\t\tif arr2[i] == '1':\n\t\t\tif arr1[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tarr1[i - 1] = '0'\n\t\t\telif arr1[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif arr1[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tarr1[i + 1] = '0'\n\tif arr2[n - 1] == '1':\n\t\tif arr1[n - 1] == '0':\n\t\t\tans += 1\n\t\telif arr1[n - 2] == '1':\n\t\t\tans += 1\n\t\t\tarr1[n - 2] = '0'\n\tprint(ans)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ts = list(map(int, list(input())))\n\tm = list(map(int, list(input())))\n\tans = 0\n\tif m[0] == 1:\n\t\tif s[0] == 0:\n\t\t\tans += 1\n\t\telif s[1] == 1:\n\t\t\tans += 1\n\t\t\ts[1] = 2\n\tfor x in range(1, n):\n\t\tif m[x] == 1:\n\t\t\tif s[x] == 0:\n\t\t\t\tans += 1\n\t\t\telif s[x - 1] == 1:\n\t\t\t\tans += 1\n\t\t\telif x + 1 != n and s[x + 1] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts[x + 1] = 2\n\tprint(ans)\n",
        "import sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\tenemy = input()\n\tgregor = input()\n\tcount = 0\n\tprev_available = False\n\tcur_available = True\n\tfor i in range(n):\n\t\tif gregor[i] == '1' and enemy[i] == '0':\n\t\t\tcount += 1\n\t\t\t(prev_available, cur_available) = (False, True)\n\t\telif gregor[i] == '1' and prev_available:\n\t\t\tcount += 1\n\t\t\t(prev_available, cur_available) = (cur_available, True)\n\t\telif gregor[i] == '1' and i < n - 1 and (enemy[i + 1] == '1'):\n\t\t\tcount += 1\n\t\t\t(prev_available, cur_available) = (cur_available, False)\n\t\telif gregor[i] == '1':\n\t\t\t(prev_available, cur_available) = (cur_available, True)\n\t\telif enemy[i] == '0':\n\t\t\t(prev_available, cur_available) = (False, True)\n\t\telif enemy[i] == '1':\n\t\t\t(prev_available, cur_available) = (cur_available, True)\n\tprint(count)\n",
        "n = int(input())\nfor i in range(n):\n\twin = 0\n\tl = int(input())\n\tent = list(input())\n\tgreg = list(input())\n\tfor x in range(l):\n\t\tif greg[x] == '1':\n\t\t\tif ent[x] == '0':\n\t\t\t\twin += 1\n\t\t\t\tent[x] = '2'\n\t\t\telif x - 1 >= 0 and ent[x - 1] == '1':\n\t\t\t\twin += 1\n\t\t\t\tent[x - 1] = '2'\n\t\t\telif x + 1 < l and ent[x + 1] == '1':\n\t\t\t\twin += 1\n\t\t\t\tent[x + 1] = '2'\n\tprint(win)\n",
        "for i in range(int(input())):\n\ta = int(input())\n\tb = input()\n\tc = input()\n\tm = []\n\tn = []\n\tfor i in range(a):\n\t\tm.append(b[i])\n\t\tn.append(c[i])\n\tcount = 0\n\tfor i in range(a):\n\t\tif n[i] == '1' and m[i] == '0':\n\t\t\tcount += 1\n\t\t\tm[i] = '2'\n\t\t\tcontinue\n\t\tif n[i] == '1' and i != 0 and (m[i - 1] == '1'):\n\t\t\tcount += 1\n\t\t\tm[i - 1] = '2'\n\t\t\tcontinue\n\t\tif n[i] == '1' and i != a - 1 and (m[i + 1] == '1'):\n\t\t\tcount += 1\n\t\t\tm[i + 1] = '2'\n\t\t\tcontinue\n\tprint(count)\n",
        "import sys\n\ndef get_ints():\n\treturn map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n\treturn list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_list_string():\n\treturn list(map(str, sys.stdin.readline().strip().split()))\n\ndef get_string():\n\treturn sys.stdin.readline().strip()\n\ndef get_int():\n\treturn int(sys.stdin.readline().strip())\n\ndef get_print_int(x):\n\tsys.stdout.write(str(x) + '\\n')\n\ndef get_print(x):\n\tsys.stdout.write(x + '\\n')\n\ndef get_print_int_same(x):\n\tsys.stdout.write(str(x) + ' ')\n\ndef get_print_same(x):\n\tsys.stdout.write(x + ' ')\nfrom sys import maxsize\n\ndef solve():\n\tfor _ in range(get_int()):\n\t\tn = get_int()\n\t\ts1 = get_string()\n\t\ts2 = get_string()\n\t\td1 = list(s1)\n\t\td2 = list(s2)\n\t\tans = 0\n\t\tfor i in range(n):\n\t\t\tif d2[i] == '1':\n\t\t\t\tif d1[i] == '0':\n\t\t\t\t\tans += 1\n\t\t\t\telif i - 1 >= 0 and d1[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\td1[i - 1] = '0'\n\t\t\t\telif i + 1 < n and d1[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\td1[i + 1] = '0'\n\t\tget_print_int(ans)\nsolve()\n",
        "def answer(enemy, gregory):\n\tresult = 0\n\tfor i in range(len(gregory)):\n\t\tif enemy[i] == '0':\n\t\t\tif gregory[i] == '1':\n\t\t\t\tgregory[i] = '-1'\n\t\t\t\tresult += 1\n\t\telif i - 1 >= 0 and gregory[i - 1] == '1':\n\t\t\tresult += 1\n\t\telif i + 1 <= len(gregory) - 1 and gregory[i + 1] == '1':\n\t\t\tresult += 1\n\t\t\tgregory[i + 1] = '-1'\n\treturn result\ntest = int(input())\nfor i in range(test):\n\tn = int(input())\n\tenemy = list(input())\n\tgregory = list(input())\n\tprint(answer(enemy, gregory))\n",
        "import sys\nt = int(sys.stdin.readline())\nfor _ in range(t):\n\tn = int(sys.stdin.readline())\n\tarr_1 = list(sys.stdin.readline().strip())\n\tarr_2 = list(sys.stdin.readline().strip())\n\tcount = 0\n\tfor i in range(len(arr_1) - 1):\n\t\tif arr_1[i] == '0' and arr_2[i] == '1':\n\t\t\tarr_1[i] = '2'\n\t\t\tarr_2[i] = '0'\n\t\t\tcount += 1\n\t\tif arr_1[i + 1] == '0' and arr_2[i + 1] == '1':\n\t\t\tarr_1[i + 1] = '2'\n\t\t\tarr_2[i + 1] = '0'\n\t\t\tcount += 1\n\t\tif arr_1[i] == '1' and arr_2[i + 1] == '1':\n\t\t\tarr_1[i] = '2'\n\t\t\tarr_2[i + 1] = '0'\n\t\t\tcount += 1\n\t\tif arr_1[i + 1] == '1' and arr_2[i] == '1':\n\t\t\tarr_1[i + 1] = '0'\n\t\t\tarr_2[i] = '0'\n\t\t\tcount += 1\n\tprint(count)\n",
        "from sys import stdin\nfor _ in range(int(stdin.readline())):\n\tn = int(stdin.readline())\n\ta = list(stdin.readline().strip())\n\tb = list(stdin.readline().strip())\n\tres = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif i > 0 and a[i - 1] == '1':\n\t\t\t\tres += 1\n\t\t\telif a[i] == '0':\n\t\t\t\tres += 1\n\t\t\telif i < n - 1 and a[i + 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\ta[i + 1] = '2'\n\tprint(res)\n",
        "def sol(A, B):\n\tsett = set()\n\tcount = 0\n\tfor i in range(len(B)):\n\t\tif B[i] == '1':\n\t\t\tif A[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif i - 1 >= 0 and A[i - 1] == '1' and (i - 1 not in sett):\n\t\t\t\tcount += 1\n\t\t\t\tsett.add(i - 1)\n\t\t\telif i + 1 <= len(B) - 1 and A[i + 1] == '1' and (i + 1 not in sett):\n\t\t\t\tcount += 1\n\t\t\t\tsett.add(i + 1)\n\treturn count\nx = int(input())\nfor _ in range(x):\n\ty = input()\n\tA = input()\n\tB = input()\n\tprint(sol(A, B))\n",
        "from math import *\nfrom math import factorial as fact, comb as ncr\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom collections import Counter as ctr\nfrom collections import deque as dq\nfrom array import array\nfrom re import search\nli = lambda : list(map(int, input().split()))\narr = lambda a: array('i', a)\nbi = lambda n: bin(n).replace('0b', '')\nyn = lambda f: print('NYOE S'[f::2])\nsbstr = lambda a, s: search('.*'.join(a), s)\n\ndef gcdsum(n):\n\ts = sum((int(x) for x in str(n)))\n\treturn gcd(n, s)\n\ndef solve():\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\ta = list(input())\n\t\tb = input()\n\t\tt = False\n\t\tans = 0\n\t\tfor i in range(n):\n\t\t\tif b[i] == '1':\n\t\t\t\tif a[i] == '0':\n\t\t\t\t\tans += 1\n\t\t\t\telif i > 0 and a[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\ta[i - 1] = '#'\n\t\t\t\telif i < n - 1 and a[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\ta[i + 1] = '#'\n\t\tprint(ans)\nsolve()\n",
        "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\ndef list2d(a, b, c):\n\treturn [[c] * b for i in range(a)]\n\ndef list3d(a, b, c, d):\n\treturn [[[d] * c for j in range(b)] for i in range(a)]\n\ndef list4d(a, b, c, d, e):\n\treturn [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\n\ndef ceil(x, y=1):\n\treturn int(-(-x // y))\n\ndef INT():\n\treturn int(input())\n\ndef MAP():\n\treturn map(int, input().split())\n\ndef LIST(N=None):\n\treturn list(MAP()) if N is None else [INT() for i in range(N)]\n\ndef Yes():\n\tprint('Yes')\n\ndef No():\n\tprint('No')\n\ndef YES():\n\tprint('YES')\n\ndef NO():\n\tprint('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nRi = lambda : [int(x) for x in sys.stdin.readline().split()]\nri = lambda : sys.stdin.readline().strip()\ntt = int(input())\nfor qq in range(tt):\n\tn = int(input())\n\ts = [i for i in input()]\n\tt = [i for i in input()]\n\tcnt = 0\n\tif t[0] == '1' and s[0] == '0':\n\t\tcnt += 1\n\t\ts[0] = '-1'\n\telif t[0] == '1' and s[1] == '1':\n\t\tcnt += 1\n\t\ts[1] = '-1'\n\tfor i in range(1, n):\n\t\tif t[i] == '1':\n\t\t\tif s[i - 1] == '1':\n\t\t\t\tcnt += 1\n\t\t\t\ts[i - 1] = '-1'\n\t\t\telif s[i] == '0':\n\t\t\t\tcnt += 1\n\t\t\t\ts[i] = '-1'\n\t\t\telif i + 1 < n and s[i + 1] == '1':\n\t\t\t\tcnt += 1\n\t\t\t\ts[i + 1] = '-1'\n\tprint(cnt)\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tls1 = list(input())\n\tls2 = list(input())\n\ts = 0\n\tfor i in range(n):\n\t\tif ls2[i] == '1':\n\t\t\tif i > 0:\n\t\t\t\tif ls1[i - 1] == '1':\n\t\t\t\t\tls1[i - 1] = '2'\n\t\t\t\t\ts += 1\n\t\t\t\t\tcontinue\n\t\t\tif ls1[i] == '0':\n\t\t\t\tls1[i] = '2'\n\t\t\t\ts += 1\n\t\t\t\tcontinue\n\t\t\tif i < n - 1:\n\t\t\t\tif ls1[i + 1] == '1':\n\t\t\t\t\tls1[i + 1] = '2'\n\t\t\t\t\ts += 1\n\tprint(s)\n",
        "import os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nelse:\n\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\n\tinput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nfor t in range(int(input())):\n\tn = int(input())\n\tenemy = list(input())\n\tgregor = list(input())\n\tindices = []\n\tindices = set(indices)\n\tusedindices = []\n\tans = 0\n\tfor i in range(n):\n\t\tif enemy[i] == '1':\n\t\t\tindices.add(i)\n\tif indices == []:\n\t\tprint(gregor.count('1'))\n\t\tcontinue\n\tfor i in range(n):\n\t\tif gregor[i] == '1':\n\t\t\tif i in indices:\n\t\t\t\tif i - 1 in indices:\n\t\t\t\t\tans += 1\n\t\t\t\t\tindices.remove(i - 1)\n\t\t\t\telif i + 1 in indices:\n\t\t\t\t\tans += 1\n\t\t\t\t\tindices.remove(i + 1)\n\t\t\telse:\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "import math\nmod = 1000000007\nfrom sys import stdin, stdout\nfor abcd in range(int(input())):\n\tn = int(stdin.readline())\n\tt = list(stdin.readline().strip('\\n'))\n\ts = list(stdin.readline().strip('\\n'))\n\tif n == 1:\n\t\tif t[i] == '0':\n\t\t\tprint(0)\n\t\telif t[i] == '1':\n\t\t\tif s[i] == '1':\n\t\t\t\tprint(0)\n\t\t\telse:\n\t\t\t\tprint(1)\n\t\telse:\n\t\t\tprint(0)\n\t\tcontinue\n\tc = 0\n\tfor i in range(n):\n\t\tif s[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif t[i] == '0':\n\t\t\t\t\tc += 1\n\t\t\t\telif t[i + 1] == '1':\n\t\t\t\t\tc += 1\n\t\t\t\t\tt[i + 1] = 0\n\t\t\telif i == n - 1:\n\t\t\t\tif t[i] == '0':\n\t\t\t\t\tc += 1\n\t\t\t\telif t[i - 1] == '1':\n\t\t\t\t\tc += 1\n\t\t\t\t\tt[i - 1] = 0\n\t\t\telif t[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif t[i - 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\tt[i - 1] = 0\n\t\t\telif t[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\tt[i + 1] = 0\n\tprint(c)\n",
        "t = int(input())\nwhile t:\n\tn = int(input())\n\tenemy = list(input())\n\tenemy = ['0'] + enemy + ['0']\n\tgreg = input()\n\tcnt = 0\n\tfor i in range(len(greg)):\n\t\tif greg[i] == '1':\n\t\t\tif enemy[i + 1] == '0':\n\t\t\t\tcnt += 1\n\t\t\telif enemy[i] == '1':\n\t\t\t\tcnt += 1\n\t\t\t\tenemy[i] = '0'\n\t\t\telif enemy[i + 2] == '1':\n\t\t\t\tcnt += 1\n\t\t\t\tenemy[i + 2] = '0'\n\tprint(cnt)\n\tt -= 1\n",
        "t = int(input())\nwhile t:\n\tt -= 1\n\tn = int(input())\n\tblocked = [0] * n\n\tcount = 0\n\tl0 = str(input())\n\tl1 = str(input())\n\tfor i in range(n):\n\t\tif l1[i] == '1':\n\t\t\tif l0[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tcontinue\n\t\t\tif i > 0:\n\t\t\t\tif l0[i - 1] == '1':\n\t\t\t\t\tif blocked[i - 1] == 0:\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tblocked[i - 1] = 1\n\t\t\t\t\t\tcontinue\n\t\t\tif i < n - 1:\n\t\t\t\tif l0[i + 1] == '1':\n\t\t\t\t\tif blocked[i + 1] == 0:\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tblocked[i + 1] = 1\n\t\t\t\t\t\tcontinue\n\tprint(count)\n",
        "import sys\nimport math\nimport bisect\nt = int(input())\nfor a0 in range(t):\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tc = 0\n\tf = [0] * n\n\tif s2[0] == '1' and s1[0] == '0':\n\t\tc += 1\n\t\tf[0] = 1\n\telif s2[0] == '1' and s1[1] == '1':\n\t\tc += 1\n\t\tf[1] = 1\n\tfor i in range(1, n - 1):\n\t\tif s2[i] == '1':\n\t\t\tif s1[i - 1] == '1' and f[i - 1] == 0:\n\t\t\t\tc += 1\n\t\t\t\tf[i - 1] = 1\n\t\t\telif s1[i] == '0':\n\t\t\t\tc += 1\n\t\t\t\tf[i] = 1\n\t\t\telif s1[i + 1] == '1' and f[i + 1] == 0:\n\t\t\t\tc += 1\n\t\t\t\tf[i + 1] = 1\n\tif s2[n - 1] == '1' and s1[n - 2] == '1' and (f[n - 2] == 0):\n\t\tc += 1\n\telif s2[n - 1] == '1' and s1[n - 1] == '0':\n\t\tc += 1\n\tprint(c)\n",
        "T = int(input())\nres = [0] * T\nfor i in range(T):\n\tN = int(input())\n\tO = list(map(lambda x: int(x), list(input())))\n\tP = list(map(lambda x: int(x), list(input())))\n\tj = 0\n\twhile j < N:\n\t\tif P[j] == 1:\n\t\t\tif O[j] == 0:\n\t\t\t\tres[i] += 1\n\t\t\telif j > 0 and O[j - 1] == 1:\n\t\t\t\tres[i] += 1\n\t\t\telif j < N - 1 and O[j + 1] == 1:\n\t\t\t\tO[j + 1] = 0\n\t\t\t\tres[i] += 1\n\t\tj += 1\n[print(r) for r in res]\n",
        "T = int(input())\nwhile T:\n\tn = int(input())\n\tans = 0\n\ta1 = list(input())\n\ta2 = list(input())\n\tfor (i, ele) in enumerate(a2):\n\t\tif ele == '1':\n\t\t\tif a1[i] == '0':\n\t\t\t\ta1[i] = '2'\n\t\t\t\tans += 1\n\t\t\telif i - 1 >= 0 and a1[i - 1] == '1':\n\t\t\t\ta1[i - 1] = 2\n\t\t\t\tans += 1\n\t\t\telif i + 1 < n and a1[i + 1] == '1':\n\t\t\t\ta1[i + 1] = 2\n\t\t\t\tans += 1\n\tprint(ans)\n\tT -= 1\n",
        "tests = int(input())\nfor _ in range(tests):\n\tn = int(input())\n\tres = 0\n\ts1 = [c for c in input()]\n\ts2 = [c for c in input()]\n\tif s2[n - 1] == '1' and s1[n - 1] == '0':\n\t\tres += 1\n\t\ts1[n - 1] = '*'\n\telif s2[n - 1] == '1' and s1[n - 2] == '1':\n\t\tres += 1\n\t\ts1[n - 2] = '*'\n\tif s2[0] == '1' and s1[0] == '0':\n\t\tres += 1\n\t\ts1[0] = '*'\n\telif s2[0] == '1' and s1[1] == '1':\n\t\tres += 1\n\t\ts1[1] = '*'\n\tfor i in range(1, n - 1):\n\t\tif s2[i] == '1' and s1[i] == '0':\n\t\t\tres += 1\n\t\t\ts1[i] == '*'\n\t\telif s2[i] == '1' and s1[i - 1] == '1':\n\t\t\tres += 1\n\t\t\ts1[i - 1] = '*'\n\t\telif s2[i] == '1' and s1[i + 1] == '1':\n\t\t\tres += 1\n\t\t\ts1[i + 1] = '*'\n\tprint(res)\n",
        "import logging\nl = logging.Logger('')\nh = logging.StreamHandler()\nf = logging.Formatter(fmt='[{filename}:{lineno}] {msg}', style='{')\nh.setFormatter(f)\nl.addHandler(h)\nbug = l.info\nfrom math import sqrt\n\ndef main():\n\tt = int(input())\n\tfor T in range(t):\n\t\tsize = int(input())\n\t\tenemy = list(input())\n\t\tallie = list(input())\n\t\ttotal = 0\n\t\tfor i in range(size):\n\t\t\tif allie[i] == '1':\n\t\t\t\tif enemy[i] == '0':\n\t\t\t\t\ttotal += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif i > 0 and enemy[i - 1] == '1':\n\t\t\t\t\ttotal += 1\n\t\t\t\t\tenemy[i - 1] = '#'\n\t\t\t\t\tcontinue\n\t\t\t\tif i < size - 1 and enemy[i + 1] == '1':\n\t\t\t\t\ttotal += 1\n\t\t\t\t\tenemy[i + 1] = '#'\n\t\t\t\t\tcontinue\n\t\tprint(total)\nmain()\n",
        "import sys, os, io\nfrom sys import stdin, stdout\nfrom math import log, gcd, ceil\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport math\nalphabets = list('abcdefghijklmnopqrstuvwxyz')\n\ndef isPrime(x):\n\tfor i in range(2, x):\n\t\tif i * i > x:\n\t\t\tbreak\n\t\tif x % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\n\ndef primeFactors(n):\n\tl = []\n\twhile n % 2 == 0:\n\t\tl.append(2)\n\t\tn = n / 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tl.append(int(i))\n\t\t\tn = n / i\n\tif n > 2:\n\t\tl.append(n)\n\treturn list(set(l))\n\ndef power(x, y, p):\n\tres = 1\n\tx = x % p\n\tif x == 0:\n\t\treturn 0\n\twhile y > 0:\n\t\tif y & 1 == 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef SieveOfEratosthenes(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\treturn prime\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef si():\n\treturn input()\n\ndef prefix_sum(arr):\n\tr = [0] * (len(arr) + 1)\n\tfor (i, el) in enumerate(arr):\n\t\tr[i + 1] = r[i] + el\n\treturn r\n\ndef divideCeil(n, x):\n\tif n % x == 0:\n\t\treturn n // x\n\treturn n // x + 1\n\ndef ii():\n\treturn int(input())\n\ndef li():\n\treturn list(map(int, input().split()))\n\ndef ws(s):\n\tsys.stdout.write(s + '\\n')\n\ndef wi(n):\n\tsys.stdout.write(str(n) + '\\n')\n\ndef wia(a):\n\tsys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\ndef power_set(L):\n\tcardinality = len(L)\n\tn = 2 ** cardinality\n\tpowerset = []\n\tfor i in range(n):\n\t\ta = bin(i)[2:]\n\t\tsubset = []\n\t\tfor j in range(len(a)):\n\t\t\tif a[-j - 1] == '1':\n\t\t\t\tsubset.append(L[j])\n\t\tpowerset.append(subset)\n\tpowerset_orderred = []\n\tfor k in range(cardinality + 1):\n\t\tfor w in powerset:\n\t\t\tif len(w) == k:\n\t\t\t\tpowerset_orderred.append(w)\n\treturn powerset_orderred\n\ndef fastPlrintNextLines(a):\n\tprint('\\n'.join(map(str, a)))\n\ndef sortByFirstAndSecond(A):\n\tA = sorted(A, key=lambda x: x[0])\n\tA = sorted(A, key=lambda x: x[1])\n\treturn list(A)\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nfor _ in range(int(input())):\n\tn = int(input())\n\tepawn = input()\n\tgpawn = input()\n\tepawn = [int(i) for i in epawn]\n\tgpawn = [int(i) for i in gpawn]\n\tcount = 0\n\tfor i in range(n):\n\t\tif epawn[i] == 0 and gpawn[i] == 1:\n\t\t\tcount += 1\n\t\t\tepawn[i] = -1\n\t\t\tgpawn[i] = -1\n\t\tif i >= 1 and epawn[i - 1] == 1 and (gpawn[i] == 1):\n\t\t\tepawn[i - 1] = -1\n\t\t\tgpawn[i] = -1\n\t\t\tcount += 1\n\t\telif i < n - 1 and epawn[i + 1] == 1 and (gpawn[i] == 1):\n\t\t\tepawn[i + 1] = -1\n\t\t\tgpawn[i] = -1\n\t\t\tcount += 1\n\tprint(count)\n",
        "import sys\nimport math\nimport heapq\nfrom collections import defaultdict as dd\nfrom collections import OrderedDict as od\nfrom collections import deque\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom sys import stdin\nfrom functools import cmp_to_key\nfrom functools import lru_cache\nfrom bisect import bisect_left as bs_l\nfrom bisect import bisect_right as bs_r\ninput = sys.stdin.readline\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 5)\nT = int(input())\nfor _ in range(T):\n\tn = int(input())\n\ts1 = input().strip()\n\ts2 = input().strip()\n\tl1 = list(s1)\n\tl2 = list(s2)\n\t(l3, l4) = (l1.copy(), l2.copy())\n\t(ans1, ans2) = (0, 0)\n\tfor i in range(n):\n\t\tif l2[i] == '1':\n\t\t\tif i - 1 >= 0 and l1[i - 1] == '1':\n\t\t\t\tl1[i - 1] = '2'\n\t\t\t\tans1 += 1\n\t\t\telif l1[i] == '0':\n\t\t\t\tl1[i] = '2'\n\t\t\t\tans1 += 1\n\t\t\telif i + 1 < n and l1[i + 1] == '1':\n\t\t\t\tl1[i + 1] = '2'\n\t\t\t\tans1 += 1\n\tfor i in range(n - 1):\n\t\tif l4[i] == '1':\n\t\t\tif i + 1 < n and l3[i + 1] == '1':\n\t\t\t\tl3[i + 1] = '2'\n\t\t\t\tans2 += 1\n\t\t\telif l3[i] == '0':\n\t\t\t\tl3[i] = '2'\n\t\t\t\tans2 += 1\n\t\t\telif i - 1 >= 0 and l3[i - 1] == '1':\n\t\t\t\tl3[i - 1] = '2'\n\t\t\t\tans2 += 1\n\tprint(max(ans1, ans2))\n",
        "from collections import deque\nimport heapq\nfrom math import sqrt\nimport operator\nfrom operator import itemgetter\nimport sys\nimport copy\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_one_float():\n\treturn float(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef main():\n\ttests = read_one_int()\n\tfor _ in range(tests):\n\t\tn = read_one_int()\n\t\tenemy = list(read_str())\n\t\tme = list(read_str())\n\t\tcnt = 0\n\t\tfor i in range(n):\n\t\t\tif me[i] == '0':\n\t\t\t\tcontinue\n\t\t\tif enemy[i] == '0':\n\t\t\t\tcnt += 1\n\t\t\t\tenemy[i] = '2'\n\t\t\t\tcontinue\n\t\t\tprev_i = i - 1\n\t\t\tnext_i = i + 1\n\t\t\tif prev_i >= 0:\n\t\t\t\tif enemy[prev_i] == '1':\n\t\t\t\t\tcnt += 1\n\t\t\t\t\tenemy[prev_i] = '2'\n\t\t\t\t\tcontinue\n\t\t\tif next_i < n:\n\t\t\t\tif enemy[next_i] == '1':\n\t\t\t\t\tcnt += 1\n\t\t\t\t\tenemy[next_i] = '2'\n\t\t\t\t\tcontinue\n\t\tprint(cnt)\nmain()\n",
        "def solves():\n\tn = int(input())\n\tenemy = list(input())\n\tme = list(input())\n\tans = 0\n\tfor i in range(0, n):\n\t\tif me[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif enemy[0] == '0':\n\t\t\t\t\tans += 1\n\t\t\t\telif enemy[1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tenemy[1] = '0'\n\t\t\telif i == n - 1:\n\t\t\t\tif enemy[i] == '0':\n\t\t\t\t\tans += 1\n\t\t\t\telif enemy[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tenemy[i - 1] = '0'\n\t\t\telif enemy[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif enemy[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\telif enemy[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tenemy[i + 1] = '0'\n\tprint(ans)\nt = int(input())\nfor _ in range(t):\n\tsolves()\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ten = input()\n\tme = input()\n\ten = list(en)\n\tans = 0\n\tfor i in range(n):\n\t\tif me[i] == '1':\n\t\t\tif i - 1 >= 0 and en[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ten[i - 1] = '-1'\n\t\t\telif en[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\ten[i] = '-1'\n\t\t\telif i + 1 < n and en[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ten[i + 1] = '-1'\n\tprint(ans)\n",
        "import sys\n\ndef fun(en, ger, n):\n\ttaken = [False for i in range(n)]\n\tcount = 0\n\tfor i in range(n):\n\t\tif ger[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif en[0] == '1' and en[1] == '1':\n\t\t\t\t\ttaken[1] = True\n\t\t\t\t\tcount += 1\n\t\t\t\telif en[0] == '0':\n\t\t\t\t\ttaken[0] = True\n\t\t\t\t\tcount += 1\n\t\t\telif i == n - 1:\n\t\t\t\tif en[i] == '1' and en[i - 1] == '1':\n\t\t\t\t\tif not taken[i - 1]:\n\t\t\t\t\t\ttaken[i - 1] = True\n\t\t\t\t\t\tcount += 1\n\t\t\t\telif en[i] == '0':\n\t\t\t\t\ttaken[i] = True\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tif en[i - 1] == '1' and (not taken[i - 1]):\n\t\t\t\t\ttaken[i - 1] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif en[i] == '0':\n\t\t\t\t\ttaken[i] = True\n\t\t\t\t\tcount += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif en[i + 1] == '1':\n\t\t\t\t\ttaken[i + 1] = True\n\t\t\t\t\tcount += 1\n\treturn count\nt = int(sys.stdin.readline())\nfor i in range(t):\n\tn = int(sys.stdin.readline())\n\ten = sys.stdin.readline()\n\tger = sys.stdin.readline()\n\tprint(fun(en, ger, n))\n",
        "from sys import stdin\ninput = stdin.readline\n\ndef f(en, us):\n\tcnt = 0\n\tfor i in range(len(en)):\n\t\tif en[i] == '0' and us[i] == '1':\n\t\t\ten[i] = 'f'\n\t\t\tcnt += 1\n\t\telif i > 0 and en[i - 1] == '1' and (us[i] == '1'):\n\t\t\ten[i - 1] = 'f'\n\t\t\tcnt += 1\n\t\telif i <= len(us) - 2 and en[i + 1] == '1' and (us[i] == '1'):\n\t\t\ten[i + 1] = 'f'\n\t\t\tcnt += 1\n\treturn cnt\nfor i in range(int(input())):\n\ts = input()\n\ten = list(input())\n\tus = list(input())\n\tprint(f(en, us))\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tp = input()\n\tq = input()\n\ta = [char for char in p]\n\tb = [char for char in q]\n\tfor i in range(n):\n\t\tif a[i] == '0' and b[i] == '1':\n\t\t\ta[i] = '2'\n\t\t\tb[i] = '0'\n\tfor i in range(n):\n\t\tif i > 0 and i < n - 1:\n\t\t\tif a[i - 1] == '1' and b[i] == '1':\n\t\t\t\ta[i - 1] = '2'\n\t\t\telif a[i + 1] == '1' and b[i] == '1':\n\t\t\t\ta[i + 1] = '2'\n\t\telif i == 0:\n\t\t\tif a[i + 1] == '1' and b[i] == '1':\n\t\t\t\ta[i + 1] = '2'\n\t\telif a[i - 1] == '1' and b[i] == '1':\n\t\t\ta[i - 1] = '2'\n\tc = 0\n\tfor i in range(n):\n\t\tif a[i] == '2':\n\t\t\tc += 1\n\tprint(c)\n",
        "t = int(input())\nwhile t:\n\tt -= 1\n\tn = int(input())\n\tb = input()\n\ta = input()\n\ti = c = 0\n\ts = set()\n\twhile i < n:\n\t\tif a[i] == '1' and b[i] == '0':\n\t\t\tc += 1\n\t\t\ti += 1\n\t\telif a[i] == '1' and b[i] == '1':\n\t\t\tif i > 0 and i - 1 not in s and (b[i - 1] == '1'):\n\t\t\t\tc += 1\n\t\t\t\ti += 1\n\t\t\telif i < n - 1 and b[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\ts.add(i + 1)\n\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\ti += 1\n\t\telse:\n\t\t\ti += 1\n\tprint(c)\n",
        "tests = int(input())\nfor _ in range(tests):\n\tn = int(input())\n\tbusy = [None if c == '0' else False for c in input()]\n\tpawns = input()\n\treached_count = 0\n\tfor i in range(n):\n\t\tif pawns[i] == '1':\n\t\t\tif i > 0 and busy[i - 1] is False:\n\t\t\t\tbusy[i - 1] = True\n\t\t\t\treached_count += 1\n\t\t\telif busy[i] is None:\n\t\t\t\treached_count += 1\n\t\t\telif i < n - 1 and busy[i + 1] is False:\n\t\t\t\tbusy[i + 1] = True\n\t\t\t\treached_count += 1\n\tprint(reached_count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tblack = list(input())\n\twhite = list(input())\n\tans = 0\n\tcheckLast = False\n\tfor i in range(n):\n\t\tif white[i] == '1':\n\t\t\tif i != 0 and black[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tblack[i - 1] = '-1'\n\t\t\telif black[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i != n - 1 and black[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tblack[i + 1] = '-1'\n\tprint(ans)\n",
        "from typing import Counter\nimport sys\nfrom collections import defaultdict as dd\nfrom math import *\n\ndef vinp():\n\treturn map(int, input().split())\n\ndef linp():\n\treturn list(input())\n\ndef sinp():\n\treturn input()\n\ndef inp():\n\treturn int(input())\n\ndef mod(f):\n\treturn f % 1000000007\n\ndef pr(*x):\n\tprint(*x)\n\ndef finp():\n\tf = open('input.txt', 'r')\n\tf = f.read().split('\\n')\n\treturn f\n\ndef finp():\n\tf = open('input.txt', 'r')\n\tf = f.read().split('\\n')\n\treturn f\n\ndef fout():\n\treturn open('output.txt', 'w')\n\ndef fpr(f, x):\n\tf.write(x + '\\n')\n\ndef csort(c):\n\tsorted(c.items(), key=lambda pair: pair[1], reverse=True)\n\ndef indc(l, n):\n\tc = {}\n\tfor i in range(n):\n\t\tc[l[i]] = c.get(l[i], []) + [i + 1]\n\treturn c\ncou = inp()\nfor i in range(cou):\n\tn = inp()\n\tl = linp()\n\tl2 = linp()\n\tc = 0\n\tfor i in range(n):\n\t\tp = False\n\t\tif l2[i] == '1':\n\t\t\tif l[i] == '1':\n\t\t\t\tif i != 0:\n\t\t\t\t\tif l[i - 1] == '1':\n\t\t\t\t\t\tl[i - 1] = '0'\n\t\t\t\t\t\tp = True\n\t\t\t\tif i != n - 1 and (not p):\n\t\t\t\t\tif l[i + 1] == '1':\n\t\t\t\t\t\tl[i + 1] = '0'\n\t\t\t\t\t\tp = True\n\t\t\t\tif p:\n\t\t\t\t\tc += 1\n\t\t\telse:\n\t\t\t\tc += 1\n\tpr(c)\n",
        "import math\nfrom collections import defaultdict\nfrom collections import Counter\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = input()\n\tb = input()\n\tans = 0\n\tvar = 0\n\tcnt = [0] * (len(a) + 1)\n\tflag = [0] * (len(b) + 1)\n\tfor i in range(n):\n\t\tif a[i] == '0':\n\t\t\tcnt[i] = 0\n\t\telse:\n\t\t\tcnt[i] = 1\n\tres = b\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif flag[i - 1] == 0 and i - 1 >= 0 and (cnt[i - 1] == 1):\n\t\t\t\tflag[i - 1] = 1\n\t\t\t\tans += 1\n\t\t\telif cnt[i] == 0:\n\t\t\t\tflag[i] = 1\n\t\t\t\tans += 1\n\t\t\telif cnt[i + 1] == 1 and flag[i + 1] == 0 and (i + 1 < n):\n\t\t\t\tflag[i + 1] = 1\n\t\t\t\tans += 1\n\tfor i in range(n):\n\t\tflag[i] = 0\n\tvar = max(var, ans)\n\tans = 0\n\tfor i in range(n - 1, -1, -1):\n\t\tif b[i] == '1':\n\t\t\tif flag[i - 1] == 0 and cnt[i - 1] == 1 and (i - 1 >= 0):\n\t\t\t\tflag[i - 1] = 1\n\t\t\t\tans += 1\n\t\t\telif cnt[i] == 0:\n\t\t\t\tflag[i] = 1\n\t\t\t\tans += 1\n\t\t\telif flag[i + 1] == 0 and cnt[i + 1] == 1 and (i + 1 < n):\n\t\t\t\tflag[i + 1] = 1\n\t\t\t\tans += 1\n\tvar = max(ans, var)\n\tprint(var)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tw = input()\n\tcount = 0\n\tsignal = -1\n\tfor i in range(n):\n\t\tif w[i] == '1':\n\t\t\tif s[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif i != 0 and s[i - 1] == '1' and (i - 1 != signal):\n\t\t\t\tcount += 1\n\t\t\telif i != n - 1 and s[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tsignal = i + 1\n\tprint(count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tc = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif i == 0:\n\t\t\t\tif a[i + 1] == '1':\n\t\t\t\t\tc += 1\n\t\t\t\t\ta[i + 1] = 'x'\n\t\t\telif a[i - 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\ta[i - 1] = 'x'\n\t\t\telif i + 1 < n and a[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\ta[i + 1] = 'x'\n\tprint(c)\n",
        "t = int(input())\nfor i in range(0, t):\n\tn = int(input())\n\tenemy = list(input())\n\tmine = input()\n\tcount = 0\n\tfor x in range(0, n):\n\t\tif mine[x] == '1':\n\t\t\tif enemy[x] == '0':\n\t\t\t\tcount += 1\n\t\t\telif x - 1 >= 0 and enemy[x - 1] == '1':\n\t\t\t\tenemy[x - 1] = '*'\n\t\t\t\tcount += 1\n\t\t\telif x + 1 < n and enemy[x + 1] == '1':\n\t\t\t\tenemy[x + 1] = '*'\n\t\t\t\tcount += 1\n\tprint(count)\n",
        "n = int(input())\nfor i in range(n):\n\tm = int(input())\n\tx2 = list(input())\n\tx1 = list(input())\n\ty = 0\n\tfor j in range(m):\n\t\tif x1[j] == '1':\n\t\t\tif j == 0:\n\t\t\t\tif x2[j] == '0':\n\t\t\t\t\ty += 1\n\t\t\t\telif x2[j + 1] == '1':\n\t\t\t\t\ty += 1\n\t\t\t\t\tx2[j + 1] = ''\n\t\t\telif j == m - 1:\n\t\t\t\tif x2[j] == '0':\n\t\t\t\t\ty += 1\n\t\t\t\telif x2[j - 1] == '1':\n\t\t\t\t\ty += 1\n\t\t\t\t\tx2[j - 1] = ''\n\t\t\telif x2[j] == '0':\n\t\t\t\ty += 1\n\t\t\telif x2[j - 1] == '1':\n\t\t\t\ty += 1\n\t\t\t\tx2[j - 1] = ''\n\t\t\telif x2[j + 1] == '1':\n\t\t\t\ty += 1\n\t\t\t\tx2[j + 1] = ''\n\tprint(y)\n",
        "import sys, os, io\n\ndef rs():\n\treturn sys.stdin.readline().rstrip()\n\ndef ri():\n\treturn int(sys.stdin.readline())\n\ndef ria():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef ws(s):\n\tsys.stdout.write(s + '\\n')\n\ndef wi(n):\n\tsys.stdout.write(str(n) + '\\n')\n\ndef wia(a):\n\tsys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\nimport math, datetime, functools, itertools, operator, bisect, fractions, statistics\nfrom collections import deque, defaultdict, OrderedDict, Counter\nfrom fractions import Fraction\nfrom decimal import Decimal\nfrom sys import stdout\nfrom heapq import heappush, heappop, heapify, _heapify_max, _heappop_max, nsmallest, nlargest\nINF = 999999999999999999999999\nalphabets = 'abcdefghijklmnopqrstuvwxyz'\n\nclass SortedList:\n\n\tdef __init__(self, iterable=[], _load=200):\n\t\tvalues = sorted(iterable)\n\t\tself._len = _len = len(values)\n\t\tself._load = _load\n\t\tself._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n\t\tself._list_lens = [len(_list) for _list in _lists]\n\t\tself._mins = [_list[0] for _list in _lists]\n\t\tself._fen_tree = []\n\t\tself._rebuild = True\n\n\tdef _fen_build(self):\n\t\tself._fen_tree[:] = self._list_lens\n\t\t_fen_tree = self._fen_tree\n\t\tfor i in range(len(_fen_tree)):\n\t\t\tif i | i + 1 < len(_fen_tree):\n\t\t\t\t_fen_tree[i | i + 1] += _fen_tree[i]\n\t\tself._rebuild = False\n\n\tdef _fen_update(self, index, value):\n\t\tif not self._rebuild:\n\t\t\t_fen_tree = self._fen_tree\n\t\t\twhile index < len(_fen_tree):\n\t\t\t\t_fen_tree[index] += value\n\t\t\t\tindex |= index + 1\n\n\tdef _fen_query(self, end):\n\t\tif self._rebuild:\n\t\t\tself._fen_build()\n\t\t_fen_tree = self._fen_tree\n\t\tx = 0\n\t\twhile end:\n\t\t\tx += _fen_tree[end - 1]\n\t\t\tend &= end - 1\n\t\treturn x\n\n\tdef _fen_findkth(self, k):\n\t\t_list_lens = self._list_lens\n\t\tif k < _list_lens[0]:\n\t\t\treturn (0, k)\n\t\tif k >= self._len - _list_lens[-1]:\n\t\t\treturn (len(_list_lens) - 1, k + _list_lens[-1] - self._len)\n\t\tif self._rebuild:\n\t\t\tself._fen_build()\n\t\t_fen_tree = self._fen_tree\n\t\tidx = -1\n\t\tfor d in reversed(range(len(_fen_tree).bit_length())):\n\t\t\tright_idx = idx + (1 << d)\n\t\t\tif right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n\t\t\t\tidx = right_idx\n\t\t\t\tk -= _fen_tree[idx]\n\t\treturn (idx + 1, k)\n\n\tdef _delete(self, pos, idx):\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t_list_lens = self._list_lens\n\t\tself._len -= 1\n\t\tself._fen_update(pos, -1)\n\t\tdel _lists[pos][idx]\n\t\t_list_lens[pos] -= 1\n\t\tif _list_lens[pos]:\n\t\t\t_mins[pos] = _lists[pos][0]\n\t\telse:\n\t\t\tdel _lists[pos]\n\t\t\tdel _list_lens[pos]\n\t\t\tdel _mins[pos]\n\t\t\tself._rebuild = True\n\n\tdef _loc_left(self, value):\n\t\tif not self._len:\n\t\t\treturn (0, 0)\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t(lo, pos) = (-1, len(_lists) - 1)\n\t\twhile lo + 1 < pos:\n\t\t\tmi = lo + pos >> 1\n\t\t\tif value <= _mins[mi]:\n\t\t\t\tpos = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\tif pos and value <= _lists[pos - 1][-1]:\n\t\t\tpos -= 1\n\t\t_list = _lists[pos]\n\t\t(lo, idx) = (-1, len(_list))\n\t\twhile lo + 1 < idx:\n\t\t\tmi = lo + idx >> 1\n\t\t\tif value <= _list[mi]:\n\t\t\t\tidx = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\treturn (pos, idx)\n\n\tdef _loc_right(self, value):\n\t\tif not self._len:\n\t\t\treturn (0, 0)\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t(pos, hi) = (0, len(_lists))\n\t\twhile pos + 1 < hi:\n\t\t\tmi = pos + hi >> 1\n\t\t\tif value < _mins[mi]:\n\t\t\t\thi = mi\n\t\t\telse:\n\t\t\t\tpos = mi\n\t\t_list = _lists[pos]\n\t\t(lo, idx) = (-1, len(_list))\n\t\twhile lo + 1 < idx:\n\t\t\tmi = lo + idx >> 1\n\t\t\tif value < _list[mi]:\n\t\t\t\tidx = mi\n\t\t\telse:\n\t\t\t\tlo = mi\n\t\treturn (pos, idx)\n\n\tdef add(self, value):\n\t\t_load = self._load\n\t\t_lists = self._lists\n\t\t_mins = self._mins\n\t\t_list_lens = self._list_lens\n\t\tself._len += 1\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_right(value)\n\t\t\tself._fen_update(pos, 1)\n\t\t\t_list = _lists[pos]\n\t\t\t_list.insert(idx, value)\n\t\t\t_list_lens[pos] += 1\n\t\t\t_mins[pos] = _list[0]\n\t\t\tif _load + _load < len(_list):\n\t\t\t\t_lists.insert(pos + 1, _list[_load:])\n\t\t\t\t_list_lens.insert(pos + 1, len(_list) - _load)\n\t\t\t\t_mins.insert(pos + 1, _list[_load])\n\t\t\t\t_list_lens[pos] = _load\n\t\t\t\tdel _list[_load:]\n\t\t\t\tself._rebuild = True\n\t\telse:\n\t\t\t_lists.append([value])\n\t\t\t_mins.append(value)\n\t\t\t_list_lens.append(1)\n\t\t\tself._rebuild = True\n\n\tdef discard(self, value):\n\t\t_lists = self._lists\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_right(value)\n\t\t\tif idx and _lists[pos][idx - 1] == value:\n\t\t\t\tself._delete(pos, idx - 1)\n\n\tdef remove(self, value):\n\t\t_len = self._len\n\t\tself.discard(value)\n\t\tif _len == self._len:\n\t\t\traise ValueError('{0!r} not in list'.format(value))\n\n\tdef pop(self, index=-1):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\tvalue = self._lists[pos][idx]\n\t\tself._delete(pos, idx)\n\t\treturn value\n\n\tdef bisect_left(self, value):\n\t\t(pos, idx) = self._loc_left(value)\n\t\treturn self._fen_query(pos) + idx\n\n\tdef bisect_right(self, value):\n\t\t(pos, idx) = self._loc_right(value)\n\t\treturn self._fen_query(pos) + idx\n\n\tdef count(self, value):\n\t\treturn self.bisect_right(value) - self.bisect_left(value)\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef __getitem__(self, index):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\treturn self._lists[pos][idx]\n\n\tdef __delitem__(self, index):\n\t\t(pos, idx) = self._fen_findkth(self._len + index if index < 0 else index)\n\t\tself._delete(pos, idx)\n\n\tdef __contains__(self, value):\n\t\t_lists = self._lists\n\t\tif _lists:\n\t\t\t(pos, idx) = self._loc_left(value)\n\t\t\treturn idx < len(_lists[pos]) and _lists[pos][idx] == value\n\t\treturn False\n\n\tdef __iter__(self):\n\t\treturn (value for _list in self._lists for value in _list)\n\n\tdef __reversed__(self):\n\t\treturn (value for _list in reversed(self._lists) for value in reversed(_list))\n\n\tdef __repr__(self):\n\t\treturn 'SortedList({0})'.format(list(self))\n\nclass SegTree:\n\n\tdef __init__(self, n):\n\t\tself.N = 1 << n.bit_length()\n\t\tself.tree = [0] * (self.N << 1)\n\n\tdef update(self, i, j, v):\n\t\ti += self.N\n\t\tj += self.N\n\t\twhile i <= j:\n\t\t\tif i % 2 == 1:\n\t\t\t\tself.tree[i] += v\n\t\t\tif j % 2 == 0:\n\t\t\t\tself.tree[j] += v\n\t\t\t(i, j) = (i + 1 >> 1, j - 1 >> 1)\n\n\tdef query(self, i):\n\t\tv = 0\n\t\ti += self.N\n\t\twhile i > 0:\n\t\t\tv += self.tree[i]\n\t\t\ti >>= 1\n\t\treturn v\n\ndef SieveOfEratosthenes(limit):\n\tisPrime = [True] * (limit + 1)\n\tisPrime[0] = isPrime[1] = False\n\tprimes = []\n\tfor i in range(2, limit + 1):\n\t\tif not isPrime[i]:\n\t\t\tcontinue\n\t\tprimes += [i]\n\t\tfor j in range(i * i, limit + 1, i):\n\t\t\tisPrime[j] = False\n\treturn primes\n\ndef main():\n\tmod = 1000000007\n\tstarttime = datetime.datetime.now()\n\tif os.path.exists('input.txt'):\n\t\tsys.stdin = open('input.txt', 'r')\n\t\tsys.stdout = open('output.txt', 'w')\n\ttc = ri()\n\tfor _ in range(tc):\n\t\tn = ri()\n\t\ta = list(rs())\n\t\tb = list(rs())\n\t\tfor i in range(n):\n\t\t\tif b[i] == '1':\n\t\t\t\tif i - 1 >= 0 and a[i - 1] == '1':\n\t\t\t\t\ta[i - 1] = 'd'\n\t\t\t\telif a[i] == '0':\n\t\t\t\t\ta[i] = 'd'\n\t\t\t\telif i + 1 < n and a[i + 1] == '1':\n\t\t\t\t\ta[i + 1] = 'd'\n\t\twi(Counter(a)['d'])\n\tendtime = datetime.datetime.now()\n\ttime = (endtime - starttime).total_seconds() * 1000\n\tif os.path.exists('input.txt'):\n\t\tprint('Time:', time, 'ms')\n\nclass FastReader(io.IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, fd, chunk_size=1024 * 8):\n\t\tself._fd = fd\n\t\tself._chunk_size = chunk_size\n\t\tself.buffer = io.BytesIO()\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self, size=-1):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\nclass FastWriter(io.IOBase):\n\n\tdef __init__(self, fd):\n\t\tself._fd = fd\n\t\tself.buffer = io.BytesIO()\n\t\tself.write = self.buffer.write\n\n\tdef flush(self):\n\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass FastStdin(io.IOBase):\n\n\tdef __init__(self, fd=0):\n\t\tself.buffer = FastReader(fd)\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\nclass FastStdout(io.IOBase):\n\n\tdef __init__(self, fd=1):\n\t\tself.buffer = FastWriter(fd)\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.flush = self.buffer.flush\nsys.stdin = FastStdin()\nsys.stdout = FastStdout()\nmain()\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tY = list(input())\n\tX = list(input())\n\tcount = 0\n\tfor j in range(n):\n\t\tif j == 0:\n\t\t\ta = None\n\t\t\tb = Y[0]\n\t\t\tc = Y[1]\n\t\telif j == n - 1:\n\t\t\ta = Y[n - 2]\n\t\t\tb = Y[n - 1]\n\t\t\tc = None\n\t\telse:\n\t\t\ta = Y[j - 1]\n\t\t\tb = Y[j]\n\t\t\tc = Y[j + 1]\n\t\tif X[j] == '1':\n\t\t\tif b == '0':\n\t\t\t\tcount += 1\n\t\t\telif b == '1':\n\t\t\t\tif a == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tY[j - 1] = '0'\n\t\t\t\telif c == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tY[j + 1] = '0'\n\tprint(count)\n",
        "T = int(input())\nfor t in range(T):\n\tn = int(input())\n\tboard = [list(map(int, list(input()))) for i in range(2)]\n\tmoves = 0\n\tfor i in range(n):\n\t\tif board[1][i]:\n\t\t\tif board[0][i] == 0:\n\t\t\t\tmoves += 1\n\t\t\t\tboard[0][i] = 2\n\t\t\telif i > 0 and board[0][i - 1] == 1:\n\t\t\t\tmoves += 1\n\t\t\t\tboard[0][i - 1] = 2\n\t\t\telif i < n - 1 and board[0][i + 1] == 1:\n\t\t\t\tmoves += 1\n\t\t\t\tboard[0][i + 1] = 2\n\tprint(moves)\n",
        "import sys\ninput = sys.stdin\noutput = sys.stdout\nt = int(input.readline().strip())\nfor y in range(t):\n\tn = int(input.readline().strip())\n\tenemy = list('0' + input.readline().strip() + '0')\n\tfriendly = list('0' + input.readline().strip() + '0')\n\tcount = 0\n\tfor i in range(1, n + 1):\n\t\tif friendly[i] == '1':\n\t\t\tif enemy[i - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i - 1] = '2'\n\t\t\telif enemy[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i] = '2'\n\t\t\telif enemy[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = '2'\n\tprint(count)\n",
        "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n\treturn list(sys.stdin.readline().strip())\n\ndef li():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n\treturn map(int, sys.stdin.readline().split())\n\ndef inp():\n\treturn int(sys.stdin.readline())\n\ndef pr(n):\n\treturn sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n\treturn sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef solve():\n\tn = inp()\n\ta = st()\n\tb = st()\n\ta = list(map(int, a))\n\tb = list(map(int, b))\n\tans = 0\n\tfor i in range(n):\n\t\tif a[i]:\n\t\t\tif i - 1 >= 0:\n\t\t\t\tif b[i - 1]:\n\t\t\t\t\tans += 1\n\t\t\t\t\tb[i - 1] ^= 1\n\t\t\t\t\tcontinue\n\t\t\tif i + 1 < n:\n\t\t\t\tif b[i + 1]:\n\t\t\t\t\tans += 1\n\t\t\t\t\tb[i + 1] ^= 1\n\t\telif b[i]:\n\t\t\tans += 1\n\t\t\tb[i] = 0\n\tpr(ans)\nfor _ in range(inp()):\n\tsolve()\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\te = input()\n\tm = input()\n\te = list(e)\n\tm = list(m)\n\tans = 0\n\tfor i in range(n):\n\t\tif e[i] == '0' and m[i] == '1':\n\t\t\tans += 1\n\t\t\tm[i] = '0'\n\tfor i in range(n):\n\t\tif e[i] == '1':\n\t\t\tif i > 0 and m[i - 1] == '1':\n\t\t\t\tm[i - 1] = '0'\n\t\t\t\tans += 1\n\t\t\telif i < n - 1 and m[i + 1] == '1':\n\t\t\t\tm[i + 1] = '0'\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\te = list(map(int, input()))\n\to = list(map(int, input()))\n\tans = 0\n\tused = [0] * n\n\tfor i in range(n):\n\t\tif o[i] == 0:\n\t\t\tcontinue\n\t\tif e[i] == 0:\n\t\t\tans += 1\n\t\telif i > 0 and e[i - 1] == 1 and (used[i - 1] == 0):\n\t\t\tans += 1\n\t\t\tused[i - 1] = 1\n\t\telif i < n - 1 and e[i + 1] == 1 and (used[i + 1] == 0):\n\t\t\tans += 1\n\t\t\tused[i + 1] = 1\n\tprint(ans)\n",
        "def test():\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tc = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tc += 1\n\t\t\t\ta[i] = '2'\n\t\t\telif i > 0 and a[i - 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\ta[i - 1] = '2'\n\t\t\telif i < n - 1 and a[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\ta[i + 1] = '2'\n\tprint(c)\nt = int(input())\nwhile t:\n\ttest()\n\tt -= 1\n",
        "from sys import stdin\ninput = stdin.readline\nt = int(input().rstrip())\nfor _ in range(t):\n\tn = int(input().rstrip())\n\tenemy = list(input().rstrip())\n\tGregor = list(input().rstrip())\n\tans = 0\n\tfor i in range(n):\n\t\tif Gregor[i] == '1':\n\t\t\tif enemy[i] == '1' or enemy[i] is None:\n\t\t\t\tif i > 0 and enemy[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\telif i < n - 1 and enemy[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tenemy[i + 1] = None\n\t\t\telif enemy[i] == '0':\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "t = int(input())\nans = []\nfor _ in range(t):\n\tn = int(input())\n\ta1 = input()\n\ta = []\n\totv = 0\n\tfor i in a1:\n\t\ta.append(i)\n\ta1 = a.copy()\n\ta2 = input()\n\ta = []\n\tfor i in a2:\n\t\ta.append(i)\n\ta2 = a.copy()\n\tfor i in range(len(a1)):\n\t\tif a1[i] == '0':\n\t\t\tif a2[i] == '1':\n\t\t\t\ta2[i] = '0'\n\t\t\t\totv += 1\n\t\telif a1[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif a2[1] == '1':\n\t\t\t\t\ta2[1] = '0'\n\t\t\t\t\totv += 1\n\t\t\telif i == n - 1:\n\t\t\t\tif a2[n - 2] == '1':\n\t\t\t\t\ta2[n - 2] = '0'\n\t\t\t\t\totv += 1\n\t\t\telif a2[i - 1] == '1':\n\t\t\t\ta2[i - 1] = '0'\n\t\t\t\totv += 1\n\t\t\telif a2[i + 1] == '1':\n\t\t\t\ta2[i + 1] = '0'\n\t\t\t\totv += 1\n\tans.append(otv)\nfor i in ans:\n\tprint(i)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ts = list(input())\n\tt = list(input())\n\tans = 0\n\tmarked = [False] * n\n\tfor i in range(n):\n\t\tif t[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif s[i] == '0' and (not marked[i]):\n\t\t\t\t\tans += 1\n\t\t\t\t\tmarked[i] = True\n\t\t\t\telif s[i + 1] == '1' and (not marked[i + 1]):\n\t\t\t\t\tans += 1\n\t\t\t\t\tmarked[i + 1] = True\n\t\t\telif i == n - 1:\n\t\t\t\tif s[i] == '0' and (not marked[i]):\n\t\t\t\t\tans += 1\n\t\t\t\t\tmarked[i] = True\n\t\t\t\telif s[i - 1] == '1' and (not marked[i - 1]):\n\t\t\t\t\tans += 1\n\t\t\t\t\tmarked[i - 1] = True\n\t\t\telif s[i - 1] == '1' and (not marked[i - 1]):\n\t\t\t\tans += 1\n\t\t\t\tmarked[i - 1] = True\n\t\t\telif s[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\tmarked[i] = True\n\t\t\telif s[i + 1] == '1' and (not marked[i + 1]):\n\t\t\t\tans += 1\n\t\t\t\tmarked[i + 1] = True\n\tprint(ans)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tl1 = []\n\tl2 = []\n\tfor i in s1:\n\t\tl1.append(int(i))\n\tfor i in s2:\n\t\tl2.append(int(i))\n\tans = 0\n\tif l1[0] == 0 and l2[0] == 1:\n\t\tans += 1\n\telif l1[1] == 1 and l2[0] == 1:\n\t\tans += 1\n\t\tl1[1] = 2\n\tfor i in range(1, n - 1):\n\t\tif l1[i] == 0 and l2[i] == 1:\n\t\t\tans += 1\n\t\telif l1[i - 1] == 1 and l2[i] == 1:\n\t\t\tans += 1\n\t\t\tl1[i - 1] = 2\n\t\telif l1[i + 1] == 1 and l2[i] == 1:\n\t\t\tans += 1\n\t\t\tl1[i + 1] = 2\n\tif l1[-1] == 0 and l2[-1] == 1:\n\t\tans += 1\n\telif l1[-2] == 1 and l2[-1] == 1:\n\t\tans += 1\n\t\tl1[-2] = 2\n\tprint(ans)\n",
        "import sys\nimport math\nimport heapq\nimport bisect\nfrom collections import Counter\nfrom collections import defaultdict\nfrom io import BytesIO, IOBase\nimport string\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\timport os\n\t\tself.os = os\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\t\tself.BUFSIZE = 8192\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tself.os.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef get_int():\n\treturn int(input())\n\ndef get_ints():\n\treturn list(map(int, input().split(' ')))\n\ndef get_int_grid(n):\n\treturn [get_ints() for _ in range(n)]\n\ndef get_str():\n\treturn input().strip()\n\ndef get_strs():\n\treturn get_str().split(' ')\n\ndef flat_list(arr):\n\treturn [item for subarr in arr for item in subarr]\n\ndef yes_no(b):\n\tif b:\n\t\treturn 'YES'\n\telse:\n\t\treturn 'NO'\n\ndef binary_search(good, left, right, delta=1, right_true=False):\n\tlimits = [left, right]\n\twhile limits[1] - limits[0] > delta:\n\t\tif delta == 1:\n\t\t\tmid = sum(limits) // 2\n\t\telse:\n\t\t\tmid = sum(limits) / 2\n\t\tif good(mid):\n\t\t\tlimits[int(right_true)] = mid\n\t\telse:\n\t\t\tlimits[int(~right_true)] = mid\n\tif good(limits[int(right_true)]):\n\t\treturn limits[int(right_true)]\n\telse:\n\t\treturn False\n\ndef prefix_sums(a):\n\tp = [0]\n\tfor x in a:\n\t\tp.append(p[-1] + x)\n\treturn p\n\ndef solve_a():\n\tp = get_int()\n\tif p == 5:\n\t\treturn (2, 4)\n\telse:\n\t\treturn (2, (p - 1) // 2)\n\ndef solve_b():\n\tn = get_int()\n\tenemy = list(get_str())\n\tme = list(get_str())\n\tcnt = 0\n\tfor i in range(n):\n\t\tif me[i] == '1' and enemy[i] == '0':\n\t\t\tcnt += 1\n\t\telif i > 0 and me[i] == '1' and (enemy[i - 1] == '1'):\n\t\t\tenemy[i - 1] = 'x'\n\t\t\tcnt += 1\n\t\telif i < n - 1 and me[i] == '1' and (enemy[i + 1] == '1'):\n\t\t\tenemy[i + 1] = 'x'\n\t\t\tcnt += 1\n\treturn cnt\nt = get_int()\nfor _ in range(t):\n\tprint(solve_b())\n",
        "import os\nimport sys\nfrom math import ceil, floor, sqrt, gcd, factorial\nfrom io import BytesIO, IOBase\nfrom collections import Counter\nBUFSIZE = 8192\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\tene = list(input())\n\t\tg = list(input())\n\t\tcount = 0\n\t\tfor i in range(n):\n\t\t\tif g[i] == '1':\n\t\t\t\tif ene[i] == '0':\n\t\t\t\t\tcount += 1\n\t\t\t\telif i != 0 and ene[i - 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tene[i - 1] = '0'\n\t\t\t\telif i != n - 1 and ene[i + 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tene[i + 1] = '0'\n\t\tprint(count)\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "import math\n\ndef solve(n, s1, s2):\n\tans = 0\n\tfor i in range(n):\n\t\tif s2[i] == '1':\n\t\t\tif s1[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i >= 1 and s1[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ts1[i - 1] = '2'\n\t\t\telif i < n - 1 and s1[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ts1[i + 1] = '2'\n\treturn ans\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\ts1 = list(input())\n\ts2 = list(input())\n\tprint(solve(n, s1, s2))\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\te = list(input())\n\tg = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif g[i] == '1':\n\t\t\tif e[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i > 0 and e[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\te[i - 1] = '2'\n\t\t\telif i < n - 1 and e[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\te[i + 1] = '2'\n\tprint(ans)\n",
        "def solve(n, a, b):\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i - 1 >= 0 and a[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\telif i + 1 < n and a[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ta[i + 1] = '-'\n\treturn ans\nt = int(input())\nwhile t:\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tprint(solve(n, a, b))\n\tt -= 1\n",
        "import os, sys\nfrom io import BytesIO, IOBase\nfrom math import log2, ceil, sqrt, gcd\nfrom _collections import deque\nimport heapq as hp\nfrom bisect import bisect_left, bisect_right\nfrom math import cos, sin\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = [int(i) for i in input()]\n\tb = [int(i) for i in input()]\n\tans = 0\n\tx = y = 0\n\tfor i in range(n):\n\t\tif a[i] == 1 and b[i] == 1:\n\t\t\tif x == 1 and y == 1:\n\t\t\t\tans += 2\n\t\t\t\tx = 0\n\t\t\t\ty = 0\n\t\t\telif x == 1:\n\t\t\t\tans += 1\n\t\t\t\tx = 1\n\t\t\telse:\n\t\t\t\tx = y = 1\n\t\telif a[i] == 0:\n\t\t\tx = 0\n\t\t\ty = 0\n\t\t\tif b[i] == 1:\n\t\t\t\tans += 1\n\t\telif a[i] == 1:\n\t\t\tif y == 1:\n\t\t\t\tans += 1\n\t\t\t\tx = 0\n\t\t\t\ty = 0\n\t\t\telse:\n\t\t\t\tx = 1\n\t\t\t\ty = 0\n\tprint(ans)\n",
        "def f(opp, us, count=0, i=0):\n\tfor i in range(len(opp)):\n\t\tif us[i] == '0':\n\t\t\tcontinue\n\t\telif opp[i] == '0':\n\t\t\tcount += 1\n\t\telif i > 0 and opp[i - 1] == '1':\n\t\t\tcount += 1\n\t\t\topp[i - 1] = '*'\n\t\telif i < len(opp) - 1 and opp[i + 1] == '1':\n\t\t\tcount += 1\n\t\t\topp[i + 1] = '*'\n\tprint(count)\nfor _ in range(int(input())):\n\tn = int(input())\n\topp = list(input())\n\tus = list(input())\n\tf(opp, us)\n",
        "t = int(input())\nwhile t:\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tc = 0\n\tfor i in range(0, n):\n\t\tif a[i] == '0' and b[i] == '1':\n\t\t\tb[i] = -1\n\t\t\ta[i] = -1\n\t\telif b[i] == '1':\n\t\t\tif i == 0 and a[i + 1] == '1':\n\t\t\t\ta[i + 1] = -1\n\t\t\t\tb[i] = -1\n\t\t\tif i == n - 1 and a[i - 1] == '1':\n\t\t\t\ta[i - 1] = -1\n\t\t\t\tb[i] = -1\n\t\t\tif 0 < i < n - 1:\n\t\t\t\tif a[i - 1] == '1':\n\t\t\t\t\ta[i - 1] = -1\n\t\t\t\t\tb[i] = -1\n\t\t\t\telif a[i + 1] == '1':\n\t\t\t\t\ta[i + 1] = -1\n\t\t\t\t\tb[i] = -1\n\tprint(b.count(-1))\n\tt -= 1\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tenemy = [int(i) for i in input()]\n\tgreg = [int(i) for i in input()]\n\tcount = 0\n\tfor i in range(n):\n\t\tif i == 0:\n\t\t\tif greg[i] == 1:\n\t\t\t\tif enemy[i] == 0:\n\t\t\t\t\tcount += 1\n\t\t\t\telif enemy[i + 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i + 1] = 0\n\t\t\t\telse:\n\t\t\t\t\tpass\n\t\telif i == n - 1:\n\t\t\tif greg[i] == 1:\n\t\t\t\tif enemy[i] == 0:\n\t\t\t\t\tcount += 1\n\t\t\t\telif enemy[i - 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i - 1] = 0\n\t\telif greg[i] == 1:\n\t\t\tif enemy[i] == 0:\n\t\t\t\tcount += 1\n\t\t\telif enemy[i - 1] == 1:\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i - 1] = 0\n\t\t\telif enemy[i + 1] == 1:\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = 0\n\tprint(count)\n",
        "def checkPossible(pos, enemy):\n\tif enemy[pos] == '0':\n\t\treturn 1\n\telif pos - 1 >= 0 and enemy[pos - 1] == '1':\n\t\tenemy[pos - 1] = '2'\n\t\treturn 1\n\telif pos + 1 <= len(enemy) - 1 and enemy[pos + 1] == '1':\n\t\tenemy[pos + 1] = '2'\n\t\treturn 1\n\telse:\n\t\treturn 0\nt = int(input())\nfor CASE in range(t):\n\tn = int(input())\n\tenemy = input()\n\tme = input()\n\tenemy = [a for a in enemy]\n\tres = 0\n\tfor i in range(n):\n\t\tif me[i] == '1':\n\t\t\tres += checkPossible(i, enemy)\n\tprint(res)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tans = int(0)\n\ten = list('2' + input() + '2')\n\tgr = list('2' + input() + '2')\n\tfor i in range(1, n + 1):\n\t\tif gr[i] == '1':\n\t\t\tif en[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif en[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ten[i - 1] = '2'\n\t\t\telif en[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ten[i + 1] = '2'\n\tprint(ans)\n",
        "t = int(input())\nfor _ in range(0, t):\n\tc = 0\n\tn = int(input())\n\th = [0] * n\n\ta = input()\n\tb = input()\n\tfor i in range(0, n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif i != 0 and a[i - 1] == '1' and (not h[i - 1]):\n\t\t\t\tc += 1\n\t\t\t\th[i - 1] = 1\n\t\t\telif i != n - 1 and a[i + 1] == '1' and (not h[i + 1]):\n\t\t\t\tc += 1\n\t\t\t\th[i + 1] = 1\n\tprint(c, end='\\n')\n",
        "k = []\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = list(input(''))\n\tb = input('')\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\ta[i] = '2'\n\t\t\telif i != 0 and a[i - 1] == '1':\n\t\t\t\ta[i - 1] = '2'\n\t\t\telif i != n - 1 and a[i + 1] == '1':\n\t\t\t\ta[i + 1] = '2'\n\tk.append(a.count('2'))\nfor i in k:\n\tprint(i)\n",
        "tinytales = int(input())\nwhile tinytales:\n\ttinytales -= 1\n\tnobels = int(input())\n\tstationary1 = input()\n\tstationary2 = input()\n\tstationary1 = list(stationary1)\n\tstationary2 = list(stationary2)\n\tantrax = 0\n\tfor icecream in range(0, nobels):\n\t\tif stationary2[icecream] == '0':\n\t\t\tcontinue\n\t\tif stationary1[icecream] == '0':\n\t\t\tantrax += 1\n\t\telif icecream - 1 >= 0 and stationary1[icecream - 1] == '1':\n\t\t\tantrax += 1\n\t\t\tstationary1[icecream - 1] = '0'\n\t\telif icecream + 1 < nobels and stationary1[icecream + 1] == '1':\n\t\t\tantrax += 1\n\t\t\tstationary1[icecream + 1] = '0'\n\tprint(antrax)\n",
        "t = int(input())\nans = []\nfor _ in range(t):\n\tn = int(input())\n\tu = list(input())\n\tv = list(input())\n\tret = 0\n\tbn = n - 1\n\tfor i in range(n):\n\t\tif v[i] == '1':\n\t\t\tif u[i] == '0':\n\t\t\t\tret += 1\n\t\t\telif i > 0 and u[i - 1] == '1':\n\t\t\t\tret += 1\n\t\t\telif i < bn and u[i + 1] == '1':\n\t\t\t\tu[i + 1] = '#'\n\t\t\t\tret += 1\n\tans.append(str(ret))\nprint('\\n'.join(ans))\n",
        "from bisect import insort, bisect_right, bisect_left\nfrom sys import stdout, stdin, setrecursionlimit\nfrom heapq import heappush, heappop, heapify\nfrom io import BytesIO, IOBase\nfrom collections import *\nfrom itertools import *\nfrom random import *\nfrom string import *\nfrom queue import *\nfrom math import *\nfrom re import *\nfrom os import *\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = read(self._fd, max(fstat(self._fd).st_size, 8192))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = read(self._fd, max(fstat(self._fd).st_size, 8192))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\twrite(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(stdin, stdout) = (IOWrapper(stdin), IOWrapper(stdout))\n(graph, mod, szzz) = ({}, 10 ** 9 + 7, lambda : sorted(zzz()))\n\ndef getStr():\n\treturn input()\n\ndef getInt():\n\treturn int(input())\n\ndef listStr():\n\treturn list(input())\n\ndef getStrs():\n\treturn input().split()\n\ndef isInt(s):\n\treturn '0' <= s[0] <= '9'\n\ndef input():\n\treturn stdin.readline().strip()\n\ndef zzz():\n\treturn [int(i) for i in input().split()]\n\ndef output(answer, end='\\n'):\n\tstdout.write(str(answer) + end)\n\ndef lcd(xnum1, xnum2):\n\treturn xnum1 * xnum2 // gcd(xnum1, xnum2)\n\ndef getPrimes(N=10 ** 5):\n\tSN = int(sqrt(N))\n\tsieve = [i for i in range(N + 1)]\n\tsieve[1] = 0\n\tfor i in sieve:\n\t\tif i > SN:\n\t\t\tbreak\n\t\tif i == 0:\n\t\t\tcontinue\n\t\tfor j in range(2 * i, N + 1, i):\n\t\t\tsieve[j] = 0\n\tprime = [i for i in range(N + 1) if sieve[i] != 0]\n\treturn prime\n\ndef primeFactor(n, prime=getPrimes()):\n\tlst = []\n\tmx = int(sqrt(n)) + 1\n\tfor i in prime:\n\t\tif i > mx:\n\t\t\tbreak\n\t\twhile n % i == 0:\n\t\t\tlst.append(i)\n\t\t\tn //= i\n\tif n > 1:\n\t\tlst.append(n)\n\treturn lst\ndx = [-1, 1, 0, 0, 1, -1, 1, -1]\ndy = [0, 0, 1, -1, 1, -1, -1, 1]\ndaysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\nnum = getInt()\nfor _ in range(num):\n\tn = getInt()\n\tarr1 = listStr()\n\tarr2 = listStr()\n\tans = 0\n\tmx = 0\n\tfor i in range(n):\n\t\tx = arr1[i]\n\t\ty = arr2[i]\n\t\tif x == '0':\n\t\t\tif y == '1':\n\t\t\t\tans += 1\n\t\t\t\tarr1[i] = '2'\n\t\t\tcontinue\n\t\tif y == '1':\n\t\t\tif i == 0:\n\t\t\t\tif arr1[i + 1] != '2' and arr1[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tarr1[i + 1] = '2'\n\t\t\telif i < n - 1:\n\t\t\t\tif arr1[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tarr1[i - 1] = '2'\n\t\t\t\telif arr1[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tarr1[i + 1] = '2'\n\t\t\telif arr1[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tarr1[i - 1] = '2'\n\t\t\telif arr1[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\tarr1[i] = '2'\n\tprint(ans)\n",
        "import sys\nsys.setrecursionlimit(200000)\nimport math\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\ninput = sys.stdin.readline\nfrom functools import lru_cache\nimport heapq\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\ntestcases = inp()\nfor _ in range(testcases):\n\tn = inp()\n\tx = insr()\n\ty = insr()\n\tpawn = 0\n\tfor i in range(len(x)):\n\t\tif y[i] == '0':\n\t\t\tcontinue\n\t\tif x[i] == '0':\n\t\t\tpawn += 1\n\t\t\tx[i] = '#'\n\t\telif i - 1 >= 0 and x[i - 1] == '1':\n\t\t\tpawn += 1\n\t\telif i + 1 < len(x) and x[i + 1] == '1':\n\t\t\tpawn += 1\n\t\t\tx[i + 1] = '#'\n\tprint(pawn)\n",
        "n = int(input())\na = []\nfor y in range(n):\n\tp = int(input())\n\tn1 = input()\n\tnn = input()\n\tsumm = 0\n\tstop = -1\n\tfor i in range(p):\n\t\tif nn[i] == '1':\n\t\t\tif (i >= 1 and n1[i - 1] == '1') and stop != i - 1:\n\t\t\t\tsumm = summ + 1\n\t\t\telif n1[i] == '0':\n\t\t\t\tsumm = summ + 1\n\t\t\telif i < p - 1 and n1[i + 1] == '1':\n\t\t\t\tsumm = summ + 1\n\t\t\t\tstop = i + 1\n\ta.append(summ)\nfor y in range(n):\n\tprint(a[y])\n",
        "import math\nimport sys\nimport itertools\nimport fractions\nwtf = sys.stdin.read()\nwtf = wtf.strip().split('\\n')\nfor t in [wtf[i:i + 3] for i in range(1, len(wtf), 3)]:\n\tn = int(t[0])\n\tr0 = [x for x in t[1]]\n\trn = [x for x in t[2]]\n\tans = 0\n\tfor i in range(n):\n\t\tif rn[i] == '1':\n\t\t\tif r0[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i - 1 >= 0 and r0[i - 1] == '1':\n\t\t\t\tr0[i - 1] = '0'\n\t\t\t\tans += 1\n\t\t\telif i + 1 < n and r0[i + 1] == '1':\n\t\t\t\tr0[i + 1] = '0'\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "result = []\nfor _ in range(int(input())):\n\tn = int(input())\n\tyou = [int(x) for x in input()]\n\tmy = [int(x) for x in input()]\n\toccupy = set()\n\tcnt = 0\n\tfor i in range(n):\n\t\tif my[i] == 1:\n\t\t\tif you[i] == 0:\n\t\t\t\toccupy.add(i)\n\t\t\t\tcnt += 1\n\t\t\telif i > 0 and you[i - 1] == 1 and (i - 1 not in occupy):\n\t\t\t\toccupy.add(i - 1)\n\t\t\t\tcnt += 1\n\t\t\telif i < n - 1 and you[i + 1] == 1:\n\t\t\t\toccupy.add(i + 1)\n\t\t\t\tcnt += 1\n\tresult.append(cnt)\nprint(*result, sep='\\n')\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ta = ['X'] + list(input()) + ['X']\n\tm = 'X' + input() + 'X'\n\tans = 0\n\tfor i in range(1, n + 1):\n\t\tif m[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif a[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ta[i - 1] = '2'\n\t\t\telif a[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\ta[i + 1] = '2'\n\tprint(ans)\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tvr = list(input())\n\tgreg = list(input())\n\thr = 0\n\tfor e in range(len(greg)):\n\t\tif greg[e] == '1':\n\t\t\tif vr[e] == '0':\n\t\t\t\thr += 1\n\t\t\t\tvr[e] = '2'\n\t\t\telif e > 0 and vr[e - 1] == '1':\n\t\t\t\thr += 1\n\t\t\t\tvr[e - 1] = '2'\n\t\t\telif e < n - 1 and vr[e + 1] == '1':\n\t\t\t\thr += 1\n\t\t\t\tvr[e + 1] = '2'\n\tprint(hr)\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tblack = list(input())\n\twhite = list(input())\n\tres = 0\n\tif white[0] == '1':\n\t\tif black[0] == '0':\n\t\t\tres += 1\n\t\telif black[1] == '1':\n\t\t\tblack[1] = '0'\n\t\t\tres += 1\n\tfor i in range(1, n - 1):\n\t\tif white[i] == '1':\n\t\t\tif black[i] == '0':\n\t\t\t\tres += 1\n\t\t\telif black[i - 1] == '1':\n\t\t\t\tblack[i - 1] = '0'\n\t\t\t\tres += 1\n\t\t\telif black[i + 1] == '1':\n\t\t\t\tblack[i + 1] = '0'\n\t\t\t\tres += 1\n\tif white[n - 1] == '1':\n\t\tif black[n - 1] == '0':\n\t\t\tres += 1\n\t\telif black[n - 2] == '1':\n\t\t\tblack[n - 1] = '0'\n\t\t\tres += 1\n\tprint(res)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tb = list(input())\n\ta = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif a[i] == '1':\n\t\t\tif b[i] == '1':\n\t\t\t\tif i != 0:\n\t\t\t\t\tif b[i - 1] == '1':\n\t\t\t\t\t\tans += 1\n\t\t\t\t\t\tb[i - 1] = '0'\n\t\t\t\t\t\tcontinue\n\t\t\t\tif i != n - 1:\n\t\t\t\t\tif b[i + 1] == '1':\n\t\t\t\t\t\tans += 1\n\t\t\t\t\t\tb[i + 1] = '0'\n\t\t\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "ttt_ = int(input())\nfor __t in range(ttt_):\n\tn = int(input())\n\ttt = input()\n\ts = input()\n\tt = ['0'] * n\n\tfor i in range(n):\n\t\tt[i] = tt[i]\n\tk = 0\n\tfor i in range(n):\n\t\tif s[i] == '1':\n\t\t\tif t[i] == '0':\n\t\t\t\tk += 1\n\t\t\telif i > 0 and t[i - 1] == '1':\n\t\t\t\tk += 1\n\t\t\telif i < n - 1 and t[i + 1] == '1':\n\t\t\t\tk += 1\n\t\t\t\tt[i + 1] = '0'\n\tprint(k)\n",
        "for i in range(int(input())):\n\tn = int(input())\n\ts = list(input())\n\tl = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif l[i] == '1':\n\t\t\tif s[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i != 0 and s[i - 1] == '1':\n\t\t\t\ts[i - 1] = '0'\n\t\t\t\tans += 1\n\t\t\telif i != n - 1 and s[i + 1] == '1':\n\t\t\t\ts[i + 1] = '0'\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "def solve(n, me, enemy):\n\tcnt = 0\n\tgoal = [0] * n\n\tfor i in range(n):\n\t\tif me[i] == '1':\n\t\t\tif i > 0 and enemy[i - 1] == '1' and (goal[i - 1] == 0):\n\t\t\t\tgoal[i - 1] = 1\n\t\t\t\tcnt += 1\n\t\t\telif enemy[i] == '0' and goal[i] == 0:\n\t\t\t\tgoal[i] = 1\n\t\t\t\tcnt += 1\n\t\t\telif i < n - 1 and enemy[i + 1] == '1' and (goal[i + 1] == 0):\n\t\t\t\tgoal[i + 1] = 1\n\t\t\t\tcnt += 1\n\treturn cnt\n\ndef main():\n\tans = []\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\tenemy = input()\n\t\tme = input()\n\t\tans.append(solve(n, me, enemy))\n\tfor a in ans:\n\t\tprint(a)\nmain()\n",
        "t = int(input())\nfor p in range(t):\n\tn = int(input())\n\ten = input()\n\ten = [int(x) for x in en]\n\tus = input()\n\tus = [int(x) for x in us]\n\top = 0\n\tfor i in range(n):\n\t\tif us[i]:\n\t\t\tif not en[i]:\n\t\t\t\top += 1\n\t\t\telif en[i - 1] and i > 0:\n\t\t\t\top += 1\n\t\t\telif i < n - 1:\n\t\t\t\tif en[i + 1]:\n\t\t\t\t\ten[i + 1] = 0\n\t\t\t\t\top += 1\n\tprint(op)\n",
        "def fun(n):\n\tif n == 5:\n\t\tprint('2 4')\n\t\tprint()\n\t\treturn\n\tv = n - 1\n\tf = 2\n\ts = v // 2\n\tprint(f, s, end=' ')\n\tprint()\n\treturn\nfor _ in range(int(input())):\n\tn = int(input())\n\td = input()\n\ts = input()\n\ts = list(s)\n\td = list(d)\n\tif s.count('1') == 0:\n\t\tprint(0)\n\telif d.count('1') == 0:\n\t\tprint(s.count('1'))\n\telse:\n\t\tcnt = 0\n\t\tfor i in range(n):\n\t\t\tif s[i] == '1' and d[i] == '0':\n\t\t\t\tcnt = cnt + 1\n\t\t\telif s[i] == '1' and (d[i] == '1' or d[i] == '-1'):\n\t\t\t\tif i - 1 >= 0 and d[i - 1] == '1':\n\t\t\t\t\td[i - 1] = '-1'\n\t\t\t\t\tcnt = cnt + 1\n\t\t\t\telif i + 1 < n and d[i + 1] == '1':\n\t\t\t\t\td[i + 1] = '-1'\n\t\t\t\t\tcnt = cnt + 1\n\t\tprint(cnt)\n",
        "T = int(input())\nfor t in range(T):\n\tn = int(input())\n\tgrid = []\n\tans = 0\n\tfor i in range(2):\n\t\tx = input()\n\t\tx = [int(i) for i in x]\n\t\tgrid.append(x)\n\tfor i in range(n):\n\t\tif i > 0 and grid[1][i] == 1 and (grid[0][i - 1] == 1):\n\t\t\tgrid[0][i - 1] = -1\n\t\telif grid[1][i] == 1 and grid[0][i] == 0:\n\t\t\tgrid[0][i] = -1\n\t\telif i < n - 1 and grid[1][i] == 1 and (grid[0][i + 1] == 1):\n\t\t\tgrid[0][i + 1] = -1\n\tprint(grid[0].count(-1))\n",
        "t = int(input())\nfor dummy_i in range(t):\n\tn = int(input())\n\telis = input()\n\te = [i for i in elis]\n\tm = input()\n\teaten = set()\n\tfor i in range(n):\n\t\tif m[i] == '1':\n\t\t\tif e[i] == '0':\n\t\t\t\teaten.add(i)\n\t\t\telif i != 0 and e[i - 1] == '1':\n\t\t\t\teaten.add(i - 1)\n\t\t\t\te[i - 1] = '-1'\n\t\t\telif i != n - 1 and e[i + 1] == '1':\n\t\t\t\teaten.add(i + 1)\n\t\t\t\te[i + 1] = '-1'\n\tprint(len(eaten))\n",
        "t = int(input())\nfor i in range(t):\n\tn = int(input())\n\tene = ['x'] + list(input()) + ['x']\n\tgeo = ['x'] + list(input()) + ['x']\n\tans = 0\n\tfor j in range(1, n + 1):\n\t\tif geo[j] == '1':\n\t\t\tif ene[j] == '0':\n\t\t\t\tans += 1\n\t\t\telif ene[j - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tene[j - 1] = '2'\n\t\t\telif ene[j + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tene[j + 1] = '2'\n\tprint(ans)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = [int(i) for i in input()]\n\tb = [int(i) for i in input()]\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == 0:\n\t\t\tcontinue\n\t\tif a[i] == 0:\n\t\t\tans += 1\n\t\telif i != 0 and a[i - 1] == 1:\n\t\t\tans += 1\n\t\t\ta[i - 1] = 2\n\t\telif i < n - 1 and a[i + 1] == 1:\n\t\t\tans += 1\n\t\t\ta[i + 1] = 2\n\tprint(ans)\n",
        "from math import *\nfrom collections import defaultdict as dt\nfrom sys import stdin\ninp = lambda : stdin.readline().strip()\nI = lambda : int(inp())\nM = lambda : map(int, inp().split())\nL = lambda : list(M())\nmod = 1000000007\ninf = 100000000000000000000\nss = 'abcdefghijklmnopqrstuvwxyz'\n\ndef solve():\n\tn = I()\n\ta = list('0' + inp() + '0')\n\tb = list('0' + inp() + '0')\n\tc = 0\n\tfor i in range(1, n + 1):\n\t\tif a[i] == '0' and b[i] == '1':\n\t\t\tc = c + 1\n\t\telif a[i] == '1' and b[i] == '1':\n\t\t\tif a[i - 1] == '1':\n\t\t\t\tc = c + 1\n\t\t\t\ta[i - 1] = '0'\n\t\t\telif a[i + 1] == '1':\n\t\t\t\tc = c + 1\n\t\t\t\ta[i + 1] = '0'\n\tprint(c)\ntt = 1\ntt = I()\nfor _ in range(tt):\n\tsolve()\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tePawns = input()\n\tgPawns = input()\n\tindices = {}\n\tcount = 0\n\tfor i in range(n):\n\t\tif gPawns[i] != '0':\n\t\t\tif ePawns[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tindices[i] = False\n\t\t\telif i - 1 >= 0 and ePawns[i - 1] == '1' and (i - 1 not in indices):\n\t\t\t\tcount += 1\n\t\t\t\tindices[i - 1] = False\n\t\t\telif i + 1 < n and ePawns[i + 1] == '1' and (i + 1 not in indices):\n\t\t\t\tcount += 1\n\t\t\t\tindices[i + 1] = False\n\tprint(count)\n",
        "import sys\ntokens = ''.join(sys.stdin.readlines()).split()[::-1]\n\ndef next():\n\treturn tokens.pop()\n\ndef nextInt():\n\treturn int(next())\n\ndef nextFloat():\n\treturn float(next())\n\ndef getIntArray(n):\n\treturn [nextInt() for _ in range(n)]\n\ndef getFloatArray(n):\n\treturn [nextFloat() for _ in range(n)]\n\ndef getStringArray(n):\n\treturn [next() for _ in range(n)]\nflush = sys.stdout.flush\ntestcase = True\n\ndef solve(testcase=1):\n\tN = nextInt()\n\t(A, B) = (list(next()), list(next()))\n\tc = 0\n\tfor i in range(N):\n\t\tif B[i] == '1':\n\t\t\tif A[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif i > 0 and A[i - 1] == B[i]:\n\t\t\t\tA[i - 1] = '0'\n\t\t\t\tc += 1\n\t\t\telif i + 1 < N and A[i + 1] == B[i]:\n\t\t\t\tA[i + 1] = '0'\n\t\t\t\tc += 1\n\tprint(c)\ntestcaseCount = nextInt() if testcase else 1\nfor tc in range(testcaseCount):\n\tsolve(tc + 1)\nassert not tokens\n",
        "def solve():\n\tn = int(input())\n\tenemy = list(input())\n\tme = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif me[i] == '1':\n\t\t\tif enemy[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i - 1 >= 0 and enemy[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\telif i + 1 < n and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = '0'\n\t\t\t\tans += 1\n\tprint(ans)\nt = int(input())\nfor i in range(t):\n\tsolve()\n",
        "for t in range(int(input())):\n\tn = int(input())\n\tp = list(input())\n\tp = list(map(int, p))\n\tm = list(input())\n\tm = list(map(int, m))\n\tfor i in range(n):\n\t\tif m[i] == 0:\n\t\t\tcontinue\n\t\tif i == 0:\n\t\t\tif p[0] == 0:\n\t\t\t\tm[i] = 0\n\t\t\t\tp[0] = 2\n\t\tif m[i] != 0 and i != 0 and (p[i - 1] == 1):\n\t\t\tm[i] = 0\n\t\t\tp[i - 1] = 2\n\t\telif m[i] != 0 and p[i] == 0:\n\t\t\tm[i] = 0\n\t\t\tp[i] = 2\n\t\telif m[i] != 0 and i + 1 < n and (p[i + 1] == 1):\n\t\t\tm[i] = 0\n\t\t\tp[i + 1] = 2\n\tprint(p.count(2))\n",
        "from collections import defaultdict, deque\nimport sys\ninput = lambda : sys.stdin.readline().strip()\nfor _ in range(int(input())):\n\tn = int(input())\n\ta1 = input()\n\tb1 = input()\n\ta = ['2']\n\tb = ['2']\n\tfor i in range(n):\n\t\ta.append(a1[i])\n\t\tb.append(b1[i])\n\ta.append('2')\n\tb.append('2')\n\tcount = 0\n\tfor i in range(1, n + 1):\n\t\tif b[i] == '1' and a[i] == '0':\n\t\t\ta[i] = '2'\n\t\t\tcount += 1\n\t\telif b[i] == '1' and a[i - 1] == '1':\n\t\t\ta[i - 1] = '2'\n\t\t\tcount += 1\n\t\telif b[i] == '1' and a[i + 1] == '1':\n\t\t\ta[i + 1] = '2'\n\t\t\tcount += 1\n\tprint(count)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tcaptured = set()\n\topp = input()\n\tme = input()\n\tresult = 0\n\tfor index in range(n):\n\t\tif me[index] == '1':\n\t\t\tif index > 0 and opp[index - 1] == '1' and (index - 1 not in captured):\n\t\t\t\tresult += 1\n\t\t\telif opp[index] == '0':\n\t\t\t\tresult += 1\n\t\t\telif index < n - 1 and opp[index + 1] == '1':\n\t\t\t\tresult += 1\n\t\t\t\tcaptured.add(index + 1)\n\tprint(result)\n",
        "t = int(input())\nfor test in range(t):\n\tn = int(input())\n\tstring1 = input()\n\tarray1 = []\n\tfor item in string1:\n\t\tarray1.append(item)\n\tarray2 = []\n\tstring2 = input()\n\tfor item in string2:\n\t\tarray2.append(item)\n\ts = 0\n\tfor i in range(n):\n\t\tif array2[i] == '1':\n\t\t\tif i - 1 >= 0 and array1[i - 1] == '1':\n\t\t\t\tarray1[i - 1] = '2'\n\t\t\t\ts += 1\n\t\t\telif array1[i] == '0':\n\t\t\t\tarray1[i] = '2'\n\t\t\t\ts += 1\n\t\t\telif i + 1 < n and array1[i + 1] == '1':\n\t\t\t\tarray1[i + 1] = '2'\n\t\t\t\ts += 1\n\tprint(s)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tarr = list(input())\n\tbrr = list(input())\n\tfor i in range(n):\n\t\tarr[i] = int(arr[i])\n\t\tbrr[i] = int(brr[i])\n\tans = 0\n\tdic = {}\n\tif brr[0] == 1:\n\t\tif arr[0] == 1:\n\t\t\tif arr[1] == 1:\n\t\t\t\tans += 1\n\t\t\t\tdic[1] = 1\n\t\telse:\n\t\t\tans += 1\n\t\t\tdic[0] = 1\n\tfor i in range(1, n - 1):\n\t\tif brr[i] == 1:\n\t\t\tif arr[i] == 0 and i not in dic:\n\t\t\t\tans += 1\n\t\t\t\tdic[i] = 1\n\t\t\telif arr[i - 1] == 1 and i - 1 not in dic:\n\t\t\t\tans += 1\n\t\t\t\tdic[i - 1] = 1\n\t\t\telif arr[i + 1] == 1 and i + 1 not in dic:\n\t\t\t\tans += 1\n\t\t\t\tdic[i + 1] = 1\n\tif brr[n - 1] == 1:\n\t\tif arr[n - 1] == 0 and n - 1 not in dic:\n\t\t\tans += 1\n\t\telif arr[n - 2] == 1 and n - 2 not in dic:\n\t\t\tans += 1\n\tprint(ans)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tenemy = input()\n\tgregor = input()\n\tdct = {a: 0 for a in range(n)}\n\tans = 0\n\tdct[-1] = -1\n\tdct[n] = -1\n\tfor i in range(n):\n\t\tif gregor[i] == '1':\n\t\t\tif enemy[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif dct[i - 1] == 0:\n\t\t\t\tif enemy[i - 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tdct[i - 1] = 1\n\t\t\t\telif dct[i + 1] == 0:\n\t\t\t\t\tif enemy[i + 1] == '1':\n\t\t\t\t\t\tans += 1\n\t\t\t\t\t\tdct[i + 1] = 1\n\t\t\telif dct[i + 1] == 0:\n\t\t\t\tif enemy[i + 1] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\tdct[i + 1] = 1\n\tprint(ans)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tm1 = list(map(int, input()))\n\tm2 = list(map(int, input()))\n\tans = 0\n\tprev_set = False\n\tif m2[0]:\n\t\tif not m1[0]:\n\t\t\tans += 1\n\t\telif m1[1]:\n\t\t\tans += 1\n\t\t\tm1[1] = 0\n\tprev_set = m1[0]\n\tfor i in range(1, n):\n\t\tif m2[i]:\n\t\t\tif prev_set:\n\t\t\t\tans += 1\n\t\t\telif not m1[i]:\n\t\t\t\tans += 1\n\t\t\telif i + 1 < n and m1[i + 1]:\n\t\t\t\tans += 1\n\t\t\t\tm1[i + 1] = 0\n\t\tprev_set = m1[i]\n\tprint(ans)\n",
        "t = int(input())\nresult = []\nfor i in range(t):\n\tn = int(input())\n\tenemy = list(map(int, input()))\n\tpawn = list(map(int, input()))\n\tcount = 0\n\tfor i in range(len(pawn)):\n\t\tif pawn[i] != 0:\n\t\t\tif enemy[i] == 0:\n\t\t\t\tenemy[i] = 2\n\t\t\t\tcount += 1\n\t\t\telif i == 0:\n\t\t\t\tif enemy[i + 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i + 1] = 2\n\t\t\telif i == n - 1:\n\t\t\t\tif enemy[i - 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i - 1] = 2\n\t\t\telif (enemy[i + 1] == 1) | (enemy[i - 1] == 1):\n\t\t\t\tif enemy[i - 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i - 1] = 2\n\t\t\t\telif enemy[i + 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tenemy[i + 1] = 2\n\tresult.append(count)\nfor i in result:\n\tprint(i)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ta = input()\n\tb = input()\n\tc = [True] * n\n\to = 0\n\tif b[0] == '1' and a[0] == '0':\n\t\to += 1\n\telif b[0] == '1' and a[1] == '1':\n\t\to += 1\n\t\tc[1] = False\n\tfor i in range(1, n - 1):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\to += 1\n\t\t\telif a[i - 1] == '1' and c[i - 1] == True:\n\t\t\t\to += 1\n\t\t\t\tc[i - 1] = False\n\t\t\telif a[i + 1] == '1' and c[i + 1] == True:\n\t\t\t\to += 1\n\t\t\t\tc[i + 1] = False\n\tif b[n - 1] == '1' and a[n - 1] == '0':\n\t\to += 1\n\telif b[n - 1] == '1' and a[n - 2] == '1' and (c[n - 2] == True):\n\t\to += 1\n\t\tc[n - 1] = False\n\tprint(o)\n",
        "for ii in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\ta = list(map(int, a))\n\tb = list(map(int, b))\n\tc = 0\n\tif b[0]:\n\t\tif a[0] == 0:\n\t\t\tc += 1\n\t\t\ta[0] = 2\n\t\telif a[1] == 1:\n\t\t\tc += 1\n\t\t\ta[1] = 2\n\tfor jj in range(1, n - 1):\n\t\tif b[jj]:\n\t\t\tif a[jj] == 0:\n\t\t\t\tc += 1\n\t\t\t\ta[jj] = 2\n\t\t\telif a[jj - 1] == 1:\n\t\t\t\tc += 1\n\t\t\t\ta[jj - 1] = 2\n\t\t\telif a[jj + 1] == 1:\n\t\t\t\tc += 1\n\t\t\t\ta[jj + 1] = 2\n\tif b[-1]:\n\t\tif a[-1] == 0:\n\t\t\tc += 1\n\t\t\ta[-1] = 2\n\t\telif a[-2] == 1:\n\t\t\tc += 1\n\t\t\ta[-2] = 2\n\tprint(c)\n",
        "t = int(input())\n\ndef sp():\n\tn = int(input())\n\te1 = str(input())\n\te = list(''.join(e1))\n\tg1 = str(input())\n\tg = list(''.join(g1))\n\tc = 0\n\tfor i in range(len(g)):\n\t\tif i == 0:\n\t\t\tif g[i] == '1' and e[i] == '0':\n\t\t\t\tc += 1\n\t\t\t\te[i] = '2'\n\t\t\telif g[i] == '1' and e[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\te[i + 1] = '2'\n\t\telif i > 0 and i < n - 1:\n\t\t\tif g[i] == '1' and e[i] == '0':\n\t\t\t\tc += 1\n\t\t\t\te[i] = '2'\n\t\t\telif g[i] == '1' and e[i - 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\te[i - 1] = '2'\n\t\t\telif g[i] == '1' and e[i + 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\te[i + 1] = '2'\n\t\telif i == n - 1:\n\t\t\tif g[i] == '1' and e[i] == '0':\n\t\t\t\tc += 1\n\t\t\t\te[i] = '2'\n\t\t\telif g[i] == '1' and e[i - 1] == '1':\n\t\t\t\tc += 1\n\t\t\t\te[i - 1] = '2'\n\tprint(c)\nfor i in range(t):\n\tsp()\n",
        "import math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nfrom collections import defaultdict\nmod = 10 ** 9 + 7\nmod1 = 998244353\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass TreeNode:\n\n\tdef __init__(self, k, v):\n\t\tself.key = k\n\t\tself.value = v\n\t\tself.left = None\n\t\tself.right = None\n\t\tself.parent = None\n\t\tself.height = 1\n\t\tself.num_left = 1\n\t\tself.num_total = 1\n\nclass AvlTree:\n\n\tdef __init__(self):\n\t\tself._tree = None\n\n\tdef add(self, k, v):\n\t\tif not self._tree:\n\t\t\tself._tree = TreeNode(k, v)\n\t\t\treturn\n\t\tnode = self._add(k, v)\n\t\tif node:\n\t\t\tself._rebalance(node)\n\n\tdef _add(self, k, v):\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tif node.left:\n\t\t\t\t\tnode = node.left\n\t\t\t\telse:\n\t\t\t\t\tnode.left = TreeNode(k, v)\n\t\t\t\t\tnode.left.parent = node\n\t\t\t\t\treturn node.left\n\t\t\telif node.key < k:\n\t\t\t\tif node.right:\n\t\t\t\t\tnode = node.right\n\t\t\t\telse:\n\t\t\t\t\tnode.right = TreeNode(k, v)\n\t\t\t\t\tnode.right.parent = node\n\t\t\t\t\treturn node.right\n\t\t\telse:\n\t\t\t\tnode.value = v\n\t\t\t\treturn\n\n\t@staticmethod\n\tdef get_height(x):\n\t\treturn x.height if x else 0\n\n\t@staticmethod\n\tdef get_num_total(x):\n\t\treturn x.num_total if x else 0\n\n\tdef _rebalance(self, node):\n\t\tn = node\n\t\twhile n:\n\t\t\tlh = self.get_height(n.left)\n\t\t\trh = self.get_height(n.right)\n\t\t\tn.height = max(lh, rh) + 1\n\t\t\tbalance_factor = lh - rh\n\t\t\tn.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n\t\t\tn.num_left = 1 + self.get_num_total(n.left)\n\t\t\tif balance_factor > 1:\n\t\t\t\tif self.get_height(n.left.left) < self.get_height(n.left.right):\n\t\t\t\t\tself._rotate_left(n.left)\n\t\t\t\tself._rotate_right(n)\n\t\t\telif balance_factor < -1:\n\t\t\t\tif self.get_height(n.right.right) < self.get_height(n.right.left):\n\t\t\t\t\tself._rotate_right(n.right)\n\t\t\t\tself._rotate_left(n)\n\t\t\telse:\n\t\t\t\tn = n.parent\n\n\tdef _remove_one(self, node):\n\t\treplacement = node.left or node.right\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = replacement\n\t\t\telse:\n\t\t\t\tnode.parent.right = replacement\n\t\t\treplacement.parent = node.parent\n\t\t\tnode.parent = None\n\t\telse:\n\t\t\tself._tree = replacement\n\t\t\treplacement.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\t\tnode.parent = None\n\t\tself._rebalance(replacement)\n\n\tdef _remove_leaf(self, node):\n\t\tif node.parent:\n\t\t\tif AvlTree._is_left(node):\n\t\t\t\tnode.parent.left = None\n\t\t\telse:\n\t\t\t\tnode.parent.right = None\n\t\t\tself._rebalance(node.parent)\n\t\telse:\n\t\t\tself._tree = None\n\t\tnode.parent = None\n\t\tnode.left = None\n\t\tnode.right = None\n\n\tdef remove(self, k):\n\t\tnode = self._get_node(k)\n\t\tif not node:\n\t\t\treturn\n\t\tif AvlTree._is_leaf(node):\n\t\t\tself._remove_leaf(node)\n\t\t\treturn\n\t\tif node.left and node.right:\n\t\t\tnxt = AvlTree._get_next(node)\n\t\t\tnode.key = nxt.key\n\t\t\tnode.value = nxt.value\n\t\t\tif self._is_leaf(nxt):\n\t\t\t\tself._remove_leaf(nxt)\n\t\t\telse:\n\t\t\t\tself._remove_one(nxt)\n\t\t\tself._rebalance(node)\n\t\telse:\n\t\t\tself._remove_one(node)\n\n\tdef get(self, k):\n\t\tnode = self._get_node(k)\n\t\treturn node.value if node else -1\n\n\tdef _get_node(self, k):\n\t\tif not self._tree:\n\t\t\treturn None\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif k < node.key:\n\t\t\t\tnode = node.left\n\t\t\telif node.key < k:\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn node\n\t\treturn None\n\n\tdef get_at(self, pos):\n\t\tx = pos + 1\n\t\tnode = self._tree\n\t\twhile node:\n\t\t\tif x < node.num_left:\n\t\t\t\tnode = node.left\n\t\t\telif node.num_left < x:\n\t\t\t\tx -= node.num_left\n\t\t\t\tnode = node.right\n\t\t\telse:\n\t\t\t\treturn (node.key, node.value)\n\t\traise IndexError('Out of ranges')\n\n\t@staticmethod\n\tdef _is_left(node):\n\t\treturn node.parent.left and node.parent.left == node\n\n\t@staticmethod\n\tdef _is_leaf(node):\n\t\treturn node.left is None and node.right is None\n\n\tdef _rotate_right(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.left\n\t\t\tnode.left.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.left\n\t\t\tnode.left.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.left\n\t\t\tnode.left.parent = node.parent\n\t\tbk = node.left.right\n\t\tnode.left.right = node\n\t\tnode.parent = node.left\n\t\tnode.left = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\tdef _rotate_left(self, node):\n\t\tif not node.parent:\n\t\t\tself._tree = node.right\n\t\t\tnode.right.parent = None\n\t\telif AvlTree._is_left(node):\n\t\t\tnode.parent.left = node.right\n\t\t\tnode.right.parent = node.parent\n\t\telse:\n\t\t\tnode.parent.right = node.right\n\t\t\tnode.right.parent = node.parent\n\t\tbk = node.right.left\n\t\tnode.right.left = node\n\t\tnode.parent = node.right\n\t\tnode.right = bk\n\t\tif bk:\n\t\t\tbk.parent = node\n\t\tnode.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n\t\tnode.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n\t\tnode.num_left = 1 + self.get_num_total(node.left)\n\n\t@staticmethod\n\tdef _get_next(node):\n\t\tif not node.right:\n\t\t\treturn node.parent\n\t\tn = node.right\n\t\twhile n.left:\n\t\t\tn = n.left\n\t\treturn n\n\nclass SegmentTree1:\n\n\tdef __init__(self, data, default=2 ** 51, func=lambda a, b: a & b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass SegmentTree:\n\n\tdef __init__(self, data, default=0, func=lambda a, b: a + b):\n\t\tself._default = default\n\t\tself._func = func\n\t\tself._len = len(data)\n\t\tself._size = _size = 1 << (self._len - 1).bit_length()\n\t\tself.data = [default] * (2 * _size)\n\t\tself.data[_size:_size + self._len] = data\n\t\tfor i in reversed(range(_size)):\n\t\t\tself.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n\tdef __delitem__(self, idx):\n\t\tself[idx] = self._default\n\n\tdef __getitem__(self, idx):\n\t\treturn self.data[idx + self._size]\n\n\tdef __setitem__(self, idx, value):\n\t\tidx += self._size\n\t\tself.data[idx] = value\n\t\tidx >>= 1\n\t\twhile idx:\n\t\t\tself.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n\t\t\tidx >>= 1\n\n\tdef __len__(self):\n\t\treturn self._len\n\n\tdef query(self, start, stop):\n\t\tif start == stop:\n\t\t\treturn self.__getitem__(start)\n\t\tstop += 1\n\t\tstart += self._size\n\t\tstop += self._size\n\t\tres = self._default\n\t\twhile start < stop:\n\t\t\tif start & 1:\n\t\t\t\tres = self._func(res, self.data[start])\n\t\t\t\tstart += 1\n\t\t\tif stop & 1:\n\t\t\t\tstop -= 1\n\t\t\t\tres = self._func(res, self.data[stop])\n\t\t\tstart >>= 1\n\t\t\tstop >>= 1\n\t\treturn res\n\n\tdef __repr__(self):\n\t\treturn 'SegmentTree({0})'.format(self.data)\n\nclass Factorial:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorials = [1, 1]\n\t\tself.invModulos = [0, 1]\n\t\tself.invFactorial_ = [1, 1]\n\n\tdef calc(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.factorials):\n\t\t\treturn self.factorials[n]\n\t\tnextArr = [0] * (n + 1 - len(self.factorials))\n\t\tinitialI = len(self.factorials)\n\t\tprev = self.factorials[-1]\n\t\tm = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * i % m\n\t\tself.factorials += nextArr\n\t\treturn self.factorials[n]\n\n\tdef inv(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate n^(-1)')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tp = self.MOD\n\t\tpi = n % p\n\t\tif pi < len(self.invModulos):\n\t\t\treturn self.invModulos[pi]\n\t\tnextArr = [0] * (n + 1 - len(self.invModulos))\n\t\tinitialI = len(self.invModulos)\n\t\tfor i in range(initialI, min(p, n + 1)):\n\t\t\tnext = -self.invModulos[p % i] * (p // i) % p\n\t\t\tself.invModulos.append(next)\n\t\treturn self.invModulos[pi]\n\n\tdef invFactorial(self, n):\n\t\tif n <= -1:\n\t\t\tprint('Invalid argument to calculate (n^(-1))!')\n\t\t\tprint('n must be non-negative value. But the argument was ' + str(n))\n\t\t\texit()\n\t\tif n < len(self.invFactorial_):\n\t\t\treturn self.invFactorial_[n]\n\t\tself.inv(n)\n\t\tnextArr = [0] * (n + 1 - len(self.invFactorial_))\n\t\tinitialI = len(self.invFactorial_)\n\t\tprev = self.invFactorial_[-1]\n\t\tp = self.MOD\n\t\tfor i in range(initialI, n + 1):\n\t\t\tprev = nextArr[i - initialI] = prev * self.invModulos[i % p] % p\n\t\tself.invFactorial_ += nextArr\n\t\treturn self.invFactorial_[n]\n\nclass Combination:\n\n\tdef __init__(self, MOD):\n\t\tself.MOD = MOD\n\t\tself.factorial = Factorial(MOD)\n\n\tdef ncr(self, n, k):\n\t\tif k < 0 or n < k:\n\t\t\treturn 0\n\t\tk = min(k, n - k)\n\t\tf = self.factorial\n\t\treturn f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\ndef powm(a, n, m):\n\tif a == 1 or n == 0:\n\t\treturn 1\n\tif n % 2 == 0:\n\t\ts = powm(a, n // 2, m)\n\t\treturn s * s % m\n\telse:\n\t\treturn a * powm(a, n - 1, m) % m\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\n\ndef product(l):\n\tpor = 1\n\tfor i in range(len(l)):\n\t\tpor *= l[i]\n\treturn por\n\ndef binarySearchCount(arr, n, key):\n\tleft = 0\n\tright = n - 1\n\tcount = 0\n\twhile left <= right:\n\t\tmid = int((right + left) / 2)\n\t\tif arr[mid] < key:\n\t\t\tcount = mid + 1\n\t\t\tleft = mid + 1\n\t\telse:\n\t\t\tright = mid - 1\n\treturn count\n\ndef countdig(n):\n\tc = 0\n\twhile n > 0:\n\t\tn //= 10\n\t\tc += 1\n\treturn c\n\ndef binary(x, length):\n\ty = bin(x)[2:]\n\treturn y if len(y) >= length else '0' * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n\tl = 0\n\tr = n - 1\n\tleftGreater = n\n\twhile l <= r:\n\t\tm = int(l + (r - l) / 2)\n\t\tif arr[m] >= k:\n\t\t\tleftGreater = m\n\t\t\tr = m - 1\n\t\telse:\n\t\t\tl = m + 1\n\treturn n - leftGreater\nfor ik in range(int(input())):\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i > 0 and a[i - 1] == '1':\n\t\t\t\ta[i - 1] = '0'\n\t\t\t\tans += 1\n\t\t\telif i < n - 1 and a[i + 1] == '1':\n\t\t\t\ta[i + 1] = '0'\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "def solve(first_row, curr_row):\n\tif curr_row.count(1) == 0:\n\t\tprint(0)\n\t\treturn\n\tn = len(first_row)\n\tif first_row.count(0) == n:\n\t\tprint(curr_row.count(1))\n\telse:\n\t\tpawns = 0\n\t\tfor i in range(n):\n\t\t\tif curr_row[i] == 0:\n\t\t\t\tcontinue\n\t\t\telif first_row[i] == 0:\n\t\t\t\tpawns += 1\n\t\t\telif i >= 1 and first_row[i - 1] == 1:\n\t\t\t\tpawns += 1\n\t\t\t\tfirst_row[i - 1] = -1\n\t\t\telif i < n - 1 and first_row[i + 1] == 1:\n\t\t\t\tpawns += 1\n\t\t\t\tfirst_row[i + 1] = -1\n\t\tprint(pawns)\n\treturn\nfor _ in range(int(input())):\n\tn = int(input())\n\tfirst_row = list(input())\n\tcurr_row = list(input())\n\tfirst_row = [int(x) for x in first_row]\n\tcurr_row = [int(x) for x in curr_row]\n\tsolve(first_row, curr_row)\n",
        "t = int(input())\nfor ttt in range(t):\n\tn = int(input())\n\ta1 = input()\n\ta2 = input()\n\taa1 = []\n\taa2 = []\n\tfor pro in range(n):\n\t\taa1.append(a1[pro])\n\t\taa2.append(a2[pro])\n\tones = []\n\tans = 0\n\tfor k in range(n):\n\t\tif a1[k] == '1':\n\t\t\tones.append(k)\n\t\tif a1[k] == '0' and a2[k] == '1':\n\t\t\tans += 1\n\ti = 0\n\tif len(ones) > 1:\n\t\twhile i < len(ones) - 1:\n\t\t\tif ones[i + 1] == ones[i] + 1:\n\t\t\t\tif aa2[ones[i]] == '1' and aa2[ones[i + 1]] == '1':\n\t\t\t\t\tans += 2\n\t\t\t\t\ti += 2\n\t\t\t\telif aa2[ones[i]] == '1' and aa2[ones[i + 1]] == '0':\n\t\t\t\t\tans += 1\n\t\t\t\t\ti += 2\n\t\t\t\telif aa2[ones[i]] == '0' and aa2[ones[i + 1]] == '1':\n\t\t\t\t\tans += 1\n\t\t\t\t\taa2[ones[i + 1]] = '0'\n\t\t\t\t\ti += 1\n\t\t\t\telse:\n\t\t\t\t\ti += 1\n\t\t\telse:\n\t\t\t\ti += 1\n\tprint(ans)\n",
        "def main():\n\tn = int(input())\n\tanswer = []\n\tfor i in range(n):\n\t\tanswer.append(in_put())\n\tfor i in range(n):\n\t\tprint(answer[i])\n\ndef in_put():\n\tp = int(input())\n\tans = 0\n\tx = list(input())\n\ty = list(input())\n\tfor i in range(p):\n\t\tif y[i] == '1':\n\t\t\tif x[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i != 0 and x[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tx[i - 1] = '0'\n\t\t\telif i != p - 1 and x[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tx[i + 1] = '0'\n\treturn ans\nmain()\n",
        "def game(l, li_1, li_2):\n\tn = 0\n\tli1 = []\n\tli2 = []\n\tfor i in range(l):\n\t\tli1.append(int(li_1[i]))\n\t\tli2.append(int(li_2[i]))\n\tfor i in range(l):\n\t\tif li2[i] == 1:\n\t\t\tif li1[i] == 0:\n\t\t\t\tli1[i] = 2\n\t\t\t\tn += 1\n\t\t\t\tcontinue\n\t\t\tif i - 1 >= 0 and li1[i - 1] == 1:\n\t\t\t\tli1[i - 1] = 2\n\t\t\t\tn += 1\n\t\t\t\tcontinue\n\t\t\tif i + 1 < l and li1[i + 1] == 1:\n\t\t\t\tli1[i + 1] = 2\n\t\t\t\tn += 1\n\t\t\t\tcontinue\n\treturn n\nn = int(input())\nl = []\nli1 = []\nli2 = []\nfor i in range(n):\n\tl.append(int(input()))\n\tli1.append(input())\n\tli2.append(input())\nfor i in range(n):\n\tprint(game(l[i], li1[i], li2[i]))\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tb = list(input())\n\ta = list(input())\n\tvisited = []\n\tcount = 0\n\tif a[0] == '1':\n\t\tif b[0] == '0':\n\t\t\tcount += 1\n\t\t\tb[0] = 'w'\n\t\telif n > 1 and b[1] == '1':\n\t\t\tcount += 1\n\t\t\tb[1] = 'w'\n\tfor i in range(1, n - 1):\n\t\tif a[i] == '1':\n\t\t\tif b[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tb[i] = 'w'\n\t\t\telif b[i - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tb[i - 1] = 'w'\n\t\t\telif b[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tb[i + 1] = 'w'\n\tif a[n - 1] == '1' and n > 1:\n\t\tif b[n - 1] == '0':\n\t\t\tcount += 1\n\t\t\tb[n - 1] = 'w'\n\t\telif b[n - 2] == '1':\n\t\t\tcount += 1\n\t\t\tb[n - 2] = 'w'\n\tprint(count)\n",
        "from sys import stdin\ninput = stdin.readline\n\ndef processPawns(ln, enemy, gregs):\n\tif '1' not in gregs:\n\t\treturn 0\n\tcount = 0\n\tfor i in range(ln):\n\t\tif i == 0 and gregs[i] == '1':\n\t\t\tif gregs[i] == '1' and enemy[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i] = '2'\n\t\t\telif enemy[i] == '1' and ln > 1 and (enemy[i + 1] == '1'):\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = '2'\n\t\telif gregs[i] == '1':\n\t\t\tif enemy[i] == '0':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i] = '2'\n\t\t\telif enemy[i - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i - 1] = '2'\n\t\t\telif i < ln - 1 and enemy[i + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tenemy[i + 1] = '2'\n\treturn count\nn = int(input())\nfor _ in range(n):\n\tln = int(input())\n\tenemy = list(input().strip())\n\tgregs = list(input().strip())\n\tprint(processPawns(ln, enemy, gregs))\n",
        "import sys\nimport bisect as bi\nimport collections as cc\nimport itertools as it\ninput = sys.stdin.readline\nI = lambda : list(map(int, input().split()))\nmod = 10 ** 9 + 7\nfor tc in range(int(input())):\n\t(n,) = I()\n\tfirst = list(input().strip())\n\tlast = list(input().strip())\n\tans = 0\n\tfor i in range(n):\n\t\tif last[i] == '0':\n\t\t\tcontinue\n\t\tif first[i] == '0':\n\t\t\tans += 1\n\t\telif i > 0 and first[i - 1] == '1':\n\t\t\tans += 1\n\t\telif i < n - 1 and first[i + 1] == '1':\n\t\t\tfirst[i + 1] = '-'\n\t\t\tans += 1\n\tprint(ans)\n",
        "answer = []\nfor _ in range(int(input())):\n\tn = int(input())\n\ts = [int(i) for i in input()]\n\tt = [int(i) for i in input()]\n\tans = 0\n\tfor i in range(n):\n\t\tif i == 0 and t[i] == 1:\n\t\t\tif s[i] == 0:\n\t\t\t\tans += 1\n\t\t\t\ts[i] = 0\n\t\t\telif i + 1 < n and s[i + 1] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts[i + 1] = 0\n\t\telif i > 0 and i < n - 1 and (t[i] == 1):\n\t\t\tif s[i] == 0:\n\t\t\t\tans += 1\n\t\t\t\ts[i] = 0\n\t\t\telif s[i - 1] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts[i - 1] = 0\n\t\t\telif s[i + 1] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts[i + 1] = 0\n\t\telif i == n - 1 and t[i] == 1:\n\t\t\tif s[i] == 0:\n\t\t\t\tans += 1\n\t\t\t\ts[i] = 0\n\t\t\telif i - 1 > -1 and s[i - 1] == 1:\n\t\t\t\tans += 1\n\t\t\t\ts[i - 1] = 0\n\tanswer.append(ans)\nfor i in answer:\n\tprint(i)\n",
        "t = int(input())\nanswer = []\nfor i in range(t):\n\tn = int(input())\n\tenemy = list(input())\n\tgregor = list(input())\n\tcount = 0\n\tfor p in range(n):\n\t\tif enemy[p] == '0' and gregor[p] == '1':\n\t\t\tgregor[p] = '0'\n\t\t\tcount += 1\n\tfor b in range(n):\n\t\tif enemy[b] == '1':\n\t\t\tif b == 0:\n\t\t\t\tif gregor[b + 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgregor[b + 1] = '0'\n\t\t\telif b == n - 1:\n\t\t\t\tif gregor[b - 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgregor[b - 1] == '0'\n\t\t\telif gregor[b - 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tgregor[b - 1] = '0'\n\t\t\telif gregor[b + 1] == '1':\n\t\t\t\tcount += 1\n\t\t\t\tgregor[b + 1] = '0'\n\tanswer.append(count)\nfor item in answer:\n\tprint(item)\n",
        "import sys\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef input_list():\n\treturn list(map(int, input().split()))\n\ndef input_string():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\ntests = inp()\nfor _ in range(tests):\n\tsize = inp()\n\tenemy = input_string()\n\tgeo = input_string()\n\tpassed = 0\n\tfor i in range(size):\n\t\te = enemy[i]\n\t\tg = geo[i]\n\t\tif e == '0' and g == '1':\n\t\t\tpassed += 1\n\t\telif e == '1' and g == '1':\n\t\t\tif i >= 1 and enemy[i - 1] == '1':\n\t\t\t\tenemy[i - 1] = '0'\n\t\t\t\tpassed += 1\n\t\t\telif i < size - 1 and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = '0'\n\t\t\t\tpassed += 1\n\tprint(passed)\n",
        "t = int(input())\nresult = []\nfor i in range(t):\n\tr = 0\n\tn = int(input())\n\ta = input()\n\tb = input()\n\te = [int(x) for x in str(a)]\n\th = [int(x) for x in str(b)]\n\tfor j in range(n):\n\t\tif e[j] == 0 and h[j] == 1:\n\t\t\tr += 1\n\t\t\tcontinue\n\t\telif j != 0 and h[j] == 1 and (e[j - 1] == 1):\n\t\t\tr += 1\n\t\t\te[j - 1] = 0\n\t\t\tcontinue\n\t\telif j != n - 1 and h[j] == 1 and (e[j + 1] == 1):\n\t\t\tr += 1\n\t\t\te[j + 1] = 0\n\t\t\tcontinue\n\tresult.append(r)\nfor i in result:\n\tprint(i)\n",
        "import math\nfrom heapq import heappush, heappop, heapify\nimport random\nimport string\nfrom collections import deque\nfrom bisect import bisect, bisect_left, bisect_right, insort\nimport sys\ninput = sys.stdin.readline\nS = lambda : input().rstrip()\nI = lambda : int(S())\nM = lambda : map(int, S().split())\nL = lambda : list(M())\nH = 1000000000 + 7\nfor _ in range(I()):\n\tn = I()\n\ts1 = S()\n\ts2 = S()\n\td = {}\n\tc = 0\n\tfor i in range(n):\n\t\tif s2[i] == '1':\n\t\t\tif i - 1 >= 0 and s1[i - 1] == '1' and (d.get(i - 1, 0) == 0):\n\t\t\t\tc += 1\n\t\t\t\td[i - 1] = 1\n\t\t\telif s1[i] == '0':\n\t\t\t\tc += 1\n\t\t\telif i + 1 < n and s1[i + 1] == '1' and (d.get(i + 1, 0) == 0):\n\t\t\t\tc += 1\n\t\t\t\td[i + 1] = 1\n\tprint(c)\n",
        "import sys, threading, heapq, math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tn = int(input())\n\t\tenemy = input().strip()\n\t\tgregor = input().strip()\n\t\tcount = 0\n\t\tvisited = set()\n\t\tfor i in range(n):\n\t\t\tif gregor[i] == '1':\n\t\t\t\tif enemy[i] == '0':\n\t\t\t\t\tcount += 1\n\t\t\t\telif i > 0 and enemy[i - 1] == '1' and (i - 1 not in visited):\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited.add(i - 1)\n\t\t\t\telif i < n - 1 and enemy[i + 1] == '1' and (i + 1 not in visited):\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited.add(i + 1)\n\t\tprint(count)\nmain()\n",
        "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tarr = []\n\tfor c in s1:\n\t\tarr.append(c)\n\tans = 0\n\tfor i in range(n):\n\t\tif s2[i] == '1':\n\t\t\tif i > 0 and arr[i - 1] == '1':\n\t\t\t\tarr[i - 1] = '0'\n\t\t\t\tans += 1\n\t\t\t\tcontinue\n\t\t\telif arr[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\tcontinue\n\t\t\telif i < n - 1 and arr[i + 1] == '1':\n\t\t\t\tarr[i + 1] = '0'\n\t\t\t\tans += 1\n\t\t\t\tcontinue\n\tprint(ans)\n",
        "for t in range(int(input())):\n\tn = int(input())\n\tA = list(input())\n\tB = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif B[i] == '1':\n\t\t\tif A[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i >= 1 and A[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tA[i - 1] = '0'\n\t\t\telif i < n - 1 and A[i + 1] == '1':\n\t\t\t\tans += 1\n\t\t\t\tA[i + 1] = '0'\n\tprint(ans)\n",
        "t = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tenemey = str(input())\n\tgregor = str(input())\n\tans_arr = [0 for i in range(n)]\n\tfor i in range(n):\n\t\tif gregor[i] == '1':\n\t\t\tif enemey[i] == '0':\n\t\t\t\tans_arr[i] = 1\n\t\t\telif i == 0:\n\t\t\t\tif enemey[i + 1] == '1' and ans_arr[i + 1] != 1:\n\t\t\t\t\tans_arr[i + 1] = 1\n\t\t\telif i == n - 1:\n\t\t\t\tif enemey[i - 1] == '1' and ans_arr[i - 1] != 1:\n\t\t\t\t\tans_arr[i - 1] = 1\n\t\t\telif enemey[i - 1] == '1' and ans_arr[i - 1] != 1:\n\t\t\t\tans_arr[i - 1] = 1\n\t\t\telif enemey[i + 1] == '1' and ans_arr[i + 1] != 1:\n\t\t\t\tans_arr[i + 1] = 1\n\tprint(ans_arr.count(1))\n",
        "def main():\n\tt = int(input())\n\tanst = []\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\tv = list(map(int, input()))\n\t\tg = list(map(int, input()))\n\t\tans = 0\n\t\tfor num in range(n):\n\t\t\tflag = 0\n\t\t\tif g[num] == 1:\n\t\t\t\tif v[num] == 0:\n\t\t\t\t\tflag = 1\n\t\t\t\telif num != 0 and (not flag) and (v[num - 1] == 1):\n\t\t\t\t\tv[num - 1] = -1\n\t\t\t\t\tflag = 1\n\t\t\t\telif num != n - 1 and (not flag) and (v[num + 1] == 1):\n\t\t\t\t\tv[num + 1] = -1\n\t\t\t\t\tflag = 1\n\t\t\tans += flag\n\t\tanst.append(ans)\n\tfor _ in anst:\n\t\tprint(_)\nmain()\n",
        "import sys, os.path\nsys.setrecursionlimit(200000)\nif os.path.exists('input.txt'):\n\tsys.stdin = open('input.txt', 'r+')\n\tsys.stdout = open('output.txt', 'w')\nfrom collections import defaultdict\nfrom math import ceil\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n\tn = int(input())\n\ta = input()\n\tb = input()\n\tans = 0\n\tv = [0] * (n + 1)\n\tfor i in range(n):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans += 1\n\t\t\t\tv[i] = 1\n\t\t\telif i > 0 and a[i - 1] == '1' and (v[i - 1] == 0):\n\t\t\t\tans += 1\n\t\t\t\tv[i - 1] = 1\n\t\t\telif i < n - 1 and a[i + 1] == '1' and (v[i + 1] == 0):\n\t\t\t\tans += 1\n\t\t\t\tv[i + 1] = 1\n\tv1 = [0] * (n + 1)\n\tans1 = 0\n\tfor i in range(n - 1, -1, -1):\n\t\tif b[i] == '1':\n\t\t\tif a[i] == '0':\n\t\t\t\tans1 += 1\n\t\t\t\tv1[i] = 1\n\t\t\telif i > 0 and a[i - 1] == '1' and (v1[i - 1] == 0):\n\t\t\t\tans1 += 1\n\t\t\t\tv1[i - 1] = 1\n\t\t\telif i < n - 1 and a[i + 1] == '1' and (v1[i + 1] == 0):\n\t\t\t\tans1 += 1\n\t\t\t\tv1[i + 1] = 1\n\tprint(max(ans, ans1))\n",
        "t = int(input())\nwhile t > 0:\n\tn = int(input())\n\tenemy = input()\n\tl_enemy = [int(x) for x in enemy]\n\tplayer = input()\n\tl_player = [int(x) for x in player]\n\tboard = [l_enemy, l_player]\n\ti = 1\n\tcount = 0\n\tfor j in range(n):\n\t\tif board[i][j] == 1:\n\t\t\tif board[i - 1][j] == 0:\n\t\t\t\tcount += 1\n\t\t\t\tboard[i - 1][j] = -1\n\t\t\telse:\n\t\t\t\tif j == 0:\n\t\t\t\t\tif board[i - 1][1] == 1:\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tboard[i - 1][1] = -1\n\t\t\t\t\tcontinue\n\t\t\t\tif j == n - 1:\n\t\t\t\t\tif board[i - 1][j - 1] == 1:\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\t\tboard[i - 1][j - 1] = -1\n\t\t\t\t\tcontinue\n\t\t\t\tif board[i - 1][j - 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tboard[i - 1][j - 1] = -1\n\t\t\t\telif board[i - 1][j + 1] == 1:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tboard[i - 1][j + 1] = -1\n\tprint(count)\n\tt -= 1\n",
        "t = int(input())\ngames = [[int(input()), input(), input()] for _ in range(t)]\nanswer = []\nfor k in range(t):\n\tcount = 0\n\tvisited = [False] * games[k][0]\n\tfor i in range(games[k][0]):\n\t\tif '1' == games[k][2][i]:\n\t\t\tif '0' == games[k][1][i]:\n\t\t\t\tcount += 1\n\t\t\telif 0 <= i - 1 and '1' == games[k][1][i - 1] and (not visited[i - 1]):\n\t\t\t\tvisited[i - 1] = True\n\t\t\t\tcount += 1\n\t\t\telif i + 1 < games[k][0] and '1' == games[k][1][i + 1] and (not visited[i + 1]):\n\t\t\t\tvisited[i + 1] = True\n\t\t\t\tcount += 1\n\tanswer.append(count)\nanswer = '\\n'.join(map(str, answer))\nprint(answer)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tt = input()\n\tvis = set()\n\tans = 0\n\tif s[0] == '0' and t[0] == '1':\n\t\tans += 1\n\telif s[1] == '1' and t[0] == '1' and (1 not in vis):\n\t\tans += 1\n\t\tvis.add(1)\n\tfor i in range(1, n - 1):\n\t\tif s[i] == '0' and t[i] == '1':\n\t\t\tans += 1\n\t\telif s[i] == '1' and t[i] == '1':\n\t\t\tif s[i - 1] == '1' and t[i] == '1' and (i - 1 not in vis):\n\t\t\t\tans += 1\n\t\t\t\tvis.add(i - 1)\n\t\t\telif s[i + 1] == '1' and t[i] == '1' and (i + 1 not in vis):\n\t\t\t\tans += 1\n\t\t\t\tvis.add(i + 1)\n\tif s[n - 1] == '0' and t[n - 1] == '1':\n\t\tans += 1\n\telif s[n - 2] == '1' and t[n - 1] == '1' and (n - 2 not in vis):\n\t\tans += 1\n\t\tvis.add(n - 2)\n\tprint(ans)\n",
        "import math\n\ndef intlist():\n\treturn [int(i) for i in input().split(' ')]\n\ndef stringlist():\n\treturn input().split(' ')\n\ndef yes(t):\n\tif t:\n\t\treturn 'YES'\n\treturn 'NO'\n\ndef printjoin(l, str=False):\n\tif str:\n\t\tl = [str(i) for i in l]\n\treturn ' '.join(l)\n\ndef power_of_two(n):\n\tb = bin(n)[2:]\n\treturn int(b) == 10 ** (len(b) - 1)\n\ndef bit_count(n):\n\treturn bin(n).count('1')\n\ndef gcd(x, y):\n\twhile y:\n\t\t(x, y) = (y, x % y)\n\treturn x\n\ndef lcm(x, y):\n\tlcm = x * y // gcd(x, y)\n\treturn lcm\n\ndef isint(str):\n\ttry:\n\t\tint(str)\n\t\treturn True\n\texcept ValueError:\n\t\treturn False\n\ndef solve():\n\tn = int(input())\n\ta = list(input())\n\tb = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif b[i] != '1':\n\t\t\tcontinue\n\t\tif i != 0 and a[i - 1] == '1':\n\t\t\ta[i - 1] = '2'\n\t\t\tans += 1\n\t\telif a[i] == '0':\n\t\t\ta[i] == '2'\n\t\t\tans += 1\n\t\telif i != n - 1 and a[i + 1] == '1':\n\t\t\ta[i + 1] = '2'\n\t\t\tans += 1\n\treturn ans\nt = input()\nfor tt in range(int(t)):\n\tprint(solve())\n",
        "from __future__ import division, print_function\nimport os, sys\nimport math\nimport random\nimport collections\nfrom io import BytesIO, IOBase\nif sys.version_info[0] < 3:\n\tfrom __builtin__ import xrange as range\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\n\nclass my_dictionary(dict):\n\n\tdef __init__(self):\n\t\tself = dict()\n\n\tdef add(self, key, value):\n\t\tself[key] = value\n\ndef ii():\n\treturn int(input())\n\ndef si():\n\treturn input()\n\ndef mi():\n\treturn map(int, input().strip().split(' '))\n\ndef msi():\n\treturn map(str, input().strip().split(' '))\n\ndef li():\n\treturn list(mi())\n\ndef sli():\n\treturn list(msi())\n\ndef dmain():\n\tsys.setrecursionlimit(100000000)\n\tthreading.stack_size(40960000)\n\tthread = threading.Thread(target=main)\n\tthread.start()\nabc = 'abcdefghijklmnopqrstuvwxyz'\nabd = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod = 1000000007\ninf = float('inf')\nvow = ['a', 'e', 'i', 'o', 'u']\n(dx, dy) = ([-1, 1, 0, 0], [0, 0, 1, -1])\n\ndef getKey(item):\n\treturn item[1]\n\ndef sort2(l):\n\treturn sorted(l, key=getKey, reverse=True)\n\ndef d2(n, m, num):\n\treturn [[num for x in range(m)] for y in range(n)]\n\ndef isPowerOfTwo(x):\n\treturn x and (not x & x - 1)\n\ndef decimalToBinary(n):\n\treturn bin(n).replace('0b', '')\n\ndef ntl(n):\n\treturn [int(i) for i in str(n)]\n\ndef factorial(n):\n\treturn 1 if n == 1 or n == 0 else n * factorial(n - 1)\n\ndef ncr(n, r):\n\treturn factorial(n) // (factorial(r) * factorial(n - r))\n\ndef binary_search(arr, low, high, r, l, c):\n\tif high >= low:\n\t\tmid = (high + low) // 2\n\t\tif arr[mid] <= r or arr[mid] >= l:\n\t\t\tc += 1\n\t\telif arr[mid] > r:\n\t\t\treturn binary_search(arr, low, mid - 1, r, l, c)\n\t\telse:\n\t\t\treturn binary_search(arr, mid + 1, high, r, l, c)\n\telse:\n\t\treturn c\n\ndef ceil(x, y):\n\tif x % y == 0:\n\t\treturn x // y\n\telse:\n\t\treturn x // y + 1\n\ndef powerMod(x, y, p):\n\tres = 1\n\tx %= p\n\twhile y > 0:\n\t\tif y & 1:\n\t\t\tres = res * x % p\n\t\ty = y >> 1\n\t\tx = x * x % p\n\treturn res\n\ndef gcd(x, y):\n\twhile y:\n\t\t(x, y) = (y, x % y)\n\treturn x\n\ndef nCr(n, r):\n\treturn fact(n) / (fact(r) * fact(n - r))\n\ndef fact(n):\n\tres = 1\n\tfor i in range(2, n + 1):\n\t\tres = res * i\n\treturn res\n\ndef printDivisors(n):\n\ti = 1\n\tcount = 0\n\twhile i <= math.sqrt(n):\n\t\tif n % i == 0:\n\t\t\tif n / i == i:\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tcount += 1\n\t\ti = i + 1\n\treturn count\n\ndef isPrime(n):\n\tif n <= 1:\n\t\treturn False\n\tif n <= 3:\n\t\treturn True\n\tif n % 2 == 0 or n % 3 == 0:\n\t\treturn False\n\ti = 5\n\twhile i * i <= n:\n\t\tif n % i == 0 or n % (i + 2) == 0:\n\t\t\treturn False\n\t\ti = i + 6\n\treturn True\n\ndef read():\n\tsys.stdin = open('tessst.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef padded_bin_with_complement(x):\n\tif x < 0:\n\t\treturn bin(2 ** 16 - abs(x))[2:].zfill(16)\n\telse:\n\t\treturn bin(x)[2:].zfill(16)\n\ndef binaryToDecimal(binary):\n\tbinary1 = binary\n\t(decimal, i, n) = (0, 0, 0)\n\twhile binary != 0:\n\t\tdec = binary % 10\n\t\tdecimal = decimal + dec * pow(2, i)\n\t\tbinary = binary // 10\n\t\ti += 1\n\treturn decimal\n\ndef CountFrequency(my_list):\n\tfreq = {}\n\tfor item in my_list:\n\t\tif item in freq:\n\t\t\tfreq[item] += 1\n\t\telse:\n\t\t\tfreq[item] = 1\n\treturn freq\n\ndef pos(a):\n\tb = [0] * len(a)\n\tc = sorted(a)\n\tfor i in range(len(a)):\n\t\tfor j in range(len(a)):\n\t\t\tif c[j] == a[i]:\n\t\t\t\tb[i] = j\n\t\t\t\tbreak\n\treturn b\n\ndef smallestDivisor(n):\n\tif n % 2 == 0:\n\t\treturn 2\n\ti = 3\n\twhile i * i <= n:\n\t\tif n % i == 0:\n\t\t\treturn i\n\t\ti += 2\n\treturn n\n\ndef commonn(a, b, n):\n\tc = []\n\tfor i in range(n):\n\t\tif a[i] == b[i]:\n\t\t\tc.append('-1')\n\t\telse:\n\t\t\tc.append(b[i])\n\treturn c\n\ndef find_lcm(num1, num2):\n\tif num1 > num2:\n\t\tnum = num1\n\t\tden = num2\n\telse:\n\t\tnum = num2\n\t\tden = num1\n\trem = num % den\n\twhile rem != 0:\n\t\tnum = den\n\t\tden = rem\n\t\trem = num % den\n\tgcd = den\n\tlcm = int(int(num1 * num2) / int(gcd))\n\treturn lcm\n\ndef sumdigit(n):\n\tn = str(n)\n\tk = 0\n\tfor i in range(len(n)):\n\t\tk += int(n[i])\n\treturn k\n\ndef sort_list(list1, list2):\n\tzipped_pairs = zip(list2, list1)\n\tz = [x for (_, x) in sorted(zipped_pairs)]\n\treturn z\nfrom itertools import permutations\n\ndef isPerfectSquare(x):\n\tif x >= 0:\n\t\tsr = math.sqrt(x)\n\t\treturn sr * sr == x\n\treturn False\n\ndef knapSack(W, wt, val, n):\n\tK = [[0 for x in range(W + 1)] for x in range(n + 1)]\n\tfor i in range(n + 1):\n\t\tfor w in range(W + 1):\n\t\t\tif i == 0 or w == 0:\n\t\t\t\tK[i][w] = 0\n\t\t\telif wt[i - 1] <= w:\n\t\t\t\tK[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])\n\t\t\telse:\n\t\t\t\tK[i][w] = K[i - 1][w]\n\treturn K[n][W]\nfrom collections import Counter\n\nclass Node:\n\n\tdef __init__(self, val):\n\t\tself.next = None\n\t\tself.data = val\n\nclass linkedList:\n\n\tdef __init__(self):\n\t\tself.head = None\n\t\tself.tail = None\n\n\tdef add(self, num):\n\t\tif self.head is None:\n\t\t\tself.head = Node(num)\n\t\t\tself.tail = self.head\n\t\telse:\n\t\t\tself.tail.next = Node(num)\n\t\t\tself.tail = self.tail.next\n\n\tdef isLoop(self):\n\t\tif self.head is None:\n\t\t\treturn False\n\t\tslow = self.head\n\t\tfast = self.head.next\n\t\tslow = slow.next\n\t\tfast = fast.next.next\n\t\twhile slow != fast:\n\t\t\tif fast is None or fast.next == None:\n\t\t\t\treturn False\n\t\t\tfast = fast.next.next\n\t\t\tslow = slow.next\n\t\treturn True\n\n\tdef loopHere(self, pos):\n\t\tif pos == 0:\n\t\t\treturn\n\t\twalk = self.head\n\t\tfor _ in range(1, pos):\n\t\t\twalk = walk.next\n\t\tself.tail.next = walk\n\n\tdef length(self):\n\t\twalk = self.head\n\t\tc = 0\n\t\twhile walk:\n\t\t\tc += 1\n\t\t\twalk = walk.next\n\t\treturn c\nfrom heapq import heappop, heappush, heapify\n\ndef sort_k(arr, n, k):\n\theap = arr[:k + 1]\n\theapify(heap)\n\ttarget_index = 0\n\tfor rem_elmnts_index in range(k + 1, n):\n\t\tarr[target_index] = heappop(heap)\n\t\theappush(heap, arr[rem_elmnts_index])\n\t\ttarget_index += 1\n\twhile heap:\n\t\tarr[target_index] = heappop(heap)\n\t\ttarget_index += 1\nimport string\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tn = ii()\n\t\tb = si()\n\t\ta = si()\n\t\tvisited = {}\n\t\tcount = 0\n\t\tfor i in range(n):\n\t\t\tif a[i] == '0':\n\t\t\t\tcontinue\n\t\t\tif i == 0:\n\t\t\t\tif b[i] == '0':\n\t\t\t\t\tcount += 1\n\t\t\t\telif b[i + 1] == '1':\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i + 1] = 1\n\t\t\telif i == n - 1:\n\t\t\t\tif b[i] == '0':\n\t\t\t\t\tcount += 1\n\t\t\t\telif b[i - 1] == '1' and i - 1 not in visited:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i - 1] = 1\n\t\t\telif a[i] == '1' and b[i] == '0':\n\t\t\t\tcount += 1\n\t\t\telif a[i] == '1' and (b[i - 1] == '1' or b[i + 1] == '1'):\n\t\t\t\tif b[i - 1] == '1' and i - 1 not in visited:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i - 1] = 1\n\t\t\t\telif b[i + 1] == '1' and i + 1 not in visited:\n\t\t\t\t\tcount += 1\n\t\t\t\t\tvisited[i + 1] = 1\n\t\tprint(count)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop('end', '\\n'))\n\tif kwargs.pop('flush', False):\n\t\tfile.flush()\nif sys.version_info[0] < 3:\n\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\nelse:\n\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ta = str(input())\n\tb = str(input())\n\tdem = 0\n\tcnt = [0] * (n + 1)\n\tfor i in range(0, len(a)):\n\t\tif b[i] == '1':\n\t\t\tif i == 0:\n\t\t\t\tif a[i] == '0':\n\t\t\t\t\tdem += 1\n\t\t\t\telif a[i + 1] == '1' and cnt[i + 1] == 0:\n\t\t\t\t\tcnt[i + 1] = 1\n\t\t\t\t\tdem += 1\n\t\t\telif i == n - 1:\n\t\t\t\tif a[i] == '0':\n\t\t\t\t\tdem += 1\n\t\t\t\telif a[i - 1] == '1' and cnt[i - 1] == 0:\n\t\t\t\t\tcnt[i - 1] = 1\n\t\t\t\t\tdem += 1\n\t\t\telif a[i] == '0':\n\t\t\t\tdem += 1\n\t\t\telif a[i - 1] == '1' and cnt[i - 1] == 0:\n\t\t\t\tcnt[i - 1] = 1\n\t\t\t\tdem += 1\n\t\t\telif a[i + 1] == '1' and cnt[i + 1] == 0:\n\t\t\t\tcnt[i + 1] = 1\n\t\t\t\tdem += 1\n\tprint(dem)\n",
        "t = int(input())\nwhile t != 0:\n\tn = int(input())\n\ts1 = list(input())\n\ts2 = list(input())\n\tc = 0\n\tif s2[0] == '1':\n\t\tif s1[0] == '0':\n\t\t\tc = c + 1\n\t\telif s1[1] == '1':\n\t\t\tc = c + 1\n\t\t\ts1[1] = '0'\n\tfor i in range(1, n - 1):\n\t\tif s2[i] == '1':\n\t\t\tif s1[i] == '0':\n\t\t\t\tc = c + 1\n\t\t\telif s1[i - 1] == '1':\n\t\t\t\ts1[i - 1] = '0'\n\t\t\t\tc = c + 1\n\t\t\telif s1[i + 1] == '1':\n\t\t\t\tc = c + 1\n\t\t\t\ts1[i + 1] = '0'\n\tif s2[n - 1] == '1':\n\t\tif s1[n - 1] == '0':\n\t\t\tc = c + 1\n\t\telif s1[n - 2] == '1':\n\t\t\tc = c + 1\n\t\t\ts1[n - 2] = '0'\n\tprint(c)\n\tt = t - 1\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tv = input()\n\ts = input()\n\ts = '0' + s + '0'\n\tv = '0' + v + '0'\n\ten = ['0'] * len(v)\n\tfor i in range(len(v)):\n\t\ten[i] = v[i]\n\tans = 0\n\tfor i in range(1, n + 2):\n\t\tif s[i] == '1':\n\t\t\tif en[i - 1] == '1':\n\t\t\t\tans += 1\n\t\t\telif en[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif en[i + 1] == '1':\n\t\t\t\ten[i + 1] = '2'\n\t\t\t\tans += 1\n\tprint(ans)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ta = input()\n\tb = input()\n\tar1 = []\n\tar2 = []\n\tc = 0\n\tfor i in range(n):\n\t\tar1.append(int(a[i]))\n\t\tar2.append(int(b[i]))\n\tfor i in range(n):\n\t\tif i == 0:\n\t\t\tif ar2[i] == 1:\n\t\t\t\tif ar1[i] == 0:\n\t\t\t\t\tar1[i] = None\n\t\t\t\t\tc += 1\n\t\t\t\telif ar1[i + 1] == 1:\n\t\t\t\t\tar1[i + 1] = None\n\t\t\t\t\tc += 1\n\t\telif i == n - 1:\n\t\t\tif ar2[i] == 1:\n\t\t\t\tif ar1[i] == 0:\n\t\t\t\t\tar1[i] = None\n\t\t\t\t\tc += 1\n\t\t\t\telif ar1[i - 1] == 1:\n\t\t\t\t\tar1[i - 1] = None\n\t\t\t\t\tc += 1\n\t\telif ar2[i] == 1:\n\t\t\tif ar1[i] == 0:\n\t\t\t\tar1[i] = None\n\t\t\t\tc += 1\n\t\t\telif ar1[i - 1] == 1:\n\t\t\t\tar1[i - 1] = None\n\t\t\t\tc += 1\n\t\t\telif ar1[i + 1] == 1:\n\t\t\t\tar1[i + 1] = None\n\t\t\t\tc += 1\n\tprint(c)\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\ten = input()\n\tgr = input()\n\tl1 = [-1]\n\tl2 = [-1]\n\tfor i in range(n):\n\t\tl1.append(int(en[i]))\n\t\tl2.append(int(gr[i]))\n\tcount = 0\n\tl1.append(-1)\n\tl2.append(-1)\n\tfor i in range(1, n + 1):\n\t\tif l2[i] == 1:\n\t\t\tif l1[i] == 0:\n\t\t\t\tcount += 1\n\t\t\t\tl1[i] = -1\n\t\t\telif l1[i - 1] == 1:\n\t\t\t\tcount += 1\n\t\t\t\tl1[i - 1] == -1\n\t\t\telif l1[i + 1] == 1:\n\t\t\t\tcount += 1\n\t\t\t\tl1[i + 1] = -1\n\tprint(count)\n",
        "import sys\ninput = sys.stdin.readline\n\ndef main():\n\tt = int(input())\n\tfor _ in range(t):\n\t\tn = int(input())\n\t\tep = list(map(int, input().strip()))\n\t\typ = list(map(int, input().strip()))\n\t\tans = 0\n\t\tfor i in range(n):\n\t\t\tif yp[i] == 1:\n\t\t\t\tif ep[i] == 0:\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\t\t\t\tif i >= 1 and ep[i - 1] == 1:\n\t\t\t\t\tep[i - 1] = 0\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\t\t\t\telif i < n - 1 and ep[i + 1] == 1:\n\t\t\t\t\tep[i + 1] = 0\n\t\t\t\t\tans += 1\n\t\t\t\t\tcontinue\n\t\tprint(ans)\nmain()\n",
        "def solution(enemy, my):\n\tres = 0\n\tfor i in range(len(my)):\n\t\tif my[i] == '1':\n\t\t\tif enemy[i] == '0':\n\t\t\t\tres += 1\n\t\t\t\tenemy[i] = '2'\n\t\t\telif i > 0 and enemy[i - 1] == '1':\n\t\t\t\tres += 1\n\t\t\t\tenemy[i - 1] = '2'\n\t\t\telif i + 1 < len(my) and enemy[i + 1] == '1':\n\t\t\t\tenemy[i + 1] = '2'\n\t\t\t\tres += 1\n\treturn res\nn = int(input())\nfor _ in range(n):\n\tnum = int(input())\n\tenemy = list(input())\n\tmy = list(input())\n\tprint(solution(enemy, my))\n",
        "for _ in range(int(input())):\n\tn = int(input())\n\tblack = list(input())\n\twhite = list(input())\n\tans = 0\n\tfor i in range(n):\n\t\tif white[i] == '1' and black[i] == '0':\n\t\t\tans += 1\n\t\t\twhite[i] = '0'\n\tw = True\n\twhile w:\n\t\tl = 0\n\t\tfor i in range(n):\n\t\t\tif white[i] == '1':\n\t\t\t\tif i + 1 < n and i - 1 >= 0:\n\t\t\t\t\tif black[i + 1] == '1' and black[i - 1] == '1':\n\t\t\t\t\t\tcontinue\n\t\t\t\t\telse:\n\t\t\t\t\t\twhite[i] = '0'\n\t\t\t\t\t\tif black[i + 1] == '1':\n\t\t\t\t\t\t\tblack[i + 1] = '0'\n\t\t\t\t\t\t\tl = 1\n\t\t\t\t\t\t\tans += 1\n\t\t\t\t\t\telif black[i - 1] == '1':\n\t\t\t\t\t\t\tblack[i - 1] = '0'\n\t\t\t\t\t\t\tl = 1\n\t\t\t\t\t\t\tans += 1\n\t\t\t\telse:\n\t\t\t\t\tif i + 1 < n and black[i + 1] == '1':\n\t\t\t\t\t\twhite[i] = '0'\n\t\t\t\t\t\tblack[i + 1] = '0'\n\t\t\t\t\t\tl = 1\n\t\t\t\t\t\tans += 1\n\t\t\t\t\tif i - 1 >= 0 and black[i - 1] == '1':\n\t\t\t\t\t\twhite[i] = '0'\n\t\t\t\t\t\tblack[i - 1] = '0'\n\t\t\t\t\t\tl = 1\n\t\t\t\t\t\tans += 1\n\t\tif l == 0:\n\t\t\tw = False\n\t\t\tfor i in range(n):\n\t\t\t\tif white[i] == '1':\n\t\t\t\t\tif i + 1 < n and black[i + 1] == '1' or (i - 1 >= 0 and black[i - 1] == '1'):\n\t\t\t\t\t\tans += 1\n\tprint(ans)\n",
        "from collections import *\nfrom math import *\nTT = int(input())\nfor y in range(TT):\n\tn = int(input())\n\ts1 = input()\n\ts2 = input()\n\tvis = [0] * n\n\tans = 0\n\tfor i in range(n):\n\t\tif s2[i] == '1':\n\t\t\tif s1[i] == '0':\n\t\t\t\tans += 1\n\t\t\telif i - 1 >= 0 and s1[i - 1] == '1' and (vis[i - 1] == 0):\n\t\t\t\tans += 1\n\t\t\t\tvis[i - 1] = 1\n\t\t\telif i + 1 < n and s1[i + 1] == '1' and (vis[i + 1] == 0):\n\t\t\t\tans += 1\n\t\t\t\tvis[i + 1] = 1\n\tprint(ans)\n",
        "from sys import *\ninput = stdin.readline\nfrom bisect import *\nimport math\nfrom collections import *\nimport operator\nfrom heapq import *\nfrom itertools import *\ninf = 10 ** 18\nmod = 10 ** 9 + 7\nfor _ in range(int(input())):\n\tn = int(input())\n\tmat = []\n\tfor _ in range(2):\n\t\trow = list(input())[:-1]\n\t\tmat.append(row)\n\tche = [0] * n\n\tvis = [0] * n\n\tcnt = 0\n\tfor i in range(n):\n\t\tif mat[1][i] == '1':\n\t\t\tif i > 0 and mat[0][i - 1] == '1' and (che[i - 1] == 0):\n\t\t\t\tvis[i] = 1\n\t\t\t\tche[i - 1] = 1\n\t\t\t\tcnt += 1\n\t\t\telif mat[0][i] == '0' and che[i] == 0:\n\t\t\t\tche[i] = 1\n\t\t\t\tvis[i] = 1\n\t\t\t\tcnt += 1\n\t\t\telif i < n - 1 and mat[0][i + 1] == '1' and (che[i + 1] == 0):\n\t\t\t\tvis[i] = 1\n\t\t\t\tche[i + 1] = 1\n\t\t\t\tcnt += 1\n\tprint(cnt)\n",
        "num = int(input())\nfor i in range(num):\n\tn = int(input())\n\tvrag = list(input())\n\tgregor = list(input())\n\tkol = 0\n\tfor i in range(n):\n\t\tif gregor[i] == '1':\n\t\t\tif vrag[i] == '0':\n\t\t\t\tkol += 1\n\t\t\telif i >= 1:\n\t\t\t\tif vrag[i - 1] == '1':\n\t\t\t\t\tkol += 1\n\t\t\t\t\tvrag[i - 1] = 0\n\t\t\t\telif i + 1 <= n - 1:\n\t\t\t\t\tif vrag[i + 1] == '1':\n\t\t\t\t\t\tkol += 1\n\t\t\t\t\t\tvrag[i + 1] = 0\n\t\t\telif vrag[i + 1] == '1':\n\t\t\t\tkol += 1\n\t\t\t\tvrag[i + 1] = 0\n\tprint(kol)\n"
      ],
      "original_code": null
    },
    "status": "success",
    "code": "def solve():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    pos = 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[pos])\n        pos += 1\n        enemy = list(data[pos])\n        pos += 1\n        gregor = list(data[pos])\n        pos += 1\n\n        # We'll mark enemy cells that have been occupied or used via capture.\n        used = [False] * n\n        count = 0\n\n        # For each pawn belonging to Gregor (given as '1' in the third line),\n        # try to find a cell in the enemy row (first row) where it can end up.\n        # There are two possibilities:\n        #    1. Move straight upward if the cell is empty ('0').\n        #    2. Capture an enemy pawn diagonally if the cell has an enemy pawn ('1').\n        #\n        # IMPORTANT:\n        # - A pawn cannot move straight upward on a cell with an enemy pawn.\n        # - However, if an enemy pawn is available in a cell adjacent (left or right)\n        #   to the pawn's current column (when moving diagonally), the pawn may capture that enemy.\n        # - Each enemy cell (or empty cell that the pawn lands in) can only be used once.\n        #\n        # The greedy matching approach: If a Gregor pawn is at column i,\n        # (a) first check if it can capture an enemy pawn from the left neighbor (i-1) if available,\n        # (b) otherwise, try a straight move if cell i is empty,\n        # (c) otherwise, try capturing an enemy pawn from the right neighbor (i+1).\n        \n        for i in range(n):\n            if gregor[i] == '1':\n                # Option 1: Try left neighbor: can capture an enemy pawn diagonally from left if available.\n                if i > 0 and enemy[i - 1] == '1' and not used[i - 1]:\n                    count += 1\n                    used[i - 1] = True\n                # Option 2: Move vertically if the cell in the same column is empty.\n                elif enemy[i] == '0' and not used[i]:\n                    count += 1\n                    used[i] = True\n                # Option 3: Try right neighbor: can capture an enemy pawn diagonally from right if available.\n                elif i < n - 1 and enemy[i + 1] == '1' and not used[i + 1]:\n                    count += 1\n                    used[i + 1] = True\n\n        results.append(str(count))\n\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == '__main__':\n    solve()",
    "pass_ratio": 1.0,
    "tests_passed": 288,
    "tests_total": 288,
    "iterations": 1,
    "history": [
      {
        "iteration": 1,
        "code": "def solve():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    pos = 1\n    results = []\n\n    for _ in range(t):\n        n = int(data[pos])\n        pos += 1\n        enemy = list(data[pos])\n        pos += 1\n        gregor = list(data[pos])\n        pos += 1\n\n        # We'll mark enemy cells that have been occupied or used via capture.\n        used = [False] * n\n        count = 0\n\n        # For each pawn belonging to Gregor (given as '1' in the third line),\n        # try to find a cell in the enemy row (first row) where it can end up.\n        # There are two possibilities:\n        #    1. Move straight upward if the cell is empty ('0').\n        #    2. Capture an enemy pawn diagonally if the cell has an enemy pawn ('1').\n        #\n        # IMPORTANT:\n        # - A pawn cannot move straight upward on a cell with an enemy pawn.\n        # - However, if an enemy pawn is available in a cell adjacent (left or right)\n        #   to the pawn's current column (when moving diagonally), the pawn may capture that enemy.\n        # - Each enemy cell (or empty cell that the pawn lands in) can only be used once.\n        #\n        # The greedy matching approach: If a Gregor pawn is at column i,\n        # (a) first check if it can capture an enemy pawn from the left neighbor (i-1) if available,\n        # (b) otherwise, try a straight move if cell i is empty,\n        # (c) otherwise, try capturing an enemy pawn from the right neighbor (i+1).\n        \n        for i in range(n):\n            if gregor[i] == '1':\n                # Option 1: Try left neighbor: can capture an enemy pawn diagonally from left if available.\n                if i > 0 and enemy[i - 1] == '1' and not used[i - 1]:\n                    count += 1\n                    used[i - 1] = True\n                # Option 2: Move vertically if the cell in the same column is empty.\n                elif enemy[i] == '0' and not used[i]:\n                    count += 1\n                    used[i] = True\n                # Option 3: Try right neighbor: can capture an enemy pawn diagonally from right if available.\n                elif i < n - 1 and enemy[i + 1] == '1' and not used[i + 1]:\n                    count += 1\n                    used[i + 1] = True\n\n        results.append(str(count))\n\n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == '__main__':\n    solve()",
        "pass_ratio": 1.0,
        "tests_passed": 288,
        "tests_total": 288
      }
    ],
    "model_type": "openai",
    "model_name": "o3_mini"
  },
  {
    "problem": {
      "problem_id": 2,
      "question": "The king is left alone on the chessboard. In spite of this loneliness, he doesn't lose heart, because he has business of national importance. For example, he has to pay an official visit to square t. As the king is not in habit of wasting his time, he wants to get from his current position s to square t in the least number of moves. Help him to do this.\n\n<image>\n\nIn one move the king can get to the square that has a common side or a common vertex with the square the king is currently in (generally there are 8 different squares he can move to).\n\nInput\n\nThe first line contains the chessboard coordinates of square s, the second line \u2014 of square t.\n\nChessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.\n\nOutput\n\nIn the first line print n \u2014 minimum number of the king's moves. Then in n lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD. \n\nL, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them. \n\nExamples\n\nInput\n\na8\nh1\n\n\nOutput\n\n7\nRD\nRD\nRD\nRD\nRD\nRD\nRD",
      "tests": [
        {
          "stdin": "e3\ne3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "h1\nh1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "b2\nb2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "a8\na8\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g8\na8\n",
          "stdout": "6\nL\nL\nL\nL\nL\nL\n"
        },
        {
          "stdin": "h1\nb2\n",
          "stdout": "6\nLU\nL\nL\nL\nL\nL\n"
        },
        {
          "stdin": "d4\nh2\n",
          "stdout": "4\nRD\nRD\nR\nR\n"
        },
        {
          "stdin": "g6\nf2\n",
          "stdout": "4\nLD\nD\nD\nD\n"
        },
        {
          "stdin": "e6\nb6\n",
          "stdout": "3\nL\nL\nL\n"
        },
        {
          "stdin": "f8\nf8\n",
          "stdout": "0\n\n"
        },
        {
          "stdin": "h4\nd1\n",
          "stdout": "4\nLD\nLD\nLD\nL\n"
        },
        {
          "stdin": "e7\nb1\n",
          "stdout": "6\nLD\nLD\nLD\nD\nD\nD\n"
        },
        {
          "stdin": "g2\na6\n",
          "stdout": "6\nLU\nLU\nLU\nLU\nL\nL\n"
        },
        {
          "stdin": "d2\nf1\n",
          "stdout": "2\nRD\nR\n"
        },
        {
          "stdin": "d1\nb7\n",
          "stdout": "6\nLU\nLU\nU\nU\nU\nU\n"
        },
        {
          "stdin": "a7\ne5\n",
          "stdout": "4\nRD\nRD\nR\nR\n"
        },
        {
          "stdin": "c5\na2\n",
          "stdout": "3\nLD\nLD\nD\n"
        },
        {
          "stdin": "f5\nd2\n",
          "stdout": "3\nLD\nLD\nD\n"
        },
        {
          "stdin": "h8\nf1\n",
          "stdout": "7\nLD\nLD\nD\nD\nD\nD\nD\n"
        },
        {
          "stdin": "b3\na5\n",
          "stdout": "2\nLU\nU\n"
        },
        {
          "stdin": "f1\nc5\n",
          "stdout": "4\nLU\nLU\nLU\nU\n"
        },
        {
          "stdin": "a6\ng4\n",
          "stdout": "6\nRD\nRD\nR\nR\nR\nR\n"
        },
        {
          "stdin": "e1\nf2\n",
          "stdout": "1\nRU\n"
        },
        {
          "stdin": "a5\na5\n",
          "stdout": "0\n\n"
        },
        {
          "stdin": "a8\nb2\n",
          "stdout": "6\nRD\nD\nD\nD\nD\nD\n"
        },
        {
          "stdin": "f5\ng5\n",
          "stdout": "1\nR\n"
        },
        {
          "stdin": "f7\nc2\n",
          "stdout": "5\nLD\nLD\nLD\nD\nD\n"
        },
        {
          "stdin": "c5\nh2\n",
          "stdout": "5\nRD\nRD\nRD\nR\nR\n"
        },
        {
          "stdin": "b7\nh8\n",
          "stdout": "6\nRU\nR\nR\nR\nR\nR\n"
        },
        {
          "stdin": "g4\nc4\n",
          "stdout": "4\nL\nL\nL\nL\n"
        },
        {
          "stdin": "g4\nd2\n",
          "stdout": "3\nLD\nLD\nL\n"
        },
        {
          "stdin": "h5\nf8\n",
          "stdout": "3\nLU\nLU\nU\n"
        },
        {
          "stdin": "g7\nd6\n",
          "stdout": "3\nLD\nL\nL\n"
        },
        {
          "stdin": "c8\na3\n",
          "stdout": "5\nLD\nLD\nD\nD\nD\n"
        },
        {
          "stdin": "b2\nb4\n",
          "stdout": "2\nU\nU\n"
        },
        {
          "stdin": "d6\nb1\n",
          "stdout": "5\nLD\nLD\nD\nD\nD\n"
        },
        {
          "stdin": "c7\ne5\n",
          "stdout": "2\nRD\nRD\n"
        },
        {
          "stdin": "e3\ne3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "f5\nf5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "a1\na1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "f6\nf6\n",
          "stdout": "0\n"
        },
        {
          "stdin": "e1\ne1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "d4\nd4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "c4\nc4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g8\ng8\n",
          "stdout": "0\n"
        },
        {
          "stdin": "c1\nc1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "d5\nd5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "d2\nd2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "c3\nc3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g5\ng5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "e5\ne5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "h8\nh8\n",
          "stdout": "0\n"
        },
        {
          "stdin": "e4\ne4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "d3\nd3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "e8\ne8\n",
          "stdout": "0\n"
        },
        {
          "stdin": "f2\nf2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g1\ng1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "d1\nd1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "f8\na8\n",
          "stdout": "5\nL\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "d3\nh2\n",
          "stdout": "4\nRD\n\nR\nR\nR\n\n"
        },
        {
          "stdin": "f6\nb6\n",
          "stdout": "4\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "f7\nb1\n",
          "stdout": "6\nLD\nLD\nLD\nLD\n\nD\nD\n\n"
        },
        {
          "stdin": "d1\nb8\n",
          "stdout": "7\nLU\nLU\n\nU\nU\nU\nU\nU\n\n"
        },
        {
          "stdin": "c4\na2\n",
          "stdout": "2\nLD\nLD\n\n"
        },
        {
          "stdin": "b2\na5\n",
          "stdout": "3\nLU\n\nU\nU\n\n"
        },
        {
          "stdin": "a6\ng5\n",
          "stdout": "6\nRD\n\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "e1\ne2\n",
          "stdout": "1\nU\n\n"
        },
        {
          "stdin": "f5\ng6\n",
          "stdout": "1\nRU\n\n"
        },
        {
          "stdin": "f8\nc2\n",
          "stdout": "6\nLD\nLD\nLD\n\nD\nD\nD\n\n"
        },
        {
          "stdin": "b8\nh8\n",
          "stdout": "6\nR\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "g4\nd1\n",
          "stdout": "3\nLD\nLD\nLD\n\n"
        },
        {
          "stdin": "c8\na4\n",
          "stdout": "4\nLD\nLD\n\nD\nD\n\n"
        },
        {
          "stdin": "d3\ng2\n",
          "stdout": "3\nRD\n\nR\nR\n\n"
        },
        {
          "stdin": "a6\nh5\n",
          "stdout": "7\nRD\n\nR\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "e5\ng6\n",
          "stdout": "2\nRU\n\nR\n\n"
        },
        {
          "stdin": "e5\ng7\n",
          "stdout": "2\nRU\nRU\n\n"
        },
        {
          "stdin": "g7\na8\n",
          "stdout": "6\nLU\n\nL\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "h1\nc2\n",
          "stdout": "5\nLU\n\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "h4\nd2\n",
          "stdout": "4\nLD\nLD\n\nL\nL\n\n"
        },
        {
          "stdin": "d2\ne1\n",
          "stdout": "1\nRD\n\n"
        },
        {
          "stdin": "d1\nb6\n",
          "stdout": "5\nLU\nLU\n\nU\nU\nU\n\n"
        },
        {
          "stdin": "h8\ne1\n",
          "stdout": "7\nLD\nLD\nLD\n\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "b8\nb2\n",
          "stdout": "6\nD\nD\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "g7\nc2\n",
          "stdout": "5\nLD\nLD\nLD\nLD\n\nD\n\n"
        },
        {
          "stdin": "b7\ng8\n",
          "stdout": "5\nRU\n\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "g4\nd4\n",
          "stdout": "3\nL\nL\nL\n\n"
        },
        {
          "stdin": "c6\ne5\n",
          "stdout": "2\nRD\n\nR\n\n"
        },
        {
          "stdin": "f4\ng6\n",
          "stdout": "2\nRU\n\nU\n\n"
        },
        {
          "stdin": "e8\nc2\n",
          "stdout": "6\nLD\nLD\n\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "a7\ng4\n",
          "stdout": "6\nRD\nRD\nRD\n\nR\nR\nR\n\n"
        },
        {
          "stdin": "b8\na2\n",
          "stdout": "6\nLD\n\nD\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "f5\nf4\n",
          "stdout": "1\nD\n\n"
        },
        {
          "stdin": "c6\ne6\n",
          "stdout": "2\nR\nR\n\n"
        },
        {
          "stdin": "g6\nb5\n",
          "stdout": "5\nLD\n\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "a5\nh5\n",
          "stdout": "7\nR\nR\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "e4\ng7\n",
          "stdout": "3\nRU\nRU\n\nU\n\n"
        },
        {
          "stdin": "h1\nb3\n",
          "stdout": "6\nLU\nLU\n\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "g6\ng2\n",
          "stdout": "4\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "g2\nb6\n",
          "stdout": "5\nLU\nLU\nLU\nLU\n\nL\n\n"
        },
        {
          "stdin": "e5\nd2\n",
          "stdout": "3\nLD\n\nD\nD\n\n"
        },
        {
          "stdin": "b3\nb5\n",
          "stdout": "2\nU\nU\n\n"
        },
        {
          "stdin": "e1\nf1\n",
          "stdout": "1\nR\n\n"
        },
        {
          "stdin": "b7\nb2\n",
          "stdout": "5\nD\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "c5\nh3\n",
          "stdout": "5\nRD\nRD\n\nR\nR\nR\n\n"
        },
        {
          "stdin": "f7\nd6\n",
          "stdout": "2\nLD\n\nL\n\n"
        },
        {
          "stdin": "d3\nh3\n",
          "stdout": "4\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "c8\nh8\n",
          "stdout": "5\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "d8\na4\n",
          "stdout": "4\nLD\nLD\nLD\n\nD\n\n"
        },
        {
          "stdin": "d3\ng3\n",
          "stdout": "3\nR\nR\nR\n\n"
        },
        {
          "stdin": "d2\nb6\n",
          "stdout": "4\nLU\nLU\n\nU\nU\n\n"
        },
        {
          "stdin": "a5\ng3\n",
          "stdout": "6\nRD\nRD\n\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "g4\ne4\n",
          "stdout": "2\nL\nL\n\n"
        },
        {
          "stdin": "g5\nf4\n",
          "stdout": "1\nLD\n\n"
        },
        {
          "stdin": "a5\nh6\n",
          "stdout": "7\nRU\n\nR\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "d4\ng7\n",
          "stdout": "3\nRU\nRU\nRU\n\n"
        },
        {
          "stdin": "h1\na2\n",
          "stdout": "7\nLU\n\nL\nL\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "g2\nb5\n",
          "stdout": "5\nLU\nLU\nLU\n\nL\nL\n\n"
        },
        {
          "stdin": "f7\nc1\n",
          "stdout": "6\nLD\nLD\nLD\n\nD\nD\nD\n\n"
        },
        {
          "stdin": "e6\na6\n",
          "stdout": "4\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "f5\nc2\n",
          "stdout": "3\nLD\nLD\nLD\n\n"
        },
        {
          "stdin": "a5\ng4\n",
          "stdout": "6\nRD\n\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "f5\ng4\n",
          "stdout": "1\nRD\n\n"
        },
        {
          "stdin": "e3\nh2\n",
          "stdout": "3\nRD\n\nR\nR\n\n"
        },
        {
          "stdin": "g6\nb6\n",
          "stdout": "5\nL\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "e7\nc1\n",
          "stdout": "6\nLD\nLD\n\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "a5\ng5\n",
          "stdout": "6\nR\nR\nR\nR\nR\nR\n\n"
        },
        {
          "stdin": "f4\ng5\n",
          "stdout": "1\nRU\n\n"
        },
        {
          "stdin": "h1\nc1\n",
          "stdout": "5\nL\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "h7\ne1\n",
          "stdout": "6\nLD\nLD\nLD\n\nD\nD\nD\n\n"
        },
        {
          "stdin": "e4\ng6\n",
          "stdout": "2\nRU\nRU\n\n"
        },
        {
          "stdin": "h1\nd1\n",
          "stdout": "4\nL\nL\nL\nL\n\n"
        },
        {
          "stdin": "d6\ne5\n",
          "stdout": "1\nRD\n\n"
        },
        {
          "stdin": "e8\nb1\n",
          "stdout": "7\nLD\nLD\nLD\n\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "d2\nf2\n",
          "stdout": "2\nR\nR\n\n"
        },
        {
          "stdin": "a2\nb4\n",
          "stdout": "2\nRU\n\nU\n\n"
        },
        {
          "stdin": "f7\nd1\n",
          "stdout": "6\nLD\nLD\n\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "f8\nb2\n",
          "stdout": "6\nLD\nLD\nLD\nLD\n\nD\nD\n\n"
        },
        {
          "stdin": "g7\nc1\n",
          "stdout": "6\nLD\nLD\nLD\nLD\n\nD\nD\n\n"
        },
        {
          "stdin": "e5\nf7\n",
          "stdout": "2\nRU\n\nU\n\n"
        },
        {
          "stdin": "g4\ng5\n",
          "stdout": "1\nU\n\n"
        },
        {
          "stdin": "d2\nf3\n",
          "stdout": "2\nRU\n\nR\n\n"
        },
        {
          "stdin": "e2\nf1\n",
          "stdout": "1\nRD\n\n"
        },
        {
          "stdin": "b6\nb2\n",
          "stdout": "4\nD\nD\nD\nD\n\n"
        },
        {
          "stdin": "f8\nd6\n",
          "stdout": "2\nLD\nLD\n\n"
        },
        {
          "stdin": "a2\na4\n",
          "stdout": "2\nU\nU\n\n"
        },
        {
          "stdin": "g7\nd1\n",
          "stdout": "6\nLD\nLD\nLD\n\nD\nD\nD\n\n"
        },
        {
          "stdin": "a8\nh1\n",
          "stdout": "7\nRD\nRD\nRD\nRD\nRD\nRD\nRD\n"
        },
        {
          "stdin": "b8\nb8\n",
          "stdout": "0\n"
        },
        {
          "stdin": "c7\nc7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "e7\ne7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "h2\nh2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "c2\nc2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "b2\nb2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g2\ng2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "g7\ng7\n",
          "stdout": "0\n"
        }
      ],
      "source": "codeforces",
      "difficulty": "EASY",
      "human_solutions": [
        "xi = tuple(input())\nxf = tuple(input())\nrow = [1, 2, 3, 4, 5, 6, 7, 8]\ncol = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nmovelist = []\nrow_in = int(xi[1])\ncol_in = xi[0]\nrow_fin = int(xf[1])\ncol_fin = xf[0]\nindex_ri = row.index(row_in)\nindex_rf = row.index(row_fin)\nindex_ci = col.index(col_in)\nindex_cf = col.index(col_fin)\n\ndef d():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri > 0:\n\t\tindex_ri -= 1\n\tmovelist += ['D']\n\ndef u():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri < 7:\n\t\tindex_ri += 1\n\tmovelist += ['U']\n\ndef l():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ci > 0:\n\t\tindex_ci -= 1\n\tmovelist += ['L']\n\ndef r():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ci < 7:\n\t\tindex_ci += 1\n\tmovelist += ['R']\n\ndef dl():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri > 0 and index_ci > 0:\n\t\tindex_ri -= 1\n\t\tindex_ci -= 1\n\tmovelist += ['LD']\n\ndef dr():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri > 0 and index_ci < 7:\n\t\tindex_ri -= 1\n\t\tindex_ci += 1\n\tmovelist += ['RD']\n\ndef ul():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri < 7 and index_ci > 0:\n\t\tindex_ri += 1\n\t\tindex_ci -= 1\n\tmovelist += ['LU']\n\ndef ur():\n\tglobal index_ri, index_rf, index_ci, index_cf, movelist\n\tif index_ri < 7 and index_ci < 7:\n\t\tindex_ri += 1\n\t\tindex_ci += 1\n\tmovelist += ['RU']\nsteps = 0\nwhile index_ri != index_rf or index_ci != index_cf:\n\tif index_ri == index_rf:\n\t\tif index_ci < index_cf:\n\t\t\twhile index_ci != index_cf:\n\t\t\t\tr()\n\t\t\t\tsteps += 1\n\t\tif index_ci > index_cf:\n\t\t\twhile index_ci != index_cf:\n\t\t\t\tl()\n\t\t\t\tsteps += 1\n\tif index_ci == index_cf:\n\t\tif index_ri < index_rf:\n\t\t\twhile index_ri != index_rf:\n\t\t\t\tu()\n\t\t\t\tsteps += 1\n\t\tif index_ri > index_rf:\n\t\t\twhile index_ri != index_rf:\n\t\t\t\td()\n\t\t\t\tsteps += 1\n\tif index_ri > index_rf:\n\t\tif index_ci < index_cf:\n\t\t\twhile index_ci != index_cf and index_ri != index_rf:\n\t\t\t\tdr()\n\t\t\t\tsteps += 1\n\t\tif index_ci > index_cf:\n\t\t\twhile index_ci != index_cf and index_ri != index_rf:\n\t\t\t\tdl()\n\t\t\t\tsteps += 1\n\tif index_ri < index_rf:\n\t\tif index_ci < index_cf:\n\t\t\twhile index_ci != index_cf and index_ri != index_rf:\n\t\t\t\tur()\n\t\t\t\tsteps += 1\n\t\tif index_ci > index_cf:\n\t\t\twhile index_ci != index_cf and index_ri != index_rf:\n\t\t\t\tul()\n\t\t\t\tsteps += 1\nprint(steps)\nfor el in movelist:\n\tprint(el)\n",
        "s = input()\nt = input()\nsteps = []\ncountermanigga = 0\nwhile s[0] != t[0] or s[1] != t[1]:\n\ta = ''\n\tif s[0] < t[0]:\n\t\ta = 'R'\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\telif s[0] > t[0]:\n\t\ta = 'L'\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\telse:\n\t\tpass\n\tif s[1] < t[1]:\n\t\ta += 'U'\n\t\ts = s[0] + chr(ord(s[1]) + 1)\n\telif s[1] > t[1]:\n\t\ta += 'D'\n\t\ts = s[0] + chr(ord(s[1]) - 1)\n\telse:\n\t\tpass\n\tsteps.append(a)\n\tcountermanigga += 1\nprint(countermanigga)\nfor i in steps:\n\tprint(i)\n",
        "s = input().strip()\nt = input().strip()\ns = [ord(s[0]), int(s[1])]\nt = [ord(t[0]), int(t[1])]\nsteps = {'R': 0, 'L': 0, 'U': 0, 'D': 0}\nwhile t[0] > s[0]:\n\ts[0] += 1\n\tsteps['R'] += 1\nwhile t[0] < s[0]:\n\ts[0] -= 1\n\tsteps['L'] += 1\nwhile t[1] > s[1]:\n\ts[1] += 1\n\tsteps['U'] += 1\nwhile t[1] < s[1]:\n\ts[1] -= 1\n\tsteps['D'] += 1\nresult = []\nwhile steps['R'] > 0 and steps['U'] > 0:\n\tresult.append('RU')\n\tsteps['R'] -= 1\n\tsteps['U'] -= 1\nwhile steps['R'] > 0 and steps['D'] > 0:\n\tresult.append('RD')\n\tsteps['R'] -= 1\n\tsteps['D'] -= 1\nwhile steps['L'] > 0 and steps['U'] > 0:\n\tresult.append('LU')\n\tsteps['L'] -= 1\n\tsteps['U'] -= 1\nwhile steps['L'] > 0 and steps['D'] > 0:\n\tresult.append('LD')\n\tsteps['L'] -= 1\n\tsteps['D'] -= 1\nfor d in steps:\n\twhile steps[d] > 0:\n\t\tresult.append(d)\n\t\tsteps[d] -= 1\nprint(len(result))\nfor x in result:\n\tprint(x)\n",
        "p1 = input()\np2 = input()\ny1 = int(p1[1])\nx1 = ord(p1[0]) - ord('a')\ny2 = int(p2[1])\nx2 = ord(p2[0]) - ord('a')\nlr = 'R' if x2 > x1 else 'L'\nud = 'U' if y2 > y1 else 'D'\nr = max(abs(x2 - x1), abs(y2 - y1))\nprint(r)\nfor i in range(r):\n\tif i >= abs(x2 - x1):\n\t\tlr = ''\n\tif i >= abs(y2 - y1):\n\t\tud = ''\n\tprint(lr + ud)\n",
        "(start_x, start_y) = map(str, input())\n(end_x, end_y) = map(str, input())\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nmoves = ['', '', '', '', '', '', '', '']\nif d[end_x] > d[start_x]:\n\tfor i in range(d[end_x] - d[start_x]):\n\t\tmoves[i] = moves[i] + 'R'\nelif d[end_x] < d[start_x]:\n\tfor i in range(d[start_x] - d[end_x]):\n\t\tmoves[i] = moves[i] + 'L'\nelse:\n\tpass\nif int(end_y) > int(start_y):\n\tfor i in range(int(end_y) - int(start_y)):\n\t\tmoves[i] = moves[i] + 'U'\nelif int(end_y) < int(start_y):\n\tfor i in range(int(start_y) - int(end_y)):\n\t\tmoves[i] = moves[i] + 'D'\nelse:\n\tpass\ni = 0\nwhile i in range(len(moves)):\n\tif moves[i] == '':\n\t\tmoves.pop(i)\n\t\ti -= 1\n\ti += 1\nprint(len(moves))\nprint('\\n'.join(moves))\n",
        "movList = []\n\ndef coordtotuple(s):\n\tss = s[0]\n\tif ss == 'a':\n\t\txxx = 1\n\telif ss == 'b':\n\t\txxx = 2\n\telif ss == 'c':\n\t\txxx = 3\n\telif ss == 'd':\n\t\txxx = 4\n\telif ss == 'e':\n\t\txxx = 5\n\telif ss == 'f':\n\t\txxx = 6\n\telif ss == 'g':\n\t\txxx = 7\n\telif ss == 'h':\n\t\txxx = 8\n\treturn [xxx, int(s[1])]\n\ndef move():\n\tif x == xx:\n\t\tif y < yy:\n\t\t\tmovList.append('U')\n\t\t\treturn [0, 1]\n\t\telif y > yy:\n\t\t\tmovList.append('D')\n\t\t\treturn [0, -1]\n\telif y == yy:\n\t\tif x < xx:\n\t\t\tmovList.append('R')\n\t\t\treturn [1, 0]\n\t\telif x > xx:\n\t\t\tmovList.append('L')\n\t\t\treturn [-1, 0]\n\telif x < xx and y < yy:\n\t\tmovList.append('RU')\n\t\treturn [1, 1]\n\telif x < xx and y > yy:\n\t\tmovList.append('RD')\n\t\treturn [1, -1]\n\telif x > xx and y < yy:\n\t\tmovList.append('LU')\n\t\treturn [-1, 1]\n\telif x > xx and y > yy:\n\t\tmovList.append('LD')\n\t\treturn [-1, -1]\n\ndef printres():\n\tprint(len(movList))\n\tfor i in movList:\n\t\tprint(i)\ninn = input()\nx = coordtotuple(inn)[0]\ny = coordtotuple(inn)[1]\ninn = input()\nxx = coordtotuple(inn)[0]\nyy = coordtotuple(inn)[1]\nwhile x != xx or y != yy:\n\tp = move()\n\tx += p[0]\n\ty += p[1]\nprintres()\n",
        "(p1, p2) = (input(), input())\n(x1, y1) = (ord(p1[0]) - ord('a') + 1, int(p1[1]))\n(x2, y2) = (ord(p2[0]) - ord('a') + 1, int(p2[1]))\nx = x2 - x1\ny = y2 - y1\n(d1, d2) = ('L', 'D')\nif x > 0:\n\td1 = 'R'\nelse:\n\tx = -x\nif y > 0:\n\td2 = 'U'\nelse:\n\ty = -y\nif x > y:\n\tprint(x)\nelse:\n\tprint(y)\nwhile x or y:\n\tif x:\n\t\tx -= 1\n\t\tprint(d1, end='')\n\tif y:\n\t\ty -= 1\n\t\tprint(d2, end='')\n\tprint()\n",
        "def move(i, j, x, y):\n\tans = []\n\tif x == i and y == j:\n\t\treturn []\n\twhile i != x or j != y:\n\t\tch = ''\n\t\tif i < x:\n\t\t\tch += 'R'\n\t\t\ti += 1\n\t\telif i > x:\n\t\t\tch += 'L'\n\t\t\ti -= 1\n\t\tif j < y:\n\t\t\tch += 'U'\n\t\t\tj += 1\n\t\telif j > y:\n\t\t\tch += 'D'\n\t\t\tj -= 1\n\t\tans.append(ch)\n\treturn ans\n\ndef check():\n\tp1 = input()\n\t(i, j) = (ord(p1[0]) - ord('a') + 1, ord(p1[1]) - ord('0'))\n\tp2 = input()\n\t(x, y) = (ord(p2[0]) - ord('a') + 1, ord(p2[1]) - ord('0'))\n\tans = move(i, j, x, y)\n\tprint(len(ans))\n\tfor s in ans:\n\t\tprint(s)\ncheck()\n",
        "def solve():\n\ts = input()\n\tt = input()\n\tx_count = ord(t[0]) - ord(s[0])\n\ty_count = ord(t[1]) - ord(s[1])\n\tcnt = 0\n\tresult = ''\n\twhile x_count != 0 or y_count != 0:\n\t\tif x_count > 0:\n\t\t\tresult += 'R'\n\t\t\tx_count -= 1\n\t\telif x_count < 0:\n\t\t\tresult += 'L'\n\t\t\tx_count += 1\n\t\tif y_count > 0:\n\t\t\tresult += 'U'\n\t\t\ty_count -= 1\n\t\telif y_count < 0:\n\t\t\tresult += 'D'\n\t\t\ty_count += 1\n\t\tresult += '\\n'\n\t\tcnt += 1\n\tprint(cnt)\n\tprint(result)\nsolve()\n",
        "s = list(input())\nt = list(input())\n(s0, s1) = (s[0], int(s[1]))\n(t0, t1) = (t[0], int(t[1]))\nnum_s0 = ord(s0) - 96\nnum_t0 = ord(t0) - 96\nx_axis = abs(num_s0 - num_t0)\ny_axis = abs(s1 - t1)\nmax_moves = max(abs(num_s0 - num_t0), abs(s1 - t1))\nmin_diagonal = min(abs(num_s0 - num_t0), abs(s1 - t1))\nif max_moves <= 7:\n\tprint(max_moves)\n\tif s0 < t0:\n\t\tif s1 < t1:\n\t\t\twhile max_moves > 0:\n\t\t\t\tif min_diagonal > 0:\n\t\t\t\t\tprint('RU', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\t\t\t\t\tmin_diagonal -= 1\n\t\t\t\telif x_axis > y_axis:\n\t\t\t\t\tprint('R', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\t\t\t\telse:\n\t\t\t\t\tprint('U', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\t\telif s1 == t1:\n\t\t\twhile max_moves > 0:\n\t\t\t\tprint('R', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\telse:\n\t\t\twhile max_moves > 0:\n\t\t\t\tif min_diagonal > 0:\n\t\t\t\t\tprint('RD', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\t\t\t\t\tmin_diagonal -= 1\n\t\t\t\telif x_axis > y_axis:\n\t\t\t\t\tprint('R', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\t\t\t\telse:\n\t\t\t\t\tprint('D', end='\\n')\n\t\t\t\t\tmax_moves -= 1\n\telif s0 == t0:\n\t\tif s1 < t1:\n\t\t\twhile max_moves > 0:\n\t\t\t\tprint('U', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\telse:\n\t\t\twhile max_moves > 0:\n\t\t\t\tprint('D', end='\\n')\n\t\t\t\tmax_moves -= 1\n\telif s1 < t1:\n\t\twhile max_moves > 0:\n\t\t\tif min_diagonal > 0:\n\t\t\t\tprint('LU', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\t\t\tmin_diagonal -= 1\n\t\t\telif x_axis > y_axis:\n\t\t\t\tprint('L', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\t\telse:\n\t\t\t\tprint('U', end='\\n')\n\t\t\t\tmax_moves -= 1\n\telif s1 == t1:\n\t\twhile max_moves > 0:\n\t\t\tprint('L', end='\\n')\n\t\t\tmax_moves -= 1\n\telse:\n\t\twhile max_moves > 0:\n\t\t\tif min_diagonal > 0:\n\t\t\t\tprint('LD', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\t\t\tmin_diagonal -= 1\n\t\t\telif x_axis > y_axis:\n\t\t\t\tprint('L', end='\\n')\n\t\t\t\tmax_moves -= 1\n\t\t\telse:\n\t\t\t\tprint('D', end='\\n')\n\t\t\t\tmax_moves -= 1\n",
        "def bfs(s, t):\n\t(visited, q) = (set(), [])\n\tq.append((s, 0, ''))\n\tvisited.add(s)\n\twhile q:\n\t\t(front, dist, path) = q.pop(0)\n\t\tif front == t:\n\t\t\treturn (dist, path)\n\t\tfor v in board[front[0]][front[1]]:\n\t\t\tif (v[0], v[1]) not in visited:\n\t\t\t\tvisited.add((v[0], v[1]))\n\t\t\t\tq.append(((v[0], v[1]), dist + 1, '{0},{1}'.format(path, v[2])))\nboard = [[[] for j in range(8)] for i in range(8)]\nfor i in range(8):\n\tfor j in range(8):\n\t\tif i + 1 < 8:\n\t\t\tboard[i][j].append((i + 1, j, 'U'))\n\t\t\tif j + 1 < 8:\n\t\t\t\tboard[i][j].append((i + 1, j + 1, 'RU'))\n\t\t\tif j - 1 >= 0:\n\t\t\t\tboard[i][j].append((i + 1, j - 1, 'LU'))\n\t\tif i - 1 >= 0:\n\t\t\tboard[i][j].append((i - 1, j, 'D'))\n\t\t\tif j + 1 < 8:\n\t\t\t\tboard[i][j].append((i - 1, j + 1, 'RD'))\n\t\t\tif j - 1 >= 0:\n\t\t\t\tboard[i][j].append((i - 1, j - 1, 'LD'))\n\t\tif j + 1 < 8:\n\t\t\tboard[i][j].append((i, j + 1, 'R'))\n\t\tif j - 1 >= 0:\n\t\t\tboard[i][j].append((i, j - 1, 'L'))\ncol_map = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\ns = input()\ns = (int(s[1]) - 1, col_map[s[0]])\nt = input()\nt = (int(t[1]) - 1, col_map[t[0]])\n(dist, path) = bfs(s, t)\nprint(dist)\nfor (i, j) in enumerate(path.split(',')):\n\tif i == 0:\n\t\tcontinue\n\tprint(j)\n",
        "i = input()\ns = (ord(i[0]) - 96, int(i[1]))\nj = input()\nt = (ord(j[0]) - 96, int(j[1]))\nd = [t[0] - s[0], t[1] - s[1]]\nif d[0] > 0:\n\tx = 'R'\nelse:\n\tx = 'L'\n\td[0] = -d[0]\nif d[1] > 0:\n\ty = 'U'\nelse:\n\ty = 'D'\n\td[1] = -d[1]\npath = []\ndiag = min(d)\npath.extend([x + y] * diag)\nd = [d[0] - diag, d[1] - diag]\nif d[0] > 0:\n\tpath.extend([x] * d[0])\nif d[1] > 0:\n\tpath.extend([y] * d[1])\nprint(len(path))\nfor step in path:\n\tprint(step)\n",
        "s = input()\nt = input()\n(sc, sr) = (ord(s[0]) - 65, int(s[1]))\n(tc, tr) = (ord(t[0]) - 65, int(t[1]))\ntrail = []\nwhile sc < tc and sr < tr:\n\ttrail.append('RU')\n\tsc += 1\n\tsr += 1\nwhile sc < tc and sr > tr:\n\ttrail.append('RD')\n\tsc += 1\n\tsr -= 1\nwhile sc > tc and sr < tr:\n\ttrail.append('LU')\n\tsc -= 1\n\tsr += 1\nwhile sc > tc and sr > tr:\n\ttrail.append('LD')\n\tsc -= 1\n\tsr -= 1\nwhile sc < tc:\n\ttrail.append('R')\n\tsc += 1\nwhile sc > tc:\n\ttrail.append('L')\n\tsc -= 1\nwhile sr < tr:\n\ttrail.append('U')\n\tsr += 1\nwhile sr > tr:\n\ttrail.append('D')\n\tsr -= 1\nprint(len(trail))\nfor step in trail:\n\tprint(step)\n",
        "s1 = input()\ns2 = input()\nstart = (8 - (ord(s1[1]) - ord('0')), ord(s1[0]) - ord('a'))\nend = (8 - (ord(s2[1]) - ord('0')), ord(s2[0]) - ord('a'))\nx = end[0] - start[0]\ny = end[1] - start[1]\nstep = max(abs(x), abs(y))\nprint(step)\na = min(abs(x), abs(y))\nif x >= 0 and y >= 0:\n\tfor i in range(0, a):\n\t\tprint('RD')\nelif x >= 0 and y <= 0:\n\tfor i in range(0, a):\n\t\tprint('LD')\nelif x <= 0 and y >= 0:\n\tfor i in range(0, a):\n\t\tprint('RU')\nelif x <= 0 and y <= 0:\n\tfor i in range(0, a):\n\t\tprint('LU')\nif abs(x) != a:\n\tb = abs(x) - a\n\tif x >= 0:\n\t\tfor i in range(0, b):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(0, b):\n\t\t\tprint('U')\nelse:\n\tb = abs(y) - a\n\tif y >= 0:\n\t\tfor i in range(0, b):\n\t\t\tprint('R')\n\telse:\n\t\tfor i in range(0, b):\n\t\t\tprint('L')\n",
        "class Node:\n\n\tdef __init__(self, parent=None, position=None):\n\t\tself.parent = parent\n\t\tself.position = position\n\t\tself.g = 0\n\t\tself.h = 0\n\t\tself.f = 0\n\n\tdef __eq__(self, other):\n\t\treturn self.position == other.position\n\ndef heuristic(A, B):\n\treturn abs(A[0] - B[0]) + abs(A[1] - B[1])\n\ndef Astar(maze, start, end):\n\tstart_node = Node(None, start)\n\tstart_node.g = 0\n\tstart_node.h = heuristic(start, end)\n\tstart_node.f = start_node.g + start_node.h\n\tend_node = Node(None, end)\n\tend_node.g = heuristic(start, end)\n\tend_node.h = 0\n\tend_node.f = end_node.g + end_node.h\n\topen_list = []\n\tclosed_list = []\n\topen_list.append(start_node)\n\twhile True:\n\t\tif len(open_list) == 0:\n\t\t\treturn -1\n\t\tcurrent_node = open_list[0]\n\t\tcurrent_index = 0\n\t\tfor (index, item) in enumerate(open_list):\n\t\t\tif item.f < current_node.f:\n\t\t\t\tcurrent_node = item\n\t\t\t\tcurrent_index = index\n\t\topen_list.pop(current_index)\n\t\tclosed_list.append(current_node)\n\t\tif current_node == end_node:\n\t\t\tpath = []\n\t\t\tcurrent = current_node\n\t\t\twhile current is not None:\n\t\t\t\tpath.append(current.position)\n\t\t\t\tcurrent = current.parent\n\t\t\treturn path[::-1]\n\t\telse:\n\t\t\tchildren = []\n\t\t\tfor new_position in [(0, -1), (0, 1), (1, 0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n\t\t\t\tnode_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])\n\t\t\t\tif node_position[0] > len(maze) - 1 or node_position[0] < 0 or node_position[1] > len(maze[len(maze) - 1]) - 1 or (node_position[1] < 0):\n\t\t\t\t\tcontinue\n\t\t\t\tif maze[node_position[0]][node_position[1]] != 0:\n\t\t\t\t\tcontinue\n\t\t\t\tnew_node = Node(current_node, node_position)\n\t\t\t\tnew_node.g = current_node.g + 1\n\t\t\t\tnew_node.h = heuristic(new_node.position, end)\n\t\t\t\tnew_node.f = new_node.g + new_node.h\n\t\t\t\tchildren.append(new_node)\n\t\t\tvisited = False\n\t\t\tfor child in children:\n\t\t\t\tfor open_child in open_list:\n\t\t\t\t\tif child.position == open_child.position:\n\t\t\t\t\t\tif child.f < open_child.f:\n\t\t\t\t\t\t\topen_child = child\n\t\t\t\t\t\tvisited = True\n\t\t\t\tfor closed_child in closed_list:\n\t\t\t\t\tif child.position == closed_child.position:\n\t\t\t\t\t\tif child.f < closed_child.f:\n\t\t\t\t\t\t\tclosed_child = child\n\t\t\t\t\t\tvisited = True\n\t\t\t\tif visited:\n\t\t\t\t\tvisited = False\n\t\t\t\telse:\n\t\t\t\t\topen_list.append(child)\n\ndef move_the_king():\n\tmaze = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]\n\tdic_letters = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\n\tdic_numbers = {8: 0, 7: 1, 6: 2, 5: 3, 4: 4, 3: 5, 2: 6, 1: 7}\n\tdic_move = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L', (-1, -1): 'LU', (-1, 1): 'RU', (1, -1): 'LD', (1, 1): 'RD'}\n\tstart = input()\n\tend = input()\n\tactual_start = (dic_numbers[int(start[1])], dic_letters[start[0]])\n\tactual_end = (dic_numbers[int(end[1])], dic_letters[end[0]])\n\tpath = Astar(maze, actual_start, actual_end)\n\tprint(len(path) - 1)\n\tfor i in range(1, len(path)):\n\t\ttemp = (path[i][0] - path[i - 1][0], path[i][1] - path[i - 1][1])\n\t\tprint(dic_move[temp])\nmove_the_king()\n",
        "a = input()\nb = input()\nx = ord(a[0]) - ord(b[0])\ny = ord(a[1]) - ord(b[1])\nprint(max(x, -x, y, -y))\nwhile x != 0 or y != 0:\n\tr = ''\n\tif x < 0:\n\t\tr = 'R'\n\t\tx = x + 1\n\tif x > 0:\n\t\tr = 'L'\n\t\tx = x - 1\n\tif y < 0:\n\t\tr = r + 'U'\n\t\ty = y + 1\n\tif y > 0:\n\t\tr = r + 'D'\n\t\ty = y - 1\n\tprint(r)\n",
        "def convert_point(point):\n\treturn (ord(point[0]) - ord('a') + 1, int(point[1]))\n\ndef move(src, dest):\n\tx = src[0]\n\ty = src[1]\n\tmove = ''\n\tif src[0] > dest[0]:\n\t\tx -= 1\n\t\tmove += 'L'\n\telif src[0] < dest[0]:\n\t\tx += 1\n\t\tmove += 'R'\n\tif src[1] > dest[1]:\n\t\ty -= 1\n\t\tmove += 'D'\n\telif src[1] < dest[1]:\n\t\ty += 1\n\t\tmove += 'U'\n\treturn ((x, y), move)\n\ndef go(src, dest):\n\tmoves = []\n\twhile not src == dest:\n\t\t(src, m) = move(src, dest)\n\t\tmoves.append(m)\n\tprint(moves.__len__())\n\tfor step in moves:\n\t\tprint(step)\ngo(convert_point(input()), convert_point(input()))\n",
        "I = input\nP = print\na = I() + I()\n(a, b) = (ord(a[i]) - ord(a[i + 2]) for i in (0, 1))\nP(max(a, -a, b, -b))\nwhile a != 0 or b != 0:\n\tr = ''\n\tif a < 0:\n\t\tr = 'R'\n\t\ta += 1\n\tif a > 0:\n\t\tr = 'L'\n\t\ta -= 1\n\tif b < 0:\n\t\tr += 'U'\n\t\tb += 1\n\tif b > 0:\n\t\tr += 'D'\n\t\tb -= 1\n\tP(r)\n",
        "import math\nalph = 'abcdefghijklmnopqrstuvwxyz'\ns = str(input())\nt = str(input())\nx1 = alph.index(s[0])\nx2 = alph.index(t[0])\ny1 = int(s[1])\ny2 = int(t[1])\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile x1 != x2 or y1 != y2:\n\tif x1 < x2:\n\t\tif y1 < y2:\n\t\t\tprint('RU')\n\t\t\tx1 += 1\n\t\t\ty1 += 1\n\t\telif y1 > y2:\n\t\t\tprint('RD')\n\t\t\tx1 += 1\n\t\t\ty1 -= 1\n\t\telse:\n\t\t\tprint('R')\n\t\t\tx1 += 1\n\telif x1 == x2:\n\t\tif y1 < y2:\n\t\t\tprint('U')\n\t\t\ty1 += 1\n\t\telse:\n\t\t\tprint('D')\n\t\t\ty1 -= 1\n\telif y1 < y2:\n\t\tprint('LU')\n\t\tx1 -= 1\n\t\ty1 += 1\n\telif y1 == y2:\n\t\tprint('L')\n\t\tx1 -= 1\n\telse:\n\t\tprint('LD')\n\t\tx1 -= 1\n\t\ty1 -= 1\n",
        "a = input()\nb = input()\nif a == b:\n\tprint(0)\n\tquit()\na1 = int(str(ord(a[0]) - 96) + a[1])\nb1 = int(str(ord(b[0]) - 96) + b[1])\n\ndef ok(i, j):\n\treturn 0 < i <= 8 and 0 < j <= 8\ng = {}\nfor i in range(1, 9):\n\tfor j in range(1, 9):\n\t\tg[10 * i + j] = []\nfor i in range(1, 9):\n\tfor j in range(1, 9):\n\t\tfor k in range(-1, 2):\n\t\t\tfor l in range(-1, 2):\n\t\t\t\tif ok(i + k, j + l) and (not (k == 0 and l == 0)):\n\t\t\t\t\tg[10 * i + j].append(10 * (i + k) + j + l)\nvisited = [False] * 90\nparent = [0] * 90\ndist = [10000] * 90\ns = [a1]\ndist[a1] = 0\nwhile s:\n\ta = s.pop()\n\tif not visited[a]:\n\t\tvisited[a] = True\n\t\tfor i in g[a]:\n\t\t\ts = [i] + s\n\t\t\tif dist[a] + 1 < dist[i]:\n\t\t\t\tparent[i] = a\n\t\t\t\tdist[i] = dist[a] + 1\nchain = [b1]\nwhile parent[chain[-1]] != a1:\n\tchain.append(parent[chain[-1]])\nchain.append(a1)\nchain.reverse()\nprint(dist[b1])\nfor i in range(len(chain) - 1):\n\ta = chain[i + 1] // 10 - chain[i] // 10\n\tb = chain[i + 1] % 10 - chain[i] % 10\n\tstrx = ''\n\tstrx += {-1: 'L', 0: '', 1: 'R'}[a]\n\tstrx += {-1: 'D', 0: '', 1: 'U'}[b]\n\tprint(strx)\n",
        "s = input()\nt = input()\nvertical = int(s[1]) - int(t[1])\nhorizontal = ord(s[0]) - ord(t[0])\nif vertical < 0:\n\tdir_ver = 'U'\nelse:\n\tdir_ver = 'D'\nif horizontal < 0:\n\tdir_hor = 'R'\nelse:\n\tdir_hor = 'L'\nc_diagonal = 0\nwhile vertical != 0 and horizontal != 0:\n\tif dir_ver == 'U':\n\t\tvertical += 1\n\telse:\n\t\tvertical -= 1\n\tif dir_hor == 'R':\n\t\thorizontal += 1\n\telse:\n\t\thorizontal -= 1\n\tc_diagonal += 1\nif vertical == 0 and horizontal == 0:\n\tprint(c_diagonal)\n\tfor i in range(c_diagonal):\n\t\tprint(dir_hor, dir_ver, sep='')\nelif vertical == 0:\n\tprint(c_diagonal + abs(horizontal))\n\tfor i in range(c_diagonal):\n\t\tprint(dir_hor, dir_ver, sep='')\n\tfor i in range(abs(horizontal)):\n\t\tif horizontal < 0:\n\t\t\tprint('R')\n\t\telse:\n\t\t\tprint('L')\nelse:\n\tprint(c_diagonal + abs(vertical))\n\tfor i in range(c_diagonal):\n\t\tprint(dir_hor, dir_ver, sep='')\n\tfor i in range(abs(vertical)):\n\t\tif vertical < 0:\n\t\t\tprint('U')\n\t\telse:\n\t\t\tprint('D')\n",
        "(s,) = [str(x) for x in input().split()]\n(t,) = [str(x) for x in input().split()]\ntrans = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nwidth = abs(int(s[1]) - int(t[1]))\nlenght = abs(trans[s[0]] - trans[t[0]])\nprint(max(width, lenght))\nif trans[t[0]] >= trans[s[0]] and int(t[1]) >= int(s[1]):\n\tfor i in range(min(width, lenght)):\n\t\tprint('RU')\n\tif width > lenght:\n\t\tfor i in range(width - lenght):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(lenght - width):\n\t\t\tprint('R')\nif trans[t[0]] < trans[s[0]] and int(t[1]) >= int(s[1]):\n\tfor i in range(min(width, lenght)):\n\t\tprint('LU')\n\tif width > lenght:\n\t\tfor i in range(width - lenght):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(lenght - width):\n\t\t\tprint('L')\nif trans[t[0]] >= trans[s[0]] and int(t[1]) < int(s[1]):\n\tfor i in range(min(width, lenght)):\n\t\tprint('RD')\n\tif width > lenght:\n\t\tfor i in range(width - lenght):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(lenght - width):\n\t\t\tprint('R')\nif trans[t[0]] < trans[s[0]] and int(t[1]) < int(s[1]):\n\tfor i in range(min(width, lenght)):\n\t\tprint('LD')\n\tif width > lenght:\n\t\tfor i in range(width - lenght):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(lenght - width):\n\t\t\tprint('L')\n",
        "a = [ord(i) for i in input()]\nb = [ord(i) for i in input()]\nd1 = {1: 'R', -1: 'L'}\nd2 = {1: 'U', -1: 'D'}\nd3 = ('U', 'D', 'R', 'L')\np = max(abs(a[0] - b[0]), abs(a[1] - b[1]))\np1 = min(abs(a[0] - b[0]), abs(a[1] - b[1]))\nprint(p)\nf1 = 1 if a[0] < b[0] else -1\nf2 = 1 if a[1] < b[1] else -1\nfor _ in range(p1):\n\tprint(d1[f1], d2[f2], sep='')\na[0] += p1 * f1\na[1] += p1 * f2\nif a[0] == b[0]:\n\tf = 0 if a[1] < b[1] else 1\nelse:\n\tf = 2 if a[0] < b[0] else 3\nfor _ in range(p - p1):\n\tprint(d3[f])\n",
        "S = input()\nT = input()\nR = 0\nL = 0\nU = 0\nD = 0\nRD = 0\nRU = 0\nLD = 0\nLU = 0\nM = 0\n(s, t) = ([0] * 2, [0] * 2)\n(s[1], t[1]) = (int(S[1]), int(T[1]))\ns[0] = ord(S[0]) - 96\nt[0] = ord(T[0]) - 96\nfor i in range(8):\n\tif s[0] < t[0] and s[1] < t[1]:\n\t\tRU = RU + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] - 1\n\t\tt[1] = t[1] - 1\n\telif s[0] < t[0] and s[1] > t[1]:\n\t\tRD = RD + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] - 1\n\t\tt[1] = t[1] + 1\n\telif s[0] > t[0] and s[1] < t[1]:\n\t\tLU = LU + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] + 1\n\t\tt[1] = t[1] - 1\n\telif s[0] > t[0] and s[1] > t[1]:\n\t\tLD = LD + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] + 1\n\t\tt[1] = t[1] + 1\n\telif s[0] < t[0]:\n\t\tR = R + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] - 1\n\telif s[0] > t[0]:\n\t\tL = L + 1\n\t\tM = M + 1\n\t\tt[0] = t[0] + 1\n\telif s[1] < t[1]:\n\t\tU = U + 1\n\t\tM = M + 1\n\t\tt[1] = t[1] - 1\n\telif s[1] > t[1]:\n\t\tD = D + 1\n\t\tM = M + 1\n\t\tt[1] = t[1] + 1\nprint(M)\nfor i in range(RU):\n\tprint('RU')\nfor i in range(RD):\n\tprint('RD')\nfor i in range(LU):\n\tprint('LU')\nfor i in range(LD):\n\tprint('LD')\nfor i in range(R):\n\tprint('R')\nfor i in range(L):\n\tprint('L')\nfor i in range(U):\n\tprint('U')\nfor i in range(D):\n\tprint('D')\n",
        "import itertools\nimport sys\n\ndef main():\n\tsolve()\n\ndef solve():\n\tdata = sys.stdin.readlines()\n\t(start_pos, end_pos) = parse(data)\n\tmoves = calc_moves(start_pos, end_pos)\n\toutput = '\\n'.join(moves)\n\tprint(len(moves))\n\tprint(output)\n\ndef parse(data):\n\tstart_s = data[0]\n\tend_s = data[1]\n\tstart_pos = (ord(start_s[0]) - ord('a'), int(start_s[1]))\n\tend_pos = (ord(end_s[0]) - ord('a'), int(end_s[1]))\n\treturn (start_pos, end_pos)\n\ndef calc_moves(start_pos, end_pos):\n\tdiff_hor = end_pos[0] - start_pos[0]\n\tdiff_vert = end_pos[1] - start_pos[1]\n\tdir_vert = 'U' if diff_vert > 0 else 'D'\n\tdir_hor = 'R' if diff_hor > 0 else 'L'\n\tdiff_hor = abs(diff_hor)\n\tdiff_vert = abs(diff_vert)\n\tmoves_hor = (dir_hor for _ in range(diff_hor))\n\tmoves_vert = (dir_vert for _ in range(diff_vert))\n\treturn tuple((''.join(m_tuple) for m_tuple in itertools.zip_longest(moves_hor, moves_vert, fillvalue='')))\nmain()\n",
        "start = list(input())\nend = list(input())\ns = [0, 0]\ns[0] = 8 - int(start[1])\ns[1] = ord(start[0]) - ord('a')\ne = [0, 0]\ne[0] = 8 - int(end[1])\ne[1] = ord(end[0]) - ord('a')\nmoves = []\ndiagonal_move = ''\ndiagonal_row = 0\ndiagonal_col = 0\nif s[0] < e[0] and s[1] < e[1]:\n\tdiagonal_move = 'RD'\n\tdiagonal_row = 1\n\tdiagonal_col = 1\nelif s[0] > e[0] and s[1] > e[1]:\n\tdiagonal_move = 'LU'\n\tdiagonal_row = -1\n\tdiagonal_col = -1\nelif s[0] > e[0] and s[1] < e[1]:\n\tdiagonal_move = 'RU'\n\tdiagonal_row = -1\n\tdiagonal_col = 1\nelif s[0] < e[0] and s[1] > e[1]:\n\tdiagonal_move = 'LD'\n\tdiagonal_row = 1\n\tdiagonal_col = -1\nif diagonal_move != '':\n\twhile s[0] != e[0] and s[1] != e[1]:\n\t\ts[0] += diagonal_row\n\t\ts[1] += diagonal_col\n\t\tmoves.append(diagonal_move)\nif s[0] != e[0]:\n\twhile s[0] < e[0]:\n\t\tmoves.append('D')\n\t\ts[0] += 1\n\twhile s[0] > e[0]:\n\t\tmoves.append('U')\n\t\ts[0] -= 1\nelif s[1] != e[1]:\n\twhile s[1] < e[1]:\n\t\tmoves.append('R')\n\t\ts[1] += 1\n\twhile s[1] > e[1]:\n\t\tmoves.append('L')\n\t\ts[1] -= 1\nprint(len(moves))\nfor move in moves:\n\tprint(move)\n",
        "a = input()\nb = input()\ns = [ord(a[0]) - ord('a') + 1, int(a[1])]\nt = [ord(b[0]) - ord('a') + 1, int(b[1])]\nd = min(abs(s[0] - t[0]), abs(s[1] - t[1]))\nn = max(abs(s[0] - t[0]), abs(s[1] - t[1]))\nprint(n)\ndans = ''\nif s[0] < t[0]:\n\tdans += 'R'\n\ts[0] += d\nelif s[0] > t[0]:\n\tdans += 'L'\n\ts[0] -= d\nif s[1] < t[1]:\n\tdans += 'U'\n\ts[1] += d\nelif s[1] > t[1]:\n\tdans += 'D'\n\ts[1] -= d\nfor _ in range(0, d):\n\tprint(dans)\nif s[0] < t[0]:\n\td = t[0] - s[0]\n\tfor i in range(0, d):\n\t\tprint('R')\nelif s[0] > t[0]:\n\td = s[0] - t[0]\n\tfor i in range(0, d):\n\t\tprint('L')\nelif s[1] < t[1]:\n\td = t[1] - s[1]\n\tfor i in range(0, d):\n\t\tprint('U')\nelif s[1] > t[1]:\n\td = s[1] - t[1]\n\tfor i in range(0, d):\n\t\tprint('D')\n",
        "king_pos = input()\ntarget_pos = input()\nfields = 'abcdefgh'\nkx = fields.index(king_pos[0]) + 1\nky = int(king_pos[1])\ntx = fields.index(target_pos[0]) + 1\nty = int(target_pos[1])\nx_diff = tx - kx\ny_diff = ty - ky\nlor = 'R' if x_diff > 0 else 'L'\ndou = 'U' if y_diff > 0 else 'D'\nx_diff = abs(x_diff)\ny_diff = abs(y_diff)\nnum_moves = max(x_diff, y_diff)\nprint(num_moves)\nfor i in range(num_moves):\n\tif x_diff > 0:\n\t\tprint(lor, end='')\n\tif y_diff > 0:\n\t\tprint(dou, end='')\n\tprint('')\n\tx_diff -= 1\n\ty_diff -= 1\n",
        "p1 = list(input())\np2 = list(input())\nl_m = list()\nwhile p1[0] != p2[0] or p1[1] != p2[1]:\n\ts = ''\n\tif p1[0] < p2[0]:\n\t\ts = 'R'\n\t\tp1[0] = chr(ord(p1[0]) + 1)\n\telif p1[0] > p2[0]:\n\t\ts = 'L'\n\t\tp1[0] = chr(ord(p1[0]) - 1)\n\tif p1[1] < p2[1]:\n\t\ts = s + 'U'\n\t\tp1[1] = str(int(p1[1]) + 1)\n\telif p1[1] > p2[1]:\n\t\ts = s + 'D'\n\t\tp1[1] = str(int(p1[1]) - 1)\n\tl_m.append(s)\nprint(len(l_m))\nprint('\\n'.join(l_m))\n",
        "def main():\n\ts = input()\n\tt = input()\n\tsolver(s, t)\n\ndef solver(s, t):\n\tls = ord(s[0])\n\tlt = ord(t[0])\n\tns = int(s[1])\n\tnt = int(t[1])\n\tn = max(abs(lt - ls), abs(nt - ns))\n\tprint(n)\n\twhile ls != lt or ns != nt:\n\t\tout = ''\n\t\tif ls < lt:\n\t\t\tout += 'R'\n\t\t\tls += 1\n\t\telif ls > lt:\n\t\t\tout += 'L'\n\t\t\tls -= 1\n\t\tif ns < nt:\n\t\t\tout += 'U'\n\t\t\tns += 1\n\t\telif ns > nt:\n\t\t\tout += 'D'\n\t\t\tns -= 1\n\t\tprint(out)\nmain()\n",
        "import math\n\ndef dist(arr1, arr2):\n\tx1 = arr1[0]\n\ty1 = arr1[1]\n\tx2 = arr2[0]\n\ty2 = arr2[1]\n\tx1x2 = math.pow(abs(x1 - x2), 2)\n\ty1y2 = math.pow(abs(y1 - y2), 2)\n\tdistance = math.pow(x1x2 + y1y2, 0.5)\n\treturn distance\n\ndef getneighbours(loc):\n\tx1 = loc[0]\n\ty1 = loc[1]\n\tneighbours = [[x1 + 1, y1], [x1 - 1, y1], [x1, y1 + 1], [x1, y1 - 1], [x1 + 1, y1 + 1], [x1 - 1, y1 - 1], [x1 + 1, y1 - 1], [x1 - 1, y1 + 1]]\n\tfor i in neighbours:\n\t\tfor k in i:\n\t\t\tif k > 8 or k < 1:\n\t\t\t\tif i in neighbours:\n\t\t\t\t\tneighbours.remove(i)\n\treturn neighbours\ns = input()\nt = input()\nkey = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nkingc = 0\nfor i in s:\n\tif i in key:\n\t\tkingc = [key[i], int(s[1])]\ndestination = 0\nfor i in t:\n\tif i in key:\n\t\tdestination = [key[i], int(t[1])]\nstepstaken = []\nwhile dist(kingc, destination) != 0:\n\tkingneighbours = getneighbours(kingc)\n\tpossibledistances = []\n\tfor i in kingneighbours:\n\t\tpossibledistances += [dist(i, destination)]\n\tmind = possibledistances.index(min(possibledistances))\n\tif kingneighbours[mind][0] == kingc[0]:\n\t\tif kingneighbours[mind][1] > kingc[1]:\n\t\t\tstepstaken += ['U']\n\t\telse:\n\t\t\tstepstaken += ['D']\n\tif kingneighbours[mind][1] == kingc[1]:\n\t\tif kingneighbours[mind][0] > kingc[0]:\n\t\t\tstepstaken += ['R']\n\t\telse:\n\t\t\tstepstaken += ['L']\n\tif kingneighbours[mind][0] < kingc[0] and kingneighbours[mind][1] != kingc[1]:\n\t\tif kingneighbours[mind][1] > kingc[1]:\n\t\t\tstepstaken += ['LU']\n\t\telse:\n\t\t\tstepstaken += ['LD']\n\tif kingneighbours[mind][0] > kingc[0] and kingneighbours[mind][1] != kingc[1]:\n\t\tif kingneighbours[mind][1] > kingc[1]:\n\t\t\tstepstaken += ['RU']\n\t\telse:\n\t\t\tstepstaken += ['RD']\n\tkingc = kingneighbours[mind]\nprint(len(stepstaken))\nfor i in stepstaken:\n\tprint(i)\n",
        "s = tuple(input().strip())\nt = tuple(input().strip())\nf = lambda x, y: max(ord(x), ord(y)) - min(ord(x), ord(y))\nans = max(f(s[0], t[0]), f(s[1], t[1]))\nprint(ans)\nif s[0] <= t[0] and s[1] <= t[1]:\n\tk = min(f(s[0], t[0]), f(s[1], t[1]))\n\tfor i in range(k):\n\t\tprint('RU')\n\tif f(s[0], t[0]) < f(s[1], t[1]):\n\t\tfor i in range(ans - k):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(ans - k):\n\t\t\tprint('R')\nelif s[0] <= t[0] and s[1] >= t[1]:\n\tk = min(f(s[0], t[0]), f(s[1], t[1]))\n\tfor i in range(k):\n\t\tprint('RD')\n\tif f(s[0], t[0]) < f(s[1], t[1]):\n\t\tfor i in range(ans - k):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(ans - k):\n\t\t\tprint('R')\nelif s[0] >= t[0] and s[1] <= t[1]:\n\tk = min(f(s[0], t[0]), f(s[1], t[1]))\n\tfor i in range(k):\n\t\tprint('LU')\n\tif f(s[0], t[0]) < f(s[1], t[1]):\n\t\tfor i in range(ans - k):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(ans - k):\n\t\t\tprint('L')\nelif s[0] >= t[0] and s[1] >= t[1]:\n\tk = min(f(s[0], t[0]), f(s[1], t[1]))\n\tfor i in range(k):\n\t\tprint('LD')\n\tif f(s[0], t[0]) < f(s[1], t[1]):\n\t\tfor i in range(ans - k):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(ans - k):\n\t\t\tprint('L')\n",
        "from itertools import zip_longest\nbegin = list(input())\nend = list(input())\nbegin[0] = ord(begin[0]) - ord('a') + 1\nbegin[1] = int(begin[1])\nend[0] = ord(end[0]) - ord('a') + 1\nend[1] = int(end[1])\ndelta_x = end[0] - begin[0]\ndelta_y = end[1] - begin[1]\nmove_times = max(abs(delta_x), abs(delta_y))\nprint(move_times)\nmovemap = {(0, -1): 'D', (0, 1): 'U', (1, 0): 'R', (-1, 0): 'L', (1, -1): 'RD', (-1, -1): 'LD', (1, 1): 'RU', (-1, 1): 'LU'}\nmove_x = [delta_x / abs(delta_x) for _ in range(abs(delta_x))]\nmove_y = [delta_y / abs(delta_y) for _ in range(abs(delta_y))]\nmove = zip_longest(move_x, move_y, fillvalue=0)\nfor i in move:\n\tprint(movemap[i])\n",
        "A = ['', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\ndef move(s1, s2, t1, t2):\n\t_move = ''\n\tif s1 < t1:\n\t\t_move = _move + 'R'\n\tif s1 > t1:\n\t\t_move = _move + 'L'\n\tif s2 < t2:\n\t\t_move = _move + 'U'\n\tif s2 > t2:\n\t\t_move = _move + 'D'\n\treturn _move\n(s1, s2) = list(input())\n(t1, t2) = list(input())\n(s1, t1) = (A.index(s1), A.index(t1))\n(s2, t2) = (int(s2), int(t2))\n_move = True\nM = []\nwhile _move:\n\t_move = move(s1, s2, t1, t2)\n\tif 'R' in _move:\n\t\ts1 += 1\n\tif 'L' in _move:\n\t\ts1 -= 1\n\tif 'U' in _move:\n\t\ts2 += 1\n\tif 'D' in _move:\n\t\ts2 -= 1\n\tif _move == False:\n\t\tpass\n\tM = M + [_move]\nprint(len(M) - 1)\nprint('%s' % '\\n'.join(M))\n",
        "import sys\ninitPos = input()\nfinPos = input()\ninitX = int(ord(initPos[0]) - 96)\ninitY = 9 - int(initPos[1])\nfinX = int(ord(finPos[0]) - 96)\nfinY = 9 - int(finPos[1])\nif initY == finY:\n\tprint(abs(initX - finX))\n\tif finX > initX:\n\t\tfor r in range(0, abs(initX - finX)):\n\t\t\tprint('R')\n\telse:\n\t\tfor r in range(0, abs(finX - initX)):\n\t\t\tprint('L')\nelif initX == finX:\n\tprint(abs(initY - finY))\n\tif finY > initY:\n\t\tfor r in range(0, abs(initY - finY)):\n\t\t\tprint('D')\n\telse:\n\t\tfor r in range(0, abs(finY - initY)):\n\t\t\tprint('U')\nelse:\n\thoriz = abs(initX - finX)\n\tvert = abs(initY - finY)\n\tif horiz > vert:\n\t\tif initX > finX:\n\t\t\tprint(initX - finX)\n\t\t\tfor i in range(0, abs(initY - finY)):\n\t\t\t\tif initY > finY:\n\t\t\t\t\tprint('LU')\n\t\t\t\telse:\n\t\t\t\t\tprint('LD')\n\t\t\tfor i in range(0, initX - finX - abs(initY - finY)):\n\t\t\t\tprint('L')\n\t\telse:\n\t\t\tprint(finX - initX)\n\t\t\tfor i in range(0, abs(initY - finY)):\n\t\t\t\tif initY > finY:\n\t\t\t\t\tprint('RU')\n\t\t\t\telse:\n\t\t\t\t\tprint('RD')\n\t\t\tfor i in range(0, finX - initX - abs(initY - finY)):\n\t\t\t\tprint('R')\n\telif vert > horiz:\n\t\tif initY > finY:\n\t\t\tprint(initY - finY)\n\t\t\tfor i in range(0, abs(initX - finX)):\n\t\t\t\tif initX > finX:\n\t\t\t\t\tprint('LU')\n\t\t\t\telse:\n\t\t\t\t\tprint('RU')\n\t\t\tfor i in range(0, initY - finY - abs(initX - finX)):\n\t\t\t\tprint('U')\n\t\telse:\n\t\t\tprint(finY - initY)\n\t\t\tfor i in range(0, abs(initX - finX)):\n\t\t\t\tif initX > finX:\n\t\t\t\t\tprint('LD')\n\t\t\t\telse:\n\t\t\t\t\tprint('RD')\n\t\t\tfor i in range(0, finY - initY - abs(initX - finX)):\n\t\t\t\tprint('D')\n\telse:\n\t\tprint(abs(initX - finX))\n\t\tfor i in range(0, abs(initX - finX)):\n\t\t\tif initX > finX:\n\t\t\t\tif initY > finY:\n\t\t\t\t\tprint('LU')\n\t\t\t\telse:\n\t\t\t\t\tprint('LD')\n\t\t\telif initY > finY:\n\t\t\t\tprint('RU')\n\t\t\telse:\n\t\t\t\tprint('RD')\n",
        "alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nstring = input()\nc1 = alphabet.index(string[0]) + 1\nr1 = int(string[1])\nstring = input()\nc2 = alphabet.index(string[0]) + 1\nr2 = int(string[1])\na = abs(c1 - c2)\nb = abs(r1 - r2)\n\ndef x(text):\n\tprint(b)\n\tfor x in range(a):\n\t\tprint(text)\n\tfor x in range(a, b):\n\t\tprint(text[1])\n\ndef y(text):\n\tprint(a)\n\tfor x in range(b):\n\t\tprint(text)\n\tfor x in range(b, a):\n\t\tprint(text[0])\n\ndef xy(text):\n\tif a < b:\n\t\tx(text)\n\telse:\n\t\ty(text)\nif c1 < c2:\n\tif r1 < r2:\n\t\txy('RU')\n\telse:\n\t\txy('RD')\nelif r1 < r2:\n\txy('LU')\nelse:\n\txy('LD')\n",
        "s = input()\nt = input()\nq = 'abcdefgh'\n\ndef f(x):\n\treturn q.index(x)\ns = [f(s[0]), int(s[1])]\nt = [f(t[0]), int(t[1])]\nx = t[0] - s[0]\ny = t[1] - s[1]\nk = min(abs(x), abs(y))\nj = abs(abs(x) - abs(y))\nprint(k + j)\nif (x != 0) * (y != 0):\n\tw = [[[1, 1], 'RU'], [[1, -1], 'RD'], [[-1, 1], 'LU'], [[-1, -1], 'LD']]\n\ta = [x // abs(x), y // abs(y)]\n\tfor i in w:\n\t\tif i[0] == a:\n\t\t\tstep = i[1] + '\\n'\n\t\t\tprint(step * k)\n\t\t\tbreak\nif abs(x) - abs(y) > 0:\n\tnx = x // abs(x)\n\tif nx == 1:\n\t\tprint('R\\n' * j)\n\telse:\n\t\tprint('L\\n' * j)\nelif abs(x) - abs(y) < 0:\n\tny = y // abs(y)\n\tif ny == 1:\n\t\tprint('U\\n' * j)\n\telse:\n\t\tprint('D\\n' * j)\n",
        "G = {'5F': ['5E', '5G', '6F', '4F', '4E', '6E', '4G', '6G'], '1H': ['2G', '1G', '2H'], '6C': ['6B', '6D', '7C', '5C', '5B', '7B', '5D', '7D'], '3D': ['3C', '3E', '4D', '2D', '2C', '4C', '2E', '4E'], '6F': ['6E', '6G', '7F', '5F', '5E', '7E', '5G', '7G'], '8B': ['8A', '8C', '7B', '7C', '7A'], '2H': ['1H', '3H', '2G', '1G', '3G'], '5A': ['4A', '6A', '5B', '4B', '6B'], '3C': ['3B', '3D', '4C', '2C', '2B', '4B', '2D', '4D'], '4F': ['4E', '4G', '5F', '3F', '3E', '5E', '3G', '5G'], '5C': ['5B', '5D', '6C', '4C', '4B', '6B', '4D', '6D'], '6E': ['6D', '6F', '7E', '5E', '5D', '7D', '5F', '7F'], '5D': ['5C', '5E', '6D', '4D', '4C', '6C', '4E', '6E'], '2B': ['2A', '2C', '3B', '1B', '1A', '3A', '1C', '3C'], '8E': ['8D', '8F', '7E', '7F', '7D'], '7C': ['7B', '7D', '8C', '6C', '6B', '8B', '6D', '8D'], '2G': ['2F', '2H', '3G', '1G', '1F', '3F', '1H', '3H'], '3A': ['2A', '4A', '3B', '2B', '4B'], '4D': ['4C', '4E', '5D', '3D', '3C', '5C', '3E', '5E'], '4H': ['3H', '5H', '4G', '3G', '5G'], '6B': ['6A', '6C', '7B', '5B', '5A', '7A', '5C', '7C'], '5B': ['5A', '5C', '6B', '4B', '4A', '6A', '4C', '6C'], '4A': ['3A', '5A', '4B', '3B', '5B'], '8D': ['8C', '8E', '7D', '7E', '7C'], '4B': ['4A', '4C', '5B', '3B', '3A', '5A', '3C', '5C'], '8C': ['8B', '8D', '7C', '7D', '7B'], '8G': ['8F', '8H', '7G', '7H', '7F'], '1C': ['1B', '1D', '2C', '2D', '2B'], '4G': ['4F', '4H', '5G', '3G', '3F', '5F', '3H', '5H'], '8A': ['8B', '7B', '7A'], '6A': ['5A', '7A', '6B', '5B', '7B'], '2F': ['2E', '2G', '3F', '1F', '1E', '3E', '1G', '3G'], '4C': ['4B', '4D', '5C', '3C', '3B', '5B', '3D', '5D'], '7H': ['6H', '8H', '7G', '6G', '8G'], '2E': ['2D', '2F', '3E', '1E', '1D', '3D', '1F', '3F'], '2A': ['1A', '3A', '2B', '1B', '3B'], '2C': ['2B', '2D', '3C', '1C', '1B', '3B', '1D', '3D'], '1B': ['1A', '1C', '2B', '2C', '2A'], '3E': ['3D', '3F', '4E', '2E', '2D', '4D', '2F', '4F'], '5E': ['5D', '5F', '6E', '4E', '4D', '6D', '4F', '6F'], '7D': ['7C', '7E', '8D', '6D', '6C', '8C', '6E', '8E'], '8F': ['8E', '8G', '7F', '7G', '7E'], '3H': ['2H', '4H', '3G', '2G', '4G'], '7B': ['7A', '7C', '8B', '6B', '6A', '8A', '6C', '8C'], '1A': ['1B', '2B', '2A'], '7A': ['6A', '8A', '7B', '6B', '8B'], '7G': ['7F', '7H', '8G', '6G', '6F', '8F', '6H', '8H'], '5G': ['5F', '5H', '6G', '4G', '4F', '6F', '4H', '6H'], '3B': ['3A', '3C', '4B', '2B', '2A', '4A', '2C', '4C'], '7E': ['7D', '7F', '8E', '6E', '6D', '8D', '6F', '8F'], '1G': ['1F', '1H', '2G', '2H', '2F'], '2D': ['2C', '2E', '3D', '1D', '1C', '3C', '1E', '3E'], '6G': ['6F', '6H', '7G', '5G', '5F', '7F', '5H', '7H'], '6D': ['6C', '6E', '7D', '5D', '5C', '7C', '5E', '7E'], '8H': ['7G', '8G', '7H'], '1F': ['1E', '1G', '2F', '2G', '2E'], '5H': ['4H', '6H', '5G', '4G', '6G'], '3G': ['3F', '3H', '4G', '2G', '2F', '4F', '2H', '4H'], '3F': ['3E', '3G', '4F', '2F', '2E', '4E', '2G', '4G'], '1D': ['1C', '1E', '2D', '2E', '2C'], '6H': ['5H', '7H', '6G', '5G', '7G'], '4E': ['4D', '4F', '5E', '3E', '3D', '5D', '3F', '5F'], '1E': ['1D', '1F', '2E', '2F', '2D'], '7F': ['7E', '7G', '8F', '6F', '6E', '8E', '6G', '8G']}\n\ndef BFS(G, start, end):\n\tvisited = [start]\n\tqueue = [start]\n\tlevel_is = {i: -1 for i in G.keys()}\n\tlevel_is[start] = 0\n\twhile queue != []:\n\t\ttop = queue.pop(0)\n\t\tif top == end:\n\t\t\treturn level_is\n\t\tfor i in G[top]:\n\t\t\tif i not in visited:\n\t\t\t\tif level_is[i] == -1:\n\t\t\t\t\tlevel_is[i] = level_is[top] + 1\n\t\t\t\tvisited.append(i)\n\t\t\t\tqueue.append(i)\n\ndef get_path(level_is, end, start):\n\tp = []\n\twhile end != start:\n\t\tp.append(end)\n\t\tfor i in G[end]:\n\t\t\tif level_is[i] == level_is[end] - 1:\n\t\t\t\tend = i\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tpass\n\tp.append(start)\n\treturn p[::-1]\n\ndef moves_generator(path):\n\tmove = []\n\tfor i in range(1, len(path)):\n\t\ta = path[i]\n\t\tb = path[i - 1]\n\t\tif a[0] == b[0]:\n\t\t\tif a[1] < b[1]:\n\t\t\t\tmove.append('L')\n\t\t\telif a[1] > b[1]:\n\t\t\t\tmove.append('R')\n\t\telif a[1] == b[1]:\n\t\t\tif int(a[0]) < int(b[0]):\n\t\t\t\tmove.append('D')\n\t\t\telif int(a[0]) > int(b[0]):\n\t\t\t\tmove.append('U')\n\t\telif int(a[0]) == int(b[0]) + 1 and ord(a[1]) == ord(b[1]) + 1:\n\t\t\tmove.append('RU')\n\t\telif int(a[0]) == int(b[0]) - 1 and ord(a[1]) == ord(b[1]) + 1:\n\t\t\tmove.append('RD')\n\t\telif int(a[0]) == int(b[0]) + 1 and ord(a[1]) == ord(b[1]) - 1:\n\t\t\tmove.append('LU')\n\t\telif int(a[0]) == int(b[0]) - 1 and ord(a[1]) == ord(b[1]) - 1:\n\t\t\tmove.append('LD')\n\tprint(len(move))\n\tfor i in move:\n\t\tprint(i)\nstart = input()\nend = input()\nstart = start.capitalize()[::-1]\nend = end.capitalize()[::-1]\nif end in G[start]:\n\tmoves_generator([start, end])\nelse:\n\tlevel_is = BFS(G, start, end)\n\tpath = get_path(level_is, end, start)\n\tmoves_generator(path)\n",
        "import math\nsrc = input()\nst = [ord(src[0]) - ord('a'), ord(src[1]) - ord('0')]\nsrc = input()\ned = [ord(src[0]) - ord('a'), ord(src[1]) - ord('0')]\nx = ed[0] - st[0]\ny = ed[1] - st[1]\nstep = lambda x, y: abs(x) if abs(x) > abs(y) else abs(y)\nprint(step(x, y))\nwhile x != 0 or y != 0:\n\tres = ''\n\tif x != 0:\n\t\tif x > 0:\n\t\t\tx -= 1\n\t\t\tres += 'R'\n\t\telse:\n\t\t\tx += 1\n\t\t\tres += 'L'\n\tif y != 0:\n\t\tif y > 0:\n\t\t\ty -= 1\n\t\t\tres += 'U'\n\t\telse:\n\t\t\ty += 1\n\t\t\tres += 'D'\n\tprint(res)\n",
        "(s, t) = (input(), input())\nrow_diff = int(s[1]) - int(t[1])\nrow_move = ''\nif row_diff > 0:\n\trow_move = 'D'\nelif row_diff < 0:\n\trow_move = 'U'\ncol_diff = ord(s[0]) - ord(t[0])\ncol_move = ''\nif col_diff > 0:\n\tcol_move = 'L'\nelif col_diff < 0:\n\tcol_move = 'R'\nprint(max(abs(row_diff), abs(col_diff)))\n(i, j) = (0, 0)\nwhile i < abs(row_diff) and j < abs(col_diff):\n\tprint(col_move + row_move)\n\ti += 1\n\tj += 1\nwhile i < abs(row_diff):\n\tprint(row_move)\n\ti += 1\nwhile j < abs(col_diff):\n\tprint(col_move)\n\tj += 1\n",
        "from sys import stdin, stdout, setrecursionlimit\ninput = stdin.readline\nflush = stdout.flush\nOUT = []\n\ndef write(item, sep=' '):\n\tif type(item) is int:\n\t\tOUT.append(str(item))\n\telif type(item) is list:\n\t\tif type(item[0]) is int:\n\t\t\tOUT.append(sep.join(map(str, item)))\n\t\telse:\n\t\t\tOUT.append(sep.join(item))\n\telse:\n\t\tOUT.append(item)\n\ndef PRINT():\n\tprint('\\n'.join(OUT))\nGI = lambda : int(input())\nGS = lambda : input()[:-1]\ngi = lambda : list(map(int, input().split()))\ngs = lambda : input().split()\n(x, y) = GS()\nx = ord(x) - 97\ny = int(y) - 1\n(a, b) = GS()\na = ord(a) - 97\nb = int(b) - 1\narr = []\nwhile x != a and y != b:\n\tif x < a and y < b:\n\t\tarr.append('RU')\n\t\tx += 1\n\t\ty += 1\n\telif x < a and y > b:\n\t\tarr.append('RD')\n\t\tx += 1\n\t\ty -= 1\n\telif x > a and y < b:\n\t\tarr.append('LU')\n\t\tx -= 1\n\t\ty += 1\n\telse:\n\t\tarr.append('LD')\n\t\tx -= 1\n\t\ty -= 1\nwhile x != a:\n\tif x < a:\n\t\tarr.append('R')\n\t\tx += 1\n\telse:\n\t\tarr.append('L')\n\t\tx -= 1\nwhile y != b:\n\tif y < b:\n\t\tarr.append('U')\n\t\ty += 1\n\telse:\n\t\tarr.append('D')\n\t\ty -= 1\nwrite(len(arr))\nfor i in arr:\n\twrite(i)\nPRINT()\n",
        "def toCoord(pair):\n\tcol = ord(pair[0]) - ord('a')\n\trow = int(pair[1]) - 1\n\treturn (row, col)\n\ndef diff(orig, dest):\n\treturn (dest[0] - orig[0], dest[1] - orig[1])\n\ndef man_dist(df):\n\treturn abs(df[0]) + abs(df[1])\n\ndef dist(df):\n\treturn max(abs(df[0]), abs(df[1]))\n\ndef step(curr, move):\n\treturn (curr[0] + move[0], curr[1] + move[1])\n\ndef valid(pos):\n\treturn pos[0] >= 0 and pos[1] >= 0 and (pos[0] < 8) and (pos[1] < 8)\norig = toCoord(input())\ndest = toCoord(input())\nprint(dist(diff(orig, dest)))\nmoves = {(1, 1): 'RU', (-1, 1): 'RD', (1, -1): 'LU', (-1, -1): 'LD', (1, 0): 'U', (0, 1): 'R', (-1, 0): 'D', (0, -1): 'L'}\nwhile orig != dest:\n\tbest = float('inf')\n\tmove = ''\n\tansw = None\n\tfor m in moves:\n\t\tnxt = step(orig, m)\n\t\tdf = diff(nxt, dest)\n\t\tif dist(df) < best and valid(nxt):\n\t\t\tbest = dist(df)\n\t\t\tmove = moves[m]\n\t\t\tansw = nxt\n\tprint(move)\n\torig = answ\n",
        "s1 = input()\ns2 = input()\na1 = ord(s1[0])\na2 = int(s1[1])\nb1 = ord(s2[0])\nb2 = int(s2[1])\na = []\ndem = 0\nwhile a1 != b1 or a2 != b2:\n\tif a1 < b1 and a2 < b2:\n\t\ta1 += 1\n\t\ta2 += 1\n\t\ta.append('RU')\n\t\tdem += 1\n\telif a1 < b1 and a2 > b2:\n\t\ta1 += 1\n\t\ta2 -= 1\n\t\ta.append('RD')\n\t\tdem += 1\n\telif a1 > b1 and a2 < b2:\n\t\ta1 -= 1\n\t\ta2 += 1\n\t\ta.append('LU')\n\t\tdem += 1\n\telif a1 > b1 and a2 > b2:\n\t\ta1 -= 1\n\t\ta2 -= 1\n\t\ta.append('LD')\n\t\tdem += 1\n\telif a1 == b1 and a2 < b2:\n\t\ta2 += 1\n\t\ta.append('U')\n\t\tdem += 1\n\telif a1 == b1 and a2 > b2:\n\t\ta2 -= 1\n\t\ta.append('D')\n\t\tdem += 1\n\telif a1 < b1 and a2 == b2:\n\t\ta1 += 1\n\t\ta.append('R')\n\t\tdem += 1\n\telif a1 > b1 and a2 == b2:\n\t\ta1 -= 1\n\t\ta.append('L')\n\t\tdem += 1\nprint(dem)\nfor i in range(len(a)):\n\tprint(a[i])\n",
        "(a, b) = (input(), input())\n(m, n) = (ord(a[i]) - ord(b[i]) for i in range(0, 2))\np = max(abs(m), abs(n))\nprint(p)\nwhile m != 0 or n != 0:\n\tr = ''\n\tif m < 0:\n\t\tr = 'R'\n\t\tm += 1\n\telif m > 0:\n\t\tr = 'L'\n\t\tm -= 1\n\tif n < 0:\n\t\tr += 'U'\n\t\tn += 1\n\telif n > 0:\n\t\tr += 'D'\n\t\tn -= 1\n\tprint(r)\n",
        "s1 = input()\ns2 = input()\nx1 = ord(s1[0]) - ord('a')\ny1 = int(s1[1]) - 1\nx2 = ord(s2[0]) - ord('a')\ny2 = int(s2[1]) - 1\ncnt = 0\nd = []\nwhile x1 != x2 or y1 != y2:\n\tcnt += 1\n\tcx = ''\n\tcy = ''\n\tif x1 > x2:\n\t\tx1 -= 1\n\t\tcx = 'L'\n\telif x2 > x1:\n\t\tx1 += 1\n\t\tcx = 'R'\n\tif y1 > y2:\n\t\ty1 -= 1\n\t\tcy = 'D'\n\telif y2 > y1:\n\t\ty1 += 1\n\t\tcy = 'U'\n\td.append(cx + cy)\nprint(cnt)\nfor s in d:\n\tprint(s)\n",
        "Answer = []\n(Origin, Destination) = (input(), input())\nwhile Origin != Destination:\n\tif Origin[0] == Destination[0]:\n\t\tif Destination[1] > Origin[1]:\n\t\t\tAnswer.append('U')\n\t\t\tOrigin = Origin[0] + str(int(Origin[1]) + 1)\n\t\telse:\n\t\t\tAnswer.append('D')\n\t\t\tOrigin = Origin[0] + str(int(Origin[1]) - 1)\n\telif Origin[1] == Destination[1]:\n\t\tif Destination[0] > Origin[0]:\n\t\t\tAnswer.append('R')\n\t\t\tOrigin = chr(ord(Origin[0]) + 1) + Origin[1]\n\t\telse:\n\t\t\tAnswer.append('L')\n\t\t\tOrigin = chr(ord(Origin[0]) - 1) + Origin[1]\n\telif Destination[0] > Origin[0] and Destination[1] > Origin[1]:\n\t\tAnswer.append('RU')\n\t\tOrigin = chr(ord(Origin[0]) + 1) + str(int(Origin[1]) + 1)\n\telif Destination[0] > Origin[0] and Destination[1] < Origin[1]:\n\t\tAnswer.append('RD')\n\t\tOrigin = chr(ord(Origin[0]) + 1) + str(int(Origin[1]) - 1)\n\telif Destination[0] < Origin[0] and Destination[1] < Origin[1]:\n\t\tAnswer.append('LD')\n\t\tOrigin = chr(ord(Origin[0]) - 1) + str(int(Origin[1]) - 1)\n\telse:\n\t\tAnswer.append('LU')\n\t\tOrigin = chr(ord(Origin[0]) - 1) + str(int(Origin[1]) + 1)\nprint(len(Answer), *Answer, sep='\\n')\n",
        "s = list(map(ord, input()))\nt = list(map(ord, input()))\nans = max(abs(s[0] - t[0]), abs(s[1] - t[1]))\nprint(ans)\nwhile s != t:\n\tif s[0] - t[0] > 0 and s[1] - t[1] > 0:\n\t\tprint('LD')\n\t\t(s[0], s[1]) = (s[0] - 1, s[1] - 1)\n\telif s[0] - t[0] > 0 and s[1] - t[1] < 0:\n\t\tprint('LU')\n\t\t(s[0], s[1]) = (s[0] - 1, s[1] + 1)\n\telif s[0] - t[0] < 0 and s[1] - t[1] > 0:\n\t\tprint('RD')\n\t\t(s[0], s[1]) = (s[0] + 1, s[1] - 1)\n\telif s[0] - t[0] < 0 and s[1] - t[1] < 0:\n\t\tprint('RU')\n\t\t(s[0], s[1]) = (s[0] + 1, s[1] + 1)\n\telif s[0] - t[0] > 0:\n\t\tprint('L')\n\t\ts[0] = s[0] - 1\n\telif s[0] - t[0] < 0:\n\t\tprint('R')\n\t\ts[0] = s[0] + 1\n\telif s[1] - t[1] > 0:\n\t\tprint('D')\n\t\ts[1] = s[1] - 1\n\telif s[1] - t[1] < 0:\n\t\tprint('U')\n\t\ts[1] = s[1] + 1\n",
        "currPos = input()\ntargetPos = input()\nstep = []\ncurrCol = currPos[0]\ncurrRow = currPos[1]\nwhile True:\n\tif ord(currCol) < ord(targetPos[0]) and ord(currRow) < ord(targetPos[1]):\n\t\tstep.append('RU')\n\t\tcurrCol = chr(ord(currCol) + 1)\n\t\tcurrRow = chr(ord(currRow) + 1)\n\telif ord(currCol) < ord(targetPos[0]) and ord(currRow) == ord(targetPos[1]):\n\t\tstep.append('R')\n\t\tcurrCol = chr(ord(currCol) + 1)\n\telif ord(currCol) < ord(targetPos[0]) and ord(currRow) > ord(targetPos[1]):\n\t\tstep.append('RD')\n\t\tcurrCol = chr(ord(currCol) + 1)\n\t\tcurrRow = chr(ord(currRow) - 1)\n\telif ord(currCol) == ord(targetPos[0]) and ord(currRow) > ord(targetPos[1]):\n\t\tstep.append('D')\n\t\tcurrRow = chr(ord(currRow) - 1)\n\telif ord(currCol) > ord(targetPos[0]) and ord(currRow) > ord(targetPos[1]):\n\t\tstep.append('LD')\n\t\tcurrCol = chr(ord(currCol) - 1)\n\t\tcurrRow = chr(ord(currRow) - 1)\n\telif ord(currCol) > ord(targetPos[0]) and ord(currRow) == ord(targetPos[1]):\n\t\tstep.append('L')\n\t\tcurrCol = chr(ord(currCol) - 1)\n\telif ord(currCol) > ord(targetPos[0]) and ord(currRow) < ord(targetPos[1]):\n\t\tstep.append('LU')\n\t\tcurrCol = chr(ord(currCol) - 1)\n\t\tcurrRow = chr(ord(currRow) + 1)\n\telif ord(currCol) == ord(targetPos[0]) and ord(currRow) < ord(targetPos[1]):\n\t\tstep.append('U')\n\t\tcurrRow = chr(ord(currRow) + 1)\n\tif ord(currCol) == ord(targetPos[0]) and ord(currRow) == ord(targetPos[1]):\n\t\tbreak\nprint(len(step))\nfor element in step:\n\tprint(element)\n",
        "current = input()\ntarget = input()\nmx = -ord(current[0]) + ord(target[0])\nmy = -int(current[1]) + int(target[1])\nmoves_total = abs(mx) + abs(my) - min(abs(mx), abs(my))\nprint(moves_total)\nwhile mx != 0 and my != 0:\n\tif mx > 0 and my > 0:\n\t\tprint('RU')\n\t\tmx -= 1\n\t\tmy -= 1\n\telif mx < 0 and my < 0:\n\t\tprint('LD')\n\t\tmx += 1\n\t\tmy += 1\n\telif mx > 0 and my < 0:\n\t\tprint('RD')\n\t\tmx -= 1\n\t\tmy += 1\n\telse:\n\t\tprint('LU')\n\t\tmx += 1\n\t\tmy -= 1\nif mx > 0:\n\twhile mx:\n\t\tprint('R')\n\t\tmx -= 1\nelif mx < 0:\n\twhile mx:\n\t\tprint('L')\n\t\tmx += 1\nelif my > 0:\n\twhile my:\n\t\tprint('U')\n\t\tmy -= 1\nelif my < 0:\n\twhile my:\n\t\tprint('D')\n\t\tmy += 1\n",
        "(a, b) = (input(), input())\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\na = str(d[a[0]]) + a[1]\nb = str(d[b[0]]) + b[1]\n(r, u) = (int(b[0]) - int(a[0]), int(b[1]) - int(a[1]))\nm = max(abs(r), abs(u))\nprint(m)\nfor _ in range(m):\n\tif r > 0:\n\t\tprint('R', end='')\n\t\tr -= 1\n\telif r < 0:\n\t\tprint('L', end='')\n\t\tr += 1\n\tif u > 0:\n\t\tprint('U', end='')\n\t\tu -= 1\n\telif u < 0:\n\t\tprint('D', end='')\n\t\tu += 1\n\tprint()\n",
        "s = input()\nxs = ord(s[0]) - ord('a')\nys = int(s[1])\nt = input()\nxt = ord(t[0]) - ord('a')\nyt = int(t[1])\nans = []\nwhile xs < xt and ys < yt:\n\tans.append('RU')\n\txs += 1\n\tys += 1\nwhile xs > xt and ys < yt:\n\tans.append('LU')\n\txs -= 1\n\tys += 1\nwhile xs < xt and ys > yt:\n\tans.append('RD')\n\txs += 1\n\tys -= 1\nwhile xs > xt and ys > yt:\n\tans.append('LD')\n\txs -= 1\n\tys -= 1\nwhile xs < xt:\n\tans.append('R')\n\txs += 1\nwhile xs > xt:\n\tans.append('L')\n\txs -= 1\nwhile ys < yt:\n\tans.append('U')\n\tys += 1\nwhile ys > yt:\n\tans.append('D')\n\tys -= 1\nprint(len(ans))\nprint(*ans, sep='\\n')\n",
        "s = list(input())\ne = list(input())\nhoriz = ord(s[0]) - ord(e[0])\nverti = int(s[1]) - int(e[1])\nif horiz >= 0 and verti >= 0:\n\tif horiz >= verti:\n\t\tprint(horiz)\n\t\tfor i in range(verti):\n\t\t\tprint('LD')\n\t\tfor i in range(horiz - verti):\n\t\t\tprint('L')\n\telse:\n\t\tprint(verti)\n\t\tfor i in range(horiz):\n\t\t\tprint('LD')\n\t\tfor i in range(verti - horiz):\n\t\t\tprint('D')\nelif horiz >= 0 and verti < 0:\n\tverti *= -1\n\tif horiz >= verti:\n\t\tprint(horiz)\n\t\tfor i in range(verti):\n\t\t\tprint('LU')\n\t\tfor i in range(horiz - verti):\n\t\t\tprint('L')\n\telse:\n\t\tprint(verti)\n\t\tfor i in range(horiz):\n\t\t\tprint('LU')\n\t\tfor i in range(verti - horiz):\n\t\t\tprint('U')\nelif horiz < 0 and verti < 0:\n\tverti *= -1\n\thoriz *= -1\n\tif horiz >= verti:\n\t\tprint(horiz)\n\t\tfor i in range(verti):\n\t\t\tprint('RU')\n\t\tfor i in range(horiz - verti):\n\t\t\tprint('R')\n\telse:\n\t\tprint(verti)\n\t\tfor i in range(horiz):\n\t\t\tprint('RU')\n\t\tfor i in range(verti - horiz):\n\t\t\tprint('U')\nelif horiz < 0 and verti >= 0:\n\thoriz *= -1\n\tif horiz >= verti:\n\t\tprint(horiz)\n\t\tfor i in range(verti):\n\t\t\tprint('RD')\n\t\tfor i in range(horiz - verti):\n\t\t\tprint('R')\n\telse:\n\t\tprint(verti)\n\t\tfor i in range(horiz):\n\t\t\tprint('RD')\n\t\tfor i in range(verti - horiz):\n\t\t\tprint('D')\n",
        "ox = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\ninp1 = input()\ninp2 = input()\n(x1, x2, y1, y2) = (ox[inp1[0]], ox[inp2[0]], int(inp1[1]), int(inp2[1]))\nrez = []\ns = ''\nwhile x1 != x2 and y1 != y2:\n\tif x1 > x2:\n\t\ts = 'L'\n\t\tx1 -= 1\n\telse:\n\t\ts = 'R'\n\t\tx1 += 1\n\tif y1 > y2:\n\t\ts += 'D'\n\t\ty1 -= 1\n\telse:\n\t\ts += 'U'\n\t\ty1 += 1\n\trez.append(s)\n\ts = ''\nwhile x1 != x2:\n\tif x1 > x2:\n\t\ts = 'L'\n\t\tx1 -= 1\n\telse:\n\t\ts = 'R'\n\t\tx1 += 1\n\trez.append(s)\n\ts = ''\nwhile y1 != y2:\n\tif y1 > y2:\n\t\ts += 'D'\n\t\ty1 -= 1\n\telse:\n\t\ts += 'U'\n\t\ty1 += 1\n\trez.append(s)\n\ts = ''\nprint(len(rez))\n[print(i) for i in rez]\n",
        "import sys\nimport heapq\nORD_A = ord('a')\nDIRECTIONS4 = {'L': (-1, 0), 'D': (0, 1), 'R': (1, 0), 'U': (0, -1)}\nDIRECTIONS8 = dict(DIRECTIONS4)\nDIRECTIONS8.update({'LD': (-1, 1), 'RD': (1, 1), 'RU': (1, -1), 'LU': (-1, -1)})\n\nclass Grid:\n\n\tdef __init__(self, width, height, allow_diagonals=False):\n\t\tself.width = width\n\t\tself.height = height\n\t\tself.allow_diagonals = allow_diagonals\n\n\tdef neighbors(self, node):\n\t\tresults = []\n\t\t(x, y) = node\n\t\tdirections = DIRECTIONS8 if self.allow_diagonals else DIRECTIONS4\n\t\tfor (k, (dx, dy)) in directions.items():\n\t\t\t(nx, ny) = (x + dx, y + dy)\n\t\t\tif 0 <= nx < self.width and 0 <= ny < self.height:\n\t\t\t\tresults.append(((nx, ny), k))\n\t\treturn results\n\nclass PriorityQueue:\n\n\tdef __init__(self):\n\t\tself.heap = []\n\n\tdef empty(self):\n\t\treturn len(self.heap) == 0\n\n\tdef add(self, item, cost):\n\t\theapq.heappush(self.heap, (cost, item))\n\n\tdef pop(self):\n\t\treturn heapq.heappop(self.heap)[1]\n\ndef reconstruct_path(came_from, start, goal):\n\tcurrent = goal\n\tpath = []\n\tmoves = []\n\twhile current != start:\n\t\tpath.append(current)\n\t\tmoves.append(came_from[current][1])\n\t\tcurrent = came_from[current][0]\n\tpath.append(start)\n\tpath.reverse()\n\tmoves.reverse()\n\treturn (path, moves)\n\ndef diagonal_distance_h(goal, node, D, D2):\n\tdx = abs(goal[0] - node[0])\n\tdy = abs(goal[1] - node[1])\n\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\ndef Chebyshev_distance_h(goal, node):\n\treturn diagonal_distance_h(goal, node, 1, 1)\n\ndef greedy_best_first_search(grid, start, goal, costfn):\n\tfrontier = PriorityQueue()\n\tfrontier.add(start, 0)\n\tcame_from = {}\n\tcame_from[start] = None\n\twhile not frontier.empty():\n\t\tcurrent = frontier.pop()\n\t\tif current == goal:\n\t\t\tbreak\n\t\tfor (child, move) in grid.neighbors(current):\n\t\t\tif child not in came_from:\n\t\t\t\tfrontier.add(child, costfn(goal, child))\n\t\t\t\tcame_from[child] = (current, move)\n\treturn came_from\n\ndef convert_chess_coordinates(coord):\n\treturn (ord(coord[0]) - ORD_A, 8 - int(coord[1]))\n\ndef main():\n\tstart = convert_chess_coordinates(sys.stdin.readline().strip())\n\tgoal = convert_chess_coordinates(sys.stdin.readline().strip())\n\tchess = Grid(8, 8, allow_diagonals=True)\n\tmoves = reconstruct_path(greedy_best_first_search(chess, start, goal, Chebyshev_distance_h), start, goal)[1]\n\tsys.stdout.write(str(len(moves)) + '\\n')\n\tsys.stdout.write('\\n'.join(moves) + '\\n')\nmain()\n",
        "tmp = input()\n(sx, sy) = (ord(tmp[0]) - 97, int(tmp[1]) - 1)\ntmp = input()\n(ex, ey) = (ord(tmp[0]) - 97, int(tmp[1]) - 1)\n(dx, dy) = (ex - sx, ey - sy)\nh = ['R' if dx > 0 else 'L'] * max(dx, -dx)\nv = ['U' if dy > 0 else 'D'] * max(dy, -dy)\nr = max(len(h), len(v))\nprint(r)\nfor i in range(r):\n\ts = ''\n\tif len(h) > 0:\n\t\ts += h.pop(0)\n\tif len(v) > 0:\n\t\ts += v.pop(0)\n\tprint(s)\n",
        "start = input()\ntarget = input()\nhorizontal_movement = ord(start[0]) - ord(target[0])\nvertical_movement = ord(start[1]) - ord(target[1])\nprint(max(horizontal_movement, -horizontal_movement, vertical_movement, -vertical_movement))\nwhile horizontal_movement != 0 or vertical_movement != 0:\n\tmove = ''\n\tif horizontal_movement > 0:\n\t\tmove += 'L'\n\t\thorizontal_movement -= 1\n\tif horizontal_movement < 0:\n\t\tmove += 'R'\n\t\thorizontal_movement += 1\n\tif vertical_movement > 0:\n\t\tmove += 'D'\n\t\tvertical_movement -= 1\n\tif vertical_movement < 0:\n\t\tmove += 'U'\n\t\tvertical_movement += 1\n\tprint(move)\n",
        "a = list(input())\nb = list(input())\nc = ['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\na_h = c.index(a[0])\na_v = int(a[1])\nb_h = c.index(b[0])\nb_v = int(b[1])\np = [a_h - b_h, a_v - b_v]\nd = [abs(p[0]), abs(p[1])]\ntotal = max(d)\nprint(total)\nwhile p[0] != 0 or p[1] != 0:\n\tif p[0] < 0 and p[1] < 0:\n\t\tprint('LU')\n\t\tp[0] += 1\n\t\tp[1] += 1\n\telif p[0] > 0 and p[1] < 0:\n\t\tprint('RU')\n\t\tp[0] -= 1\n\t\tp[1] += 1\n\telif p[0] < 0 and p[1] > 0:\n\t\tprint('LD')\n\t\tp[0] += 1\n\t\tp[1] -= 1\n\telif p[0] > 0 and p[1] > 0:\n\t\tprint('RD')\n\t\tp[0] -= 1\n\t\tp[1] -= 1\n\telif p[0] == 0 and p[1] < 0:\n\t\tprint('U')\n\t\tp[1] += 1\n\telif p[0] == 0 and p[1] > 0:\n\t\tprint('D')\n\t\tp[1] -= 1\n\telif p[0] < 0 and p[1] == 0:\n\t\tprint('L')\n\t\tp[0] += 1\n\telif p[0] > 0 and p[1] == 0:\n\t\tprint('R')\n\t\tp[0] -= 1\n",
        "s = input()\nt = input()\nn = 0\na = []\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\nt = [ord(t[0]) - ord('a') + 1, int(t[1])]\nwhile s != t:\n\tif s[0] < t[0] and s[1] < t[1]:\n\t\ta.append('RU')\n\t\ts[0] += 1\n\t\ts[1] += 1\n\telif s[0] < t[0] and s[1] > t[1]:\n\t\ta.append('RD')\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\telif s[0] > t[0] and s[1] < t[1]:\n\t\ta.append('LU')\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\telif s[0] > t[0] and s[1] > t[1]:\n\t\ta.append('LD')\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\telif s[0] == t[0] and s[1] > t[1]:\n\t\ta.append('D')\n\t\ts[1] -= 1\n\telif s[0] == t[0] and s[1] < t[1]:\n\t\ta.append('U')\n\t\ts[1] += 1\n\telif s[0] > t[0] and s[1] == t[1]:\n\t\ta.append('L')\n\t\ts[0] -= 1\n\telif s[0] < t[0] and s[1] == t[1]:\n\t\ta.append('R')\n\t\ts[0] += 1\nprint(len(a))\nfor s in a:\n\tprint(s)\n",
        "from collections import deque\nimport sys\ns = sys.stdin.readline().strip()\ns = [int(s[1]), ord(s[0]) - 96]\nt = sys.stdin.readline().strip()\nt = [int(t[1]), ord(t[0]) - 96]\nmoves_names = ['L', 'R', 'U', 'D', 'LU', 'LD', 'RU', 'RD']\nmoves = [[0, -1], [0, 1], [-1, 0], [1, 0], [-1, -1], [1, -1], [-1, 1], [1, 1]]\ny_diff = s[0] - t[0]\nx_diff = s[1] - t[1]\nprint(max(abs(y_diff), abs(x_diff)))\nwhile y_diff != 0 or x_diff != 0:\n\ty_move = 0\n\tif y_diff > 0:\n\t\ty_move = 1\n\telif y_diff < 0:\n\t\ty_move = -1\n\tx_move = 0\n\tif x_diff > 0:\n\t\tx_move = 1\n\telif x_diff < 0:\n\t\tx_move = -1\n\tmove_i = moves.index([y_move, -x_move])\n\tprint(moves_names[move_i])\n\ty_diff -= y_move\n\tx_diff -= x_move\n",
        "from sys import stdin, stdout\nimport math\nfrom itertools import permutations, combinations\nfrom collections import defaultdict\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\ndef L():\n\treturn list(map(int, stdin.readline().split()))\n\ndef In():\n\treturn map(int, stdin.readline().split())\n\ndef I():\n\treturn int(stdin.readline())\nP = 1000000007\n\ndef main():\n\ts1 = input()\n\ts2 = input()\n\t(x, y) = (ord(s1[0]) - ord(s2[0]), int(s1[1]) - int(s2[1]))\n\tmx = max(x, y, -x, -y)\n\tprint(mx)\n\twhile x != 0 or y != 0:\n\t\tr = ''\n\t\tif x > 0:\n\t\t\tr = 'L'\n\t\t\tx -= 1\n\t\tif x < 0:\n\t\t\tr = 'R'\n\t\t\tx += 1\n\t\tif y > 0:\n\t\t\tr += 'D'\n\t\t\ty -= 1\n\t\tif y < 0:\n\t\t\tr += 'U'\n\t\t\ty += 1\n\t\tprint(r)\nmain()\n",
        "def dig(s):\n\treturn [ord(s[0]) - 96, int(s[1])]\n(b, a) = dig(input())\n(d, c) = dig(input())\nl = max(abs(a - c), abs(b - d))\nprint(l)\ne = [''] * l\nfor i in range(abs(b - d)):\n\tif b > d:\n\t\te[i] = 'L'\n\telse:\n\t\te[i] = 'R'\nfor i in range(abs(a - c)):\n\tif a > c:\n\t\te[i] = e[i] + 'D'\n\telse:\n\t\te[i] = e[i] + 'U'\nprint('\\n'.join(e))\n",
        "n = input()\nm = input()\nx0 = ord(n[0])\ny0 = ord(n[1])\nx1 = ord(m[0])\ny1 = ord(m[1])\nk = abs(x0 - x1)\nu = abs(y0 - y1)\nprint(min(k, u) + abs(k - u))\nwhile True:\n\tif x0 < x1:\n\t\tprint('R', end='')\n\t\tx0 = x0 + 1\n\telif x0 > x1:\n\t\tprint('L', end='')\n\t\tx0 = x0 - 1\n\tif y0 < y1:\n\t\tprint('U', end='')\n\t\ty0 = y0 + 1\n\telif y0 > y1:\n\t\tprint('D', end='')\n\t\ty0 = y0 - 1\n\tprint('')\n\tif x0 == x1 and y0 == y1:\n\t\tbreak\n",
        "a = input()\nb = input()\nc = int(a[-1])\nd = int(b[-1])\na = a[0]\nb = b[0]\nk = abs(c - d)\no = abs(ord(b) - ord(a))\nmi = min(k, o)\nprint(k + o - mi)\nif a >= b and c >= d:\n\tfor i in range(mi):\n\t\tprint('LD')\n\tfor i in range(k - mi):\n\t\tprint('D')\n\tfor i in range(o - mi):\n\t\tprint('L')\nelif a >= b and c < d:\n\tfor i in range(mi):\n\t\tprint('LU')\n\tfor i in range(k - mi):\n\t\tprint('U')\n\tfor i in range(o - mi):\n\t\tprint('L')\nelif a < b and c <= d:\n\tfor i in range(mi):\n\t\tprint('RU')\n\tfor i in range(k - mi):\n\t\tprint('U')\n\tfor i in range(o - mi):\n\t\tprint('R')\nelif a <= b and c >= d:\n\tfor i in range(mi):\n\t\tprint('RD')\n\tfor i in range(k - mi):\n\t\tprint('D')\n\tfor i in range(o - mi):\n\t\tprint('R')\n",
        "def coordinates():\n\ts = input()\n\treturn (' abcdefgh'.index(s[0]), int(s[1]))\n(sx, sy) = coordinates()\n(tx, ty) = coordinates()\nres = ''\ncnt = 0\nwhile sx != tx or sy != ty:\n\tcnt += 1\n\tif sx < tx:\n\t\tres += 'R'\n\t\tsx += 1\n\telif sx > tx:\n\t\tres += 'L'\n\t\tsx -= 1\n\tif sy < ty:\n\t\tres += 'U'\n\t\tsy += 1\n\telif sy > ty:\n\t\tres += 'D'\n\t\tsy -= 1\n\tres += '\\n'\nprint(cnt)\nprint(res)\n",
        "s = str(input())\ns1 = s[:1]\nb = int(s[1:])\nif s1 == 'h':\n\ta = 8\nif s1 == 'g':\n\ta = 7\nif s1 == 'f':\n\ta = 6\nif s1 == 'e':\n\ta = 5\nif s1 == 'd':\n\ta = 4\nif s1 == 'c':\n\ta = 3\nif s1 == 'b':\n\ta = 2\nif s1 == 'a':\n\ta = 1\nt = str(input())\nt1 = t[:1]\nb1 = int(t[1:])\nif t1 == 'h':\n\ta1 = 8\nif t1 == 'g':\n\ta1 = 7\nif t1 == 'f':\n\ta1 = 6\nif t1 == 'e':\n\ta1 = 5\nif t1 == 'd':\n\ta1 = 4\nif t1 == 'c':\n\ta1 = 3\nif t1 == 'b':\n\ta1 = 2\nif t1 == 'a':\n\ta1 = 1\n\ndef countthemerges(a, b, a1, b1):\n\tq = 0\n\tc = True\n\twhile c:\n\t\tif a < a1 and b > b1:\n\t\t\ta = a + 1\n\t\t\tb = b - 1\n\t\t\tq += 1\n\t\tif a > a1 and b > b1:\n\t\t\ta = a - 1\n\t\t\tb = b - 1\n\t\t\tq += 1\n\t\tif a < a1 and b < b1:\n\t\t\ta = a + 1\n\t\t\tb = b + 1\n\t\t\tq += 1\n\t\tif a > a1 and b < b1:\n\t\t\ta = a - 1\n\t\t\tb = b + 1\n\t\t\tq += 1\n\t\tif a == a1 and b > b1:\n\t\t\tb = b - 1\n\t\t\tq += 1\n\t\tif a == a1 and b < b1:\n\t\t\tb = b + 1\n\t\t\tq += 1\n\t\tif b == b1 and a1 > a:\n\t\t\ta = a + 1\n\t\t\tq += 1\n\t\tif b == b1 and a > a1:\n\t\t\ta = a - 1\n\t\t\tq += 1\n\t\tif a == a1 and b1 == b:\n\t\t\treturn q\n\ndef printthePosibitities(a, b, a1, b1):\n\tc = True\n\twhile c:\n\t\tif a < a1 and b > b1:\n\t\t\tprint('RD')\n\t\t\ta = a + 1\n\t\t\tb = b - 1\n\t\tif a > a1 and b > b1:\n\t\t\tprint('LD')\n\t\t\ta = a - 1\n\t\t\tb = b - 1\n\t\tif a < a1 and b < b1:\n\t\t\tprint('RU')\n\t\t\ta = a + 1\n\t\t\tb = b + 1\n\t\tif a > a1 and b < b1:\n\t\t\tprint('LU')\n\t\t\ta = a - 1\n\t\t\tb = b + 1\n\t\tif a == a1 and b > b1:\n\t\t\tprint('D')\n\t\t\tb = b - 1\n\t\tif a == a1 and b < b1:\n\t\t\tprint('U')\n\t\t\tb = b + 1\n\t\tif b == b1 and a1 > a:\n\t\t\tprint('R')\n\t\t\ta = a + 1\n\t\tif b == b1 and a > a1:\n\t\t\tprint('L')\n\t\t\ta = a - 1\n\t\tif a == a1 and b1 == b:\n\t\t\tc = False\nprint(countthemerges(a, b, a1, b1))\nprintthePosibitities(a, b, a1, b1)\n",
        "import sys\nimport io\nimport os\ntotal = 0\nfailed = 0\n\ndef debug(*args):\n\tif 'LOCALTEST' in os.environ:\n\t\tprint(*args, file=sys.stderr)\n\ndef run(test, res):\n\tx = io.StringIO()\n\twith io.StringIO(test) as sys.stdin:\n\t\twith x as sys.stdout:\n\t\t\twork()\n\t\t\tz = x.getvalue().strip()\n\tsys.stdout = sys.__stdout__\n\tprint('Passed?', z == res)\n\tprint('Expected: ', res)\n\tprint('Actual  : ', z)\n\tglobal total, failed\n\ttotal += 1\n\tfailed += 1 if z != res else 0\n\ndef work():\n\ts = input()\n\tt = input()\n\tdx = ord(s[0]) - ord(t[0])\n\tdy = int(s[1]) - int(t[1])\n\tdebug(dx, dy)\n\tres = []\n\tfor i in range(min(abs(dx), abs(dy))):\n\t\tres.append(('L' if dx > 0 else 'R') + ('D' if dy > 0 else 'U'))\n\tfor i in range(abs(abs(dx) - abs(dy))):\n\t\tif abs(dx) > abs(dy):\n\t\t\tres.append('L' if dx > 0 else 'R')\n\t\telse:\n\t\t\tres.append('D' if dy > 0 else 'U')\n\tprint(len(res))\n\tfor i in res:\n\t\tprint(i)\n\ndef test():\n\trun('a8\\nh1', '7\\nRD\\nRD\\nRD\\nRD\\nRD\\nRD\\nRD')\n\trun('a1\\nh1', '7\\nR\\nR\\nR\\nR\\nR\\nR\\nR')\nif 'LOCALTEST' in os.environ:\n\ttest()\n\tprint('\\n Result: %s (%d total, %d failed)' % ('FAILED' if failed > 0 else 'PASSED', total, failed))\nelse:\n\twork()\n",
        "start = str(input())\nend = str(input())\nx = ord(start[0]) - ord(end[0])\ny = int(start[1]) - int(end[1])\nprint(max(x, y, -x, -y))\nwhile x != 0 or y != 0:\n\tstr = ''\n\tif x < 0:\n\t\tstr += 'R'\n\t\tx += 1\n\tif x > 0:\n\t\tstr += 'L'\n\t\tx -= 1\n\tif y < 0:\n\t\tstr += 'U'\n\t\ty += 1\n\tif y > 0:\n\t\tstr += 'D'\n\t\ty -= 1\n\tprint(str)\n",
        "(start_column, start_row) = input()\n(end_column, end_row) = input()\nhorizontal = ord(end_column) - ord(start_column)\ndistance_hor = abs(horizontal)\nletters_horizontal = '{:<7}'.format('L' * distance_hor if horizontal < 0 else 'R' * distance_hor)\nvertical = int(end_row) - int(start_row)\ndistance_ver = abs(vertical)\nletters_vertical = '{:<7}'.format('D' * distance_ver if vertical < 0 else 'U' * distance_ver)\nnumber_of_moves = max(distance_ver, distance_hor)\nprint(number_of_moves)\nfor index in range(number_of_moves):\n\tprint((letters_horizontal[index] + letters_vertical[index]).strip())\n",
        "def main():\n\ta = [input() for _ in range(2)]\n\tcols = [ord(a[x][0]) - ord('a') for x in range(2)]\n\trows = [int(a[x][1]) for x in range(2)]\n\tif cols[0] < cols[1]:\n\t\tcol_moves = 'R' * (cols[1] - cols[0])\n\telse:\n\t\tcol_moves = 'L' * (cols[0] - cols[1])\n\tif rows[0] < rows[1]:\n\t\trow_moves = 'U' * (rows[1] - rows[0])\n\telse:\n\t\trow_moves = 'D' * (rows[0] - rows[1])\n\ta = max(len(col_moves), len(row_moves))\n\tprint(a)\n\tb = min(len(col_moves), len(row_moves))\n\tfor i in range(a):\n\t\tif i < b:\n\t\t\tprint(col_moves[i] + row_moves[i])\n\t\telif i < len(col_moves):\n\t\t\tprint(col_moves[i])\n\t\telse:\n\t\t\tprint(row_moves[i])\nmain()\n",
        "import string\ns1 = input()\ns2 = input()\nxdiff = string.ascii_lowercase.index(s2[0]) - string.ascii_lowercase.index(s1[0])\nydiff = int(s2[1]) - int(s1[1])\nanslst = []\nwhile xdiff != 0 or ydiff != 0:\n\ttmp = ''\n\tif xdiff > 0:\n\t\ttmp += 'R'\n\t\txdiff -= 1\n\telif xdiff < 0:\n\t\ttmp += 'L'\n\t\txdiff += 1\n\tif ydiff > 0:\n\t\ttmp += 'U'\n\t\tydiff -= 1\n\telif ydiff < 0:\n\t\ttmp += 'D'\n\t\tydiff += 1\n\tanslst.append(tmp)\nprint(len(anslst))\nfor a in anslst:\n\tprint(a)\n",
        "a = list(input())\nb = list(input())\nx1 = a[0]\ny1 = a[1]\nx2 = b[0]\ny2 = b[1]\n(x1, y1, x2, y2) = map(ord, (x1, y1, x2, y2))\nd = max(abs(x1 - x2), abs(y1 - y2))\ne = min(abs(x1 - x2), abs(y1 - y2))\nprint(d)\nmx = ''\nmy = ''\nif x1 < x2:\n\tmx = 'R'\nelse:\n\tmx = 'L'\nif y1 < y2:\n\tmy = 'U'\nelse:\n\tmy = 'D'\nfor i in range(0, e):\n\tprint(mx + my)\np = mx\nif abs(x1 - x2) < abs(y1 - y2):\n\tp = my\nfor i in range(0, d - e):\n\tprint(p)\n",
        "s = input()\ne = input()\nm1 = m2 = u = l = st = ''\nif int(s[1]) < int(e[1]):\n\tm2 = 'U'\nelse:\n\tm2 = 'D'\nu = abs(int(s[1]) - int(e[1]))\nif ord(s[0]) < ord(e[0]):\n\tm1 = 'R'\nelse:\n\tm1 = 'L'\nl = abs(ord(s[0]) - ord(e[0]))\nul = min(u, l)\nmove = l + u - ul\nprint(move)\nif ul != 0:\n\tfor i in range(ul):\n\t\tprint(m1 + m2)\n\tif l > u:\n\t\tfor j in range(l - u):\n\t\t\tprint(m1)\n\telse:\n\t\tfor j in range(u - l):\n\t\t\tprint(m2)\nelse:\n\tif l != 0:\n\t\tst = m1\n\telse:\n\t\tst = m2\n\tfor i in range(max(l, u)):\n\t\tprint(st)\n",
        "a = input()\nb = input()\n\ndef check(a, b, k=0):\n\tif a[0] == b[0]:\n\t\tx = abs(int(a[1]) - int(b[1]))\n\t\tif k == 0:\n\t\t\tprint(x)\n\t\tif int(a[1]) > int(b[1]):\n\t\t\tfor i in range(x):\n\t\t\t\tprint('D')\n\t\t\treturn\n\t\telse:\n\t\t\tfor i in range(x):\n\t\t\t\tprint('U')\n\t\t\treturn\n\telif a[1] == b[1]:\n\t\tx = abs(ord(a[0]) - ord(b[0]))\n\t\tif k == 0:\n\t\t\tprint(x)\n\t\tif ord(a[0]) > ord(b[0]):\n\t\t\tfor i in range(x):\n\t\t\t\tprint('L')\n\t\t\treturn\n\t\telse:\n\t\t\tfor i in range(x):\n\t\t\t\tprint('R')\n\t\t\treturn\n\telse:\n\t\t(x1, y1) = (ord(a[0]) - ord(b[0]), int(a[1]) - int(b[1]))\n\t\t(x, y) = (abs(ord(a[0]) - ord(b[0])), abs(int(a[1]) - int(b[1])))\n\t\tif x1 == y1:\n\t\t\tif k == 0:\n\t\t\t\tprint(x)\n\t\t\tif x1 > 0:\n\t\t\t\tfor i in range(x1):\n\t\t\t\t\tprint('LD')\n\t\t\telse:\n\t\t\t\tfor i in range(x):\n\t\t\t\t\tprint('RU')\n\t\t\treturn\n\t\telif x == y:\n\t\t\tif k == 0:\n\t\t\t\tprint(x)\n\t\t\tif x1 > 0:\n\t\t\t\tfor i in range(x1):\n\t\t\t\t\tprint('LU')\n\t\t\telse:\n\t\t\t\tfor i in range(x):\n\t\t\t\t\tprint('RD')\n\t\t\t\treturn\n\t\telse:\n\t\t\tprint(max(x, y))\n\t\t\tif y < x:\n\t\t\t\tm = x - y\n\t\t\t\tif x1 < 0:\n\t\t\t\t\tfor i in range(m):\n\t\t\t\t\t\tprint('R')\n\t\t\t\t\ty1 = chr(ord(a[0]) + m)\n\t\t\t\t\tb1 = y1 + a[1]\n\t\t\t\t\tcheck(b1, b, 1)\n\t\t\t\telse:\n\t\t\t\t\tfor i in range(m):\n\t\t\t\t\t\tprint('L')\n\t\t\t\t\ty1 = chr(ord(a[0]) - m)\n\t\t\t\t\tb1 = y1 + a[1]\n\t\t\t\t\tcheck(b1, b, 1)\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tm = y - x\n\t\t\t\tif y1 > 0:\n\t\t\t\t\tfor i in range(m):\n\t\t\t\t\t\tprint('D')\n\t\t\t\t\ty1 = int(a[1]) - m\n\t\t\t\t\tb1 = a[0] + str(y1)\n\t\t\t\t\tcheck(b1, b, 1)\n\t\t\t\telse:\n\t\t\t\t\tfor i in range(m):\n\t\t\t\t\t\tprint('U')\n\t\t\t\t\ty1 = int(a[1]) + m\n\t\t\t\t\tb1 = a[0] + str(y1)\n\t\t\t\t\tcheck(b1, b, 1)\n\t\t\t\treturn\ncheck(a, b, 0)\n",
        "import math, string, itertools, fractions, heapq, collections, re, array, bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict\n\ndef VI():\n\treturn list(map(int, input().split()))\n\ndef main_input(info=0):\n\t(s, x) = [ord(i) for i in input()]\n\t(t, y) = [ord(i) for i in input()]\n\tm1 = abs(s - t)\n\tm2 = abs(x - y)\n\tm = min(m1, m2)\n\tprint(max(m1, m2))\n\tfor i in range(max(m1, m2)):\n\t\tif s > t and x > y:\n\t\t\tprint('LD')\n\t\t\ts -= 1\n\t\t\tx -= 1\n\t\telif s > t and x < y:\n\t\t\tprint('LU')\n\t\t\ts -= 1\n\t\t\tx += 1\n\t\telif s > t and x == y:\n\t\t\tprint('L')\n\t\t\ts -= 1\n\t\telif s < t and x > y:\n\t\t\tprint('RD')\n\t\t\ts += 1\n\t\t\tx -= 1\n\t\telif s < t and x < y:\n\t\t\tprint('RU')\n\t\t\ts += 1\n\t\t\tx += 1\n\t\telif s < t and x == y:\n\t\t\tprint('R')\n\t\t\ts += 1\n\t\telif s == t and x < y:\n\t\t\tprint('U')\n\t\t\tx += 1\n\t\telif s == t and x > y:\n\t\t\tprint('D')\n\t\t\tx -= 1\nmain_input()\n",
        "num1 = input()\nnum2 = input()\n(tot1, tot2) = (ord(num1[i]) - ord(num2[i]) for i in range(0, 2))\nprint(max(tot1, -tot1, tot2, -tot2))\nwhile tot1 != 0 or tot2 != 0:\n\tfinal = ''\n\tif tot1 < 0:\n\t\tfinal = 'R'\n\t\ttot1 += 1\n\tif tot1 > 0:\n\t\tfinal = 'L'\n\t\ttot1 -= 1\n\tif tot2 < 0:\n\t\tfinal += 'U'\n\t\ttot2 += 1\n\tif tot2 > 0:\n\t\tfinal += 'D'\n\t\ttot2 -= 1\n\tprint(final)\n",
        "s = str(input())\nt = str(input())\n\ndef calculateMoves(s, t):\n\tcols = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\tsx = cols[s[0]]\n\tsy = int(s[1])\n\ttx = cols[t[0]]\n\tty = int(t[1])\n\tmoves = []\n\twhile True:\n\t\txflag = 0\n\t\tyflag = 0\n\t\txmove = ''\n\t\tymove = ''\n\t\tmove = ''\n\t\tif sx != tx:\n\t\t\txflag = 1\n\t\t\tif sx < tx:\n\t\t\t\txmove = 'R'\n\t\t\t\tsx = sx + 1\n\t\t\telse:\n\t\t\t\txmove = 'L'\n\t\t\t\tsx = sx - 1\n\t\tif sy != ty:\n\t\t\tyflag = 1\n\t\t\tif sy < ty:\n\t\t\t\tymove = 'U'\n\t\t\t\tsy = sy + 1\n\t\t\telse:\n\t\t\t\tymove = 'D'\n\t\t\t\tsy = sy - 1\n\t\tif xflag:\n\t\t\tmove = move + xmove\n\t\tif yflag:\n\t\t\tmove = move + ymove\n\t\tif not xflag and (not yflag):\n\t\t\tbreak\n\t\telse:\n\t\t\tmoves.append(move)\n\tprint(len(moves))\n\tfor i in moves:\n\t\tprint(i)\n\treturn\ncalculateMoves(s, t)\n",
        "s = input()\nt = input()\nend = crr = []\ncrr = (ord(s[0]) - 96, int(s[1]))\nend = (ord(t[0]) - 96, int(t[1]))\na = crr[0] - end[0]\nb = crr[1] - end[1]\nprint(max(a, -a, b, -b))\nwhile a or b != 0:\n\tp = ''\n\tif a < 0:\n\t\tp = 'R'\n\t\ta += 1\n\tif a > 0:\n\t\tp = 'L'\n\t\ta -= 1\n\tif b < 0:\n\t\tp += 'U'\n\t\tb += 1\n\tif b > 0:\n\t\tp += 'D'\n\t\tb -= 1\n\tprint(p)\n",
        "b = ['o', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ns = input()\ns1 = b.index(s[0])\ns2 = int(s[1])\ne = input()\ne1 = b.index(e[0])\ne2 = int(e[1])\nm = max(abs(s1 - e1), abs(s2 - e2))\nprint(m)\nwhile s1 != e1 or s2 != e2:\n\tss = ''\n\tif s1 != e1:\n\t\tif s1 < e1:\n\t\t\tss += 'R'\n\t\telse:\n\t\t\tss += 'L'\n\t\ts1 -= (s1 - e1) // abs(s1 - e1)\n\tif s2 != e2:\n\t\tif s2 > e2:\n\t\t\tss += 'D'\n\t\telse:\n\t\t\tss += 'U'\n\t\ts2 -= (s2 - e2) // abs(s2 - e2)\n\tprint(ss)\n",
        "def readln():\n\treturn tuple(map(int, input().split()))\n\ndef tot():\n\ts = input()\n\treturn (ord(s[0]) - ord('a') + 1, int(s[1]))\n(x0, y0) = tot()\n(x1, y1) = tot()\nprint(max(abs(x1 - x0), abs(y1 - y0)))\nwhile x0 != x1 or y0 != y1:\n\tif x1 > x0 and y1 > y0:\n\t\tx0 += 1\n\t\ty0 += 1\n\t\tprint('RU')\n\telif x1 < x0 and y1 > y0:\n\t\tx0 -= 1\n\t\ty0 += 1\n\t\tprint('LU')\n\telif x1 < x0 and y1 < y0:\n\t\tx0 -= 1\n\t\ty0 -= 1\n\t\tprint('LD')\n\telif x1 > x0 and y1 < y0:\n\t\tx0 += 1\n\t\ty0 -= 1\n\t\tprint('RD')\n\telif x1 > x0:\n\t\tx0 += 1\n\t\tprint('R')\n\telif x1 < x0:\n\t\tx0 -= 1\n\t\tprint('L')\n\telif y1 > y0:\n\t\ty0 += 1\n\t\tprint('U')\n\telse:\n\t\ty0 -= 1\n\t\tprint('D')\n",
        "import math\nline1 = input()\nline2 = input()\nrow_numeral1 = ord(line1[0])\nrow_numeral2 = ord(line2[0])\ncolumn_numeral1 = ord(line1[1])\ncolumn_numeral2 = ord(line2[1])\nrow_diff = row_numeral2 - row_numeral1\ncolumn_diff = column_numeral2 - column_numeral1\ntotal_steps = abs(row_diff) if abs(row_diff) > abs(column_diff) else abs(column_diff)\nprint(total_steps)\nrow_print_character = 'R' if row_diff > 0 else 'L'\ncolumn_print_character = 'U' if column_diff > 0 else 'D'\nrow_prints = abs(row_diff)\ncolumn_prints = abs(column_diff)\nfor i in range(total_steps):\n\tif row_prints > 0:\n\t\tprint(row_print_character, end='')\n\t\trow_prints -= 1\n\tif column_prints > 0:\n\t\tprint(column_print_character, end='')\n\t\tcolumn_prints -= 1\n\tprint('')\n",
        "def main():\n\t(x, y) = (ord(b) - ord(a) for (a, b) in zip(input(), input()))\n\tres = []\n\twhile x or y:\n\t\tif y > 0:\n\t\t\tres.append('U')\n\t\t\ty -= 1\n\t\telif y < 0:\n\t\t\tres.append('D')\n\t\t\ty += 1\n\t\tif x > 0:\n\t\t\tres.append('R')\n\t\t\tx -= 1\n\t\telif x < 0:\n\t\t\tres.append('L')\n\t\t\tx += 1\n\t\tres.append('\\n')\n\tres.append(str(res.count('\\n')))\n\tprint(''.join(reversed(res)))\nmain()\n",
        "s = input()\nd = input()\nx = ord(s[0]) - ord(d[0])\ny = int(s[1]) - int(d[1])\nm = max(x, -x, y, -y)\nl = []\nwhile x != 0 or y != 0:\n\tr = ''\n\tif x > 0:\n\t\tr = r + 'L'\n\t\tx -= 1\n\tif x < 0:\n\t\tr = r + 'R'\n\t\tx += 1\n\tif y > 0:\n\t\tr = r + 'D'\n\t\ty -= 1\n\tif y < 0:\n\t\tr = r + 'U'\n\t\ty += 1\n\tl.append(r)\nprint(m)\nfor i in l:\n\tprint(i)\n",
        "starting = list(input().lower())\nend_up = list(input())\nstring_output = []\ncount = 0\nletter_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nstarting[1] = int(starting[1])\nend_up[1] = int(end_up[1])\nstarting[0] = letter_dict[starting[0]]\nend_up[0] = letter_dict[end_up[0]]\nwhile starting[0] != end_up[0] and starting[1] != end_up[1]:\n\tif starting[0] > end_up[0]:\n\t\tstarting[0] -= 1\n\t\tif starting[1] > end_up[1]:\n\t\t\tstarting[1] -= 1\n\t\t\tstring_output.append('LD')\n\t\telse:\n\t\t\tstarting[1] += 1\n\t\t\tstring_output.append('LU')\n\telse:\n\t\tstarting[0] += 1\n\t\tif starting[1] > end_up[1]:\n\t\t\tstarting[1] -= 1\n\t\t\tstring_output.append('RD')\n\t\telse:\n\t\t\tstarting[1] += 1\n\t\t\tstring_output.append('RU')\n\tcount += 1\nwhile starting[0] != end_up[0] or starting[1] != end_up[1]:\n\tif starting[1] == end_up[1]:\n\t\tif starting[0] > end_up[0]:\n\t\t\tstarting[0] -= 1\n\t\t\tstring_output.append('L')\n\t\telse:\n\t\t\tstarting[0] += 1\n\t\t\tstring_output.append('R')\n\telif starting[1] > end_up[1]:\n\t\tstarting[1] -= 1\n\t\tstring_output.append('D')\n\telse:\n\t\tstarting[1] += 1\n\t\tstring_output.append('U')\n\tcount += 1\nprint(count)\nfor i in string_output:\n\tprint(i)\n",
        "def navigate(king, target, count, answer):\n\tif king == target:\n\t\treturn count\n\tmove = ''\n\tif king[0] > target[0]:\n\t\tking[0] = chr(ord(king[0]) - 1)\n\t\tmove += 'L'\n\telif king[0] < target[0]:\n\t\tking[0] = chr(ord(king[0]) + 1)\n\t\tmove += 'R'\n\tif king[1] > target[1]:\n\t\tking[1] = chr(ord(king[1]) - 1)\n\t\tmove += 'D'\n\telif king[1] < target[1]:\n\t\tking[1] = chr(ord(king[1]) + 1)\n\t\tmove += 'U'\n\tanswer.append(move)\n\treturn navigate(king, target, count + 1, answer)\nking = [_ for _ in input()]\ntarget = [_ for _ in input()]\ncount = 0\nanswer = []\nprint(navigate(king, target, count, answer))\nprint(*answer, sep='\\n')\n",
        "s = input()\nn = input()\nif s == n:\n\tprint(0)\n\texit()\nm = ['', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nfor i in range(1, len(m)):\n\tif s[0] == m[i]:\n\t\tx = i\n\tif n[0] == m[i]:\n\t\tx2 = i\ny = int(s[1])\ny2 = int(n[1])\nM = []\nb = ''\nxod = 0\nwhile True:\n\tif x > x2:\n\t\tx -= 1\n\t\tb += 'L'\n\tif x < x2:\n\t\tx += 1\n\t\tb += 'R'\n\tif y > y2:\n\t\ty -= 1\n\t\tb += 'D'\n\tif y < y2:\n\t\ty += 1\n\t\tb += 'U'\n\txod += 1\n\tM.append(b)\n\tb = ''\n\tif x == x2 and y == y2:\n\t\tbreak\nprint(xod)\nfor i in range(len(M)):\n\tprint(M[i])\n",
        "fr = input()\nto = input()\nfr = [ord(fr[0]) - ord('a') + 1, int(fr[1])]\nto = [ord(to[0]) - ord('a') + 1, int(to[1])]\nprint(max(abs(fr[0] - to[0]), abs(fr[1] - to[1])))\nwhile fr[0] > to[0] and fr[1] > to[1]:\n\tprint('LD')\n\tfr[0] -= 1\n\tfr[1] -= 1\nwhile fr[0] < to[0] and fr[1] > to[1]:\n\tprint('RD')\n\tfr[0] += 1\n\tfr[1] -= 1\nwhile fr[0] > to[0] and fr[1] < to[1]:\n\tprint('LU')\n\tfr[0] -= 1\n\tfr[1] += 1\nwhile fr[0] < to[0] and fr[1] < to[1]:\n\tprint('RU')\n\tfr[0] += 1\n\tfr[1] += 1\nwhile fr[0] > to[0] and fr[1] == to[1]:\n\tprint('L')\n\tfr[0] -= 1\nwhile fr[0] < to[0] and fr[1] == to[1]:\n\tprint('R')\n\tfr[0] += 1\nwhile fr[0] == to[0] and fr[1] < to[1]:\n\tprint('U')\n\tfr[1] += 1\nwhile fr[0] == to[0] and fr[1] > to[1]:\n\tprint('D')\n\tfr[1] -= 1\n",
        "s = input()\nx0 = ord(s[0]) - 96\ny0 = int(s[1])\nt = input()\nx = ord(t[0]) - 96\ny = int(t[1])\nn = 0\nstep = ['', '', '', '', '', '', '', '']\nwhile not (x == x0 and y == y0):\n\tn = n + 1\n\tif x > x0:\n\t\tx0 = x0 + 1\n\t\tstep[n] = step[n] + 'R'\n\telif x < x0:\n\t\tx0 = x0 - 1\n\t\tstep[n] = step[n] + 'L'\n\tif y > y0:\n\t\ty0 = y0 + 1\n\t\tstep[n] = step[n] + 'U'\n\telif y < y0:\n\t\ty0 = y0 - 1\n\t\tstep[n] = step[n] + 'D'\nprint(n)\nfor i in range(1, n + 1):\n\tprint(step[i])\n",
        "def judge(s, t):\n\tsx = s[0]\n\tsy = s[1]\n\ttx = t[0]\n\tty = t[1]\n\tif sx == tx and sy == ty:\n\t\treturn 'end'\n\tif tx > sx and ty > sy:\n\t\ts[0] += 1\n\t\ts[1] += 1\n\t\treturn 'RU'\n\tif tx > sx and ty < sy:\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\t\treturn 'RD'\n\tif tx < sx and ty > sy:\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\t\treturn 'LU'\n\tif tx < sx and ty < sy:\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\t\treturn 'LD'\n\tif tx == sx and ty < sy:\n\t\ts[1] -= 1\n\t\treturn 'D'\n\tif tx == sx and ty > sy:\n\t\ts[1] += 1\n\t\treturn 'U'\n\tif tx < sx and ty == sy:\n\t\ts[0] -= 1\n\t\treturn 'L'\n\tif tx > sx and ty == sy:\n\t\ts[0] += 1\n\t\treturn 'R'\ns = input()\nt = input()\ns = [s[0], s[1]]\nt = [t[0], t[1]]\ns[0] = ord(s[0]) - ord('a') + 1\ns[1] = int(s[1])\nt[0] = ord(t[0]) - ord('a') + 1\nt[1] = int(t[1])\ncnt = 0\nans = []\nmove = judge(s, t)\nwhile move != 'end':\n\tans.append(move)\n\tcnt += 1\n\tmove = judge(s, t)\nprint(cnt)\nfor i in ans:\n\tprint(i)\n",
        "def main():\n\t(x, y) = (ord(b) - ord(a) for (a, b) in zip(input(), input()))\n\tprint(max(abs(x), abs(y)))\n\twhile x or y:\n\t\tif x > 0:\n\t\t\th = 'R'\n\t\t\tx -= 1\n\t\telif x < 0:\n\t\t\th = 'L'\n\t\t\tx += 1\n\t\telse:\n\t\t\th = ''\n\t\tif y > 0:\n\t\t\tv = 'U'\n\t\t\ty -= 1\n\t\telif y < 0:\n\t\t\tv = 'D'\n\t\t\ty += 1\n\t\telse:\n\t\t\tv = ''\n\t\tprint(''.join((h, v)))\nmain()\n",
        "s1 = input()\ns2 = input()\nprint(max(abs(ord(s1[0]) - ord(s2[0])), abs(int(ord(s1[1]) - ord(s2[1])))))\ns1 = list(s1)\ns2 = list(s2)\nwhile s1 != s2:\n\tif s1[0] < s2[0]:\n\t\tprint('R', end='')\n\t\ts1[0] = chr(ord(s1[0]) + 1)\n\telif s1[0] > s2[0]:\n\t\ts1[0] = chr(ord(s1[0]) - 1)\n\t\tprint('L', end='')\n\tif s1[1] > s2[1]:\n\t\ts1[1] = chr(ord(s1[1]) - 1)\n\t\tprint('D', end='')\n\telif s1[1] < s2[1]:\n\t\ts1[1] = chr(ord(s1[1]) + 1)\n\t\tprint('U', end='')\n\tprint('')\n",
        "src = input()\ndst = input()\nxpos = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nxposinv = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h'}\ndirection = []\ncount = 0\nxsrc = src[0]\nysrc = src[1]\nxdst = dst[0]\nydst = dst[1]\nwhile xpos[xsrc] * 10 + int(ysrc) != xpos[xdst] * 10 + int(ydst):\n\txsrc = src[0]\n\tysrc = src[1]\n\txdst = dst[0]\n\tydst = dst[1]\n\tif xpos[xsrc] < xpos[xdst] and ysrc < ydst:\n\t\tdirection.append('RU')\n\t\tsrc = xposinv[xpos[xsrc] + 1] + str(int(ysrc) + 1)\n\t\tcount += 1\n\telif xpos[xsrc] < xpos[xdst] and ysrc > ydst:\n\t\tdirection.append('RD')\n\t\tsrc = xposinv[xpos[xsrc] + 1] + str(int(ysrc) - 1)\n\t\tcount += 1\n\telif xpos[xsrc] > xpos[xdst] and ysrc < ydst:\n\t\tdirection.append('LU')\n\t\tsrc = xposinv[xpos[xsrc] - 1] + str(int(ysrc) + 1)\n\t\tcount += 1\n\telif xpos[xsrc] > xpos[xdst] and ysrc > ydst:\n\t\tdirection.append('LD')\n\t\tsrc = xposinv[xpos[xsrc] - 1] + str(int(ysrc) - 1)\n\t\tcount += 1\n\telif xpos[xsrc] > xpos[xdst]:\n\t\tdirection.append('L')\n\t\tsrc = xposinv[xpos[xsrc] - 1] + ysrc\n\t\tcount += 1\n\telif xpos[xsrc] < xpos[xdst]:\n\t\tdirection.append('R')\n\t\tsrc = xposinv[xpos[xsrc] + 1] + ysrc\n\t\tcount += 1\n\telif ysrc < ydst:\n\t\tdirection.append('U')\n\t\tsrc = xposinv[xpos[xsrc]] + str(int(ysrc) + 1)\n\t\tcount += 1\n\telif ysrc > ydst:\n\t\tdirection.append('D')\n\t\tsrc = xposinv[xpos[xsrc]] + str(int(ysrc) - 1)\n\t\tcount += 1\nprint(len(direction))\nfor tmp in direction:\n\tprint(tmp)\n",
        "sta = input()\nend = input()\n(scol, srow) = (ord(sta[0]), int(sta[1]))\n(ecol, erow) = (ord(end[0]), int(end[1]))\ndcol = ecol - scol\ndrow = erow - srow\nn = max(abs(dcol), abs(drow))\nm = min(abs(dcol), abs(drow))\nprint(n)\n\ndef move1():\n\tif dcol < 0 and drow < 0:\n\t\treturn 'LD'\n\tif dcol < 0 and drow > 0:\n\t\treturn 'LU'\n\tif dcol > 0 and drow < 0:\n\t\treturn 'RD'\n\tif dcol > 0 and drow > 0:\n\t\treturn 'RU'\n\ndef move2():\n\tif dcol <= 0 and drow <= 0:\n\t\tif n == abs(dcol):\n\t\t\treturn 'L'\n\t\telse:\n\t\t\treturn 'D'\n\tif dcol <= 0 and drow >= 0:\n\t\tif n == abs(dcol):\n\t\t\treturn 'L'\n\t\telse:\n\t\t\treturn 'U'\n\tif dcol >= 0 and drow <= 0:\n\t\tif n == abs(dcol):\n\t\t\treturn 'R'\n\t\telse:\n\t\t\treturn 'D'\n\tif dcol >= 0 and drow >= 0:\n\t\tif n == abs(dcol):\n\t\t\treturn 'R'\n\t\telse:\n\t\t\treturn 'U'\nfor i in range(m):\n\tprint(move1())\nif abs(dcol) != abs(drow):\n\tfor i in range(n - m):\n\t\tprint(move2())\n",
        "import time\n\ndef calculateCoords(c):\n\treturn (8 - int(c[1]), ord(c[0]) - 97)\n\ndef run():\n\tstart = calculateCoords(input())\n\tend = calculateCoords(input())\n\tseen = [[False for x in range(8)] for y in range(8)]\n\tseen[start[0]][start[1]] = True\n\ttoCheck = []\n\ttoCheck.append((start, []))\n\twhile True:\n\t\ttemp = []\n\t\tfor (position, l) in toCheck:\n\t\t\tr = position[0]\n\t\t\tc = position[1]\n\t\t\tseen[r][c] = True\n\t\t\tif r == end[0] and c == end[1]:\n\t\t\t\tprint(len(l))\n\t\t\t\tfor ch in l:\n\t\t\t\t\tprint(ch)\n\t\t\t\treturn\n\t\t\tif r > 0:\n\t\t\t\tif c > 0 and (not seen[r - 1][c - 1]):\n\t\t\t\t\tnewl1 = [x for x in l]\n\t\t\t\t\tnewl1.append('LU')\n\t\t\t\t\ttemp.append(((r - 1, c - 1), newl1))\n\t\t\t\tif c < 7 and (not seen[r - 1][c + 1]):\n\t\t\t\t\tnewl2 = [x for x in l]\n\t\t\t\t\tnewl2.append('RU')\n\t\t\t\t\ttemp.append(((r - 1, c + 1), newl2))\n\t\t\t\tnewl3 = [x for x in l]\n\t\t\t\tnewl3.append('U')\n\t\t\t\ttemp.append(((r - 1, c), newl3))\n\t\t\tif r < 7:\n\t\t\t\tif c > 0 and (not seen[r + 1][c - 1]):\n\t\t\t\t\tnewl4 = [x for x in l]\n\t\t\t\t\tnewl4.append('LD')\n\t\t\t\t\ttemp.append(((r + 1, c - 1), newl4))\n\t\t\t\tif c < 7 and (not seen[r + 1][c + 1]):\n\t\t\t\t\tnewl5 = [x for x in l]\n\t\t\t\t\tnewl5.append('RD')\n\t\t\t\t\ttemp.append(((r + 1, c + 1), newl5))\n\t\t\t\tnewl6 = [x for x in l]\n\t\t\t\tnewl6.append('D')\n\t\t\t\ttemp.append(((r + 1, c), newl6))\n\t\t\tif c > 0:\n\t\t\t\tnewl7 = [x for x in l]\n\t\t\t\tnewl7.append('L')\n\t\t\t\ttemp.append(((r, c - 1), newl7))\n\t\t\tif c < 7:\n\t\t\t\tnewl8 = [x for x in l]\n\t\t\t\tnewl8.append('R')\n\t\t\t\ttemp.append(((r, c + 1), newl8))\n\t\ttoCheck = []\n\t\ttoCheck.extend(temp)\nrun()\n",
        "s = input()\nt = input()\nlevel = ord(t[0]) - ord(s[0])\nvertical = int(t[1]) - int(s[1])\nsteps = max(abs(vertical), abs(level))\nprint(steps)\nwhile level or vertical:\n\tstep = ''\n\tif level > 0:\n\t\tlevel -= 1\n\t\tstep += 'R'\n\tif level < 0:\n\t\tlevel += 1\n\t\tstep += 'L'\n\tif vertical > 0:\n\t\tvertical -= 1\n\t\tstep += 'U'\n\tif vertical < 0:\n\t\tvertical += 1\n\t\tstep += 'D'\n\tprint(step)\n",
        "ax = input()\nbx = input()\nres = []\nif ax == bx:\n\tprint(0)\n\tprint('')\n\texit(0)\nay = int(ax[1:])\nax = ax[:1]\nby = int(bx[1:])\nbx = bx[:1]\ndx = ord(bx) - ord(ax)\ndy = by - ay\nif dx <= 0 and dy <= 0:\n\tfor i in range(min(abs(dx), abs(dy))):\n\t\tres.append('LD')\n\tif abs(dx) < abs(dy):\n\t\tfor i in range(abs(dy) - abs(dx)):\n\t\t\tres.append('D')\n\tif abs(dy) < abs(dx):\n\t\tfor i in range(abs(dx) - abs(dy)):\n\t\t\tres.append('L')\nelif dx >= 0 and dy <= 0:\n\tfor i in range(min(abs(dx), abs(dy))):\n\t\tres.append('RD')\n\tif abs(dx) < abs(dy):\n\t\tfor i in range(abs(dy) - abs(dx)):\n\t\t\tres.append('D')\n\tif abs(dy) < abs(dx):\n\t\tfor i in range(abs(dx) - abs(dy)):\n\t\t\tres.append('R')\nelif dx <= 0 and dy >= 0:\n\tfor i in range(min(abs(dx), abs(dy))):\n\t\tres.append('LU')\n\tif abs(dx) < abs(dy):\n\t\tfor i in range(abs(dy) - abs(dx)):\n\t\t\tres.append('U')\n\tif abs(dy) < abs(dx):\n\t\tfor i in range(abs(dx) - abs(dy)):\n\t\t\tres.append('L')\nelse:\n\tfor i in range(min(abs(dx), abs(dy))):\n\t\tres.append('RU')\n\tif abs(dx) < abs(dy):\n\t\tfor i in range(abs(dy) - abs(dx)):\n\t\t\tres.append('U')\n\tif abs(dy) < abs(dx):\n\t\tfor i in range(abs(dx) - abs(dy)):\n\t\t\tres.append('R')\nprint(max(abs(dx), abs(dy)))\nfor i in res:\n\tprint(i)\n",
        "d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nstart = input()\ndes = input()\nl = []\n(x, y) = (int(start[1]), d[start[0]])\n(x1, y1) = (int(des[1]), d[des[0]])\nwhile x != x1 or y != y1:\n\tif x == x1:\n\t\tif y < y1:\n\t\t\tl.append('R')\n\t\t\ty += 1\n\t\telse:\n\t\t\tl.append('L')\n\t\t\ty -= 1\n\telif y == y1:\n\t\tif x < x1:\n\t\t\tl.append('U')\n\t\t\tx += 1\n\t\telse:\n\t\t\tl.append('D')\n\t\t\tx -= 1\n\telif x > x1 and y < y1:\n\t\tl.append('RD')\n\t\tx -= 1\n\t\ty += 1\n\telif x > x1 and y > y1:\n\t\tl.append('LD')\n\t\tx -= 1\n\t\ty -= 1\n\telif x < x1 and y > y1:\n\t\tl.append('LU')\n\t\tx += 1\n\t\ty -= 1\n\telif x < x1 and y < y1:\n\t\tl.append('RU')\n\t\tx += 1\n\t\ty += 1\nprint(len(l))\nfor i in l:\n\tprint(i)\n",
        "start = input()\ngoal = input()\nx = ord(goal[0]) - ord(start[0])\ny = int(goal[1]) - int(start[1])\nprint(max(abs(x), abs(y)))\nwhile x != 0 or y != 0:\n\tdirection = ''\n\tif x > 0:\n\t\tdirection = 'R'\n\t\tx -= 1\n\tif x < 0:\n\t\tdirection = 'L'\n\t\tx += 1\n\tif y > 0:\n\t\tdirection += 'U'\n\t\ty -= 1\n\tif y < 0:\n\t\tdirection += 'D'\n\t\ty += 1\n\tprint(direction)\n",
        "o = input()\no = [o[0], int(o[1])]\np = input()\np = [p[0], int(p[1])]\nl = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\na2 = []\nk = 0\nfor i in range(7):\n\ta = abs(l.index(o[0]) - l.index(p[0]))\n\tb = abs(o[1] - p[1])\n\tif a > 0 or b > 0:\n\t\tm1 = m2 = ''\n\t\tif l.index(o[0]) > l.index(p[0]):\n\t\t\tm1 = 'L'\n\t\t\tif o[1] < p[1]:\n\t\t\t\tm2 = 'U'\n\t\t\t\to[1] += 1\n\t\t\telif o[1] > p[1]:\n\t\t\t\tm2 = 'D'\n\t\t\t\to[1] -= 1\n\t\t\to[0] = l[l.index(o[0]) - 1]\n\t\t\ta2.append(m1 + m2)\n\t\t\tk += 1\n\t\telif l.index(o[0]) < l.index(p[0]):\n\t\t\tm1 = 'R'\n\t\t\tif o[1] < p[1]:\n\t\t\t\tm2 = 'U'\n\t\t\t\to[1] += 1\n\t\t\telif o[1] > p[1]:\n\t\t\t\tm2 = 'D'\n\t\t\t\to[1] -= 1\n\t\t\ta2.append(m1 + m2)\n\t\t\to[0] = l[l.index(o[0]) + 1]\n\t\t\tk += 1\n\t\telif l.index(o[0]) == l.index(p[0]):\n\t\t\tif o[1] < p[1]:\n\t\t\t\tm2 = 'U'\n\t\t\t\to[1] += 1\n\t\t\telif o[1] > p[1]:\n\t\t\t\tm2 = 'D'\n\t\t\t\to[1] -= 1\n\t\t\ta2.append(m1 + m2)\n\t\t\tk += 1\nprint(k)\nfor g in a2:\n\tprint(g)\n",
        "s = input()\n(s1, s2) = (s[0], s[1])\nt = input()\n(t1, t2) = (t[0], t[1])\nv_dif = int(s2) - int(t2)\nh_dif = ord(s1) - ord(t1)\nstep = max(abs(v_dif), abs(h_dif))\nnond = abs(abs(v_dif) - abs(h_dif))\nprint(step)\nfor i in range(nond):\n\tif abs(v_dif) > abs(h_dif):\n\t\tif v_dif < 0:\n\t\t\tprint('U')\n\t\telse:\n\t\t\tprint('D')\n\telif h_dif < 0:\n\t\tprint('R')\n\telse:\n\t\tprint('L')\nfor i in range(step - nond):\n\tif v_dif < 0 and h_dif < 0:\n\t\tprint('RU')\n\telif v_dif > 0 and h_dif < 0:\n\t\tprint('RD')\n\telif v_dif < 0 and h_dif > 0:\n\t\tprint('LU')\n\telif v_dif > 0 and h_dif > 0:\n\t\tprint('LD')\n",
        "a = input()\nb = input()\n(h, v) = (ord(a[0]) - ord(b[0]), ord(a[1]) - ord(b[1]))\nprint(max(v, -v, h, -h))\nwhile v != 0 or h != 0:\n\tr = ''\n\tif h > 0:\n\t\tr = 'L'\n\t\th -= 1\n\tif h < 0:\n\t\tr = 'R'\n\t\th += 1\n\tif v < 0:\n\t\tr += 'U'\n\t\tv += 1\n\tif v > 0:\n\t\tr += 'D'\n\t\tv -= 1\n\tprint(r)\n",
        "l = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nn = ['1', '2', '3', '4', '5', '6', '7', '8']\nm = [['LU', 'U', 'RU'], ['L', '  ', 'R'], ['LD', 'D', 'RD']]\na = input()\nb = input()\na = [l.index(a[0]), n.index(a[1])]\nb = [l.index(b[0]), n.index(b[1])]\nk = 0\ns = ''\nwhile a != b:\n\tx = y = 1\n\tif a[0] > b[0]:\n\t\tx = 0\n\telif a[0] < b[0]:\n\t\tx = 2\n\tif a[1] > b[1]:\n\t\ty = 0\n\telif a[1] < b[1]:\n\t\ty = 2\n\ta[0] += x - 1\n\ta[1] += y - 1\n\tk += 1\n\ts += m[2 - y][x] + '\\n'\nprint(k)\nprint(s)\n",
        "dictionary = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ns = input()\nt = input()\nsx = dictionary[s[0]]\nsy = int(s[1])\ntx = dictionary[t[0]]\nty = int(t[1])\nn = max(abs(sx - tx), abs(sy - ty))\nprint(n)\nd = min(abs(sx - tx), abs(sy - ty))\nstep = ''\nif sx > tx:\n\tstep += 'L'\nelse:\n\tstep += 'R'\nif sy > ty:\n\tstep += 'D'\nelse:\n\tstep += 'U'\nfor i in range(d):\n\tprint(step)\nstep = ''\nif abs(sx - tx) > abs(sy - ty):\n\tif sx > tx:\n\t\tstep += 'L'\n\telse:\n\t\tstep += 'R'\nelif sy > ty:\n\tstep += 'D'\nelse:\n\tstep += 'U'\nfor i in range(n - d):\n\tprint(step)\n",
        "cell1 = input()\ncell2 = input()\nh_dist = ord(cell2[0]) - ord(cell1[0])\nv_dist = ord(cell2[1]) - ord(cell1[1])\nprint(max(abs(h_dist), abs(v_dist)))\ndiag = ('R', 'L')[h_dist < 0] + ('U', 'D')[v_dist < 0] + '\\n'\nif abs(h_dist) >= abs(v_dist):\n\tprint(diag * abs(v_dist), end='')\n\th = ('R', 'L')[h_dist < 0] + '\\n'\n\tprint(h * (abs(h_dist) - abs(v_dist)), end='')\nelse:\n\tprint(diag * abs(h_dist), end='')\n\tv = ('U', 'D')[v_dist < 0] + '\\n'\n\tprint(v * (abs(v_dist) - abs(h_dist)), end='')\n",
        "s = str(input())\nf = str(input())\nif s[0] == 'a':\n\ts1 = 0\nelif s[0] == 'b':\n\ts1 = 1\nelif s[0] == 'c':\n\ts1 = 2\nelif s[0] == 'd':\n\ts1 = 3\nelif s[0] == 'e':\n\ts1 = 4\nelif s[0] == 'f':\n\ts1 = 5\nelif s[0] == 'g':\n\ts1 = 6\nelif s[0] == 'h':\n\ts1 = 7\ns2 = int(s[1])\nif f[0] == 'a':\n\tf1 = 0\nelif f[0] == 'b':\n\tf1 = 1\nelif f[0] == 'c':\n\tf1 = 2\nelif f[0] == 'd':\n\tf1 = 3\nelif f[0] == 'e':\n\tf1 = 4\nelif f[0] == 'f':\n\tf1 = 5\nelif f[0] == 'g':\n\tf1 = 6\nelif f[0] == 'h':\n\tf1 = 7\nf2 = int(f[1])\nans = 0\nif abs(f1 - s1) > ans:\n\tans = abs(f1 - s1)\nif abs(f2 - s2) > ans:\n\tans = abs(f2 - s2)\nprint(ans)\nwhile abs(f1 - s1) + abs(f2 - s2) > 0:\n\tif f1 > s1:\n\t\tdir = 'R'\n\t\ts1 += 1\n\telif f1 < s1:\n\t\tdir = 'L'\n\t\ts1 -= 1\n\telse:\n\t\tdir = ''\n\tif f2 > s2:\n\t\tdir = dir + 'U'\n\t\ts2 += 1\n\telif f2 < s2:\n\t\ts2 -= 1\n\t\tdir = dir + 'D'\n\tprint(dir)\n",
        "def main():\n\t(m, n) = (input(), input())\n\t(x1, y1, x2, y2, a) = (m[0], int(m[1]), n[0], int(n[1]), [])\n\tif x1 == 'a':\n\t\tx1 = 1\n\telif x1 == 'b':\n\t\tx1 = 2\n\telif x1 == 'c':\n\t\tx1 = 3\n\telif x1 == 'd':\n\t\tx1 = 4\n\telif x1 == 'e':\n\t\tx1 = 5\n\telif x1 == 'f':\n\t\tx1 = 6\n\telif x1 == 'g':\n\t\tx1 = 7\n\telif x1 == 'h':\n\t\tx1 = 8\n\tif x2 == 'a':\n\t\tx2 = 1\n\telif x2 == 'b':\n\t\tx2 = 2\n\telif x2 == 'c':\n\t\tx2 = 3\n\telif x2 == 'd':\n\t\tx2 = 4\n\telif x2 == 'e':\n\t\tx2 = 5\n\telif x2 == 'f':\n\t\tx2 = 6\n\telif x2 == 'g':\n\t\tx2 = 7\n\telif x2 == 'h':\n\t\tx2 = 8\n\twhile x2 - x1 > 0 and y2 - y1 > 0:\n\t\tx1 += 1\n\t\ty1 += 1\n\t\ta.append('RU')\n\twhile x2 - x1 < 0 and y2 - y1 > 0:\n\t\tx1 -= 1\n\t\ty1 += 1\n\t\ta.append('LU')\n\twhile x2 - x1 < 0 and y2 - y1 < 0:\n\t\tx1 -= 1\n\t\ty1 -= 1\n\t\ta.append('LD')\n\twhile x2 - x1 > 0 and y2 - y1 < 0:\n\t\tx1 += 1\n\t\ty1 -= 1\n\t\ta.append('RD')\n\twhile x2 - x1 > 0:\n\t\tx1 += 1\n\t\ta.append('R')\n\twhile x2 - x1 < 0:\n\t\tx1 -= 1\n\t\ta.append('L')\n\twhile y2 - y1 > 0:\n\t\ty1 += 1\n\t\ta.append('U')\n\twhile y2 - y1 < 0:\n\t\ty1 -= 1\n\t\ta.append('D')\n\tprint(len(a))\n\tfor item in a:\n\t\tprint(item)\nmain()\n",
        "notation = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\ndef left(x):\n\tfor let in range(7):\n\t\tif notation[let + 1] == x:\n\t\t\treturn notation[let]\n\ndef right(x):\n\tfor let in range(7):\n\t\tif notation[let] == x:\n\t\t\treturn notation[let + 1]\n\ndef u(x, y):\n\treturn [x, y + 1]\n\ndef d(x, y):\n\treturn [x, y - 1]\n\ndef l(x, y):\n\treturn [left(x), y]\n\ndef r(x, y):\n\treturn [right(x), y]\n\ndef lu(x, y):\n\treturn [left(x), y + 1]\n\ndef ld(x, y):\n\treturn [left(x), y - 1]\n\ndef ru(x, y):\n\treturn [right(x), y + 1]\n\ndef rd(x, y):\n\treturn [right(x), y - 1]\n\ndef sameColumn(a, b):\n\tif a[0] == b[0]:\n\t\treturn True\n\treturn False\n\ndef sameRow(a, b):\n\tif int(a[1]) == int(b[1]):\n\t\treturn True\n\treturn False\n\ndef lexDistance(a, b):\n\t(m, n) = (0, 0)\n\tfor x in range(len(notation)):\n\t\tif notation[x] == a[0]:\n\t\t\tm = x\n\t\telif notation[x] == b[0]:\n\t\t\tn = x\n\treturn abs(m - n)\na = input()\nb = input()\n(a, b) = (' '.join(a).split(), ' '.join(b).split())\nb[1] = int(b[1])\nc = 0\nmoves = []\nover = False\nif a[0] == b[0] and int(a[1]) == int(b[1]):\n\tprint(0)\nelif sameColumn(a, b):\n\tprint(abs(int(a[1]) - int(b[1])))\n\tif int(a[1]) < int(b[1]):\n\t\twhile a != b:\n\t\t\ta = u(a[0], int(a[1]))\n\t\t\tmoves.append('U')\n\t\t\tc += 1\n\t\t\tif a == b:\n\t\t\t\tfor m in moves:\n\t\t\t\t\tprint(m)\n\t\t\t\tover = True\n\t\t\t\tbreak\n\telse:\n\t\twhile a != b:\n\t\t\ta = d(a[0], int(a[1]))\n\t\t\tmoves.append('D')\n\t\t\tc += 1\n\t\t\tif a == b:\n\t\t\t\tfor m in moves:\n\t\t\t\t\tprint(m)\n\t\t\t\tover = True\n\t\t\t\tbreak\nelif sameRow(a, b):\n\tprint(lexDistance(a, b))\n\tif ord(a[0]) < ord(b[0]):\n\t\twhile a != b:\n\t\t\ta = r(a[0], int(a[1]))\n\t\t\tmoves.append('R')\n\t\t\tc += 1\n\t\t\tif a == b:\n\t\t\t\tfor m in moves:\n\t\t\t\t\tprint(m)\n\t\t\t\tover = True\n\t\t\t\tbreak\n\telse:\n\t\twhile a != b:\n\t\t\ta = l(a[0], int(a[1]))\n\t\t\tmoves.append('L')\n\t\t\tc += 1\n\t\t\tif a == b:\n\t\t\t\tfor m in moves:\n\t\t\t\t\tprint(m)\n\t\t\t\tover = True\n\t\t\t\tbreak\nelif ord(a[0]) < ord(b[0]) and int(a[1]) < int(b[1]):\n\twhile a[0] != b[0] and int(a[1]) != int(b[1]):\n\t\ta = ru(a[0], int(a[1]))\n\t\tmoves.append('RU')\n\t\tc += 1\n\t\tif a == b:\n\t\t\tprint(c)\n\t\t\tfor m in moves:\n\t\t\t\tprint(m)\n\t\t\tover = True\n\t\t\tbreak\n\telse:\n\t\tif not over:\n\t\t\twhile int(a[1]) == int(b[1]):\n\t\t\t\ta = r(a[0], int(a[1]))\n\t\t\t\tmoves.append('R')\n\t\t\t\tc += 1\n\t\t\t\tif a == b:\n\t\t\t\t\tprint(c)\n\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\tprint(m)\n\t\t\t\t\tover = True\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif not over:\n\t\t\t\t\twhile a[0] == b[0]:\n\t\t\t\t\t\ta = u(a[0], int(a[1]))\n\t\t\t\t\t\tmoves.append('U')\n\t\t\t\t\t\tc += 1\n\t\t\t\t\t\tif a == b:\n\t\t\t\t\t\t\tprint(c)\n\t\t\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\t\t\tprint(m)\n\t\t\t\t\t\t\tover = True\n\t\t\t\t\t\t\tbreak\nelif ord(a[0]) < ord(b[0]) and int(a[1]) > int(b[1]):\n\twhile a[0] != b[0] and int(a[1]) != int(b[1]):\n\t\ta = rd(a[0], int(a[1]))\n\t\tmoves.append('RD')\n\t\tc += 1\n\t\tif a == b:\n\t\t\tprint(c)\n\t\t\tfor m in moves:\n\t\t\t\tprint(m)\n\t\t\tover = True\n\t\t\tbreak\n\telse:\n\t\tif not over:\n\t\t\twhile int(a[1]) == int(b[1]):\n\t\t\t\ta = r(a[0], int(a[1]))\n\t\t\t\tmoves.append('R')\n\t\t\t\tc += 1\n\t\t\t\tif a == b:\n\t\t\t\t\tprint(c)\n\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\tprint(m)\n\t\t\t\t\tover = True\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif not over:\n\t\t\t\t\twhile a[0] == b[0]:\n\t\t\t\t\t\ta = d(a[0], int(a[1]))\n\t\t\t\t\t\tmoves.append('D')\n\t\t\t\t\t\tc += 1\n\t\t\t\t\t\tif a == b:\n\t\t\t\t\t\t\tprint(c)\n\t\t\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\t\t\tprint(m)\n\t\t\t\t\t\t\tover = True\n\t\t\t\t\t\t\tbreak\nelif ord(a[0]) > ord(b[0]) and int(a[1]) > int(b[1]):\n\twhile a[0] != b[0] and int(a[1]) != int(b[1]):\n\t\ta = ld(a[0], int(a[1]))\n\t\tmoves.append('LD')\n\t\tc += 1\n\t\tif a == b:\n\t\t\tprint(c)\n\t\t\tfor m in moves:\n\t\t\t\tprint(m)\n\t\t\tover = True\n\t\t\tbreak\n\telse:\n\t\tif not over:\n\t\t\twhile int(a[1]) == int(b[1]):\n\t\t\t\ta = l(a[0], int(a[1]))\n\t\t\t\tmoves.append('L')\n\t\t\t\tc += 1\n\t\t\t\tif a == b:\n\t\t\t\t\tprint(c)\n\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\tprint(m)\n\t\t\t\t\tover = True\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif not over:\n\t\t\t\t\twhile a[0] == b[0]:\n\t\t\t\t\t\ta = d(a[0], int(a[1]))\n\t\t\t\t\t\tmoves.append('D')\n\t\t\t\t\t\tc += 1\n\t\t\t\t\t\tif a == b:\n\t\t\t\t\t\t\tprint(c)\n\t\t\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\t\t\tprint(m)\n\t\t\t\t\t\t\tover = True\n\t\t\t\t\t\t\tbreak\nelif ord(a[0]) > ord(b[0]) and int(a[1]) < int(b[1]):\n\twhile a[0] != b[0] and int(a[1]) != int(b[1]):\n\t\ta = lu(a[0], int(a[1]))\n\t\tmoves.append('LU')\n\t\tc += 1\n\t\tif a == b:\n\t\t\tprint(c)\n\t\t\tfor m in moves:\n\t\t\t\tprint(m)\n\t\t\tover = True\n\t\t\tbreak\n\telse:\n\t\tif not over:\n\t\t\twhile int(a[1]) == int(b[1]):\n\t\t\t\ta = l(a[0], int(a[1]))\n\t\t\t\tmoves.append('L')\n\t\t\t\tc += 1\n\t\t\t\tif a == b:\n\t\t\t\t\tprint(c)\n\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\tprint(m)\n\t\t\t\t\tover = True\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tif not over:\n\t\t\t\t\twhile a[0] == b[0]:\n\t\t\t\t\t\ta = u(a[0], int(a[1]))\n\t\t\t\t\t\tmoves.append('U')\n\t\t\t\t\t\tc += 1\n\t\t\t\t\t\tif a == b:\n\t\t\t\t\t\t\tprint(c)\n\t\t\t\t\t\t\tfor m in moves:\n\t\t\t\t\t\t\t\tprint(m)\n\t\t\t\t\t\t\tover = True\n\t\t\t\t\t\t\tbreak\n",
        "(p, q) = (input(), input())\nn = 0\nsteps = []\n(x1, y1, x2, y2) = (ord(p[0]), int(p[1]), ord(q[0]), int(q[1]))\nwhile x1 != x2 or y1 != y2:\n\tn += 1\n\ts = ''\n\tif x1 < x2:\n\t\ts += 'R'\n\t\tx1 += 1\n\tif x1 > x2:\n\t\ts += 'L'\n\t\tx1 -= 1\n\tif y1 < y2:\n\t\ts += 'U'\n\t\ty1 += 1\n\tif y1 > y2:\n\t\ts += 'D'\n\t\ty1 -= 1\n\tsteps.append(s)\nprint(n)\nfor j in steps:\n\tprint(j)\n",
        "s = list(input())\na = list(input())\nr = ord(s[0]) - ord(a[0])\ny = int(s[1]) - int(a[1])\nprint(max(r, y, -r, -y))\nl = []\nwhile r != 0 or y != 0:\n\tl = []\n\tif r > 0:\n\t\tl.append('L')\n\t\tr = r - 1\n\tif r < 0:\n\t\tl.append('R')\n\t\tr = r + 1\n\tif y > 0:\n\t\tl.append('D')\n\t\ty = y - 1\n\tif y < 0:\n\t\tl.append('U')\n\t\ty = y + 1\n\tprint(''.join(l))\n",
        "def main():\n\t(start_c, start_r) = input()\n\t(end_c, end_r) = input()\n\t(start_r, end_r) = (int(start_r) - 1, int(end_r) - 1)\n\ta = ord('A')\n\t(start_c, end_c) = (ord(start_c) - a, ord(end_c) - a)\n\t(cdiff, rdiff) = (end_c - start_c, end_r - start_r)\n\t(cd, rd) = (abs(cdiff), abs(rdiff))\n\t(max_diff, min_diff) = (max(cd, rd), min(cd, rd))\n\tcelm = 'R' if cdiff >= 0 else 'L'\n\trelm = 'U' if rdiff >= 0 else 'D'\n\tres = [celm] * max_diff if max_diff == cd else [relm] * max_diff\n\tfor i in range(min_diff):\n\t\tres[i] = res[i] + relm if max_diff == cd else celm + res[i]\n\tprint(len(res))\n\tprint('\\n'.join(res))\nmain()\n",
        "s = input()\nsx = ord(s[0]) - ord('a')\nsy = int(s[1])\ns = input()\nfx = ord(s[0]) - ord('a')\nfy = int(s[1])\na = []\nk = 0\nwhile sy != fy or sx != fx:\n\ts = ''\n\tif sx > fx:\n\t\ts = 'L'\n\t\tsx -= 1\n\telif sx < fx:\n\t\ts = 'R'\n\t\tsx += 1\n\tif sy < fy:\n\t\ts += 'U'\n\t\tsy += 1\n\telif sy > fy:\n\t\ts += 'D'\n\t\tsy -= 1\n\ta.append(s)\n\tk += 1\nprint(k)\nfor s in a:\n\tprint(s)\n",
        "s = input()\nt = input()\nc = ord(s[0])\nd = ord(t[0])\nf = int(s[1])\ng = int(t[1])\nk = []\nwhile True:\n\tif c == d and f == int(t[1]):\n\t\tbreak\n\tif c > d and f > int(t[1]):\n\t\tc -= 1\n\t\tf = f - 1\n\t\tk.append('LD')\n\tif c < d and f < int(t[1]):\n\t\tc += 1\n\t\tf = f + 1\n\t\tk.append('RU')\n\tif c > d and f < int(t[1]):\n\t\tc -= 1\n\t\tf = f + 1\n\t\tk.append('LU')\n\tif c < d and f > int(t[1]):\n\t\tc += 1\n\t\tf = f - 1\n\t\tk.append('RD')\n\tif c == d and f > int(t[1]):\n\t\tf = f - 1\n\t\tk.append('D')\n\tif c == d and f < int(t[1]):\n\t\tf = f + 1\n\t\tk.append('U')\n\tif c > d and f == int(t[1]):\n\t\tc -= 1\n\t\tk.append('L')\n\tif c < d and f == int(t[1]):\n\t\tc += 1\n\t\tk.append('R')\nprint(len(k))\nfor i in k:\n\tprint(i)\n",
        "def shortpath(k, p):\n\tletters = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\tk = [int(letters[k[0]]), int(k[1])]\n\tp = [int(letters[p[0]]), int(p[1])]\n\tdiff = list([abs(int(k[0]) - int(p[0])), abs(int(k[1]) - int(p[1]))])\n\tcurr = k\n\tif diff[0] != diff[1]:\n\t\tn_moves = max(diff)\n\t\tprint(n_moves)\n\t\tn_diag = min(diff)\n\t\ttem = n_diag\n\telse:\n\t\tn_moves = diff[0]\n\t\tprint(n_moves)\n\t\tn_diag = diff[0]\n\t\ttem = n_diag\n\tif n_diag > 0:\n\t\tif p[0] > k[0]:\n\t\t\tif p[1] > k[1]:\n\t\t\t\tfor i in range(n_diag):\n\t\t\t\t\tprint('RU')\n\t\t\t\t\tcurr[0] += 1\n\t\t\t\t\tcurr[1] += 1\n\t\t\tif p[1] < k[1]:\n\t\t\t\tfor i in range(n_diag):\n\t\t\t\t\tprint('RD')\n\t\t\t\t\tcurr[0] += 1\n\t\t\t\t\tcurr[1] -= 1\n\t\tif p[0] < k[0]:\n\t\t\tif p[1] > k[1]:\n\t\t\t\tfor i in range(n_diag):\n\t\t\t\t\tprint('LU')\n\t\t\t\t\tcurr[0] -= 1\n\t\t\t\t\tcurr[1] += 1\n\t\t\tif p[1] < k[1]:\n\t\t\t\tfor i in range(n_diag):\n\t\t\t\t\tprint('LD')\n\t\t\t\t\tcurr[0] -= 1\n\t\t\t\t\tcurr[1] -= 1\n\tif curr[0] == p[0]:\n\t\tif p[1] > curr[1]:\n\t\t\tfor i in range(n_moves - n_diag):\n\t\t\t\tprint('U')\n\t\tif p[1] < curr[1]:\n\t\t\tfor i in range(n_moves - n_diag):\n\t\t\t\tprint('D')\n\tif curr[1] == p[1]:\n\t\tif p[0] > curr[0]:\n\t\t\tfor i in range(n_moves - n_diag):\n\t\t\t\tprint('R')\n\t\tif p[0] < curr[0]:\n\t\t\tfor i in range(n_moves - n_diag):\n\t\t\t\tprint('L')\nk = input()\np = input()\nshortpath(k, p)\n",
        "__author__ = 'liraim'\n\ndef read_input():\n\tstart = input()\n\ttarget = input()\n\treturn {'start': parse_position(start), 'target': parse_position(target)}\n\ndef parse_position(chess_position):\n\tcolumn = ord(chess_position[0]) - ord('a')\n\trow = int(chess_position[1]) - 1\n\treturn (column, row)\n\ndef solve(input_data):\n\tstart = input_data['start']\n\ttarget = input_data['target']\n\tdiagonal_move_count = min(abs(start[0] - target[0]), abs(start[1] - target[1]))\n\tmove_count = diagonal_move_count + (abs(start[0] - target[0]) - diagonal_move_count) + (abs(start[1] - target[1]) - diagonal_move_count)\n\tdiagonal_direction = ('R' if target[0] - start[0] > 0 else 'L') + ('D' if target[1] - start[1] < 0 else 'U')\n\tanswer = [diagonal_direction] * diagonal_move_count\n\tanswer += ['D' if target[1] - start[1] < 0 else 'U'] * (abs(start[1] - target[1]) - diagonal_move_count) + ['R' if target[0] - start[0] > 0 else 'L'] * (abs(start[0] - target[0]) - diagonal_move_count)\n\treturn {'count': move_count, 'moves': answer}\n\ndef output_answer(answer):\n\tprint(answer['count'])\n\tfor move in answer['moves']:\n\t\tprint(move)\noutput_answer(solve(read_input()))\n",
        "def div(est):\n\treturn (est[0], est[1])\n\ndef move(moveh, movev):\n\tmov = ''\n\tif moveh == 1:\n\t\tmov = mov + 'R'\n\telif moveh == -1:\n\t\tmov = mov + 'L'\n\tif movev == 1:\n\t\tmov = mov + 'U'\n\telif movev == -1:\n\t\tmov = mov + 'D'\n\treturn mov\ns = input()\nt = input()\ntablero = []\nletras = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nnum = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h'}\nactual = s\n(lt, nt) = div(t)\ncont = 0\nmoves = []\nwhile actual != t:\n\t(lactual, nactual) = div(actual)\n\tif letras[lactual] > letras[lt]:\n\t\tmoveh = -1\n\telif letras[lactual] == letras[lt]:\n\t\tmoveh = 0\n\telse:\n\t\tmoveh = 1\n\tif nactual > nt:\n\t\tmovev = -1\n\telif nactual == nt:\n\t\tmovev = 0\n\telse:\n\t\tmovev = 1\n\tmov = move(moveh, movev)\n\tcont += 1\n\tmoves.append(mov)\n\tactual = num[letras[lactual] + moveh]\n\tpaso = int(nactual) + movev\n\tactual += str(paso)\nprint(cont)\nfor m in moves:\n\tprint(m)\n",
        "def fun(x1, y1, x2, y2):\n\tif abs(x2 - x1) == abs(y2 - y1):\n\t\tprint(abs(x2 - x1))\n\telif abs(x2 - x1) == 0 and abs(y2 - y1) > 0:\n\t\tprint(abs(y2 - y1))\n\telif abs(x2 - x1) > 0 and abs(y2 - y1) == 0:\n\t\tprint(abs(x2 - x1))\n\telif abs(x2 - x1) > 0 and abs(y2 - y1) > 0 and (abs(x2 - x1) != abs(y2 - y1)):\n\t\tprint(max(abs(y2 - y1), abs(x2 - x1)))\n\twhile x1 - x2 != 0 or y1 - y2 != 0:\n\t\tif x1 - x2 < 0 and y1 - y2 == 0:\n\t\t\tx1 = x1 + 1\n\t\t\tprint('D')\n\t\tif x1 - x2 > 0 and y1 - y2 == 0:\n\t\t\tx1 = x1 - 1\n\t\t\tprint('U')\n\t\tif x1 - x2 == 0 and y1 - y2 < 0:\n\t\t\ty1 = y1 + 1\n\t\t\tprint('R')\n\t\tif x1 - x2 == 0 and y1 - y2 > 0:\n\t\t\ty1 = y1 - 1\n\t\t\tprint('L')\n\t\tif x1 - x2 > 0 and y1 - y2 > 0:\n\t\t\tx1 = x1 - 1\n\t\t\ty1 = y1 - 1\n\t\t\tprint('LU')\n\t\tif x1 - x2 > 0 and y1 - y2 < 0:\n\t\t\tx1 = x1 - 1\n\t\t\ty1 = y1 + 1\n\t\t\tprint('RU')\n\t\tif x1 - x2 < 0 and y1 - y2 < 0:\n\t\t\tx1 = x1 + 1\n\t\t\ty1 = y1 + 1\n\t\t\tprint('RD')\n\t\tif x1 - x2 < 0 and y1 - y2 > 0:\n\t\t\tx1 = x1 + 1\n\t\t\ty1 = y1 - 1\n\t\t\tprint('LD')\n\treturn\na = input()\nb = input()\nDict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ny1 = Dict.get(a[0])\nx1 = 9 - int(a[1])\ny2 = Dict.get(b[0])\nx2 = 9 - int(b[1])\nfun(x1, y1, x2, y2)\n",
        "q = input()\nw = input()\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\ndef j(m, n):\n\tif m >= n:\n\t\treturn m - n\n\telse:\n\t\treturn n - m\na = int(q[1])\nb = int(w[1])\nc = d.get(q[0])\nh = d.get(w[0])\nbushu = max(j(a, b), j(c, h))\nprint(bushu)\nfor i in range(bushu):\n\tif a == b and c == h:\n\t\tbreak\n\tr = ''\n\tif c < h:\n\t\tr += 'R'\n\t\tc += 1\n\tif c > h:\n\t\tr += 'L'\n\t\tc -= 1\n\tif a < b:\n\t\tr += 'U'\n\t\ta += 1\n\tif a > b:\n\t\tr += 'D'\n\t\ta -= 1\n\tprint(r)\n",
        "a = input()\nb = input()\nx = ord(a[0]) - ord('a')\ny = int(a[1])\nx1 = ord(b[0]) - ord('a')\ny1 = int(b[1])\nperx = x1 - x\npery = y1 - y\nprint(max(abs(perx), abs(pery)))\nif abs(perx) >= abs(pery):\n\tif perx < 0:\n\t\tnum = ['L' for i in range(abs(perx))]\n\telse:\n\t\tnum = ['R' for i in range(abs(perx))]\n\tif pery < 0:\n\t\tfor i in range(abs(pery)):\n\t\t\tnum[i] += 'D'\n\telse:\n\t\tfor i in range(abs(pery)):\n\t\t\tnum[i] += 'U'\nelse:\n\tif pery < 0:\n\t\tnum = ['D' for i in range(abs(pery))]\n\telse:\n\t\tnum = ['U' for i in range(abs(pery))]\n\tif perx < 0:\n\t\tfor i in range(abs(perx)):\n\t\t\tnum[i] += 'L'\n\telse:\n\t\tfor i in range(abs(perx)):\n\t\t\tnum[i] += 'R'\nfor i in range(len(num)):\n\tif len(num[i]) == 2:\n\t\tif num[i][0] == 'D' or num[i][0] == 'U':\n\t\t\tnum[i] = num[i][1] + num[i][0]\n\tprint(num[i])\n",
        "dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nc = list(input())\nd = list(input())\nc[0] = dict[c[0]]\nd[0] = dict[d[0]]\nc[1] = int(c[1])\nd[1] = int(d[1])\nhor = []\nif c[0] >= d[0]:\n\thor.extend(list('L' * (c[0] - d[0])))\nelse:\n\thor.extend(list('R' * abs(c[0] - d[0])))\nver = []\nif c[1] >= d[1]:\n\tver.extend(list('D' * (c[1] - d[1])))\nelse:\n\tver.extend(list('U' * abs(c[1] - d[1])))\nprint(max(len(ver), len(hor)))\nfor i in range(min(len(ver), len(hor))):\n\tprint(hor[i], end='')\n\tprint(ver[i])\nif len(ver) > len(hor):\n\tif len(hor) != 0:\n\t\tprint('\\n'.join(ver[len(hor):]))\n\telse:\n\t\tprint('\\n'.join(ver))\nelif len(ver) < len(hor):\n\tif len(ver) != 0:\n\t\tprint('\\n'.join(hor[abs(len(ver)):]))\n\telse:\n\t\tprint('\\n'.join(hor))\n",
        "(a, b) = input()\na = ord(a) - 96\na = int(a)\nb = int(b)\n(c, d) = input()\nc = ord(c) - 96\nd = int(d)\nans = 0\nans = a - c + (b - d)\n(x, y) = (a - c, b - d)\nprint(max(abs(x), abs(y)))\nwhile x != 0 or y != 0:\n\tr = ''\n\tif x < 0:\n\t\tr = 'R'\n\t\tx += 1\n\tif x > 0:\n\t\tr = 'L'\n\t\tx -= 1\n\tif y < 0:\n\t\tr += 'U'\n\t\ty += 1\n\tif y > 0:\n\t\tr += 'D'\n\t\ty -= 1\n\tprint(r)\n",
        "s = input()\nt = input()\nd1 = ord(s[0]) - ord(t[0])\nd2 = ord(s[1]) - ord(t[1])\nif d1 < 0:\n\td3 = -d1\nelse:\n\td3 = d1\nif d2 < 0:\n\td4 = -d2\nelse:\n\td4 = d2\nif d3 > d4:\n\tprint(d3)\n\tr = d3\nelse:\n\tprint(d4)\n\tr = d4\nfor i in range(r):\n\tif i < d3:\n\t\tif d1 < 0:\n\t\t\tprint('R', end='')\n\t\telif d1 > 0:\n\t\t\tprint('L', end='')\n\tif i < d4:\n\t\tif d2 < 0:\n\t\t\tprint('U')\n\t\telif d2 > 0:\n\t\t\tprint('D')\n\telse:\n\t\tprint('')\n",
        "chars = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ns = input()\nt = input()\ns = (int(chars[s[0]]), int(s[1]))\nt = (int(chars[t[0]]), int(t[1]))\nx = t[0] - s[0]\ny = t[1] - s[1]\nans = []\nansx = ['L'] * abs(min(0, x)) + ['R'] * abs(max(0, x))\nansy = ['D'] * abs(min(0, y)) + ['U'] * abs(max(0, y))\nprint(max(len(ansx), len(ansy)))\nwhile ansx and ansy:\n\tprint(ansx[0], ansy[0], sep='')\n\tansx.pop(0)\n\tansy.pop(0)\nif ansx:\n\tprint(*ansx, sep='\\n')\nelif ansy:\n\tprint(*ansy, sep='\\n')\n",
        "def read():\n\ttmp = input()\n\tx = ord(tmp[0]) - ord('A')\n\ty = int(tmp[1])\n\treturn (x, y)\nX = read()\nY = read()\ncol = X[1] - Y[1]\nrow = X[0] - Y[0]\nPos = []\nwhile row > 0 and col > 0:\n\tPos.append('LD')\n\trow -= 1\n\tcol -= 1\nwhile row > 0 and col < 0:\n\tPos.append('LU')\n\trow -= 1\n\tcol += 1\nwhile row < 0 and col > 0:\n\tPos.append('RD')\n\trow += 1\n\tcol -= 1\nwhile row < 0 and col < 0:\n\tPos.append('RU')\n\trow += 1\n\tcol += 1\nwhile row < 0:\n\tPos.append('R')\n\trow += 1\nwhile row > 0:\n\tPos.append('L')\n\trow -= 1\nwhile col < 0:\n\tPos.append('U')\n\tcol += 1\nwhile col > 0:\n\tPos.append('D')\n\tcol -= 1\nprint(len(Pos))\nfor i in Pos:\n\tprint(i)\n",
        "a = str(input())\nb = str(input())\ncount1 = ord(a[0]) - ord(b[0])\ncount2 = ord(a[1]) - ord(b[1])\nbigger = abs(count1) if abs(count1) > abs(count2) else abs(count2)\ndis = abs(count1) - abs(count2)\nab = bigger - abs(dis)\nprint(bigger)\nout1 = 'R' if count1 < 0 else 'L'\nout2 = 'D' if count2 > 0 else 'U'\nfor i in range(0, ab):\n\tprint(out1 + out2)\nfor i in range(0, abs(dis)):\n\tprint(out1 if dis > 0 else out2)\n",
        "s1 = input()\ns2 = input()\ny = ord(s2[0]) - ord(s1[0])\nx = int(s2[1]) - int(s1[1])\nif abs(x) > abs(y):\n\tside = abs(y)\n\tg = abs(x)\nelse:\n\tside = abs(x)\n\tg = abs(y)\nif y >= 0 and x >= 0:\n\ts = 'RU'\nelif y < 0 and x >= 0:\n\ts = 'LU'\nelif y >= 0 and x < 0:\n\ts = 'RD'\nelse:\n\ts = 'LD'\nl = [s] * side\nif side == abs(x):\n\tif y > 0:\n\t\tfor i in range(g - side):\n\t\t\tl.append('R')\n\telse:\n\t\tfor i in range(g - side):\n\t\t\tl.append('L')\nelif x > 0:\n\tfor i in range(g - side):\n\t\tl.append('U')\nelse:\n\tfor i in range(g - side):\n\t\tl.append('D')\nprint(str(len(l)))\nfor i in range(len(l)):\n\tprint(l[i])\n",
        "def sign(n):\n\treturn 0 if n == 0 else n // abs(n)\n\ndef parse(cell):\n\treturn (ord(cell[0]), int(cell[1]))\n\ndef part(start, end, d, x, y):\n\t(start_x, start_y) = parse(start)\n\t(end_x, end_y) = parse(end)\n\tmoves = 0\n\tpath = []\n\tsign_x = sign(end_x - start_x)\n\tsign_y = sign(end_y - start_y)\n\twhile not start_x == end_x and (not start_y == end_y):\n\t\tmoves += 1\n\t\tpath.append(d)\n\t\tstart_x += sign_x\n\t\tstart_y += sign_y\n\tif start_x == end_x:\n\t\twhile not start_y == end_y:\n\t\t\tmoves += 1\n\t\t\tpath.append(y)\n\t\t\tstart_y += sign_y\n\telse:\n\t\twhile not start_x == end_x:\n\t\t\tmoves += 1\n\t\t\tpath.append(x)\n\t\t\tstart_x += sign_x\n\treturn (moves, path)\n\ndef solver(start, end):\n\tif start == end:\n\t\treturn (0, [])\n\t(start_x, start_y) = parse(start)\n\t(end_x, end_y) = parse(end)\n\tif start_x < end_x and start_y <= end_y:\n\t\treturn part(start, end, 'RU', 'R', 'U')\n\telif start_x <= end_x and start_y > end_y:\n\t\treturn part(start, end, 'RD', 'R', 'D')\n\telif start_x > end_x and start_y >= end_y:\n\t\treturn part(start, end, 'LD', 'L', 'D')\n\telse:\n\t\treturn part(start, end, 'LU', 'L', 'U')\n\ndef main():\n\tstart = input()\n\tend = input()\n\t(moves, path) = solver(start, end)\n\tprint(moves)\n\tfor el in path:\n\t\tprint(el)\nmain()\n",
        "class A:\n\n\tdef solve(self):\n\t\tmap_dict = {}\n\t\tletters = 'abcdefgh'\n\t\tindex = 1\n\t\tfor l in letters:\n\t\t\tmap_dict[l] = index\n\t\t\tindex += 1\n\t\t[sx, sy] = list(input())\n\t\t[tx, ty] = list(input())\n\t\tsx = map_dict[sx]\n\t\ttx = map_dict[tx]\n\t\t(sy, ty) = (int(sy), int(ty))\n\t\t(diffx, diffy) = (abs(sx - tx), abs(sy - ty))\n\t\tdiagonal_steps = min(diffx, diffy)\n\t\tperp_steps = max(diffx, diffy) - diagonal_steps\n\t\tprint(diagonal_steps + perp_steps)\n\t\tvert_step = ''\n\t\thor_step = ''\n\t\tif sx < tx:\n\t\t\thor_step = 'R'\n\t\telse:\n\t\t\thor_step = 'L'\n\t\tif sy < ty:\n\t\t\tvert_step = 'U'\n\t\telse:\n\t\t\tvert_step = 'D'\n\t\tdiagonal_path = [hor_step + vert_step for x in range(diagonal_steps)]\n\t\tif diagonal_steps > 0:\n\t\t\tprint('\\n'.join(diagonal_path))\n\t\tif diagonal_steps == diffx:\n\t\t\tif sy < ty:\n\t\t\t\tvert_step = 'U'\n\t\t\telse:\n\t\t\t\tvert_step = 'D'\n\t\t\tif perp_steps > 0:\n\t\t\t\tprint('\\n'.join([vert_step for x in range(perp_steps)]))\n\t\telse:\n\t\t\tif sx < tx:\n\t\t\t\thor_step = 'R'\n\t\t\telse:\n\t\t\t\thor_step = 'L'\n\t\t\tif perp_steps > 0:\n\t\t\t\tprint('\\n'.join([hor_step for x in range(perp_steps)]))\nA().solve()\n",
        "s = [i for i in input()]\nt = [i for i in input()]\na = ord(s[0]) - ord(t[0])\nb = ord(s[1]) - ord(t[1])\nprint(max(a, -a, b, -b))\nwhile a != 0 or b != 0:\n\tkk = ''\n\tif a < 0:\n\t\tkk = 'R'\n\t\ta += 1\n\tif a > 0:\n\t\tkk = 'L'\n\t\ta -= 1\n\tif b < 0:\n\t\tkk += 'U'\n\t\tb += 1\n\tif b > 0:\n\t\tkk += 'D'\n\t\tb -= 1\n\tprint(kk)\n",
        "def alphToInt(c):\n\td = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\treturn d[c]\nstartpos = input()\nstartx = alphToInt(startpos[0])\nstarty = int(startpos[1])\nendpos = input()\nendx = alphToInt(endpos[0])\nendy = int(endpos[1])\ndiffx = startx - endx\ndiffy = starty - endy\nou = []\nwhile diffx != 0 and diffy != 0:\n\tstr = ''\n\tif diffx > 0:\n\t\tstr = 'L'\n\t\tdiffx -= 1\n\telse:\n\t\tstr = 'R'\n\t\tdiffx += 1\n\tif diffy > 0:\n\t\tstr += 'D'\n\t\tdiffy -= 1\n\telse:\n\t\tstr += 'U'\n\t\tdiffy += 1\n\tou.append(str)\nwhile diffx != 0:\n\tif diffx > 0:\n\t\tou.append('L')\n\t\tdiffx -= 1\n\telse:\n\t\tou.append('R')\n\t\tdiffx += 1\nwhile diffy != 0:\n\tif diffy > 0:\n\t\tou.append('D')\n\t\tdiffy -= 1\n\telse:\n\t\tou.append('U')\n\t\tdiffy += 1\nprint(len(ou))\nfor s in ou:\n\tprint(s)\n",
        "tab = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\n\ndef norm(a):\n\tx = tab[a[0]]\n\ty = int(a[1]) - 1\n\treturn (x, y)\n\ndef decode(d):\n\tdic = {1: 'L', 2: 'R', 4: 'U', 5: 'LU', 6: 'RU', 8: 'D', 9: 'LD', 10: 'RD'}\n\treturn dic[d]\n\ndef getDirection(fx, fy, tx, ty):\n\tr = 0\n\tx = y = 0\n\tif fx < tx:\n\t\tr |= 1 << 1\n\t\tx = 1\n\telif fx > tx:\n\t\tr |= 1\n\t\tx = -1\n\telse:\n\t\tx = 0\n\tif fy < ty:\n\t\tr |= 1 << 2\n\t\ty = 1\n\telif fy > ty:\n\t\tr |= 1 << 3\n\t\ty = -1\n\telse:\n\t\ty = 0\n\treturn (r, x, y)\nfro = input()\n(fx, fy) = norm(fro)\nto = input()\n(tx, ty) = norm(to)\nmove = []\nwhile fx != tx or fy != ty:\n\t(r, x, y) = getDirection(fx, fy, tx, ty)\n\tmove.append(decode(r))\n\tfx += x\n\tfy += y\nprint(len(move))\nfor m in move:\n\tprint(m)\n",
        "T = str(input())\ns = []\ns.append(ord(T[0]) - 96)\ns.append(int(T[1]))\nT = str(input())\ne = []\ne.append(ord(T[0]) - 96)\ne.append(int(T[1]))\ncount = 0\nz = []\nwhile s != e:\n\tif s[0] == e[0]:\n\t\tif s[1] > e[1]:\n\t\t\tk = s[1] - e[1]\n\t\t\tcount += k\n\t\t\ts[1] -= k\n\t\t\tfor i in range(k):\n\t\t\t\tz.append('D')\n\t\telif s[1] < e[1]:\n\t\t\tk = e[1] - s[1]\n\t\t\tcount += k\n\t\t\ts[1] += k\n\t\t\tfor i in range(k):\n\t\t\t\tz.append('U')\n\telif s[1] == e[1]:\n\t\tif s[0] > e[0]:\n\t\t\tk = s[0] - e[0]\n\t\t\tcount += k\n\t\t\ts[0] -= k\n\t\t\tfor i in range(k):\n\t\t\t\tz.append('L')\n\t\telif s[0] < e[0]:\n\t\t\tk = e[0] - s[0]\n\t\t\tcount += k\n\t\t\ts[0] += k\n\t\t\tfor i in range(k):\n\t\t\t\tz.append('R')\n\telif e[0] - s[0] > 0:\n\t\tif e[1] - s[1] > 0:\n\t\t\tcount += 1\n\t\t\ts[1] += 1\n\t\t\ts[0] += 1\n\t\t\tz.append('RU')\n\t\telse:\n\t\t\tcount += 1\n\t\t\ts[0] += 1\n\t\t\ts[1] -= 1\n\t\t\tz.append('RD')\n\telif e[0] - s[0] < 0:\n\t\tif e[1] - s[1] > 0:\n\t\t\tcount += 1\n\t\t\ts[1] += 1\n\t\t\ts[0] -= 1\n\t\t\tz.append('LU')\n\t\telse:\n\t\t\tcount += 1\n\t\t\ts[0] -= 1\n\t\t\ts[1] -= 1\n\t\t\tz.append('LD')\nprint(count)\nfor i in z:\n\tprint(i)\n",
        "(s, t) = (input(), input())\n(x1, y1) = (ord(s[0]) - ord('a') + 1, int(s[1]))\n(x2, y2) = (ord(t[0]) - ord('a') + 1, int(t[1]))\nans = []\nwhile (x1, y1) != (x2, y2):\n\tres = ''\n\tif x2 > x1:\n\t\tres += 'R'\n\t\tx1 += 1\n\telif x2 < x1:\n\t\tres += 'L'\n\t\tx1 -= 1\n\tif y2 > y1:\n\t\tres += 'U'\n\t\ty1 += 1\n\telif y2 < y1:\n\t\tres += 'D'\n\t\ty1 -= 1\n\tans.append(res)\nprint(len(ans))\nprint('\\n'.join(ans))\n",
        "origin = input()\ntarget = input()\n\ndef char2Num(c):\n\treturn ord(c) - ord('a') + 1\n\ndef num2Char(d):\n\treturn chr(ord('a') + d - 1)\nx_origin = char2Num(origin[0])\ny_origin = int(origin[1])\nx_target = char2Num(target[0])\ny_target = int(target[1])\nx = x_origin\ny = y_origin\nsteps = []\nwhile x < x_target and y < y_target:\n\tsteps.append('RU')\n\tx += 1\n\ty += 1\nwhile x < x_target and y > y_target:\n\tsteps.append('RD')\n\tx += 1\n\ty -= 1\nwhile x > x_target and y < y_target:\n\tsteps.append('LU')\n\tx -= 1\n\ty += 1\nwhile x > x_target and y > y_target:\n\tsteps.append('LD')\n\tx -= 1\n\ty -= 1\nwhile x < x_target:\n\tsteps.append('R')\n\tx += 1\nwhile x > x_target:\n\tsteps.append('L')\n\tx -= 1\nwhile y < y_target:\n\tsteps.append('U')\n\ty += 1\nwhile y > y_target:\n\tsteps.append('D')\n\ty -= 1\nprint(len(steps))\nfor step in steps:\n\tprint(step)\n",
        "x = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ny = [1, 2, 3, 4, 5, 6, 7, 8]\nn = input()\nm = input()\nxm = x.index(m[0]) - x.index(n[0])\nym = y.index(int(m[1])) - y.index(int(n[1]))\ng = max(abs(x.index(m[0]) - x.index(n[0])), abs(y.index(int(m[1])) - y.index(int(n[1]))))\nprint(g)\nfor i in range(g):\n\tif xm < 0:\n\t\tprint('L', end='')\n\t\txm = xm + 1\n\tif xm > 0:\n\t\tprint('R', end='')\n\t\txm = xm - 1\n\tif ym < 0:\n\t\tprint('D', end='')\n\t\tym = ym + 1\n\tif ym > 0:\n\t\tprint('U', end='')\n\t\tym = ym - 1\n\tprint('')\n",
        "ch1 = str(input())\nch2 = str(input())\npos1 = (ord(ch1[0]) - ord('a'), int(ch1[1]))\npos2 = (ord(ch2[0]) - ord('a'), int(ch2[1]))\nL = list()\n(a, b, c, d) = (pos1[0], pos1[1], pos2[0], pos2[1])\n(a1, b1, c1, d1) = (a, b, c, d)\nif a < c and b > d:\n\t(a1, b1, c1, d1) = (a, b, c, d)\n\twhile a1 < c1 and b1 > d1:\n\t\ta1 += 1\n\t\tb1 -= 1\n\t\tL.append('RD')\nif a > c and b < d:\n\t(a1, b1, c1, d1) = (a, b, c, d)\n\twhile a1 > c1 and b1 < d1:\n\t\ta1 -= 1\n\t\tb1 += 1\n\t\tL.append('LU')\nif a < c and b < d:\n\t(a1, b1, c1, d1) = (a, b, c, d)\n\twhile a1 < c1 and b1 < d1:\n\t\ta1 += 1\n\t\tb1 += 1\n\t\tL.append('RU')\nif a > c and b > d:\n\t(a1, b1, c1, d1) = (a, b, c, d)\n\twhile a1 > c1 and b1 > d1:\n\t\ta1 -= 1\n\t\tb1 -= 1\n\t\tL.append('LD')\n(a, b, c, d) = (a1, b1, c1, d1)\nif a == c and b == d:\n\tif L == []:\n\t\tprint(0)\n\telse:\n\t\tprint(len(L))\n\t\tfor h in L:\n\t\t\tprint(h)\nelif a == c and b != d:\n\tif b < d:\n\t\t(a1, b1, c1, d1) = (a, b, c, d)\n\t\twhile b1 < d1:\n\t\t\tb1 += 1\n\t\t\tL.append('U')\n\telse:\n\t\t(a1, b1, c1, d1) = (a, b, c, d)\n\t\twhile b1 > d1:\n\t\t\tb1 -= 1\n\t\t\tL.append('D')\n\tprint(len(L))\n\tfor h in L:\n\t\tprint(h)\nelif a != c and b == d:\n\tif a < c:\n\t\t(a1, b1, c1, d1) = (a, b, c, d)\n\t\twhile a1 < c1:\n\t\t\ta1 += 1\n\t\t\tL.append('R')\n\telse:\n\t\t(a1, b1, c1, d1) = (a, b, c, d)\n\t\twhile a1 > c1:\n\t\t\ta1 -= 1\n\t\t\tL.append('L')\n\tprint(len(L))\n\tfor h in L:\n\t\tprint(h)\n",
        "s = input()\nt = input()\nl = []\ni = 0\nwhile True:\n\tif s[0] > t[0]:\n\t\tif s[1] > t[1]:\n\t\t\tc = chr(ord(s[1]) - 1)\n\t\t\ts = chr(ord(s[0]) - 1) + c\n\t\t\tl.append('LD')\n\t\t\ti = i + 1\n\t\telif s[1] < t[1]:\n\t\t\tc = chr(ord(s[1]) + 1)\n\t\t\ts = chr(ord(s[0]) - 1) + c\n\t\t\tl.append('LU')\n\t\t\ti = i + 1\n\t\telse:\n\t\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\t\tl.append('L')\n\t\t\ti = i + 1\n\telif s[0] < t[0]:\n\t\tif s[1] > t[1]:\n\t\t\tc = chr(ord(s[1]) - 1)\n\t\t\ts = chr(ord(s[0]) + 1) + c\n\t\t\tl.append('RD')\n\t\t\ti = i + 1\n\t\telif s[1] < t[1]:\n\t\t\tc = chr(ord(s[1]) + 1)\n\t\t\ts = chr(ord(s[0]) + 1) + c\n\t\t\tl.append('RU')\n\t\t\ti = i + 1\n\t\telse:\n\t\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\t\tl.append('R')\n\t\t\ti += 1\n\telif s[1] > t[1]:\n\t\tc = chr(ord(s[1]) - 1)\n\t\ts = s[0] + c\n\t\tl.append('D')\n\t\ti += 1\n\telif s[1] < t[1]:\n\t\tc = chr(ord(s[1]) + 1)\n\t\ts = s[0] + c\n\t\tl.append('U')\n\t\ti += 1\n\tif s == t:\n\t\tbreak\nprint(i)\nfor x in l:\n\tprint(x)\n",
        "def main():\n\tbegin_point = input()\n\tend_point = input()\n\t(b_x, b_y) = (ord(begin_point[0]), int(begin_point[1]))\n\t(e_x, e_y) = (ord(end_point[0]), int(end_point[1]))\n\tstep = max(abs(b_x - e_x), abs(b_y - e_y))\n\tprint(step)\n\twhile b_x != e_x or b_y != e_y:\n\t\tif b_x < e_x:\n\t\t\tprint('R', end='')\n\t\t\tb_x += 1\n\t\telif b_x > e_x:\n\t\t\tprint('L', end='')\n\t\t\tb_x -= 1\n\t\tif b_y < e_y:\n\t\t\tprint('U', end='')\n\t\t\tb_y += 1\n\t\telif b_y > e_y:\n\t\t\tprint('D', end='')\n\t\t\tb_y -= 1\n\t\tprint('')\nmain()\n",
        "def get_num_pos(pos):\n\tcols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\trows = ['1', '2', '3', '4', '5', '6', '7', '8']\n\t(col, row) = (pos[0], pos[1])\n\treturn [cols.index(col), rows.index(row)]\nslanting_mv = {(1, 1): 'RU', (-1, 1): 'LU', (1, -1): 'RD', (-1, -1): 'LD'}\nparallel_mv = {(1, 0): 'R', (0, 1): 'U', (-1, 0): 'L', (0, -1): 'D'}\nstart_npos = get_num_pos(input())\ndest_npos = get_num_pos(input())\ndiff_npos = [dest_npos[i] - start_npos[i] for i in range(len(dest_npos))]\n(x, y) = diff_npos\nslanting_mv_num = min(abs(x), abs(y))\nparallel_mv_num = max(abs(x), abs(y)) - slanting_mv_num\nsloss_cmd = []\nsloss_val = []\nfor (smv, cmd) in slanting_mv.items():\n\tsloss_cmd.append(smv)\n\tsloss_val.append(abs(x - smv[0] * slanting_mv_num) + abs(y - smv[1] * slanting_mv_num))\nmin_sloss_val = min(sloss_val)\nmin_sloss_cmd = sloss_cmd[sloss_val.index(min_sloss_val)]\ncmd_list = [slanting_mv[min_sloss_cmd] for i in range(slanting_mv_num)]\nx -= min_sloss_cmd[0] * slanting_mv_num\ny -= min_sloss_cmd[1] * slanting_mv_num\nploss_cmd = []\nploss_val = []\nfor (pmv, cmd) in parallel_mv.items():\n\tploss_cmd.append(pmv)\n\tploss_val.append(abs(x - pmv[0] * parallel_mv_num) + abs(y - pmv[1] * parallel_mv_num))\nmin_ploss_val = min(ploss_val)\nmin_ploss_cmd = ploss_cmd[ploss_val.index(min_ploss_val)]\ncmd_list += [parallel_mv[min_ploss_cmd] for i in range(parallel_mv_num)]\nprint(slanting_mv_num + parallel_mv_num)\nprint('\\n'.join(cmd_list))\n",
        "k = input()\np = input()\nx = ord(k[0]) - ord(p[0])\ny = int(k[1]) - int(p[1])\nm = max(abs(x), abs(y))\ns = ['', '']\nprint(m)\nif x <= m:\n\tif x < 0:\n\t\ts[0] = 'R'\n\telif x > 0:\n\t\ts[0] = 'L'\nif y <= m:\n\tif y < 0:\n\t\ts[1] = 'U'\n\telif y > 0:\n\t\ts[1] = 'D'\nfor i in range(m):\n\tif abs(x) > i:\n\t\tprint(s[0], end='')\n\tif abs(y) > i:\n\t\tprint(s[1], end='')\n\tprint()\n",
        "def ter(n, sn, sz, sp):\n\treturn sn if n < 0 else sz if n == 0 else sp\n\ndef sign(n):\n\treturn ter(n, -1, 0, 1)\ns = input()\nt = input()\nn = 0\na = []\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\nt = [ord(t[0]) - ord('a') + 1, int(t[1])]\nwhile s != t:\n\td0 = sign(t[0] - s[0])\n\td1 = sign(t[1] - s[1])\n\ts[0] += d0\n\ts[1] += d1\n\ta.append(ter(d0, 'L', '', 'R') + ter(d1, 'D', '', 'U'))\nprint(len(a))\nfor s in a:\n\tprint(s)\n",
        "(start, end, lettermap, numbermap) = (input(), input(), {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}, {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h'})\nif start == end:\n\tprint(0)\nelse:\n\tstart = (lettermap[start[0]], int(start[1]))\n\tend = (lettermap[end[0]], int(end[1]))\n\tdifference = [end[0] - start[0], end[1] - start[1]]\n\tmoves = []\n\twhile difference != [0, 0]:\n\t\tmoves.append('')\n\t\tif difference[0] > 0:\n\t\t\tmoves[-1] = 'R'\n\t\t\tdifference[0] -= 1\n\t\telif difference[0] < 0:\n\t\t\tdifference[0] += 1\n\t\t\tmoves[-1] = 'L'\n\t\tif difference[1] < 0:\n\t\t\tdifference[1] += 1\n\t\t\tmoves[-1] += 'D'\n\t\telif difference[1] > 0:\n\t\t\tdifference[1] -= 1\n\t\t\tmoves[-1] += 'U'\n\tprint(len(moves))\n\tfor move in moves:\n\t\tprint(move)\n",
        "a = input()\nb = input()\nx1 = ord(a[0]) - ord('a') + 1\ny1 = int(a[1])\nx2 = ord(b[0]) - ord('a') + 1\ny2 = int(b[1])\nz = []\nl = 0\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile x1 != x2 or y1 != y2:\n\tf = ''\n\tif x1 < x2:\n\t\tf += 'R'\n\t\tx1 += 1\n\telif x1 > x2:\n\t\tf += 'L'\n\t\tx1 -= 1\n\tif y1 < y2:\n\t\tf += 'U'\n\t\ty1 += 1\n\telif y1 > y2:\n\t\tf += 'D'\n\t\ty1 -= 1\n\tprint(f)\n",
        "A = ['', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\ndef Move(s1, s2, t1, t2):\n\tmove = ''\n\tif s1 < t1:\n\t\tmove += 'R'\n\tif s1 > t1:\n\t\tmove += 'L'\n\tif s2 < t2:\n\t\tmove += 'U'\n\tif s2 > t2:\n\t\tmove += 'D'\n\treturn move\n(s1, s2) = list(input())\n(t1, t2) = list(input())\n(s2, t2) = (int(s2), int(t2))\ns1 = A.index(s1)\nt1 = A.index(t1)\nmoves = []\nwhile True:\n\tmove = Move(s1, s2, t1, t2)\n\tif 'R' in move:\n\t\ts1 += 1\n\tif 'L' in move:\n\t\ts1 -= 1\n\tif 'U' in move:\n\t\ts2 += 1\n\tif 'D' in move:\n\t\ts2 -= 1\n\tif move == '':\n\t\tbreak\n\tmoves.append(move)\nprint(len(moves))\nfor i in moves:\n\tprint(i)\n",
        "a = input()\nb = input()\n(y1, x1) = (int(a[1]), ord(a[0]) - ord('a'))\n(y2, x2) = (int(b[1]), ord(b[0]) - ord('a'))\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nh = ''\nv = ''\nif x1 - x2 < 0:\n\th = 'R'\nelif x1 - x2 > 0:\n\th = 'L'\nif y1 - y2 < 0:\n\tv = 'U'\nelif y1 > y2:\n\tv = 'D'\nhor = [h] * abs(x1 - x2)\nver = [v] * abs(y1 - y2)\nwhile len(hor) > 0 and len(ver) > 0:\n\tprint(hor.pop(0) + ver.pop(0))\nwhile len(hor) > 0:\n\tprint(hor.pop(0))\nwhile len(ver) > 0:\n\tprint(ver.pop(0))\n",
        "a = list(input())\nb = list(input())\na[0] = ord(a[0]) - 96\nb[0] = ord(b[0]) - 96\na[1] = int(a[1])\nb[1] = int(b[1])\nc = 0\nd = []\nif a[0] < b[0] and a[1] < b[1]:\n\twhile not (a[0] == b[0] or a[1] == b[1]):\n\t\ta[0] += 1\n\t\ta[1] += 1\n\t\tc += 1\n\t\td.append('RU')\nif a[0] > b[0] and a[1] < b[1]:\n\twhile not (a[0] == b[0] or a[1] == b[1]):\n\t\ta[0] -= 1\n\t\ta[1] += 1\n\t\tc += 1\n\t\td.append('LU')\nif a[0] < b[0] and a[1] > b[1]:\n\twhile not (a[0] == b[0] or a[1] == b[1]):\n\t\ta[0] += 1\n\t\ta[1] -= 1\n\t\tc += 1\n\t\td.append('RD')\nif a[0] > b[0] and a[1] > b[1]:\n\twhile not (a[0] == b[0] or a[1] == b[1]):\n\t\ta[0] -= 1\n\t\ta[1] -= 1\n\t\tc += 1\n\t\td.append('LD')\nwhile a[0] > b[0]:\n\ta[0] -= 1\n\td.append('L')\n\tc += 1\nwhile a[0] < b[0]:\n\ta[0] += 1\n\td.append('R')\n\tc += 1\nwhile a[1] > b[1]:\n\ta[1] -= 1\n\td.append('D')\n\tc += 1\nwhile a[1] < b[1]:\n\ta[1] += 1\n\td.append('U')\n\tc += 1\nprint(c)\nfor i in d:\n\tprint(i)\n",
        "S1 = input()\nS2 = input()\nD = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nT = S1\nA = list()\nV = [0, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\ndef mod(x):\n\tif x < 0:\n\t\treturn -x\n\treturn x\nn = max(mod(int(S1[1]) - int(S2[1])), mod(D[S1[0]] - D[S2[0]]))\nprint(n)\nwhile T != S2:\n\tcur = ''\n\tstep = ''\n\tif D[T[0]] < D[S2[0]]:\n\t\tcur += V[D[T[0]] + 1]\n\t\tstep += 'R'\n\telif D[T[0]] > D[S2[0]]:\n\t\tcur += V[D[T[0]] - 1]\n\t\tstep += 'L'\n\telse:\n\t\tcur += T[0]\n\tif int(T[1]) > int(S2[1]):\n\t\tcur += str(int(T[1]) - 1)\n\t\tstep += 'D'\n\telif int(T[1]) < int(S2[1]):\n\t\tcur += str(int(T[1]) + 1)\n\t\tstep += 'U'\n\telse:\n\t\tcur += str(int(T[1]))\n\tT = cur\n\tA.append(step)\nfor i in range(len(A)):\n\tprint(A[i])\n",
        "row = 'abcdefgh'\ncol = '12345678'\nstart = input()\nend = input()\n\ndef get_next_pos(arr, pos, step):\n\tfor i in range(len(arr)):\n\t\tif pos == arr[i]:\n\t\t\treturn arr[i + step]\n\treturn pos\ncount = 0\ncur = start\nsteps = []\nwhile cur != end:\n\tstep = ''\n\tnext_row = cur[0]\n\tnext_col = cur[1]\n\tif cur[0] > end[0]:\n\t\tstep += 'L'\n\t\tnext_row = get_next_pos(row, next_row, -1)\n\telif cur[0] < end[0]:\n\t\tstep += 'R'\n\t\tnext_row = get_next_pos(row, next_row, 1)\n\tif cur[1] > end[1]:\n\t\tstep += 'D'\n\t\tnext_col = get_next_pos(col, next_col, -1)\n\telif cur[1] < end[1]:\n\t\tstep += 'U'\n\t\tnext_col = get_next_pos(col, next_col, 1)\n\tsteps.append(step)\n\tcount += 1\n\tcur = next_row + next_col\nprint(count)\nprint('\\n'.join(steps))\n",
        "p1 = str(input())\np2 = str(input())\np1 = [ord(p1[0]) - 96, int(p1[1])]\np2 = [ord(p2[0]) - 96, int(p2[1])]\nprint(max(abs(p1[0] - p2[0]), abs(p1[1] - p2[1])))\nwhile True:\n\tvector = ''\n\tif p1[0] == p2[0] and p1[1] == p2[1]:\n\t\tbreak\n\tif p1[0] < p2[0]:\n\t\tp1[0] += 1\n\t\tvector += 'R'\n\tif p1[0] > p2[0]:\n\t\tp1[0] -= 1\n\t\tvector += 'L'\n\tif p1[1] < p2[1]:\n\t\tp1[1] += 1\n\t\tvector += 'U'\n\tif p1[1] > p2[1]:\n\t\tp1[1] -= 1\n\t\tvector += 'D'\n\tprint(vector)\n",
        "s = list(input())\nt = list(input())\nmoves = list()\nwhile s[0] != t[0] or s[1] != t[1]:\n\tstring = ''\n\tif s[0] < t[0]:\n\t\tstring = 'R'\n\t\ts[0] = chr(ord(s[0]) + 1)\n\telif s[0] > t[0]:\n\t\tstring = 'L'\n\t\ts[0] = chr(ord(s[0]) - 1)\n\tif s[1] < t[1]:\n\t\tstring = string + 'U'\n\t\ts[1] = str(int(s[1]) + 1)\n\telif s[1] > t[1]:\n\t\tstring = string + 'D'\n\t\ts[1] = str(int(s[1]) - 1)\n\tmoves.append(string)\nprint(len(moves))\nprint('\\n'.join(moves))\n",
        "(fr, to) = (input(), input())\nfrx = ord(fr[0])\nfry = ord(fr[1])\ntox = ord(to[0])\ntoy = ord(to[1])\nprint(max(abs(frx - tox), abs(fry - toy)))\nwhile frx < tox and fry > toy:\n\tprint('RD')\n\tfrx += 1\n\tfry -= 1\nwhile frx > tox and fry > toy:\n\tprint('LD')\n\tfrx -= 1\n\tfry -= 1\nwhile frx < tox and fry < toy:\n\tprint('RU')\n\tfrx += 1\n\tfry += 1\nwhile frx > tox and fry < toy:\n\tprint('LU')\n\tfrx -= 1\n\tfry += 1\nwhile frx < tox:\n\tprint('R')\n\tfrx += 1\nwhile frx > tox:\n\tprint('L')\n\tfrx -= 1\nwhile fry > toy:\n\tprint('D')\n\tfry -= 1\nwhile fry < toy:\n\tprint('U')\n\tfry += 1\n",
        "a = input()\nb = input()\nc = ' abcdefgh'\np = [c.index(a[0]), int(a[1])]\ny = [c.index(b[0]), int(b[1])]\nans = []\nwhile p != y:\n\tt = ''\n\tif p[0] < y[0]:\n\t\tt += 'R'\n\t\tp[0] += 1\n\telif p[0] > y[0]:\n\t\tt += 'L'\n\t\tp[0] -= 1\n\tif p[1] > y[1]:\n\t\tt += 'D'\n\t\tp[1] -= 1\n\telif p[1] < y[1]:\n\t\tt += 'U'\n\t\tp[1] += 1\n\tans.append(t)\nprint(len(ans))\nfor i in ans:\n\tprint(i)\n",
        "ini = input().strip()\nfin = input().strip()\n(xa, ya) = (ord(ini[0]), int(ini[1]))\n(xb, yb) = (ord(fin[0]), int(fin[1]))\nprint(max(abs(xa - xb), abs(ya - yb)))\nwhile xa != xb or ya != yb:\n\tne = ''\n\tif xa < xb:\n\t\txa += 1\n\t\tne += 'R'\n\telif xa > xb:\n\t\txa -= 1\n\t\tne += 'L'\n\tif ya > yb:\n\t\tya -= 1\n\t\tne += 'D'\n\telif ya < yb:\n\t\tya += 1\n\t\tne += 'U'\n\tprint(ne)\n",
        "s = input()\nt = input()\ncount = 0\nlis = []\nwhile s != t:\n\tif s[1] == t[1]:\n\t\tcount = count + 1\n\t\tif s[0] > t[0]:\n\t\t\tlis.append('L')\n\t\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\telse:\n\t\t\tlis.append('R')\n\t\t\ts = chr(ord(s[0]) + 1) + s[1]\n\telif s[0] == t[0]:\n\t\tcount += 1\n\t\tif s[1] > t[1]:\n\t\t\tlis.append('D')\n\t\t\ts = s[0] + chr(ord(s[1]) - 1)\n\t\telse:\n\t\t\tlis.append('U')\n\t\t\ts = s[0] + chr(ord(s[1]) + 1)\n\telif s[0] > t[0] and s[1] > t[1]:\n\t\tcount += 1\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\ts = s[0] + chr(ord(s[1]) - 1)\n\t\tlis.append('LD')\n\telif s[0] < t[0] and s[1] < t[1]:\n\t\tcount += 1\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\ts = s[0] + chr(ord(s[1]) + 1)\n\t\tlis.append('RU')\n\telif s[0] > t[0] and s[1] < t[1]:\n\t\tcount += 1\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\ts = s[0] + chr(ord(s[1]) + 1)\n\t\tlis.append('LU')\n\telif s[0] < t[0] and s[1] > t[1]:\n\t\tcount += 1\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\ts = s[0] + chr(ord(s[1]) - 1)\n\t\tlis.append('RD')\nprint(count)\nfor i in lis:\n\tprint(i)\n",
        "a = input()\nd = input()\ncA = ord(a[0]) - 96\ncD = ord(d[0]) - 96\nfA = int(a[1])\nfD = int(d[1])\nnum = 0\nans = ''\nwhile not (cA == cD and fA == fD):\n\tif not (cA == cD or fA == fD):\n\t\tif fA > fD:\n\t\t\tif cA > cD:\n\t\t\t\tcA -= 1\n\t\t\t\tans += '\\nLD'\n\t\t\telse:\n\t\t\t\tcA += 1\n\t\t\t\tans += '\\nRD'\n\t\t\tfA -= 1\n\t\telse:\n\t\t\tif cA > cD:\n\t\t\t\tcA -= 1\n\t\t\t\tans += '\\nLU'\n\t\t\telse:\n\t\t\t\tcA += 1\n\t\t\t\tans += '\\nRU'\n\t\t\tfA += 1\n\telif cA == cD:\n\t\tif fA > fD:\n\t\t\tfA -= 1\n\t\t\tans += '\\nD'\n\t\telse:\n\t\t\tfA += 1\n\t\t\tans += '\\nU'\n\telif cA > cD:\n\t\tcA -= 1\n\t\tans += '\\nL'\n\telse:\n\t\tcA += 1\n\t\tans += '\\nR'\n\tnum += 1\nprint(num)\nprint(ans[1:])\n",
        "dic = {chr(n + 96): n for n in range(1, 9)}\nstart = list(input())\nend = list(input())\nstart[0] = dic[start[0]]\nend[0] = dic[end[0]]\nstart[1] = int(start[1])\nend[1] = int(end[1])\ny = end[1] - start[1]\nx = end[0] - start[0]\nxmove = 'R' * x if x > 0 else 'L' * abs(x)\nymove = 'U' * y if y > 0 else 'D' * abs(y)\ntotal = max(abs(x), abs(y))\nboth = list(zip(xmove, ymove))\nprint(total)\nfor e in both:\n\tprint(e[0] + e[1])\nfor e in range(abs(abs(x) - abs(y))):\n\tif abs(x) > abs(y):\n\t\tprint(xmove[0])\n\telse:\n\t\tprint(ymove[0])\n",
        "(a, ai) = [x for x in input()]\n(b, bi) = [x for x in input()]\n(ai, bi) = (int(ai), int(bi))\npath = []\nwhile a != b or ai != bi:\n\tcurr = ''\n\tif a < b:\n\t\tcurr += 'R'\n\t\ta = chr(ord(a) + 1)\n\tif a > b:\n\t\tcurr += 'L'\n\t\ta = chr(ord(a) - 1)\n\tif ai > bi:\n\t\tcurr += 'D'\n\t\tai -= 1\n\tif ai < bi:\n\t\tcurr += 'U'\n\t\tai += 1\n\tpath.append(curr)\nprint(len(path))\nprint('\\n'.join(path))\n",
        "letras = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nmovimientos = []\ns = input()\nt = input()\ns = [letras[s[0]], int(s[1])]\nt = [letras[t[0]], int(t[1])]\nwhile s[1] != t[1] and s[0] != t[0]:\n\tif s[1] < t[1] and s[0] > t[0]:\n\t\ts[1] += 1\n\t\ts[0] -= 1\n\t\tmovimientos += ['LU']\n\telif s[1] < t[1] and s[0] < t[0]:\n\t\ts[1] += 1\n\t\ts[0] += 1\n\t\tmovimientos += ['RU']\n\telif s[1] > t[1] and s[0] < t[0]:\n\t\ts[1] -= 1\n\t\ts[0] += 1\n\t\tmovimientos += ['RD']\n\telif s[1] > t[1] and s[0] > t[0]:\n\t\ts[1] -= 1\n\t\ts[0] -= 1\n\t\tmovimientos += ['LD']\nif s[1] == t[1]:\n\tif s[0] < t[0]:\n\t\tmovimientos += abs(s[0] - t[0]) * ['R']\n\telif s[0] > t[0]:\n\t\tmovimientos += abs(t[0] - s[0]) * ['L']\nelif s[1] > t[1]:\n\tmovimientos += abs(s[1] - t[1]) * ['D']\nelif s[1] < t[1]:\n\tmovimientos += abs(t[1] - s[1]) * ['U']\nprint(len(movimientos))\nfor m in movimientos:\n\tprint(m)\n",
        "s = input()\nt = input()\nkx = ord(s[0]) - ord('a') + 1\nky = int(s[1])\ndx = ord(t[0]) - ord('a') + 1\ndy = int(t[1])\npath = []\nwhile kx != dx or ky != dy:\n\tmove = ''\n\tif kx > dx:\n\t\tmove = 'L'\n\t\tkx -= 1\n\telif kx < dx:\n\t\tmove = 'R'\n\t\tkx += 1\n\tif ky > dy:\n\t\tmove = move + 'D'\n\t\tky -= 1\n\telif ky < dy:\n\t\tmove = move + 'U'\n\t\tky += 1\n\tpath.append(move)\nprint(len(path))\nfor x in path:\n\tprint(x)\n",
        "s = input()\nt = input()\nd = {}\nj = 1\nfor i in range(97, 105):\n\td[chr(i)] = j\n\tj += 1\n(x0, y0) = (d[s[0]], int(s[1]))\n(x, y) = (d[t[0]], int(t[1]))\nn = max(abs(x - x0), abs(y - y0))\nprint(n)\nwhile x0 < x and y0 < y:\n\tif x0 == x and y0 == y:\n\t\tbreak\n\tprint('RU')\n\tx0 += 1\n\ty0 += 1\nwhile x0 < x and y0 > y:\n\tif x0 == x and y0 == y:\n\t\tbreak\n\tprint('RD')\n\tx0 += 1\n\ty0 -= 1\nwhile x0 > x and y0 < y:\n\tif x0 == x and y0 == y:\n\t\tbreak\n\tprint('LU')\n\tx0 -= 1\n\ty0 += 1\nwhile x0 > x and y0 > y:\n\tif x0 == x and y0 == y:\n\t\tbreak\n\tprint('LD')\n\tx0 -= 1\n\ty0 -= 1\nwhile x0 < x:\n\tif x0 == x:\n\t\tbreak\n\tprint('R')\n\tx0 += 1\nwhile x0 > x:\n\tif x0 == x:\n\t\tbreak\n\tprint('L')\n\tx0 -= 1\nwhile y0 < y:\n\tif y0 == y:\n\t\tbreak\n\tprint('U')\n\ty0 += 1\nwhile y0 > y:\n\tif y0 == y:\n\t\tbreak\n\tprint('D')\n\ty0 -= 1\n",
        "A = input()\nB = input()\nx = [ord(A[0]) - 97, ord(B[0]) - 97]\ny = [int(A[1]), int(B[1])]\nd1 = abs(x[1] - x[0])\nd2 = abs(y[1] - y[0])\nd = max(d1, d2)\nprint(d)\ns = ''\nif x[0] < x[1]:\n\ts += 'R'\nif x[0] > x[1]:\n\ts += 'L'\nif y[0] < y[1]:\n\ts += 'U'\nif y[0] > y[1]:\n\ts += 'D'\nfor i in range(min(d1, d2)):\n\tprint(s)\ns = ''\nif d1 > d2:\n\tif x[0] < x[1]:\n\t\ts += 'R'\n\tif x[0] > x[1]:\n\t\ts += 'L'\nif d1 < d2:\n\tif y[0] < y[1]:\n\t\ts += 'U'\n\tif y[0] > y[1]:\n\t\ts += 'D'\nfor i in range(max(d1, d2) - min(d1, d2)):\n\tprint(s)\n",
        "__author__ = 'Darren'\n\ndef solve():\n\timport sys\n\tstdin = sys.stdin if True else open('data')\n\tstart = list(map(ord, next(stdin)))\n\tend = list(map(ord, next(stdin)))\n\tpath = []\n\tcount = 0\n\twhile start != end:\n\t\tif end[0] > start[0] and end[1] > start[1]:\n\t\t\tpath.append('RU')\n\t\t\tstart[0] += 1\n\t\t\tstart[1] += 1\n\t\telif end[0] < start[0] and end[1] > start[1]:\n\t\t\tpath.append('LU')\n\t\t\tstart[0] -= 1\n\t\t\tstart[1] += 1\n\t\telif end[0] < start[0] and end[1] < start[1]:\n\t\t\tpath.append('LD')\n\t\t\tstart[0] -= 1\n\t\t\tstart[1] -= 1\n\t\telif end[0] > start[0] and end[1] < start[1]:\n\t\t\tpath.append('RD')\n\t\t\tstart[0] += 1\n\t\t\tstart[1] -= 1\n\t\telif end[0] > start[0]:\n\t\t\tpath.append('R')\n\t\t\tstart[0] += 1\n\t\telif end[0] < start[0]:\n\t\t\tpath.append('L')\n\t\t\tstart[0] -= 1\n\t\telif end[1] > start[1]:\n\t\t\tpath.append('U')\n\t\t\tstart[1] += 1\n\t\telse:\n\t\t\tpath.append('D')\n\t\t\tstart[1] -= 1\n\t\tcount += 1\n\tprint(count)\n\tprint('\\n'.join(path))\nsolve()\n",
        "current = input()\nfinal = input()\nli = []\nwhile final != current:\n\tif ord(final[0]) > ord(current[0]):\n\t\tif int(final[1]) > int(current[1]):\n\t\t\tli.append('RU')\n\t\t\tcurrent = chr(ord(current[0]) + 1) + str(int(current[1]) + 1)\n\t\telif int(final[1]) < int(current[1]):\n\t\t\tli.append('RD')\n\t\t\tcurrent = chr(ord(current[0]) + 1) + str(int(current[1]) - 1)\n\t\telse:\n\t\t\tli.append('R')\n\t\t\tcurrent = chr(ord(current[0]) + 1) + str(int(current[1]))\n\telif ord(final[0]) < ord(current[0]):\n\t\tif int(final[1]) > int(current[1]):\n\t\t\tli.append('LU')\n\t\t\tcurrent = chr(ord(current[0]) - 1) + str(int(current[1]) + 1)\n\t\telif int(final[1]) < int(current[1]):\n\t\t\tli.append('LD')\n\t\t\tcurrent = chr(ord(current[0]) - 1) + str(int(current[1]) - 1)\n\t\telse:\n\t\t\tli.append('L')\n\t\t\tcurrent = chr(ord(current[0]) - 1) + str(int(current[1]))\n\telif int(final[1]) > int(current[1]):\n\t\tli.append('U')\n\t\tcurrent = chr(ord(current[0])) + str(int(current[1]) + 1)\n\telif int(final[1]) < int(current[1]):\n\t\tli.append('D')\n\t\tcurrent = chr(ord(current[0])) + str(int(current[1]) - 1)\nprint(len(li))\nfor i in li:\n\tprint(i)\n",
        "x = list(input())\nx[0] = ord(x[0]) - 96\nx[1] = ord(x[1]) - 48\ny = list(input())\ny[0] = ord(y[0]) - 96\ny[1] = ord(y[1]) - 48\narr = []\narr1 = []\nwhile x[0] != y[0]:\n\tif x[0] > y[0]:\n\t\tarr.append('L')\n\t\tx[0] -= 1\n\telif x[0] < y[0]:\n\t\tarr.append('R')\n\t\tx[0] += 1\nwhile x[1] != y[1]:\n\tif x[1] > y[1]:\n\t\tarr1.append('D')\n\t\tx[1] -= 1\n\telif x[1] < y[1]:\n\t\tarr1.append('U')\n\t\tx[1] += 1\nn = len(arr) - len(arr1)\nm = len(arr1) - len(arr)\nif len(arr) < len(arr1):\n\tprint(len(arr1))\n\tfor i in range(len(arr)):\n\t\tprint(arr[i] + arr1[i])\n\tfor j in range(m):\n\t\tprint(arr1[j])\nelse:\n\tprint(len(arr))\n\tfor i in range(len(arr1)):\n\t\tprint(arr[i] + arr1[i])\n\tfor j in range(n):\n\t\tprint(arr[j])\n",
        "c1 = input()\nc2 = input()\nlet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nx1 = let.index(c1[0])\ny1 = int(c1[1])\nx2 = let.index(c2[0])\ny2 = int(c2[1])\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile 1:\n\tif x1 == x2 and y1 == y2:\n\t\tbreak\n\tif x1 > x2:\n\t\tx1 -= 1\n\t\tprint('L', end='')\n\telif x1 < x2:\n\t\tx1 += 1\n\t\tprint('R', end='')\n\tif y1 > y2:\n\t\ty1 -= 1\n\t\tprint('D', end='')\n\telif y1 < y2:\n\t\ty1 += 1\n\t\tprint('U', end='')\n\tprint()\n",
        "MIN_LETTER = 'a'\nMIN_DIGIT = '1'\nX_DIRECTION_TO_MOVE = {1: 'R', -1: 'L'}\nY_DIRECTION_TO_MOVE = {1: 'U', -1: 'D'}\n\ndef get_cell_coords(cell: str):\n\tletter = cell[0]\n\tdigit = cell[1]\n\treturn [ord(letter) - ord(MIN_LETTER), ord(digit) - ord(MIN_DIGIT)]\n\ndef get_direction(x, y):\n\tif y > x:\n\t\treturn 1\n\telif y < x:\n\t\treturn -1\n\telse:\n\t\treturn 0\ncurrent_cell = input()\ndestination_cell = input()\ncurrent_point = get_cell_coords(current_cell)\ndestination_point = get_cell_coords(destination_cell)\nmoves = []\nmoves_count = 0\nwhile current_point != destination_point:\n\tmove = ''\n\tx_direction = get_direction(current_point[0], destination_point[0])\n\tif x_direction:\n\t\tmove += X_DIRECTION_TO_MOVE[x_direction]\n\t\tcurrent_point[0] += x_direction\n\ty_direction = get_direction(current_point[1], destination_point[1])\n\tif y_direction:\n\t\tmove += Y_DIRECTION_TO_MOVE[y_direction]\n\t\tcurrent_point[1] += y_direction\n\tmoves.append(move)\n\tmoves_count += 1\nprint(moves_count)\nfor move in moves:\n\tprint(move)\n",
        "s = input()\nt = input()\ns = [ord(s[0]) - ord('a'), int(s[1]) - 1]\nt = [ord(t[0]) - ord('a'), int(t[1]) - 1]\ndx = [-1, 0, 1, 1, 1, 0, -1, -1]\ndy = [1, 1, 1, 0, -1, -1, -1, 0]\nres = []\nwhile s != t:\n\tmn = 100\n\tj = 0\n\tfor i in range(8):\n\t\tif mn > abs(s[0] + dx[i] - t[0]) + abs(s[1] + dy[i] - t[1]):\n\t\t\tmn = abs(s[0] + dx[i] - t[0]) + abs(s[1] + dy[i] - t[1])\n\t\t\tj = i\n\ts = [s[0] + dx[j], s[1] + dy[j]]\n\tres.append(j)\nprint(len(res))\ndd = ['LU', 'U', 'RU', 'R', 'RD', 'D', 'LD', 'L']\nfor i in res:\n\tprint(dd[i])\n",
        "col_map = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\n\ndef index(cell):\n\tglobal col_map\n\treturn (col_map[cell[0]], 8 - int(cell[1]))\ns = input()\nt = input()\ns = index(s)\nt = index(t)\nstep_map = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1), 'LU': (-1, -1), 'RU': (1, -1), 'LD': (-1, 1), 'RD': (1, 1)}\n\ndef dist(s, t):\n\treturn (s[0] - t[0]) ** 2 + (s[1] - t[1]) ** 2\n\ndef best_step(s, t):\n\tmin_dis = 9999\n\tstep_ = None\n\tfor (step, change) in step_map.items():\n\t\tif dist((s[0] + change[0], s[1] + change[1]), t) < min_dis:\n\t\t\tmin_dis = dist((s[0] + change[0], s[1] + change[1]), t)\n\t\t\tstep_ = step\n\treturn step_\ncurr_dis = dist(s, t)\nsteps = []\nwhile curr_dis:\n\tstep_ = best_step(s, t)\n\tchange = step_map[step_]\n\ts = (s[0] + change[0], s[1] + change[1])\n\tsteps.append(step_)\n\tcurr_dis = dist(s, t)\nprint(len(steps))\nfor i in steps:\n\tprint(i)\n",
        "def comp(s):\n\ta = s[0]\n\tres1 = 0\n\tres2 = 0\n\tif a == 'a':\n\t\tres1 = 1\n\telif a == 'b':\n\t\tres1 = 2\n\telif a == 'c':\n\t\tres1 = 3\n\telif a == 'd':\n\t\tres1 = 4\n\telif a == 'e':\n\t\tres1 = 5\n\telif a == 'f':\n\t\tres1 = 6\n\telif a == 'g':\n\t\tres1 = 7\n\telif a == 'h':\n\t\tres1 = 8\n\tres2 = int(s[1])\n\treturn (res1, res2)\n\ndef move(x1, y1, x2, y2, count, counter):\n\tif x1 == x2 and y1 == y2:\n\t\tprint(count)\n\t\tfor i in counter:\n\t\t\tprint(i)\n\telif x1 < x2 and y1 > y2:\n\t\tcounter.append('RD')\n\t\tcount += 1\n\t\treturn move(x1 + 1, y1 - 1, x2, y2, count, counter)\n\telif x1 < x2 and y1 == y2:\n\t\tcounter.append('R')\n\t\tcount += 1\n\t\treturn move(x1 + 1, y1, x2, y2, count, counter)\n\telif x1 < x2 and y1 < y2:\n\t\tcounter.append('RU')\n\t\tcount += 1\n\t\treturn move(x1 + 1, y1 + 1, x2, y2, count, counter)\n\telif x1 > x2 and y1 > y2:\n\t\tcounter.append('LD')\n\t\tcount += 1\n\t\treturn move(x1 - 1, y1 - 1, x2, y2, count, counter)\n\telif x1 > x2 and y1 == y2:\n\t\tcounter.append('L')\n\t\tcount += 1\n\t\treturn move(x1 - 1, y1, x2, y2, count, counter)\n\telif x1 > x2 and y1 < y2:\n\t\tcounter.append('LU')\n\t\tcount += 1\n\t\treturn move(x1 - 1, y1 + 1, x2, y2, count, counter)\n\telif x1 == x2 and y1 < y2:\n\t\tcounter.append('U')\n\t\tcount += 1\n\t\treturn move(x1, y1 + 1, x2, y2, count, counter)\n\telse:\n\t\tcounter.append('D')\n\t\tcount += 1\n\t\treturn move(x1, y1 - 1, x2, y2, count, counter)\ns1 = input()\ns2 = input()\nmove(comp(s1)[0], comp(s1)[1], comp(s2)[0], comp(s2)[1], 0, [])\n",
        "cp = input()\ndp = input()\n(x0, y0) = (cp[0], cp[1])\n(x1, y1) = (dp[0], dp[1])\nans = max(abs(ord(x0) - ord(x1)), abs(int(y0) - abs(int(y1))))\n(x0, y0) = (ord(cp[0]), int(cp[1]))\n(x1, y1) = (ord(dp[0]), int(dp[1]))\nprint(ans)\nwhile 1:\n\tif x0 == x1 and y0 == y1:\n\t\tbreak\n\tif x0 < x1:\n\t\tx0 += 1\n\t\tprint('R', end='')\n\tif x1 < x0:\n\t\tx0 -= 1\n\t\tprint('L', end='')\n\tif y0 < y1:\n\t\ty0 += 1\n\t\tprint('U', end='')\n\tif y1 < y0:\n\t\ty0 -= 1\n\t\tprint('D', end='')\n\tprint()\n",
        "columns = 'abcdefgh'\ninp = str(input())\ncolumnS = 'abcdefgh'.index(inp[0])\nrowS = int(inp[1])\ninp = str(input())\ncolumnT = 'abcdefgh'.index(inp[0])\nrowT = int(inp[1])\nmoveC = columnT - columnS\nmoveS = rowT - rowS\nn = max(abs(moveC), abs(moveS))\nprint(n)\nfor i in range(n):\n\t(c, s) = (0, 0)\n\tif moveC > 0:\n\t\tc += 1\n\t\tmoveC -= 1\n\telif moveC < 0:\n\t\tc -= 1\n\t\tmoveC += 1\n\tif moveS > 0:\n\t\ts += 1\n\t\tmoveS -= 1\n\telif moveS < 0:\n\t\ts -= 1\n\t\tmoveS += 1\n\tdicC = {-1: 'L', 0: '', 1: 'R'}\n\tdicS = {-1: 'D', 0: '', 1: 'U'}\n\tprint(dicC[c] + dicS[s])\n",
        "Answer = []\n(Origin, Destination) = (input(), input())\nwhile Origin != Destination:\n\tThis = ''\n\tif Destination[0] > Origin[0]:\n\t\tThis += 'R'\n\t\tOrigin = chr(ord(Origin[0]) + 1) + Origin[1]\n\tif Destination[0] < Origin[0]:\n\t\tThis += 'L'\n\t\tOrigin = chr(ord(Origin[0]) - 1) + Origin[1]\n\tif Destination[1] > Origin[1]:\n\t\tThis += 'U'\n\t\tOrigin = Origin[0] + str(int(Origin[1]) + 1)\n\tif Destination[1] < Origin[1]:\n\t\tThis += 'D'\n\t\tOrigin = Origin[0] + str(int(Origin[1]) - 1)\n\tAnswer.append(This)\nprint(len(Answer), *Answer, sep='\\n')\n",
        "startpoint = input()\nendpoint = input()\nstart = [0, 0]\nend = [0, 0]\ncounter = 0\nmoves = []\n\ndef gettingfirst(n):\n\tif n[0] == 'a':\n\t\treturn 1\n\telif n[0] == 'b':\n\t\treturn 2\n\telif n[0] == 'c':\n\t\treturn 3\n\telif n[0] == 'd':\n\t\treturn 4\n\telif n[0] == 'e':\n\t\treturn 5\n\telif n[0] == 'f':\n\t\treturn 6\n\telif n[0] == 'g':\n\t\treturn 7\n\telif n[0] == 'h':\n\t\treturn 8\nstart[0] = gettingfirst(startpoint)\nend[0] = gettingfirst(endpoint)\nstart[1] = int(startpoint[1])\nend[1] = int(endpoint[1])\ndirection = [0, 0]\ndirection[0] = end[0] - start[0]\ndirection[1] = end[1] - start[1]\nwhile not 0 in direction:\n\tif direction[0] * direction[1] < 0:\n\t\tif direction[0] < 0:\n\t\t\tmoves.append('LU')\n\t\t\tcounter += 1\n\t\t\tdirection[0] += 1\n\t\t\tdirection[1] -= 1\n\t\telse:\n\t\t\tmoves.append('RD')\n\t\t\tcounter += 1\n\t\t\tdirection[0] -= 1\n\t\t\tdirection[1] += 1\n\telif direction[0] < 0:\n\t\tmoves.append('LD')\n\t\tcounter += 1\n\t\tdirection[0] += 1\n\t\tdirection[1] += 1\n\telif direction[0] > 0:\n\t\tmoves.append('RU')\n\t\tcounter += 1\n\t\tdirection[0] -= 1\n\t\tdirection[1] -= 1\nwhile not direction[0] == 0:\n\tif direction[0] > 0:\n\t\tmoves.append('R')\n\t\tcounter += 1\n\t\tdirection[0] -= 1\n\telse:\n\t\tmoves.append('L')\n\t\tcounter += 1\n\t\tdirection[0] += 1\nwhile not direction[1] == 0:\n\tif direction[1] > 0:\n\t\tmoves.append('U')\n\t\tcounter += 1\n\t\tdirection[1] -= 1\n\telse:\n\t\tmoves.append('D')\n\t\tcounter += 1\n\t\tdirection[1] += 1\nprint(counter)\nfor i in moves:\n\tprint(i)\n",
        "d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nne = {'a': 'b', 'b': 'c', 'c': 'd', 'd': 'e', 'e': 'f', 'f': 'g', 'g': 'h'}\npr = {'h': 'g', 'g': 'f', 'f': 'e', 'e': 'd', 'd': 'c', 'c': 'b', 'b': 'a'}\ns = list(input())\nst = list(input())\nnum1 = int(s[1])\nnum2 = int(st[1])\nprint(max(abs(d[s[0]] - d[st[0]]), abs(num1 - num2)))\nwhile True:\n\tif s[0] < st[0]:\n\t\tif num1 < num2:\n\t\t\tprint('RU')\n\t\t\tnum1 += 1\n\t\t\ts[0] = ne[s[0]]\n\t\telif num1 > num2:\n\t\t\tprint('RD')\n\t\t\tnum1 -= 1\n\t\t\ts[0] = ne[s[0]]\n\t\telse:\n\t\t\tprint('R')\n\t\t\ts[0] = ne[s[0]]\n\telif s[0] > st[0]:\n\t\tif num1 < num2:\n\t\t\tprint('LU')\n\t\t\tnum1 += 1\n\t\t\ts[0] = pr[s[0]]\n\t\telif num1 > num2:\n\t\t\tprint('LD')\n\t\t\tnum1 -= 1\n\t\t\ts[0] = pr[s[0]]\n\t\telse:\n\t\t\tprint('L')\n\t\t\ts[0] = pr[s[0]]\n\telif num1 < num2:\n\t\tprint('U')\n\t\tnum1 += 1\n\telif num1 > num2:\n\t\tprint('D')\n\t\tnum1 -= 1\n\telse:\n\t\tbreak\n",
        "s = input()\nt = input()\nx0 = ord(s[0])\ny0 = int(s[1])\nx = ord(t[0])\ny = int(t[1])\nmove = ''\nn = 0\nwhile True:\n\tif x == x0 and y == y0:\n\t\tbreak\n\tif x > x0:\n\t\tmove += 'R'\n\t\tx0 += 1\n\telif x < x0:\n\t\tmove += 'L'\n\t\tx0 -= 1\n\tif y > y0:\n\t\tmove += 'U'\n\t\ty0 += 1\n\telif y < y0:\n\t\tmove += 'D'\n\t\ty0 -= 1\n\tmove += '\\n'\n\tn += 1\nprint(n)\nprint(move)\n",
        "def question(p, v1, v2):\n\tif p:\n\t\treturn v1\n\treturn v2\n(s, t) = [input() for i in range(2)]\nH = ord(t[0]) - ord(s[0])\nV = int(t[1]) - int(s[1])\nprint(max(abs(H), abs(V)))\nfor i in range(min(abs(H), abs(V))):\n\tprint(question(H < 0, 'L', 'R') + question(V < 0, 'D', 'U'))\nfor i in range(abs(abs(H) - abs(V))):\n\tif abs(H) > abs(V):\n\t\tprint(question(H < 0, 'L', 'R'))\n\telse:\n\t\tprint(question(V < 0, 'D', 'U'))\nexit(0)\n",
        "cols = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nstart_position = input()\nend_position = input()\nstart_position_col = int(cols[start_position[0]])\nstart_position_row = int(start_position[1])\nend_position_col = int(cols[end_position[0]])\nend_position_row = int(end_position[1])\ndirs = list()\nif start_position_col - end_position_col > 0:\n\tcol_dir = 'L'\nelif start_position_col - end_position_col < 0:\n\tcol_dir = 'R'\nelse:\n\tcol_dir = ''\nif col_dir:\n\tfor i in range(abs(end_position_col - start_position_col)):\n\t\tdirs.append(col_dir)\nif start_position_row - end_position_row > 0:\n\trow_dir = 'D'\nelif start_position_row - end_position_row < 0:\n\trow_dir = 'U'\nelse:\n\trow_dir = ''\nif row_dir:\n\tfor i in range(abs(end_position_row - start_position_row)):\n\t\tdirs.append(row_dir)\nfor (i, x) in enumerate(dirs):\n\tif x == 'R' or x == 'L':\n\t\tif x == 'R' and 'D' in dirs:\n\t\t\tdirs[i] = 'RD'\n\t\t\tdirs.remove('D')\n\t\telif x == 'R' and 'U' in dirs:\n\t\t\tdirs[i] = 'RU'\n\t\t\tdirs.remove('U')\n\t\telif x == 'L' and 'D' in dirs:\n\t\t\tdirs[i] = 'LD'\n\t\t\tdirs.remove('D')\n\t\telif x == 'L' and 'U' in dirs:\n\t\t\tdirs[i] = 'LU'\n\t\t\tdirs.remove('U')\nprint(len(dirs))\nfor x in dirs:\n\tprint(x)\n",
        "from sys import stdin, stdout, stderr, setrecursionlimit\nimport inspect, re\nsetrecursionlimit(100000)\n\ndef debug(*e):\n\tif not __debug__:\n\t\tprint(*e, file=stderr)\n\ndef dd(*vals):\n\tframe = inspect.getframeinfo(inspect.stack()[1][0])\n\tvs = re.search('dd\\\\((.+)\\\\)', frame.code_context[0]).group(1).split(',')\n\tif vs:\n\t\tdebug(','.join(('{0} = {1}'.format(vs[i], v) for (i, v) in enumerate(vals))))\n\ndef trace(f):\n\n\tdef traced(*args, **kw):\n\t\tdebug('calling {} with args {}, {}'.format(f.__name__, args, kw))\n\t\treturn f(*args, **kw)\n\treturn traced\n\ndef read():\n\treturn stdin.readline().rstrip()\n\ndef readarr(sep=None, maxsplit=-1):\n\treturn read().split(sep, maxsplit)\n\ndef readint():\n\treturn int(read())\n\ndef readintarr(sep=None, maxsplit=-1):\n\treturn [int(a) for a in readarr(sep, maxsplit)]\n\ndef write(*args, **kwargs):\n\tsep = kwargs.get('sep', ' ')\n\tend = kwargs.get('end', '\\n')\n\tstdout.write(sep.join((str(a) for a in args)) + end)\n\ndef writearr(arr, sep=' ', end='\\n'):\n\tstdout.write(sep.join((str(a) for a in arr)) + end)\na = ord('a')\n(sx, sy) = read()\n(tx, ty) = read()\n(sx, tx) = [ord(c) - a for c in [sx, tx]]\n(sy, ty) = [int(c) - 1 for c in [sy, ty]]\ndirx = tx - sx\ndiry = ty - sy\nwrite(max(abs(dirx), abs(diry)))\nwhile (sx, sy) != (tx, ty):\n\tmov = ''\n\tif dirx < 0:\n\t\tmov += 'L'\n\t\tsx -= 1\n\tif dirx > 0:\n\t\tmov += 'R'\n\t\tsx += 1\n\tif diry < 0:\n\t\tmov += 'D'\n\t\tsy -= 1\n\tif diry > 0:\n\t\tmov += 'U'\n\t\tsy += 1\n\twrite(mov)\n\tdirx = tx - sx\n\tdiry = ty - sy\n",
        "def parse(cell):\n\treturn (ord(cell[0]) - ord('a') + 1, int(cell[1]))\n(src_x, src_y) = parse(input())\n(dst_x, dst_y) = parse(input())\n\ndef moves(src_x, src_y, dst_x, dst_y):\n\twhile src_x != dst_x or src_y != dst_y:\n\t\tmove = ''\n\t\tif src_x != dst_x:\n\t\t\tmove += 'R' if dst_x > src_x else 'L'\n\t\t\tsrc_x += 1 if dst_x > src_x else -1\n\t\tif src_y != dst_y:\n\t\t\tmove += 'U' if dst_y > src_y else 'D'\n\t\t\tsrc_y += 1 if dst_y > src_y else -1\n\t\tyield move\nm = list(moves(src_x, src_y, dst_x, dst_y))\nprint(len(m))\nprint('\\n'.join(m))\n",
        "s1 = input()\nx1 = s1[0]\ny1 = s1[1]\ns2 = input()\nx2 = s2[0]\ny2 = s2[1]\nxchange = ord(x2) - ord(x1)\nif xchange > 0:\n\txstring = 'R' * xchange\nelif xchange < 0:\n\txstring = 'L' * (-1 * xchange)\nelse:\n\txstring = ''\nychange = ord(y2) - ord(y1)\nif ychange > 0:\n\tystring = 'U' * ychange\nelif ychange < 0:\n\tystring = 'D' * (-1 * ychange)\nelse:\n\tystring = ''\nprint(max(len(xstring), len(ystring)))\nfor i in range(7):\n\toutput = ''\n\tif len(xstring) > i:\n\t\toutput += xstring[i]\n\tif len(ystring) > i:\n\t\toutput += ystring[i]\n\tif len(output) > 0:\n\t\tprint(output)\n",
        "d = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\na = input()\n(x1, y1) = (d[a[0]], int(a[1]) - 1)\nb = input()\n(x2, y2) = (d[b[0]], int(b[1]) - 1)\nans = []\nwhile x1 != x2 or y1 != y2:\n\tif x1 > x2 and y1 > y2:\n\t\tans.append('LD')\n\t\tx1 -= 1\n\t\ty1 -= 1\n\tif x1 > x2 and y1 < y2:\n\t\tans.append('LU')\n\t\tx1 -= 1\n\t\ty1 += 1\n\tif x1 < x2 and y1 > y2:\n\t\tans.append('RD')\n\t\tx1 += 1\n\t\ty1 -= 1\n\tif x1 < x2 and y1 < y2:\n\t\tans.append('RU')\n\t\tx1 += 1\n\t\ty1 += 1\n\tif x1 == x2:\n\t\tif y1 > y2:\n\t\t\tans.append('D')\n\t\t\ty1 -= 1\n\t\tif y1 < y2:\n\t\t\tans.append('U')\n\t\t\ty1 += 1\n\tif y1 == y2:\n\t\tif x1 > x2:\n\t\t\tans.append('L')\n\t\t\tx1 -= 1\n\t\tif x1 < x2:\n\t\t\tans.append('R')\n\t\t\tx1 += 1\nprint(len(ans))\nfor i in ans:\n\tprint(i)\n",
        "a = input()\nb = input()\ng = list(a)\nu = list(b)\nx = int(g[1])\ny = int(u[1])\nif x - y > 0:\n\th = 'D'\nelse:\n\th = 'U'\nq = ord(g[0])\nz = ord(u[0])\nif q - z > 0:\n\tv = 'L'\nelse:\n\tv = 'R'\ndif2 = abs(q - z)\ndif1 = abs(x - y)\nif dif1 > dif2:\n\tprint(dif1)\n\tcount = 0\n\tfor i in range(0, dif2):\n\t\tcount += 1\n\t\tprint(v + h)\n\twhile count < dif1:\n\t\tprint(h)\n\t\tcount += 1\nelse:\n\tprint(dif2)\n\tcou2 = 0\n\tfor i in range(0, dif1):\n\t\tcou2 += 1\n\t\tprint(v + h)\n\twhile cou2 < dif2:\n\t\tprint(v)\n\t\tcou2 += 1\n",
        "s = input()\nt = input()\nr = []\na = ord(s[0]) - 96\nc = ord(t[0]) - 96\nb = int(s[1])\nd = int(t[1])\ne = 0\nif a < c:\n\tif b < d:\n\t\twhile b != d and a != c:\n\t\t\ta = a + 1\n\t\t\tb = b + 1\n\t\t\tr.append('RU')\n\t\t\te = e + 1\n\t\tif b == d:\n\t\t\twhile a != c:\n\t\t\t\ta = a + 1\n\t\t\t\te = e + 1\n\t\t\t\tr.append('R')\n\t\telse:\n\t\t\twhile b != d:\n\t\t\t\tb = b + 1\n\t\t\t\te = e + 1\n\t\t\t\tr.append('U')\n\telif b == d:\n\t\twhile a != c:\n\t\t\ta = a + 1\n\t\t\te = e + 1\n\t\t\tr.append('R')\n\telse:\n\t\twhile b != d and a != c:\n\t\t\ta = a + 1\n\t\t\tb = b - 1\n\t\t\tr.append('RD')\n\t\t\te = e + 1\n\t\tif b == d:\n\t\t\twhile a != c:\n\t\t\t\ta = a + 1\n\t\t\t\te = e + 1\n\t\t\t\tr.append('R')\n\t\telse:\n\t\t\twhile b != d:\n\t\t\t\tb = b - 1\n\t\t\t\te = e + 1\n\t\t\t\tr.append('D')\nelif b < d:\n\twhile b != d and a != c:\n\t\ta = a - 1\n\t\tb = b + 1\n\t\tr.append('LU')\n\t\te = e + 1\n\tif b == d:\n\t\twhile a != c:\n\t\t\ta = a - 1\n\t\t\te = e + 1\n\t\t\tr.append('L')\n\telse:\n\t\twhile b != d:\n\t\t\tb = b + 1\n\t\t\te = e + 1\n\t\t\tr.append('U')\nelif b == d:\n\twhile a != c:\n\t\ta = a - 1\n\t\te = e + 1\n\t\tr.append('L')\nelse:\n\twhile b != d and a != c:\n\t\ta = a - 1\n\t\tb = b - 1\n\t\tr.append('LD')\n\t\te = e + 1\n\tif b == d:\n\t\twhile a != c:\n\t\t\ta = a - 1\n\t\t\te = e + 1\n\t\t\tr.append('L')\n\telse:\n\t\twhile b != d:\n\t\t\tb = b - 1\n\t\t\te = e + 1\n\t\t\tr.append('D')\nprint(e)\nfor i in r:\n\tprint(i)\n",
        "w1 = list(input())\nw2 = list(input())\nimport math\nmotion = {(1, -1): 'RD', (-1, -1): 'LD', (1, 1): 'RU', (-1, 1): 'LU'}\nhorizontal = ord(w2[0]) - ord(w1[0])\nvertical = int(w2[1]) - int(w1[1])\nfirst_move = min(abs(horizontal), abs(vertical))\nsigns = (math.copysign(1, horizontal), math.copysign(1, vertical))\ncomplex_move = motion[signs]\nanslist = []\nfor i in range(first_move):\n\tanslist.append(complex_move)\nhorizontal = signs[0] * (abs(horizontal) - first_move)\nvertical = signs[1] * (abs(vertical) - first_move)\nhorizontal = int(horizontal)\nvertical = int(vertical)\nif any((horizontal, vertical)):\n\tif horizontal:\n\t\tif horizontal > 0:\n\t\t\tanslist.extend(['R'] * horizontal)\n\t\telse:\n\t\t\tanslist.extend(['L'] * abs(horizontal))\n\telif vertical > 0:\n\t\tanslist.extend(['U'] * vertical)\n\telse:\n\t\tanslist.extend(['D'] * abs(vertical))\nprint(len(anslist))\nfor i in anslist:\n\tprint(i)\n",
        "def check(x, y):\n\treturn x >= 1 and x <= 8 and (y >= 1) and (y <= 8)\ns = input()\nt = input()\nx1 = ord(s[0]) - ord('a') + 1\nx2 = ord(t[0]) - ord('a') + 1\ny1 = int(s[1])\ny2 = int(t[1])\nd = dict()\na = ['L', 'R', 'U', 'D', 'LU', 'LD', 'RU', 'RD']\nx = [-1, 1, 0, 0, -1, -1, 1, 1]\ny = [0, 0, 1, -1, 1, -1, 1, -1]\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile x1 != x2 or y1 != y2:\n\tm = 9000\n\tfor j in range(8):\n\t\tx3 = x1 + x[j]\n\t\ty3 = y1 + y[j]\n\t\tif check(x3, y3) and abs(x3 - x2) + abs(y3 - y2) < m:\n\t\t\tm = abs(x3 - x2) + abs(y3 - y2)\n\t\t\tjmin = j\n\tx1 = x1 + x[jmin]\n\ty1 = y1 + y[jmin]\n\tprint(a[jmin])\n",
        "t = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')\nr = ('1', '2', '3', '4', '5', '6', '7', '8')\nw = input()\ninit = t.index(w[0])\ninir = r.index(w[1])\ne = input()\nfint = t.index(e[0])\nfinr = r.index(e[1])\nqw = fint - init\new = finr - inir\nty = max(qw, ew)\nl = list()\nrdy = min(qw, -ew)\nruy = min(qw, ew)\nluy = min(-qw, ew)\nldy = min(-qw, -ew)\nfor i in range(rdy):\n\tl.append('RD')\n\tqw = qw - 1\n\tew += 1\nfor i in range(ruy):\n\tl.append('RU')\n\tqw = qw - 1\n\tew -= 1\nfor i in range(luy):\n\tl.append('LU')\n\tqw = qw + 1\n\tew -= 1\nfor i in range(ldy):\n\tl.append('LD')\n\tqw = qw + 1\n\tew += 1\nif qw > 0:\n\tfor i in range(qw):\n\t\tl.append('R')\nelse:\n\tfor i in range(-qw):\n\t\tl.append('L')\nif ew > 0:\n\tfor i in range(ew):\n\t\tl.append('U')\nelse:\n\tfor i in range(-ew):\n\t\tl.append('D')\nprint(len(l))\nfor i in range(len(l)):\n\tprint(l[i])\n",
        "import queue\n\ndef adjv(v):\n\tif v[0] > 0:\n\t\tyield (v[0] - 1, v[1])\n\tif v[0] < 7:\n\t\tyield (v[0] + 1, v[1])\n\tif v[1] > 0:\n\t\tyield (v[0], v[1] - 1)\n\tif v[1] < 7:\n\t\tyield (v[0], v[1] + 1)\n\tif v[0] > 0 and v[1] > 0:\n\t\tyield (v[0] - 1, v[1] - 1)\n\tif v[0] < 7 and v[1] < 7:\n\t\tyield (v[0] + 1, v[1] + 1)\n\tif v[0] > 0 and v[1] < 7:\n\t\tyield (v[0] - 1, v[1] + 1)\n\tif v[0] < 7 and v[1] > 0:\n\t\tyield (v[0] + 1, v[1] - 1)\n\ndef sp(sr, tr):\n\tdist = dict()\n\tprev = dict()\n\tfor i in range(8):\n\t\tfor j in range(8):\n\t\t\tdist[i, j] = float('inf')\n\t\t\tprev[i, j] = None\n\tdist[sr] = 0\n\tprev[sr] = None\n\tq = queue.Queue(maxsize=0)\n\tq.put(sr)\n\twhile not q.empty():\n\t\tcv = q.get()\n\t\tfor nv in adjv(cv):\n\t\t\tnl = dist[cv] + 1\n\t\t\tif nl < dist[nv]:\n\t\t\t\tdist[nv] = nl\n\t\t\t\tprev[nv] = cv\n\t\t\t\tq.put(nv)\n\tprint(dist[tr])\n\trt = list()\n\tpv = prev[tr]\n\twhile pv:\n\t\tif pv[0] < tr[0] and pv[1] < tr[1]:\n\t\t\trt.append('RU')\n\t\telif pv[0] > tr[0] and pv[1] > tr[1]:\n\t\t\trt.append('LD')\n\t\telif pv[0] > tr[0] and pv[1] < tr[1]:\n\t\t\trt.append('LU')\n\t\telif pv[0] < tr[0] and pv[1] > tr[1]:\n\t\t\trt.append('RD')\n\t\telif pv[0] < tr[0] and pv[1] == tr[1]:\n\t\t\trt.append('R')\n\t\telif pv[0] > tr[0] and pv[1] == tr[1]:\n\t\t\trt.append('L')\n\t\telif pv[0] == tr[0] and pv[1] < tr[1]:\n\t\t\trt.append('U')\n\t\telif pv[0] == tr[0] and pv[1] > tr[1]:\n\t\t\trt.append('D')\n\t\telse:\n\t\t\trt.append('')\n\t\ttr = pv\n\t\tpv = prev[tr]\n\tfor move in reversed(rt):\n\t\tprint(move)\nl1 = input().strip()\nl2 = input().strip()\nx1 = ord(l1[0]) - 97\ny1 = int(l1[1]) - 1\nx2 = ord(l2[0]) - 97\ny2 = int(l2[1]) - 1\nsp((x1, y1), (x2, y2))\n",
        "leaving = input()\nattending = input()\nlist = [1, 2, 3, 4, 5, 6, 7, 8]\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\na0 = int(d[attending[0]])\nl0 = int(d[leaving[0]])\na1 = int(attending[1])\nl1 = int(leaving[1])\nif abs(l1 - a1) >= abs(l0 - a0):\n\tp = abs(a1 - l1)\nelse:\n\tp = abs(a0 - l0)\nprint(p)\nif a0 >= l0 and a1 >= l1:\n\tif a0 - l0 > a1 - l1:\n\t\tfor i in range(0, a1 - l1):\n\t\t\tprint('RU')\n\t\tfor i in range(a1 - l1, p):\n\t\t\tprint('R')\n\telif a0 - l0 == a1 - l1:\n\t\tfor i in range(0, p):\n\t\t\tprint('RU')\n\telse:\n\t\tfor i in range(0, a0 - l0):\n\t\t\tprint('RU')\n\t\tfor i in range(a0 - l0, p):\n\t\t\tprint('U')\nelif a0 <= l0 and a1 >= l1:\n\tif -a0 + l0 > a1 - l1:\n\t\tfor i in range(0, a1 - l1):\n\t\t\tprint('LU')\n\t\tfor i in range(a1 - l1, p):\n\t\t\tprint('L')\n\telif l0 - a0 == a1 - l1:\n\t\tfor i in range(0, p):\n\t\t\tprint('LU')\n\telse:\n\t\tfor i in range(0, l0 - a0):\n\t\t\tprint('LU')\n\t\tfor i in range(l0 - a0, p):\n\t\t\tprint('U')\nelif a0 <= l0 and a1 <= l1:\n\tif l0 - a0 > l1 - a1:\n\t\tfor i in range(0, l1 - a1):\n\t\t\tprint('LD')\n\t\tfor i in range(l1 - a1, p):\n\t\t\tprint('L')\n\telif l0 - a0 == l1 - a1:\n\t\tfor i in range(0, p):\n\t\t\tprint('LD')\n\telse:\n\t\tfor i in range(0, l0 - a0):\n\t\t\tprint('LD')\n\t\tfor i in range(l0 - a0, p):\n\t\t\tprint('D')\nelif a0 >= l0 and a1 <= l1:\n\tif a0 - l0 > -a1 + l1:\n\t\tfor i in range(0, -a1 + l1):\n\t\t\tprint('RD')\n\t\tfor i in range(-a1 + l1, p):\n\t\t\tprint('R')\n\telif a0 - l0 == -a1 + l1:\n\t\tfor i in range(0, p):\n\t\t\tprint('RD')\n\telse:\n\t\tfor i in range(0, a0 - l0):\n\t\t\tprint('RD')\n\t\tfor i in range(a0 - l0, p):\n\t\t\tprint('D')\n",
        "s = list(map(ord, list(input())))\nt = list(map(ord, list(input())))\na = s[0] - t[0]\nb = s[1] - t[1]\nM = max(abs(a), abs(b))\nm = min(abs(a), abs(b))\nx = 'LR'[a < 0]\ny = 'DU'[b < 0]\nif abs(a) == M:\n\tz = x\nelse:\n\tz = y\nprint(M)\nfor _ in range(m):\n\tprint(x + y)\nfor _ in range(M - m):\n\tprint(z)\n",
        "dic = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ns = input()\nt = input()\nhorz = dic[t[0]] - dic[s[0]]\nvert = int(t[1]) - int(s[1])\nmini = min(abs(horz), abs(vert))\nmaxi = max(abs(horz), abs(vert))\narr = []\nif horz == 0:\n\tif vert < 0:\n\t\tfor i in range(maxi):\n\t\t\tarr.append('D')\n\telse:\n\t\tfor i in range(maxi):\n\t\t\tarr.append('U')\nelif vert == 0:\n\tif horz < 0:\n\t\tfor i in range(maxi):\n\t\t\tarr.append('L')\n\telse:\n\t\tfor i in range(maxi):\n\t\t\tarr.append('R')\nelif horz > 0:\n\tif vert > 0:\n\t\tfor i in range(mini):\n\t\t\tarr.append('RU')\n\t\tif abs(horz) > abs(vert):\n\t\t\tfor i in range(maxi - mini):\n\t\t\t\tarr.append('R')\n\t\telse:\n\t\t\tfor i in range(maxi - mini):\n\t\t\t\tarr.append('U')\n\telse:\n\t\tfor i in range(mini):\n\t\t\tarr.append('RD')\n\t\tif abs(horz) > abs(vert):\n\t\t\tfor i in range(maxi - mini):\n\t\t\t\tarr.append('R')\n\t\telse:\n\t\t\tfor i in range(maxi - mini):\n\t\t\t\tarr.append('D')\nelif vert > 0:\n\tfor i in range(mini):\n\t\tarr.append('LU')\n\tif abs(horz) > abs(vert):\n\t\tfor i in range(maxi - mini):\n\t\t\tarr.append('L')\n\telse:\n\t\tfor i in range(maxi - mini):\n\t\t\tarr.append('U')\nelse:\n\tfor i in range(mini):\n\t\tarr.append('LD')\n\tif abs(horz) > abs(vert):\n\t\tfor i in range(maxi - mini):\n\t\t\tarr.append('L')\n\telse:\n\t\tfor i in range(maxi - mini):\n\t\t\tarr.append('D')\nprint(len(arr))\nfor i in arr:\n\tprint(i)\n",
        "(p1, p2) = (input(), input())\nx = ord(p2[0]) - ord(p1[0])\ny = int(p2[1]) - int(p1[1])\nprint(max(abs(x), abs(y)))\nif x >= 0 and y >= 0:\n\tfor i in range(min(x, y)):\n\t\tprint('RU')\n\tfor i in range(abs(x - y)):\n\t\tprint('U') if y >= x else print('R')\nelif x >= 0 and y < 0:\n\tfor i in range(min(x, abs(y))):\n\t\tprint('RD')\n\tfor i in range(abs(x - abs(y))):\n\t\tprint('D') if abs(y) >= x else print('R')\nelif x < 0 and y >= 0:\n\tfor i in range(min(abs(x), y)):\n\t\tprint('LU')\n\tfor i in range(abs(abs(x) - y)):\n\t\tprint('U') if y >= abs(x) else print('L')\nelse:\n\tfor i in range(min(abs(x), abs(y))):\n\t\tprint('LD')\n\tfor i in range(abs(abs(x) - abs(y))):\n\t\tprint('D') if abs(y) >= abs(x) else print('L')\n",
        "import sys\n\ndef rl(int_: bool=True):\n\tif int_:\n\t\treturn [int(w) for w in sys.stdin.readline().split()]\n\treturn [w for w in sys.stdin.readline().split()]\ns = rl(False)[0]\nt = rl(False)[0]\n(sc, sr) = (ord(s[0]) - ord('a') + 1, int(s[1]))\n(tc, tr) = (ord(t[0]) - ord('a') + 1, int(t[1]))\ncount = 0\nsteps = []\nwhile sc != tc or sr != tr:\n\tstep = ''\n\tif sc < tc:\n\t\tstep = 'R'\n\t\tsc += 1\n\telif sc > tc:\n\t\tstep = 'L'\n\t\tsc -= 1\n\tif sr < tr:\n\t\tstep += 'U'\n\t\tsr += 1\n\telif sr > tr:\n\t\tstep += 'D'\n\t\tsr -= 1\n\tsteps.append(step)\n\tcount += 1\nprint(count)\nfor step in steps:\n\tprint(step)\n",
        "s = input()\nd = input()\ns0 = int(ord(s[0]) - 96)\ns1 = int(s[1])\nd1 = int(d[1])\nd0 = int(ord(d[0]) - 96)\nem = min(abs(s0 - d0), abs(s1 - d1))\ntm = min(abs(s0 - d0), abs(s1 - d1)) + abs(abs(s0 - d0) - abs(s1 - d1))\nprint(tm)\nif s0 > d0:\n\tk = ['L']\nelse:\n\tk = ['R']\nif s1 > d1:\n\tk.append('D')\nelse:\n\tk.append('U')\nfor i in range(em):\n\tprint(''.join(k))\nif abs(s0 - d0) > abs(s1 - d1):\n\tif s0 > d0:\n\t\tg = 'L'\n\telse:\n\t\tg = 'R'\nelif s1 > d1:\n\tg = 'D'\nelse:\n\tg = 'U'\nfor i in range(tm - em):\n\tprint(g)\n",
        "x0y0 = input()\nxy = input()\nx0y0 = [ord(x0y0[0]) - ord('a') + 1, int(x0y0[1])]\nxy = [ord(xy[0]) - ord('a') + 1, int(xy[1])]\nn = max(abs(x0y0[0] - xy[0]), abs(x0y0[1] - xy[1]))\nprint(abs(n))\nfor i in range(0, n):\n\tif xy[0] > x0y0[0] and xy[1] > x0y0[1]:\n\t\tprint('RU')\n\t\tx0y0[0] += 1\n\t\tx0y0[1] += 1\n\tif xy[0] < x0y0[0] and xy[1] < x0y0[1]:\n\t\tprint('LD')\n\t\tx0y0[0] -= 1\n\t\tx0y0[1] -= 1\n\tif xy[0] < x0y0[0] and xy[1] > x0y0[1]:\n\t\tprint('LU')\n\t\tx0y0[0] -= 1\n\t\tx0y0[1] += 1\n\tif xy[0] > x0y0[0] and xy[1] < x0y0[1]:\n\t\tprint('RD')\n\t\tx0y0[0] += 1\n\t\tx0y0[1] -= 1\n\tif xy[0] > x0y0[0] and xy[1] == x0y0[1]:\n\t\tprint('R')\n\t\tx0y0[0] += 1\n\tif xy[0] < x0y0[0] and xy[1] == x0y0[1]:\n\t\tprint('L')\n\t\tx0y0[0] -= 1\n\tif xy[1] > x0y0[1] and xy[0] == x0y0[0]:\n\t\tprint('U')\n\t\tx0y0[1] += 1\n\tif xy[1] < x0y0[1] and xy[0] == x0y0[0]:\n\t\tprint('D')\n\t\tx0y0[1] -= 1\n",
        "s = input()\nt = input()\na = ord(s[0]) - 96\nb = ord(t[0]) - 96\nx = int(s[1])\ny = int(t[1])\nprint(max(abs(x - y), abs(a - b)))\nwhile x != y or a != b:\n\ts = ''\n\tif a < b:\n\t\ta += 1\n\t\ts += 'R'\n\telif a > b:\n\t\ta -= 1\n\t\ts += 'L'\n\tif x > y:\n\t\tx -= 1\n\t\ts += 'D'\n\telif x < y:\n\t\tx += 1\n\t\ts += 'U'\n\tprint(s)\n",
        "a = input()\nb = input()\na = [ord(a[0]) - ord('a') + 1, int(a[1])]\nb = [ord(b[0]) - ord('a') + 1, int(b[1])]\nc = [b[0] - a[0], b[1] - a[1]]\nmn = min(abs(c[0]), abs(c[1]))\nk = mn\nk += max(abs(c[0]) - mn, abs(c[1]) - mn)\nprint(k)\nwhile (abs(c[0]) > 0) | (abs(c[1]) > 0):\n\tans = ''\n\tif c[0] > 0:\n\t\tans += 'R'\n\t\tc[0] -= 1\n\telif c[0] < 0:\n\t\tans += 'L'\n\t\tc[0] += 1\n\tif c[1] > 0:\n\t\tans += 'U'\n\t\tc[1] -= 1\n\telif c[1] < 0:\n\t\tans += 'D'\n\t\tc[1] += 1\n\tprint(ans)\n",
        "import sys\ndic = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ns = input()\ns1 = s[0]\ns2 = s[1]\ns = (dic[s1], int(s2))\ne = input()\ne1 = e[0]\ne2 = e[1]\ne = (dic[e1], int(e2))\nxdiffer = s[0] - e[0]\nydiffer = s[1] - e[1]\noutput = []\nwhile xdiffer > 0:\n\toutput.append('L')\n\txdiffer -= 1\nwhile ydiffer > 0:\n\toutput.append('D')\n\tydiffer -= 1\nwhile xdiffer < 0:\n\toutput.append('R')\n\txdiffer += 1\nwhile ydiffer < 0:\n\toutput.append('U')\n\tydiffer += 1\nwhile 'U' in output:\n\tflag = True\n\tif 'L' in output:\n\t\toutput.remove('U')\n\t\toutput.remove('L')\n\t\toutput.append('LU')\n\t\tflag = False\n\tif 'R' in output:\n\t\toutput.remove('U')\n\t\toutput.remove('R')\n\t\toutput.append('RU')\n\t\tflag = False\n\tif flag:\n\t\tbreak\nwhile 'D' in output:\n\tflag = True\n\tif 'L' in output:\n\t\toutput.remove('D')\n\t\toutput.remove('L')\n\t\toutput.append('LD')\n\t\tflag = False\n\tif 'R' in output:\n\t\toutput.remove('D')\n\t\toutput.remove('R')\n\t\toutput.append('RD')\n\t\tflag = False\n\tif flag:\n\t\tbreak\nprint(len(output))\nfor i in output:\n\tprint(i)\n",
        "def ter(n, sn, sz, sp):\n\treturn sn if n < 0 else sz if n == 0 else sp\n\ndef sign(n):\n\treturn ter(n, -1, 0, 1)\ns = input()\nt = input()\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\nt = [ord(t[0]) - ord('a') + 1, int(t[1])]\nprint(max(abs(s[0] - t[0]), abs(s[1] - t[1])))\nwhile s != t:\n\td0 = sign(t[0] - s[0])\n\td1 = sign(t[1] - s[1])\n\ts[0] += d0\n\ts[1] += d1\n\tprint(ter(d0, 'L', '', 'R') + ter(d1, 'D', '', 'U'))\n",
        "import operator as op\n\nclass ShortestPathComputer:\n\n\tdef print_path(self):\n\t\tprint(len(self.path))\n\t\tfor i in range(len(self.path)):\n\t\t\tprint(self.path[i])\n\n\tdef generate_shortest_path(self):\n\t\tcurr_coords = self.init_coords\n\t\twhile self.manhattan_distance(curr_coords, self.final_coords) != 0:\n\t\t\tnext = self.next_neighbour(curr_coords)\n\t\t\tcurr_coords = self.relative_coords(curr_coords, next)\n\t\t\tself.path.append(next)\n\t\treturn self\n\n\tdef next_neighbour(self, coords):\n\t\tneighbours = self.list_neighbours(coords)\n\t\t(min_neighbour, min_dist) = ('U', ShortestPathComputer.MAX_MANHATTAN_DISTANCE)\n\t\tfor neighbour in neighbours:\n\t\t\tneighbour_coords = self.relative_coords(coords, neighbour)\n\t\t\tnew_dist = self.manhattan_distance(neighbour_coords, self.final_coords)\n\t\t\tif new_dist <= min_dist:\n\t\t\t\tmin_dist = new_dist\n\t\t\t\tmin_neighbour = neighbour\n\t\treturn min_neighbour\n\n\tdef list_neighbours(self, coords):\n\t\tneighbours = []\n\t\tvalues = list(ShortestPathComputer.relative.values())\n\t\tkeys = list(ShortestPathComputer.relative.keys())\n\t\tneighbours = []\n\t\tfor i in range(ShortestPathComputer.MAX_NEIGHBOURS):\n\t\t\t(key, value) = (keys[i], values[i])\n\t\t\tif self.coords_are_legit(self.relative_coords(coords, key)):\n\t\t\t\tneighbours.append(key)\n\t\treturn neighbours\n\n\tdef relative_coords(self, coords, marker):\n\t\trel_coords = ShortestPathComputer.relative[marker]\n\t\treturn tuple(map(op.add, coords, rel_coords))\n\n\tdef coords_are_legit(self, coords):\n\t\treturn 0 <= coords[0] < 8 and 0 <= coords[1] < 8\n\n\tdef manhattan_distance(self, coordsA, coordsB):\n\t\treturn abs(coordsA[0] - coordsB[0]) + abs(coordsA[1] - coordsB[1])\n\n\tdef parse_chess_square(self, square):\n\t\t(i, j) = tuple(square)\n\t\treturn (ShortestPathComputer.parseRow[j], ShortestPathComputer.parseCol[i])\n\n\tdef __init__(self, squareA, squareB):\n\t\tself.init_coords = self.parse_chess_square(squareA)\n\t\tself.final_coords = self.parse_chess_square(squareB)\n\t\tself.path = []\n\t(MAX_NEIGHBOURS, MAX_MANHATTAN_DISTANCE) = (8, 14)\n\tparseCol = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\n\tparseRow = {'1': 7, '2': 6, '3': 5, '4': 4, '5': 3, '6': 2, '7': 1, '8': 0}\n\trelative = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1), 'RU': (-1, 1), 'RD': (1, 1), 'LU': (-1, -1), 'LD': (1, -1)}\npath_finder = ShortestPathComputer(input(), input())\npath_finder.generate_shortest_path().print_path()\n",
        "def shortestPath():\n\tkingPosition = input()\n\tdestination = input()\n\tboardSize = 8\n\tchessBoard = [[-1 for x in range(boardSize)] for y in range(boardSize)]\n\tkingRow = int(kingPosition[1]) - 1\n\tkingColumn = ord(kingPosition[0]) - ord('a')\n\tif kingPosition == destination:\n\t\tprint(0)\n\t\treturn\n\tchessBoard[kingRow][kingColumn] = 0\n\tchessBoard[int(destination[1]) - 1][ord(destination[0]) - ord('a')] = -2\n\tnewNeighbors = []\n\tfillChessBoard(kingRow, kingColumn, chessBoard, newNeighbors)\n\twhile len(newNeighbors) > 0:\n\t\tfillChessBoard(newNeighbors[0][0], newNeighbors[0][1], chessBoard, newNeighbors)\n\t\tnewNeighbors.remove(newNeighbors[0])\n\tpath = [[int(destination[1]) - 1, ord(destination[0]) - ord('a')]]\n\tpath.append(findSmallestNeighbor([int(destination[1]) - 1, ord(destination[0]) - ord('a')], chessBoard))\n\twhile chessBoard[path[len(path) - 1][0]][path[len(path) - 1][1]] != 0:\n\t\tpath.append(findSmallestNeighbor(path[len(path) - 1], chessBoard))\n\tallNeighbors = [[1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1]]\n\ti = len(path) - 1\n\tprint(i)\n\twhile i > 0:\n\t\tfor neighbor in allNeighbors:\n\t\t\tif path[i][0] + neighbor[0] == path[i - 1][0] and path[i][1] + neighbor[1] == path[i - 1][1]:\n\t\t\t\tif neighbor == [1, 1]:\n\t\t\t\t\tprint('RU')\n\t\t\t\telif neighbor == [1, 0]:\n\t\t\t\t\tprint('U')\n\t\t\t\telif neighbor == [1, -1]:\n\t\t\t\t\tprint('LU')\n\t\t\t\telif neighbor == [0, -1]:\n\t\t\t\t\tprint('L')\n\t\t\t\telif neighbor == [-1, -1]:\n\t\t\t\t\tprint('LD')\n\t\t\t\telif neighbor == [-1, 0]:\n\t\t\t\t\tprint('D')\n\t\t\t\telif neighbor == [-1, 1]:\n\t\t\t\t\tprint('RD')\n\t\t\t\telif neighbor == [0, 1]:\n\t\t\t\t\tprint('R')\n\t\ti -= 1\n\ndef fillChessBoard(startRow, startColumn, chessBoard, newNeighbors):\n\tallNeighbors = [[1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1]]\n\tfor neighbor in allNeighbors:\n\t\tif startRow + neighbor[0] < len(chessBoard) and startColumn + neighbor[1] < len(chessBoard) and (startRow + neighbor[0] >= 0) and (startColumn + neighbor[1] >= 0) and (chessBoard[startRow + neighbor[0]][startColumn + neighbor[1]] == -1):\n\t\t\tchessBoard[startRow + neighbor[0]][startColumn + neighbor[1]] = chessBoard[startRow][startColumn] + 1\n\t\t\tnewNeighbors.append([startRow + neighbor[0], startColumn + neighbor[1]])\n\ndef findSmallestNeighbor(current, chessBoard):\n\tallNeighbors = [[1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1]]\n\tminValue = 8\n\tfor neighbor in allNeighbors:\n\t\tif current[0] + neighbor[0] < len(chessBoard) and current[1] + neighbor[1] < len(chessBoard) and (current[0] + neighbor[0] >= 0) and (current[1] + neighbor[1] >= 0) and (chessBoard[current[0] + neighbor[0]][current[1] + neighbor[1]] < minValue) and (chessBoard[current[0] + neighbor[0]][current[1] + neighbor[1]] != -2):\n\t\t\tminValue = chessBoard[current[0] + neighbor[0]][current[1] + neighbor[1]]\n\t\t\tminNeighbor = [current[0] + neighbor[0], current[1] + neighbor[1]]\n\treturn minNeighbor\nshortestPath()\n",
        "a = input()\nb = input()\nsatr = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\nsotoon = [8]\nn = 0\nif a[0] == b[0]:\n\tn = int(b[1]) - int(a[1])\n\tif n < 0:\n\t\tn = n * -1\n\t\tprint(n)\n\t\tfor _ in range(n):\n\t\t\tprint('D')\n\telse:\n\t\tprint(n)\n\t\tfor _ in range(n):\n\t\t\tprint('U')\nelif a[1] == b[1]:\n\tn = satr[b[0]] - satr[a[0]]\n\tif n < 0:\n\t\tn = n * -1\n\t\tprint(n)\n\t\tfor _ in range(n):\n\t\t\tprint('L')\n\telse:\n\t\tprint(n)\n\t\tfor _ in range(n):\n\t\t\tprint('R')\nelse:\n\ti = satr[b[0]] - satr[a[0]]\n\tj = int(b[1]) - int(a[1])\n\tif abs(i) > abs(j):\n\t\tprint(abs(i))\n\telse:\n\t\tprint(abs(j))\n\tif i > 0:\n\t\tif j > 0:\n\t\t\tif abs(j) >= abs(i):\n\t\t\t\tfor _ in range(i):\n\t\t\t\t\tprint('RU')\n\t\t\t\tfor _ in range(abs(j - i)):\n\t\t\t\t\tprint('U')\n\t\t\telse:\n\t\t\t\tfor _ in range(j):\n\t\t\t\t\tprint('RU')\n\t\t\t\tfor _ in range(abs(i - j)):\n\t\t\t\t\tprint('R')\n\t\telif abs(i) >= abs(j):\n\t\t\tfor _ in range(abs(j)):\n\t\t\t\tprint('RD')\n\t\t\tfor _ in range(abs(i + j)):\n\t\t\t\tprint('R')\n\t\telse:\n\t\t\tfor _ in range(abs(i)):\n\t\t\t\tprint('RD')\n\t\t\tfor _ in range(abs(i + j)):\n\t\t\t\tprint('D')\n\telif j > 0:\n\t\tif abs(i) >= abs(j):\n\t\t\tfor _ in range(j):\n\t\t\t\tprint('LU')\n\t\t\tfor _ in range(abs(i + j)):\n\t\t\t\tprint('L')\n\t\telse:\n\t\t\tfor _ in range(abs(i)):\n\t\t\t\tprint('LU')\n\t\t\tfor _ in range(abs(i + j)):\n\t\t\t\tprint('U')\n\telif abs(i) >= abs(j):\n\t\tfor _ in range(abs(j)):\n\t\t\tprint('LD')\n\t\tfor _ in range(abs(i - j)):\n\t\t\tprint('L')\n\telse:\n\t\tfor _ in range(abs(i)):\n\t\t\tprint('LD')\n\t\tfor _ in range(abs(i - j)):\n\t\t\tprint('D')\n",
        "cor = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ns = list(input())\nt = list(input())\n(x1, y1) = (cor[s[0]], int(s[1]))\n(x2, y2) = (cor[t[0]], int(t[1]))\ncount = 0\nmoves = []\nif x2 > x1:\n\tif y2 > y1:\n\t\twhile x1 != x2 and y1 != y2:\n\t\t\tx1 += 1\n\t\t\ty1 += 1\n\t\t\tcount += 1\n\t\t\tmoves.append('RU')\n\t\telse:\n\t\t\tif x1 != x2:\n\t\t\t\twhile x1 != x2:\n\t\t\t\t\tx1 += 1\n\t\t\t\t\tmoves.append('R')\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\twhile y1 != y2:\n\t\t\t\t\ty1 += 1\n\t\t\t\t\tmoves.append('U')\n\t\t\t\t\tcount += 1\n\telse:\n\t\twhile x1 != x2 and y1 != y2:\n\t\t\tx1 += 1\n\t\t\ty1 -= 1\n\t\t\tcount += 1\n\t\t\tmoves.append('RD')\n\t\telse:\n\t\t\tif x1 != x2:\n\t\t\t\twhile x1 != x2:\n\t\t\t\t\tx1 += 1\n\t\t\t\t\tmoves.append('R')\n\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\twhile y1 != y2:\n\t\t\t\t\ty1 -= 1\n\t\t\t\t\tmoves.append('D')\n\t\t\t\t\tcount += 1\nelif y2 > y1:\n\twhile x1 != x2 and y1 != y2:\n\t\tx1 -= 1\n\t\ty1 += 1\n\t\tcount += 1\n\t\tmoves.append('LU')\n\telse:\n\t\tif x1 != x2:\n\t\t\twhile x1 != x2:\n\t\t\t\tx1 -= 1\n\t\t\t\tmoves.append('L')\n\t\t\t\tcount += 1\n\t\telse:\n\t\t\twhile y1 != y2:\n\t\t\t\ty1 += 1\n\t\t\t\tmoves.append('U')\n\t\t\t\tcount += 1\nelse:\n\twhile x1 != x2 and y1 != y2:\n\t\tx1 -= 1\n\t\ty1 -= 1\n\t\tcount += 1\n\t\tmoves.append('LD')\n\telse:\n\t\tif x1 != x2:\n\t\t\twhile x1 != x2:\n\t\t\t\tx1 -= 1\n\t\t\t\tmoves.append('L')\n\t\t\t\tcount += 1\n\t\telse:\n\t\t\twhile y1 != y2:\n\t\t\t\ty1 -= 1\n\t\t\t\tmoves.append('D')\n\t\t\t\tcount += 1\nprint(count)\nfor move in moves:\n\tprint(move)\n",
        "a = input()\nb = input()\ns = 'abcdefgh'\ni = int(0)\nc = []\nfor i in range(0, len(s)):\n\tif a[0] == s[i]:\n\t\ta = [i + 1, a[1]]\n\tif b[0] == s[i]:\n\t\tb = [i + 1, b[1]]\ng = [int(a[0]) - int(b[0]), int(a[1]) - int(b[1])]\nif g[1] < 0:\n\tc.append(-g[1])\nelse:\n\tc.append(g[1])\nif g[0] < 0:\n\tc.append(-g[0])\nelse:\n\tc.append(g[0])\nprint(max(c))\nfor i in range(0, 8):\n\tif g[0] == 0 and g[1] == 0:\n\t\tbreak\n\telif g[0] != 0 and g[1] != 0:\n\t\tif g[0] > 0:\n\t\t\tk = 'L'\n\t\t\tg[0] -= 1\n\t\telse:\n\t\t\tk = 'R'\n\t\t\tg[0] += 1\n\t\tif g[1] > 0:\n\t\t\tk = k + 'D'\n\t\t\tg[1] -= 1\n\t\telse:\n\t\t\tk = k + 'U'\n\t\t\tg[1] += 1\n\t\tprint(k)\n\telse:\n\t\tif g[0] != 0:\n\t\t\tif g[0] > 0:\n\t\t\t\tk = 'L'\n\t\t\t\tg[0] -= 1\n\t\t\telse:\n\t\t\t\tk = 'R'\n\t\t\t\tg[0] += 1\n\t\t\tprint(k)\n\t\tif g[1] != 0:\n\t\t\tif g[1] > 0:\n\t\t\t\tk = 'D'\n\t\t\t\tg[1] -= 1\n\t\t\telse:\n\t\t\t\tk = 'U'\n\t\t\t\tg[1] += 1\n\t\t\tprint(k)\n",
        "s = input()\nt = input()\nfx = 'LRUD'\nhd = ord(t[0]) - ord(s[0])\nvd = ord(t[1]) - ord(s[1])\nhd_abs = abs(hd)\nvd_abs = abs(vd)\nn = max(hd_abs, vd_abs)\nprint(n)\nif hd >= 0:\n\tm = min(hd_abs, vd_abs)\n\tfor i in range(m):\n\t\tif vd >= 0:\n\t\t\tprint('RU')\n\t\telse:\n\t\t\tprint('RD')\n\tfor i in range(n - m):\n\t\tif hd_abs >= vd_abs:\n\t\t\tprint('R')\n\t\telif vd >= 0:\n\t\t\tprint('U')\n\t\telse:\n\t\t\tprint('D')\nelse:\n\tm = min(hd_abs, vd_abs)\n\tfor i in range(m):\n\t\tif vd >= 0:\n\t\t\tprint('LU')\n\t\telse:\n\t\t\tprint('LD')\n\tfor i in range(n - m):\n\t\tif hd_abs >= vd_abs:\n\t\t\tprint('L')\n\t\telif vd >= 0:\n\t\t\tprint('U')\n\t\telse:\n\t\t\tprint('D')\n",
        "x = input()\np = x[0]\nq = int(x[1])\ny = input()\na = y[0]\nb = int(y[1])\nt = 0\nd = {}\nfor i in 'abcdefgh':\n\tt += 1\n\td[i] = t\nmax = max(abs(d[p] - d[a]), abs(q - b))\nmin = min(abs(d[p] - d[a]), abs(q - b))\nprint(max)\nif d[p] - d[a] >= 0:\n\tfor i in range(min):\n\t\tprint('L', end='')\n\t\tif q - b >= 0:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('U')\nelse:\n\tfor i in range(min):\n\t\tprint('R', end='')\n\t\tif q - b >= 0:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('U')\nif abs(d[p] - d[a]) < abs(q - b):\n\tfor i in range(max - min):\n\t\tif q - b >= 0:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('U')\nelse:\n\tfor i in range(max - min):\n\t\tif d[p] - d[a] >= 0:\n\t\t\tprint('L')\n\t\telse:\n\t\t\tprint('R')\n",
        "import sys\n\ndef get_double_move(h, v):\n\tif h < 0 and v < 0:\n\t\treturn 'LD'\n\telif h > 0 and v < 0:\n\t\treturn 'RD'\n\telif h < 0 and v > 0:\n\t\treturn 'LU'\n\telif h > 0 and v > 0:\n\t\treturn 'RU'\n\ndef get_single_move(h, v):\n\tif abs(h) > abs(v):\n\t\tif h > 0:\n\t\t\treturn 'R'\n\t\telif h < 0:\n\t\t\treturn 'L'\n\telif abs(h) < abs(v):\n\t\tif v < 0:\n\t\t\treturn 'D'\n\t\telif v > 0:\n\t\t\treturn 'U'\nline1 = sys.stdin.readline()\nline2 = sys.stdin.readline()\ndx = int(ord(line2[0]) - ord(line1[0]))\ndy = int(ord(line2[1]) - ord(line1[1]))\ndouble = get_double_move(dx, dy)\nsingle = get_single_move(dx, dy)\nprint(max(abs(dx), abs(dy)))\nfor i in range(0, min(abs(dx), abs(dy))):\n\tprint(double)\nfor i in range(min(abs(dx), abs(dy)), max(abs(dx), abs(dy))):\n\tprint(single)\n",
        "s = input()\nt = input()\ncount = 0\nif s[0] == t[0]:\n\tif s[1] > t[1]:\n\t\tvalue1 = int(s[1]) - int(t[1])\n\t\tcount = count + value1\n\t\tprint(value1)\n\t\tfor i in range(value1):\n\t\t\tprint('D')\n\telif s[1] < t[1]:\n\t\tvalue1 = int(t[1]) - int(s[1])\n\t\tcount = count + value1\n\t\tprint(value1)\n\t\tfor i in range(value1):\n\t\t\tprint('U')\n\telse:\n\t\tprint(0)\nelif s[1] == t[1]:\n\tif s[0] > t[0]:\n\t\tvalue1 = ord(s[0]) - ord(t[0])\n\t\tcount = count + value1\n\t\tprint(value1)\n\t\tfor i in range(value1):\n\t\t\tprint('L')\n\telif s[0] < t[0]:\n\t\tvalue1 = ord(t[0]) - ord(s[0])\n\t\tcount = count + value1\n\t\tprint(value1)\n\t\tfor i in range(value1):\n\t\t\tprint('R')\nelif s[0] < t[0]:\n\tif s[1] > t[1]:\n\t\ta = ord(t[0]) - ord(s[0])\n\t\tb = int(s[1]) - int(t[1])\n\t\tvalue1 = min(a, b)\n\t\tcount = count + value1\n\t\ts = s.replace(s[0], chr(ord(s[0]) + value1))\n\t\ts = s.replace(s[1], str(int(s[1]) - value1))\n\t\tif s[0] == t[0]:\n\t\t\tvalue2 = int(s[1]) - int(t[1])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('RD')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('D')\n\t\telif s[1] == t[1]:\n\t\t\tvalue2 = ord(t[0]) - ord(s[0])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('RD')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('R')\n\telif s[1] < t[1]:\n\t\ta = ord(t[0]) - ord(s[0])\n\t\tb = int(t[1]) - int(s[1])\n\t\tvalue1 = min(a, b)\n\t\tcount = count + value1\n\t\ts = s.replace(s[0], chr(ord(s[0]) + value1))\n\t\ts = s.replace(s[1], str(int(s[1]) + value1))\n\t\tif s[0] == t[0]:\n\t\t\tvalue2 = int(t[1]) - int(s[1])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('RU')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('U')\n\t\telif s[1] == t[1]:\n\t\t\tvalue2 = ord(t[0]) - ord(s[0])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('RU')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('R')\nelif s[0] > t[0]:\n\tif s[1] < t[1]:\n\t\ta = ord(s[0]) - ord(t[0])\n\t\tb = int(t[1]) - int(s[1])\n\t\tvalue1 = min(a, b)\n\t\tcount = count + value1\n\t\ts = s.replace(s[0], chr(ord(s[0]) - value1))\n\t\ts = s.replace(s[1], str(int(s[1]) + value1))\n\t\tif s[0] == t[0]:\n\t\t\tvalue2 = int(t[1]) - int(s[1])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('LU')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('U')\n\t\telif s[1] == t[1]:\n\t\t\tvalue2 = ord(s[0]) - ord(t[0])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('LU')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('L')\n\telif s[1] > t[1]:\n\t\ta = ord(s[0]) - ord(t[0])\n\t\tb = int(s[1]) - int(t[1])\n\t\tvalue1 = min(a, b)\n\t\tcount = count + value1\n\t\ts = s.replace(s[0], chr(ord(s[0]) - value1))\n\t\ts = s.replace(s[1], str(int(s[1]) - value1))\n\t\tif s[0] == t[0]:\n\t\t\tvalue2 = int(s[1]) - int(t[1])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('LD')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('D')\n\t\telif s[1] == t[1]:\n\t\t\tvalue2 = ord(s[0]) - ord(t[0])\n\t\t\tcount = count + value2\n\t\t\tprint(value1 + value2)\n\t\t\tfor i in range(value1):\n\t\t\t\tprint('LD')\n\t\t\tfor i in range(value2):\n\t\t\t\tprint('L')\n",
        "s = input()\nt = input()\nm = [ord(s[0]) - 96, int(s[1])]\nn = [ord(t[0]) - 96, int(t[1])]\ns = m\npath = []\nc = 0\nwhile n != s:\n\tif s[0] == n[0]:\n\t\tif s[1] < n[1]:\n\t\t\ts[1] = s[1] + 1\n\t\t\tpath.append('U')\n\t\t\tc += 1\n\t\telif s[1] > n[1]:\n\t\t\ts[1] = s[1] - 1\n\t\t\tpath.append('D')\n\t\t\tc += 1\n\telif s[1] == n[1]:\n\t\tif s[0] < n[0]:\n\t\t\ts[0] = s[0] + 1\n\t\t\tpath.append('R')\n\t\t\tc += 1\n\t\telif s[0] > n[0]:\n\t\t\ts[0] = s[0] - 1\n\t\t\tpath.append('L')\n\t\t\tc += 1\n\telif s[0] < n[0] and s[1] < n[1]:\n\t\ts[0] = s[0] + 1\n\t\ts[1] = s[1] + 1\n\t\tpath.append('RU')\n\t\tc += 1\n\telif s[0] < n[0] and s[1] > n[1]:\n\t\ts[0] = s[0] + 1\n\t\ts[1] = s[1] - 1\n\t\tpath.append('RD')\n\t\tc += 1\n\telif s[0] > n[0] and s[1] < n[1]:\n\t\ts[0] = s[0] - 1\n\t\ts[1] = s[1] + 1\n\t\tpath.append('LU')\n\t\tc += 1\n\telif s[0] > n[0] and s[1] > n[1]:\n\t\ts[0] = s[0] - 1\n\t\ts[1] = s[1] - 1\n\t\tpath.append('LD')\n\t\tc += 1\nprint(c)\nfor i in range(c):\n\tprint(path[i])\n",
        "s = list(input())\nt = list(input())\ns[1] = int(s[1])\nt[1] = int(t[1])\ns[0] = int(ord(s[0]))\nt[0] = int(ord(t[0]))\nres = []\nwhile True:\n\tif s[0] == t[0] and s[1] == t[1]:\n\t\tbreak\n\ttmp = ''\n\tif s[0] > t[0]:\n\t\ts[0] -= 1\n\t\ttmp += 'L'\n\telif s[0] < t[0]:\n\t\ts[0] += 1\n\t\ttmp += 'R'\n\tif s[1] > t[1]:\n\t\ts[1] -= 1\n\t\ttmp += 'D'\n\telif s[1] < t[1]:\n\t\ts[1] += 1\n\t\ttmp += 'U'\n\tres.append(tmp)\nprint(len(res))\nfor x in res:\n\tprint(x)\n",
        "L = list(input())\nL1 = list(input())\np = ord(L[0]) - ord(L1[0])\ns = int(L[1]) - int(L1[1])\nL2 = []\nmax = 0\nwhile s != 0 or p != 0:\n\tif p > 0 and s > 0:\n\t\tmax += 1\n\t\tL2.append('LD')\n\t\tp = p - 1\n\t\ts = s - 1\n\telif p > 0 and s < 0:\n\t\tmax += 1\n\t\tL2.append('LU')\n\t\tp = p - 1\n\t\ts = s + 1\n\telif p > 0 and s == 0:\n\t\tmax += 1\n\t\tL2.append('L')\n\t\tp = p - 1\n\telif p < 0 and s > 0:\n\t\tmax += 1\n\t\tL2.append('RD')\n\t\tp = p + 1\n\t\ts = s - 1\n\telif p < 0 and s < 0:\n\t\tmax += 1\n\t\tL2.append('RU')\n\t\tp = p + 1\n\t\ts = s + 1\n\telif p == 0 and s < 0:\n\t\tmax += 1\n\t\tL2.append('U')\n\t\ts = s + 1\n\telif p < 0 and s == 0:\n\t\tmax += 1\n\t\tL2.append('R')\n\t\tp = p + 1\n\telif p == 0 and s > 0:\n\t\tmax += 1\n\t\tL2.append('D')\n\t\ts = s - 1\nprint(max)\nfor j in L2:\n\tprint(j + '\\n')\n",
        "symbols = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\nn = m = 8\nx = input()\nx0 = symbols[x[0]]\ny0 = int(x[1]) - 1\nc = input()\nx = symbols[c[0]]\ny = int(c[1]) - 1\nprint(max(abs(x - x0), abs(y - y0)))\nwhile True:\n\tif (x == x0) & (y == y0):\n\t\tbreak\n\tif x > x0:\n\t\tx0 = x0 + 1\n\t\tprint('R', end='')\n\telif x < x0:\n\t\tx0 = x0 - 1\n\t\tprint('L', end='')\n\tif y > y0:\n\t\ty0 = y0 + 1\n\t\tprint('U', end='')\n\telif y < y0:\n\t\ty0 = y0 - 1\n\t\tprint('D', end='')\n\tprint()\n",
        "def sgn(x):\n\treturn 1 if x > 0 else 0 if not x else -1\n(s, t) = (input(), input())\n(cs, rs) = (ord(s[0]) - 96, int(s[1]))\n(ct, rt) = (ord(t[0]) - 96, int(t[1]))\n(dc, dr) = (ct - cs, rt - rs)\nprint(max(abs(dc), abs(dr)))\nwhile dc or dr:\n\tif dc:\n\t\tprint('R' if dc > 0 else 'L', end='')\n\t\tdc -= sgn(dc)\n\tif dr:\n\t\tprint('U' if dr > 0 else 'D', end='')\n\t\tdr -= sgn(dr)\n\tprint()\n",
        "def valid_coordinates():\n\tif (col_source < 'a' or col_source > 'h') or (col_destination < 'a' or col_destination > 'h') or (row_source < 1 or row_source > 8) or (row_destination < 1 or row_destination > 8):\n\t\treturn 0\n\telse:\n\t\treturn 1\n\ndef is_done():\n\tif source == destination:\n\t\treturn 1\n\telse:\n\t\treturn 0\n\ndef is_same_col():\n\tif col_source == col_destination:\n\t\tmoves = row_destination - row_source\n\t\tno_moves = abs(moves)\n\t\tlist.append(['D' if moves < 0 else 'U', no_moves])\n\t\tcount.append(no_moves)\n\t\treturn 1\n\telse:\n\t\treturn 0\n\ndef is_same_row():\n\tif row_source == row_destination:\n\t\tmoves = ord(col_destination) - ord(col_source)\n\t\tno_moves = abs(moves)\n\t\tlist.append(['R' if moves > 0 else 'L', no_moves])\n\t\tcount.append(no_moves)\n\t\treturn 1\n\telse:\n\t\treturn 0\n\ndef is_same_diagonal():\n\tno_moves = row_source - row_destination\n\tno_cols = ord(col_destination) - ord(col_source)\n\tif no_moves == no_cols:\n\t\tlist.append([('R' if no_cols > 0 else 'L') + ('D' if no_moves > 0 else 'U'), abs(no_moves)])\n\t\tcount.append(abs(no_moves))\n\t\treturn 1\n\telse:\n\t\treturn 0\n\ndef regular_move():\n\tglobal source\n\tglobal col_source\n\tglobal row_source\n\tif col_destination > col_source:\n\t\tR_or_L = 'R'\n\t\tnew_col_val = chr(ord(source[0]) + 1)\n\telse:\n\t\tR_or_L = 'L'\n\t\tnew_col_val = chr(ord(source[0]) - 1)\n\tif row_destination > row_source:\n\t\tD_or_U = 'U'\n\t\tnew_row_val = row_source + 1\n\telse:\n\t\tD_or_U = 'D'\n\t\tnew_row_val = row_source - 1\n\tsource = new_col_val + str(new_row_val)\n\tcol_source = source[0]\n\trow_source = int(source[1:])\n\tlist.append([R_or_L + D_or_U, 1])\n\tcount.append(1)\nsource = input()\ndestination = input()\ncol_destination = destination[0]\nrow_destination = int(destination[1:])\ncol_source = source[0]\nrow_source = int(source[1:])\nif valid_coordinates():\n\tlist = []\n\tcount = []\n\twhile not is_done():\n\t\tif is_same_col():\n\t\t\tsource = destination\n\t\telif is_same_row():\n\t\t\tsource = destination\n\t\telif is_same_diagonal():\n\t\t\tsource = destination\n\t\telse:\n\t\t\tregular_move()\nprint(sum(count))\nfor value in list:\n\tprint((value[0] + '\\n') * value[1], end='')\n",
        "start = input()\nend = input()\nalist = ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')\nstartx = alist.index(start[0]) + 1\nendx = alist.index(end[0]) + 1\nstarty = int(start[1])\nendy = int(end[1])\nxdirection = 0\nydirection = 0\nxtimes = 0\nytimes = 0\noutputlist = []\nif startx > endx:\n\txdirection = 'L'\n\txtimes = startx - endx\nelif startx < endx:\n\txdirection = 'R'\n\txtimes = endx - startx\nif starty > endy:\n\tydirection = 'D'\n\tytimes = starty - endy\nelif starty < endy:\n\tytimes = endy - starty\n\tydirection = 'U'\nif xtimes == ytimes:\n\tfor x in range(xtimes):\n\t\toutputlist.append(xdirection + ydirection)\nelif xtimes < ytimes:\n\tfor x in range(xtimes):\n\t\toutputlist.append(xdirection + ydirection)\n\tfor x in range(ytimes - xtimes):\n\t\toutputlist.append(ydirection)\nelif xtimes > ytimes:\n\tfor x in range(ytimes):\n\t\toutputlist.append(xdirection + ydirection)\n\tfor x in range(xtimes - ytimes):\n\t\toutputlist.append(xdirection)\noutputlist.insert(0, len(outputlist))\nfor y in outputlist:\n\tprint(y)\n",
        "def main():\n\tsq1 = input()\n\tsq2 = input()\n\tdr = int(sq1[1]) - int(sq2[1])\n\tmove = dict()\n\tcs = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\tdc = int(cs[sq1[0]]) - int(cs[sq2[0]])\n\tif dr > 0:\n\t\tmove['row'] = 'D'\n\telif dr == 0:\n\t\tmove['row'] = ''\n\telse:\n\t\tmove['row'] = 'U'\n\tif dc > 0:\n\t\tmove['column'] = 'L'\n\telif dc == 0:\n\t\tmove['column'] = ''\n\telse:\n\t\tmove['column'] = 'R'\n\trm = abs(abs(dr) - abs(dc))\n\tzm = max(abs(dr), abs(dc)) - rm\n\tprint(rm + zm)\n\tfor i in range(zm):\n\t\tprint(move['column'] + move['row'])\n\tfor j in range(rm):\n\t\tif abs(dr) > abs(dc):\n\t\t\tprint(move['row'])\n\t\telif abs(dr) < abs(dc):\n\t\t\tprint(move['column'])\nmain()\n",
        "ini = list(input())\nfin = list(input())\na = int(fin[1]) - int(ini[1])\nif a > 0:\n\tmo_2 = 'U'\nelse:\n\tmo_2 = 'D'\ndi = dict(a=1, b=2, c=3, d=4, e=5, f=6, g=7, h=8)\nb = di[fin[0]] - di[ini[0]]\nif b > 0:\n\tmo_1 = 'R'\nelse:\n\tmo_1 = 'L'\nmaxx = max(abs(a), abs(b))\nminn = min(abs(a), abs(b))\nprint(maxx)\nfor i in range(minn):\n\tprint(mo_1 + mo_2)\nfor i in range(maxx - minn):\n\tif abs(a) > abs(b):\n\t\tprint(mo_2)\n\telse:\n\t\tprint(mo_1)\n",
        "__author__ = 'linh'\n\ndef main():\n\tstart = input()\n\tstop = input()\n\tif ord(start[0]) > 105 or ord(start[0]) < 97:\n\t\tprint(ord(start[0]))\n\t\treturn\n\telse:\n\t\tstart_row = ord(start[0]) - 96\n\tif int(start[1]) > 8 or int(start[1]) < 1:\n\t\treturn\n\telse:\n\t\tstart_col = int(start[1])\n\tif ord(stop[0]) > 105 or ord(stop[0]) < 97:\n\t\treturn\n\telse:\n\t\tstop_row = ord(stop[0]) - 96\n\tif int(stop[1]) > 8 or int(stop[1]) < 1:\n\t\treturn\n\telse:\n\t\tstop_col = int(stop[1])\n\ti = abs(start_row - stop_row)\n\tj = abs(start_col - stop_col)\n\tstep1 = min(i, j)\n\tprint(max(i, j))\n\tif start_row <= stop_row:\n\t\tif start_col <= stop_col:\n\t\t\twhile step1 != 0:\n\t\t\t\tprint('RU')\n\t\t\t\tstep1 -= 1\n\t\t\tif i <= j:\n\t\t\t\tstep2 = j - i\n\t\t\t\twhile step2 != 0:\n\t\t\t\t\tprint('U')\n\t\t\t\t\tstep2 -= 1\n\t\t\telse:\n\t\t\t\tstep2 = i - j\n\t\t\t\twhile step2 != 0:\n\t\t\t\t\tprint('R')\n\t\t\t\t\tstep2 -= 1\n\t\telse:\n\t\t\twhile step1 != 0:\n\t\t\t\tprint('RD')\n\t\t\t\tstep1 -= 1\n\t\t\tif i <= j:\n\t\t\t\tstep2 = j - i\n\t\t\t\twhile step2 != 0:\n\t\t\t\t\tprint('D')\n\t\t\t\t\tstep2 -= 1\n\t\t\telse:\n\t\t\t\tstep2 = i - j\n\t\t\t\twhile step2 != 0:\n\t\t\t\t\tprint('R')\n\t\t\t\t\tstep2 -= 1\n\telif start_col <= stop_col:\n\t\twhile step1 != 0:\n\t\t\tprint('LU')\n\t\t\tstep1 -= 1\n\t\tif i <= j:\n\t\t\tstep2 = j - i\n\t\t\twhile step2 != 0:\n\t\t\t\tprint('U')\n\t\t\t\tstep2 -= 1\n\t\telse:\n\t\t\tstep2 = i - j\n\t\t\twhile step2 != 0:\n\t\t\t\tprint('L')\n\t\t\t\tstep2 -= 1\n\telse:\n\t\twhile step1 != 0:\n\t\t\tprint('LD')\n\t\t\tstep1 -= 1\n\t\tif i <= j:\n\t\t\tstep2 = j - i\n\t\t\twhile step2 != 0:\n\t\t\t\tprint('D')\n\t\t\t\tstep2 -= 1\n\t\telse:\n\t\t\tstep2 = i - j\n\t\t\twhile step2 != 0:\n\t\t\t\tprint('L')\n\t\t\t\tstep2 -= 1\nmain()\n",
        "s = input()\nt = input()\nlis = []\nwhile s != t:\n\tr = ''\n\tif s[0] > t[0]:\n\t\tr += 'L'\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\telif s[0] < t[0]:\n\t\tr += 'R'\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\tif s[1] > t[1]:\n\t\tr += 'D'\n\t\ts = s[0] + chr(ord(s[1]) - 1)\n\telif s[1] < t[1]:\n\t\tr += 'U'\n\t\ts = s[0] + chr(ord(s[1]) + 1)\n\tlis.append(r)\nprint(len(lis))\nfor i in range(len(lis)):\n\tprint(lis[i])\n",
        "(s, t) = (input(), input())\n(sx, sy) = (ord(s[0]) - ord('A'), int(s[1]))\n(tx, ty) = (ord(t[0]) - ord('A'), int(t[1]))\nmoves = []\nwhile (sx, sy) != (tx, ty):\n\tm = ''\n\tif sx < tx:\n\t\tm += 'R'\n\t\tsx += 1\n\telif sx > tx:\n\t\tm += 'L'\n\t\tsx -= 1\n\tif sy < ty:\n\t\tm += 'U'\n\t\tsy += 1\n\telif sy > ty:\n\t\tm += 'D'\n\t\tsy -= 1\n\tmoves.append(m)\nprint(len(moves))\nfor m in moves:\n\tprint(m)\n",
        "c1 = input()\nc2 = input()\nd = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n(x0, y0) = (d[c1[0]], int(c1[1]))\n(x, y) = (d[c2[0]], int(c2[1]))\nprint(max(abs(x - x0), abs(y - y0)))\nwhile x != x0 or y != y0:\n\tif x0 < x:\n\t\tprint('R', end='')\n\t\tx0 += 1\n\telif x0 > x:\n\t\tprint('L', end='')\n\t\tx0 -= 1\n\tif y0 < y:\n\t\tprint('U', end='')\n\t\ty0 += 1\n\telif y0 > y:\n\t\tprint('D', end='')\n\t\ty0 -= 1\n\tprint()\n",
        "(a, b) = (input(), input())\nprint(max(abs(ord(a[0]) - ord(b[0])), abs(ord(a[1]) - ord(b[1]))))\nwhile 1:\n\tif a == b:\n\t\tbreak\n\tif a[0] < b[0]:\n\t\tprint('R', end='')\n\t\ta = chr(ord(a[0]) + 1) + a[1]\n\telif a[0] > b[0]:\n\t\tprint('L', end='')\n\t\ta = chr(ord(a[0]) - 1) + a[1]\n\tif int(a[1]) < int(b[1]):\n\t\tprint('U', end='')\n\t\ta = a[0] + chr(ord(a[1]) + 1)\n\telif int(a[1]) > int(b[1]):\n\t\tprint('D', end='')\n\t\ta = a[0] + chr(ord(a[1]) - 1)\n\tprint('')\n",
        "def get_pos():\n\t(j, i) = input()\n\tj = ord(j) - ord('a')\n\ti = 8 - int(i)\n\treturn (i, j)\n(i1, j1) = get_pos()\n(i2, j2) = get_pos()\nsteps = 0\nres = []\nwhile i1 != i2 or j1 != j2:\n\tret = []\n\tif j1 < j2:\n\t\tret.append('R')\n\t\tj1 += 1\n\tif j1 > j2:\n\t\tret.append('L')\n\t\tj1 -= 1\n\tif i1 < i2:\n\t\tret.append('D')\n\t\ti1 += 1\n\tif i1 > i2:\n\t\tret.append('U')\n\t\ti1 -= 1\n\tres.append(''.join(ret))\n\tsteps += 1\nprint(steps)\nfor ret in res:\n\tprint(ret)\n",
        "sgn = lambda x: 1 if x > 0 else -1 if x < 0 else 0\nDIR = {(-1, 1): 'LU', (0, 1): 'U', (1, 1): 'RU', (-1, 0): 'L', (1, 0): 'R', (-1, -1): 'LD', (0, -1): 'D', (1, -1): 'RD'}\n(s, t) = (input(), input())\n(x, y) = (ord(s[0]) - ord(t[0]), ord(s[1]) - ord(t[1]))\nprint(max(abs(x), abs(y)))\nwhile x or y:\n\t(dx, dy) = (-sgn(x), -sgn(y))\n\t(x, y) = (x + dx, y + dy)\n\tprint(DIR[dx, dy])\n",
        "def ter(n, an, az, ap):\n\treturn an if n < 0 else az if n == 0 else ap\n\ndef sign(x):\n\treturn ter(x, -1, 0, 1)\ns = input()\nt = input()\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\nt = [ord(t[0]) - ord('a') + 1, int(t[1])]\nprint(max(abs(s[0] - t[0]), abs(s[1] - t[1])))\nwhile s != t:\n\td0 = sign(t[0] - s[0])\n\td1 = sign(t[1] - s[1])\n\tprint(ter(d0, 'L', '', 'R') + ter(d1, 'D', '', 'U'))\n\ts[0] += d0\n\ts[1] += d1\n",
        "s = input()\nt = input()\n(a, b) = (ord(s[0]) - ord(t[0]), ord(s[1]) - ord(t[1]))\nprint(max(a, -a, b, -b))\nwhile a != 0 or b != 0:\n\tp = ''\n\tif a > 0:\n\t\tp += 'L'\n\t\ta -= 1\n\tif a < 0:\n\t\tp += 'R'\n\t\ta += 1\n\tif b > 0:\n\t\tp += 'D'\n\t\tb -= 1\n\tif b < 0:\n\t\tp += 'U'\n\t\tb += 1\n\tprint(p)\n",
        "import math\na = input()\nb = input()\nx1 = ord(a[0]) - ord('a')\ny1 = int(a[1]) - 1\nx2 = ord(b[0]) - ord('a')\ny2 = int(b[1]) - 1\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile x1 != x2 or y1 != y2:\n\tif x1 < x2:\n\t\tprint('R', end='')\n\t\tx1 += 1\n\telif x1 > x2:\n\t\tprint('L', end='')\n\t\tx1 -= 1\n\tif y1 > y2:\n\t\tprint('D', end='')\n\t\ty1 -= 1\n\telif y1 < y2:\n\t\tprint('U', end='')\n\t\ty1 += 1\n\tprint()\n",
        "a = list(input())\nb = list(input())\nw = ord(a[0]) - 96\nx = int(a[1])\ny = ord(b[0]) - 96\nz = int(b[1])\ns = 0\nt = 0\nA = y - w\nif A < 0:\n\ts = 1\nB = z - x\nif B < 0:\n\tt = 1\nif s == 0 and t == 0:\n\tu = 'RU'\n\tif abs(A) > abs(B):\n\t\tv = 'R'\n\telse:\n\t\tv = 'U'\nelif s == 1 and t == 0:\n\tu = 'LU'\n\tif abs(A) > abs(B):\n\t\tv = 'L'\n\telse:\n\t\tv = 'U'\nelif s == 1 and t == 1:\n\tu = 'LD'\n\tif abs(A) > abs(B):\n\t\tv = 'L'\n\telse:\n\t\tv = 'D'\nelif s == 0 and t == 1:\n\tu = 'RD'\n\tif abs(A) > abs(B):\n\t\tv = 'R'\n\telse:\n\t\tv = 'D'\nq = min(abs(A), abs(B))\ne = abs(abs(A) - abs(B))\nprint(q + e)\nfor i in range(q):\n\tprint(u)\nfor i in range(e):\n\tprint(v)\n",
        "horizontalMapping = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nsource = input()\ndest = input()\nsource = [horizontalMapping[source[0]], int(source[1])]\ndest = [horizontalMapping[dest[0]], int(dest[1])]\nprint(max(abs(int(source[1]) - int(dest[1])), abs(int(source[0]) - dest[0])))\nwhile not (source[0] == dest[0] and source[1] == dest[1]):\n\tif source[0] < dest[0]:\n\t\tprint('R', end='')\n\t\tsource[0] += 1\n\telif source[0] > dest[0]:\n\t\tprint('L', end='')\n\t\tsource[0] -= 1\n\tif source[1] < dest[1]:\n\t\tprint('U', end='')\n\t\tsource[1] += 1\n\telif source[1] > dest[1]:\n\t\tprint('D', end='')\n\t\tsource[1] -= 1\n\tprint()\n",
        "s = list(input())\nt = list(input())\ns[1] = int(s[1])\nt[1] = int(t[1])\ns[0] = int(ord(s[0]))\nt[0] = int(ord(t[0]))\nres = []\nwhile True:\n\tif s[0] == t[0] and s[1] == t[1]:\n\t\tbreak\n\telif s[0] == t[0]:\n\t\tif s[1] > t[1]:\n\t\t\ts[1] -= 1\n\t\t\tres.append('D')\n\t\telse:\n\t\t\ts[1] += 1\n\t\t\tres.append('U')\n\telif s[1] == t[1]:\n\t\tif s[0] > t[0]:\n\t\t\ts[0] -= 1\n\t\t\tres.append('L')\n\t\telse:\n\t\t\ts[0] += 1\n\t\t\tres.append('R')\n\telif s[0] > t[0] and s[1] > t[1]:\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\t\tres.append('LD')\n\telif s[0] > t[0] and s[1] < t[1]:\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\t\tres.append('LU')\n\telif s[0] < t[0] and s[1] > t[1]:\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\t\tres.append('RD')\n\telif s[0] < t[0] and s[1] < t[1]:\n\t\ts[0] += 1\n\t\ts[1] += 1\n\t\tres.append('RU')\nprint(len(res))\nfor x in res:\n\tprint(x)\n",
        "import sys\n\ndef Pathdt(st, fi, dem):\n\tXX = [1, -1, 0, 0, 1, -1, -1, 1]\n\tYY = [0, 0, 1, -1, 1, 1, -1, -1]\n\tDT = ['R', 'L', 'U', 'D', 'RU', 'LU', 'LD', 'RD']\n\tdt = ((st[0] - fi[0]) ** 2 + (st[1] - fi[1]) ** 2) ** 0.5\n\ttam = [0, 0, 0]\n\tfor k in range(8):\n\t\tdt1 = ((st[0] + XX[k] - fi[0]) ** 2 + (st[1] + YY[k] - fi[1]) ** 2) ** 0.5\n\t\tif dt1 < dt:\n\t\t\tdt = dt1\n\t\t\ttam[0] = XX[k]\n\t\t\ttam[1] = YY[k]\n\t\t\ttam[2] = k\n\tst[0] += tam[0]\n\tst[1] += tam[1]\n\tdem += 1\n\tpath.append(DT[tam[2]])\n\tif st[0] == fi[0] and st[1] == fi[1]:\n\t\tprint(dem)\n\t\tfor i in path:\n\t\t\tprint(i)\n\t\tsys.exit()\n\telse:\n\t\tPathdt(st, fi, dem)\npath = []\ns = input()\nf = input()\ndem = 0\nstart = [ord(s[0]) - ord('a'), int(s[1])]\nfinish = [ord(f[0]) - ord('a'), int(f[1])]\nif start[0] == finish[0] and start[1] == finish[1]:\n\tprint(dem)\n\tsys.exit()\nPathdt(start, finish, dem)\n",
        "(actual_char, actual_int) = input('')\n(destino_char, destino_int) = input('')\nactual_char = ord(actual_char)\nactual_int = int(actual_int)\ndestino_char = ord(destino_char)\ndestino_int = int(destino_int)\nv = []\ncont = 0\nwhile actual_char != destino_char or actual_int != destino_int:\n\tif actual_char == destino_char:\n\t\tif actual_int > destino_int:\n\t\t\tv.append('D')\n\t\t\tactual_int -= 1\n\t\telse:\n\t\t\tv.append('U')\n\t\t\tactual_int += 1\n\telif actual_int == destino_int:\n\t\tif actual_char > destino_char:\n\t\t\tv.append('L')\n\t\t\tactual_char -= 1\n\t\telse:\n\t\t\tv.append('R')\n\t\t\tactual_char += 1\n\telif actual_char > destino_char and actual_int > destino_int:\n\t\tv.append('LD')\n\t\tactual_char -= 1\n\t\tactual_int -= 1\n\telif actual_char < destino_char and actual_int < destino_int:\n\t\tv.append('RU')\n\t\tactual_char += 1\n\t\tactual_int += 1\n\telif actual_char > destino_char and actual_int < destino_int:\n\t\tv.append('LU')\n\t\tactual_char -= 1\n\t\tactual_int += 1\n\telse:\n\t\tv.append('RD')\n\t\tactual_char += 1\n\t\tactual_int -= 1\n\tcont += 1\nprint(cont)\nfor i in range(0, len(v)):\n\tprint(v[i])\n",
        "s = input()\nt = input()\n\ndef Char2Num(ch):\n\treturn ord(ch) - ord('a') + 1\n\ndef Num2Char(num):\n\treturn chr(ord('a') + num - 1)\ns_x = Char2Num(s[0])\ns_y = int(s[1])\nt_x = Char2Num(t[0])\nt_y = int(t[1])\nsteps = []\nx = s_x\ny = s_y\nwhile x < t_x and y < t_y:\n\tsteps.append('RU')\n\tx += 1\n\ty += 1\nwhile x > t_x and y > t_y:\n\tsteps.append('LD')\n\tx -= 1\n\ty -= 1\nwhile x < t_x and y > t_y:\n\tsteps.append('RD')\n\tx += 1\n\ty -= 1\nwhile x > t_x and y < t_y:\n\tsteps.append('LU')\n\tx -= 1\n\ty += 1\nwhile x < t_x:\n\tsteps.append('R')\n\tx += 1\nwhile x > t_x:\n\tsteps.append('L')\n\tx -= 1\nwhile y < t_y:\n\tsteps.append('U')\n\ty += 1\nwhile y > t_y:\n\tsteps.append('D')\n\ty -= 1\nprint(len(steps))\nfor step in steps:\n\tprint(step)\n",
        "king = input()\ngoal = input()\nkx = ord(king[0]) - 97\nky = int(king[1]) - 1\ngx = ord(goal[0]) - 97\ngy = int(goal[1]) - 1\npath = []\nwhile True:\n\tif kx > gx:\n\t\tif ky == gy:\n\t\t\tpath.append('L')\n\t\t\tkx -= 1\n\t\telif ky > gy:\n\t\t\tpath.append('LD')\n\t\t\tkx -= 1\n\t\t\tky -= 1\n\t\telse:\n\t\t\tpath.append('LU')\n\t\t\tkx -= 1\n\t\t\tky += 1\n\telif kx < gx:\n\t\tif ky == gy:\n\t\t\tpath.append('R')\n\t\t\tkx += 1\n\t\telif ky > gy:\n\t\t\tpath.append('RD')\n\t\t\tkx += 1\n\t\t\tky -= 1\n\t\telse:\n\t\t\tpath.append('RU')\n\t\t\tkx += 1\n\t\t\tky += 1\n\telif ky == gy:\n\t\tbreak\n\telif ky < gy:\n\t\tpath.append('U')\n\t\tky += 1\n\telse:\n\t\tpath.append('D')\n\t\tky -= 1\nprint(len(path))\nfor i in path:\n\tprint(i)\n",
        "a = input()\nb = input()\n(A, B) = ([], [])\ndict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nfor x in a:\n\tA.append(x)\nfor x in b:\n\tB.append(x)\n(A[0], B[0]) = (int(dict[A[0]]), int(dict[B[0]]))\n(A[1], B[1]) = (int(A[1]), int(B[1]))\nC = []\nwhile A[0] != B[0]:\n\tif A[0] < B[0]:\n\t\tif A[1] < B[1]:\n\t\t\tC.append('RU')\n\t\t\tA[0] = A[0] + 1\n\t\t\tA[1] = A[1] + 1\n\t\telif A[1] > B[1]:\n\t\t\tC.append('RD')\n\t\t\tA[0] = A[0] + 1\n\t\t\tA[1] = A[1] - 1\n\t\telif A[1] == B[1]:\n\t\t\tC.append('R')\n\t\t\tA[0] = A[0] + 1\n\telif A[0] > B[0]:\n\t\tif A[1] < B[1]:\n\t\t\tC.append('LU')\n\t\t\tA[0] = A[0] - 1\n\t\t\tA[1] = A[1] + 1\n\t\telif A[1] > B[1]:\n\t\t\tC.append('LD')\n\t\t\tA[0] = A[0] - 1\n\t\t\tA[1] = A[1] - 1\n\t\telif A[1] == B[1]:\n\t\t\tC.append('L')\n\t\t\tA[0] = A[0] - 1\n\telif A[1] < B[1]:\n\t\tC.append('U')\n\t\tA[1] = A[1] + 1\n\telif A[1] > B[1]:\n\t\tC.append('D')\n\t\tA[1] = A[1] - 1\nwhile A[1] != B[1]:\n\tif A[0] < B[0]:\n\t\tif A[1] < B[1]:\n\t\t\tC.append('RU')\n\t\t\tA[0] = A[0] + 1\n\t\t\tA[1] = A[1] + 1\n\t\telif A[1] > B[1]:\n\t\t\tC.append('RD')\n\t\t\tA[0] = A[0] + 1\n\t\t\tA[1] = A[1] - 1\n\t\telif A[1] == B[1]:\n\t\t\tC.append('R')\n\t\t\tA[0] = A[0] + 1\n\telif A[0] > B[0]:\n\t\tif A[1] < B[1]:\n\t\t\tC.append('LU')\n\t\t\tA[0] = A[0] - 1\n\t\t\tA[1] = A[1] + 1\n\t\telif A[1] > B[1]:\n\t\t\tC.append('LD')\n\t\t\tA[0] = A[0] - 1\n\t\t\tA[1] = A[1] - 1\n\t\telif A[1] == B[1]:\n\t\t\tC.append('L')\n\t\t\tA[0] = A[0] - 1\n\telif A[1] < B[1]:\n\t\tC.append('U')\n\t\tA[1] = A[1] + 1\n\telif A[1] > B[1]:\n\t\tC.append('D')\n\t\tA[1] = A[1] - 1\nprint(len(C))\nwhile C != []:\n\tprint(C[0])\n\tC.pop(0)\n",
        "def get_location(start):\n\ts = list(start)\n\tx = ord(s[0]) - ord('a') + 1\n\ty = int(s[1])\n\treturn (x, y)\n\tpass\n\nclass Solution:\n\n\tdef __init__(self):\n\t\tself.start = input()\n\t\tself.target = input()\n\t\tself.ps = get_location(self.start)\n\t\tpt = get_location(self.target)\n\t\tself.tx = pt[0]\n\t\tself.ty = pt[1]\n\t\tself.ans = []\n\n\tdef solve(self):\n\t\tself.compute_answer(self.ps)\n\t\tprint(len(self.ans))\n\t\tfor x in self.ans:\n\t\t\tprint(x)\n\t\tpass\n\n\tdef compute_answer(self, ps):\n\t\tsx = ps[0]\n\t\tsy = ps[1]\n\t\tif sx == self.tx and sy == self.ty:\n\t\t\treturn\n\t\tif sx == self.tx:\n\t\t\tif sy < self.ty:\n\t\t\t\tself.ans.append('U')\n\t\t\t\tps = (sx, sy + 1)\n\t\t\t\tself.compute_answer(ps)\n\t\t\telif sy > self.ty:\n\t\t\t\tself.ans.append('D')\n\t\t\t\tps = (sx, sy - 1)\n\t\t\t\tself.compute_answer(ps)\n\t\telif sy == self.ty:\n\t\t\tif sx > self.tx:\n\t\t\t\tself.ans.append('L')\n\t\t\t\tps = (sx - 1, sy)\n\t\t\t\tself.compute_answer(ps)\n\t\t\telif sx < self.tx:\n\t\t\t\tself.ans.append('R')\n\t\t\t\tps = (sx + 1, sy)\n\t\t\t\tself.compute_answer(ps)\n\t\tif sx < self.tx and sy > self.ty:\n\t\t\ts = (sx + 1, sy - 1)\n\t\t\tself.ans.append('RD')\n\t\t\tself.compute_answer(s)\n\t\telif sx > self.tx and sy > self.ty:\n\t\t\ts = (sx - 1, sy - 1)\n\t\t\tself.ans.append('LD')\n\t\t\tself.compute_answer(s)\n\t\telif sx > self.tx and self.ty > sy:\n\t\t\ts = (sx - 1, sy + 1)\n\t\t\tself.ans.append('LU')\n\t\t\tself.compute_answer(s)\n\t\telif self.tx > sx and self.ty > sy:\n\t\t\ts = (sx + 1, sy + 1)\n\t\t\tself.ans.append('RU')\n\t\t\tself.compute_answer(s)\n\t\tpass\ns = Solution()\ns.solve()\n",
        "__author__ = 'Obriel Muga'\ncolumnas = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\ndef ajedrez(posicion_actual, posicion_final, lista_final):\n\t(c_actual, f_actual) = posicion_actual\n\t(c_final, f_final) = posicion_final\n\tif posicion_actual == posicion_final:\n\t\tprint(len(lista_final))\n\t\tfor i in lista_final:\n\t\t\tprint(i)\n\t\treturn\n\telif c_actual < c_final and f_actual < f_final:\n\t\tlista_final.append('RU')\n\t\treturn ajedrez((c_actual + 1, f_actual + 1), posicion_final, lista_final)\n\telif c_actual > c_final and f_actual > f_final:\n\t\tlista_final.append('LD')\n\t\treturn ajedrez((c_actual - 1, f_actual - 1), posicion_final, lista_final)\n\telif c_actual == c_final and f_actual < f_final:\n\t\tlista_final.append('U')\n\t\treturn ajedrez((c_actual, f_actual + 1), posicion_final, lista_final)\n\telif c_actual > c_final and f_actual < f_final:\n\t\tlista_final.append('LU')\n\t\treturn ajedrez((c_actual - 1, f_actual + 1), posicion_final, lista_final)\n\telif c_actual == c_final and f_actual > f_final:\n\t\tlista_final.append('D')\n\t\treturn ajedrez((c_actual, f_actual - 1), posicion_final, lista_final)\n\telif c_actual < c_final and f_actual > f_final:\n\t\tlista_final.append('RD')\n\t\treturn ajedrez((c_actual + 1, f_actual - 1), posicion_final, lista_final)\n\telif f_actual == f_final and c_actual > c_final:\n\t\tlista_final.append('L')\n\t\treturn ajedrez((c_actual - 1, f_actual), posicion_final, lista_final)\n\telif f_actual == f_final and c_actual < c_final:\n\t\tlista_final.append('R')\n\t\treturn ajedrez((c_actual + 1, f_actual), posicion_final, lista_final)\ninicio = str(input())\nfinal = str(input())\ncolumna_inicial = columnas.index(inicio[0])\ncolumna_final = columnas.index(final[0])\nfila_inicial = int(inicio[1]) - 1\nfila_final = int(final[1]) - 1\najedrez((columna_inicial, fila_inicial), (columna_final, fila_final), [])\n",
        "s = input()\nt = input()\nc = ord(s[0]) - ord(t[0])\nd = ord(s[1]) - ord(t[1])\nprint(max(c, -c, d, -d))\nwhile c != 0 or d != 0:\n\tr = ''\n\tif c < 0:\n\t\tr = 'R'\n\t\tc += 1\n\tif c > 0:\n\t\tr = 'L'\n\t\tc -= 1\n\tif d < 0:\n\t\tr += 'U'\n\t\td += 1\n\tif d > 0:\n\t\tr += 'D'\n\t\td -= 1\n\tprint(r)\n",
        "s = input()\nr = input()\na = list(s)\nb = list(r)\na[0] = ord(a[0])\nb[0] = ord(b[0])\na[1] = int(a[1])\nb[1] = int(b[1])\nif a[0] < b[0]:\n\tif a[1] < b[1]:\n\t\tprint(max(b[0] - a[0], b[1] - a[1]))\n\t\twhile b[0] - a[0] and b[1] - a[1]:\n\t\t\tprint('RU')\n\t\t\ta[0] += 1\n\t\t\ta[1] += 1\n\t\tif b[0] - a[0]:\n\t\t\tfor i in range(b[0] - a[0]):\n\t\t\t\tprint('R')\n\t\telse:\n\t\t\tfor i in range(b[1] - a[1]):\n\t\t\t\tprint('U')\n\telse:\n\t\tprint(max(b[0] - a[0], a[1] - b[1]))\n\t\twhile b[0] - a[0] and a[1] - b[1]:\n\t\t\tprint('RD')\n\t\t\ta[0] += 1\n\t\t\ta[1] -= 1\n\t\tif b[0] - a[0]:\n\t\t\tfor i in range(b[0] - a[0]):\n\t\t\t\tprint('R')\n\t\telse:\n\t\t\tfor i in range(a[1] - b[1]):\n\t\t\t\tprint('D')\nelif a[1] < b[1]:\n\tprint(max(a[0] - b[0], b[1] - a[1]))\n\twhile a[0] - b[0] and b[1] - a[1]:\n\t\tprint('LU')\n\t\ta[0] -= 1\n\t\ta[1] += 1\n\tif a[0] - b[0]:\n\t\tfor i in range(a[0] - b[0]):\n\t\t\tprint('L')\n\telse:\n\t\tfor i in range(b[1] - a[1]):\n\t\t\tprint('U')\nelse:\n\tprint(max(a[0] - b[0], a[1] - b[1]))\n\twhile a[0] - b[0] and a[1] - b[1]:\n\t\tprint('LD')\n\t\ta[0] -= 1\n\t\ta[1] -= 1\n\tif a[0] - b[0]:\n\t\tfor i in range(a[0] - b[0]):\n\t\t\tprint('L')\n\telse:\n\t\tfor i in range(a[1] - b[1]):\n\t\t\tprint('D')\n",
        "s = input()\nt = input()\nx = ord(t[0]) - ord(s[0])\ny = int(t[1]) - int(s[1])\nprint(max(abs(x), abs(y)))\nwhile x != 0 or y != 0:\n\tdirection = ''\n\tif x > 0:\n\t\tdirection += 'R'\n\t\tx -= 1\n\tif x < 0:\n\t\tdirection += 'L'\n\t\tx += 1\n\tif y > 0:\n\t\tdirection += 'U'\n\t\ty -= 1\n\tif y < 0:\n\t\tdirection += 'D'\n\t\ty += 1\n\tprint(direction)\n",
        "s = input()\nt = input()\ndiff_vertical = int(s[1]) - int(t[1])\ndiff_hor = ord(s[0]) - ord(t[0])\nprint(max(abs(diff_hor), abs(diff_vertical)))\nwhile True:\n\tif diff_vertical > 0:\n\t\tif diff_hor > 0:\n\t\t\tprint('LD')\n\t\t\tdiff_hor -= 1\n\t\t\tdiff_vertical -= 1\n\t\telif diff_hor < 0:\n\t\t\tprint('RD')\n\t\t\tdiff_hor += 1\n\t\t\tdiff_vertical -= 1\n\t\telse:\n\t\t\tprint('D')\n\t\t\tdiff_vertical -= 1\n\telif diff_vertical < 0:\n\t\tif diff_hor > 0:\n\t\t\tprint('LU')\n\t\t\tdiff_hor -= 1\n\t\t\tdiff_vertical += 1\n\t\telif diff_hor < 0:\n\t\t\tprint('RU')\n\t\t\tdiff_hor += 1\n\t\t\tdiff_vertical += 1\n\t\telse:\n\t\t\tprint('U')\n\t\t\tdiff_vertical += 1\n\telif diff_hor > 0:\n\t\tprint('L')\n\t\tdiff_hor -= 1\n\telif diff_hor < 0:\n\t\tprint('R')\n\t\tdiff_hor += 1\n\telse:\n\t\tbreak\n",
        "def main():\n\tstartpoint = [i for i in input()]\n\tendpoint = [j for j in input()]\n\tx_distance = ord(startpoint[0]) - ord(endpoint[0])\n\ty_distance = int(startpoint[1]) - int(endpoint[1])\n\tx_abs_distance = abs(ord(startpoint[0]) - ord(endpoint[0]))\n\ty_abs_distance = abs(int(startpoint[1]) - int(endpoint[1]))\n\tprint(max(x_abs_distance, y_abs_distance))\n\twhile x_distance != 0 or y_distance != 0:\n\t\tr = ''\n\t\tif x_distance < 0:\n\t\t\tr = 'R'\n\t\t\tx_distance += 1\n\t\tif x_distance > 0:\n\t\t\tr = 'L'\n\t\t\tx_distance -= 1\n\t\tif y_distance < 0:\n\t\t\tr += 'U'\n\t\t\ty_distance += 1\n\t\tif y_distance > 0:\n\t\t\tr += 'D'\n\t\t\ty_distance -= 1\n\t\tprint(r)\nmain()\n",
        "s = input()\nt = input()\nimport math\nb = ord(t[0]) - ord(s[0])\nb_mod = math.fabs(b)\nc = int(t[1]) - int(s[1])\nc = int(c)\nc_mod = math.fabs(c)\notvet = max(b_mod, c_mod)\nprint(int(otvet))\nwhile b_mod != c_mod:\n\tif c_mod < b_mod:\n\t\tif b > 0:\n\t\t\tb_mod = b_mod - 1\n\t\t\tprint('R')\n\t\telse:\n\t\t\tb_mod = b_mod - 1\n\t\t\tprint('L')\n\telif c > 0:\n\t\tc_mod = c_mod - 1\n\t\tprint('U')\n\telse:\n\t\tc_mod = c_mod - 1\n\t\tprint('D')\nwhile c_mod > 0 and b_mod > 0:\n\tif c > 0 and b > 0:\n\t\tc_mod = c_mod - 1\n\t\tb_mod = b_mod - 1\n\t\tprint('RU')\n\telif c > 0 and b < 0:\n\t\tc_mod = c_mod - 1\n\t\tb_mod = b_mod - 1\n\t\tprint('LU')\n\telif c < 0 and b < 0:\n\t\tc_mod = c_mod - 1\n\t\tb_mod = b_mod - 1\n\t\tprint('LD')\n\telse:\n\t\tc_mod = c_mod - 1\n\t\tb_mod = b_mod - 1\n\t\tprint('RD')\n",
        "t1 = input()\nt2 = input()\nx1 = ord(t1[0]) - ord('a') + 1\ny1 = int(t1[1])\nx2 = ord(t2[0]) - ord('a') + 1\ny2 = int(t2[1])\nprint(max(abs(x2 - x1), abs(y2 - y1)))\nif x1 <= x2 and y1 <= y2:\n\tfor i in range(min(x2 - x1, y2 - y1)):\n\t\tprint('RU')\nif x1 <= x2 and y1 > y2:\n\tfor i in range(min(x2 - x1, y1 - y2)):\n\t\tprint('RD')\nif x1 > x2 and y1 <= y2:\n\tfor i in range(min(x1 - x2, y2 - y1)):\n\t\tprint('LU')\nif x1 > x2 and y1 > y2:\n\tfor i in range(min(x1 - x2, y1 - y2)):\n\t\tprint('LD')\nif x2 - x1 > abs(y2 - y1):\n\tfor i in range(x2 - x1 - abs(y2 - y1)):\n\t\tprint('R')\nif x1 - x2 > abs(y2 - y1):\n\tfor i in range(x1 - x2 - abs(y2 - y1)):\n\t\tprint('L')\nif y2 - y1 > abs(x2 - x1):\n\tfor i in range(y2 - y1 - abs(x2 - x1)):\n\t\tprint('U')\nif y1 - y2 > abs(x2 - x1):\n\tfor i in range(y1 - y2 - abs(x2 - x1)):\n\t\tprint('D')\n",
        "s1 = input()\ns2 = input()\ndx = ord(s2[0]) - ord(s1[0])\ndy = ord(s2[1]) - ord(s1[1])\nans = []\nstep = 0\nwhile dx != 0 or dy != 0:\n\ttans = ''\n\tstep = step + 1\n\tif dx > 0:\n\t\ttans = tans + 'R'\n\t\tdx = dx - 1\n\telif dx < 0:\n\t\ttans = tans + 'L'\n\t\tdx = dx + 1\n\tif dy > 0:\n\t\ttans = tans + 'U'\n\t\tdy = dy - 1\n\telif dy < 0:\n\t\ttans = tans + 'D'\n\t\tdy = dy + 1\n\tans.append(tans)\nprint(step)\nfor st in ans:\n\tprint(st)\n",
        "s = str(input())\nt = str(input())\nif s[0] == t[0]:\n\tprint(abs(int(s[1]) - int(t[1])))\n\tfor i in range(abs(int(s[1]) - int(t[1]))):\n\t\tif int(s[1]) - int(t[1]) > 0:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('U')\nelif s[1] == t[1]:\n\tprint(abs(ord(s[0]) - ord(t[0])))\n\tfor i in range(abs(ord(s[0]) - ord(t[0]))):\n\t\tif ord(s[0]) - ord(t[0]) < 0:\n\t\t\tprint('R')\n\t\telse:\n\t\t\tprint('L')\nelse:\n\tprint(max(abs(int(s[1]) - int(t[1])), abs(ord(s[0]) - ord(t[0]))))\n\tfor i in range(min(abs(ord(s[0]) - ord(t[0])), abs(int(s[1]) - int(t[1])))):\n\t\tif int(s[1]) - int(t[1]) > 0 and ord(s[0]) - ord(t[0]) < 0:\n\t\t\tprint('RD')\n\t\telif int(s[1]) - int(t[1]) < 0 and ord(s[0]) - ord(t[0]) > 0:\n\t\t\tprint('LU')\n\t\telif int(s[1]) - int(t[1]) > 0 and ord(s[0]) - ord(t[0]) > 0:\n\t\t\tprint('LD')\n\t\telse:\n\t\t\tprint('RU')\n\tfor i in range(max(abs(int(s[1]) - int(t[1])), abs(ord(s[0]) - ord(t[0]))) - min(abs(ord(s[0]) - ord(t[0])), abs(int(s[1]) - int(t[1])))):\n\t\tif abs(int(s[1]) - int(t[1])) >= abs(ord(s[0]) - ord(t[0])):\n\t\t\tif int(s[1]) > int(t[1]):\n\t\t\t\tprint('D')\n\t\t\telse:\n\t\t\t\tprint('U')\n\t\telif s[0] > t[0]:\n\t\t\tprint('L')\n\t\telse:\n\t\t\tprint('R')\n",
        "a = input()\nb = input()\ns = ord(a[0]) - ord(b[0])\nt = int(a[1]) - int(b[1])\ni = 0\nk = 0\nj = 0\nif s < 0:\n\tl = 'R'\nelse:\n\tl = 'L'\nif t > 0:\n\tm = 'D'\nelse:\n\tm = 'U'\nprint(max(abs(s), abs(t)))\nwhile i < max(abs(s), abs(t)):\n\tif abs(s) > j:\n\t\tprint(l, end='')\n\t\tj = j + 1\n\tif abs(t) > k:\n\t\tprint(m)\n\t\tk = k + 1\n\telse:\n\t\tprint()\n\ti = i + 1\n",
        "s = input()\nt = input()\na = int(s[1]) - int(t[1])\nf = ord(s[0])\ng = ord(t[0])\nb = chr(f)\nc = chr(g)\nd = int(s[1])\ne = int(t[1])\nh = f - g\nif b == c and d == e:\n\tprint(0)\nelse:\n\tprint(max(abs(a), abs(h)))\n\twhile b != c or d != e:\n\t\tif b < c:\n\t\t\tprint('R', end='')\n\t\t\tb = chr(ord(b) + 1)\n\t\telif b > c:\n\t\t\tprint('L', end='')\n\t\t\tb = chr(ord(b) - 1)\n\t\tif d < e:\n\t\t\tprint('U')\n\t\t\td += 1\n\t\telif d > e:\n\t\t\tprint('D')\n\t\t\td -= 1\n\t\telse:\n\t\t\tprint(' ')\n",
        "import os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\n\ndef gcd(a, b):\n\tif b == 0:\n\t\treturn a\n\telse:\n\t\treturn gcd(b, a % b)\n\ndef lcm(a, b):\n\treturn a * b // gcd(a, b)\n\ndef ncr(n, r):\n\treturn math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\ndef npr(n, r):\n\treturn math.factorial(n) // math.factorial(n - r)\n\ndef seive(n):\n\tprimes = [True] * (n + 1)\n\tans = []\n\tfor i in range(2, n):\n\t\tif not primes[i]:\n\t\t\tcontinue\n\t\tj = 2 * i\n\t\twhile j <= n:\n\t\t\tprimes[j] = False\n\t\t\tj += i\n\tfor p in range(2, n + 1):\n\t\tif primes[p]:\n\t\t\tans += [p]\n\treturn ans\n\ndef factors(n):\n\tfactors = []\n\tx = 1\n\twhile x * x <= n:\n\t\tif n % x == 0:\n\t\t\tif n // x == x:\n\t\t\t\tfactors.append(x)\n\t\t\telse:\n\t\t\t\tfactors.append(x)\n\t\t\t\tfactors.append(n // x)\n\t\tx += 1\n\treturn factors\n\ndef main():\n\ttry:\n\t\ts = input()\n\t\th = input()\n\t\tho = ord(s[0])\n\t\thd = ord(h[0])\n\t\tvo = ord(s[1])\n\t\tvd = ord(h[1])\n\t\tans = max(abs(ho - hd), abs(vo - vd))\n\t\tprint(ans)\n\t\tans = []\n\t\tif ho < hd:\n\t\t\tif abs(ho - hd) > abs(vo - vd):\n\t\t\t\tans += ['R'] * (abs(ho - hd) - abs(vo - vd))\n\t\t\t\tif vo > vd:\n\t\t\t\t\tans += ['RD'] * abs(vo - vd)\n\t\t\t\telse:\n\t\t\t\t\tans += ['RU'] * abs(vo - vd)\n\t\t\telif vo > vd:\n\t\t\t\tans += ['D'] * abs(abs(ho - hd) - abs(vo - vd))\n\t\t\t\tans += ['RD'] * abs(hd - ho)\n\t\t\telse:\n\t\t\t\tans += ['U'] * abs(abs(ho - hd) - abs(vo - vd))\n\t\t\t\tans += ['RU'] * abs(hd - ho)\n\t\telif abs(ho - hd) > abs(vo - vd):\n\t\t\tans += ['L'] * (abs(ho - hd) - abs(vo - vd))\n\t\t\tif vo > vd:\n\t\t\t\tans += ['LD'] * abs(vo - vd)\n\t\t\telse:\n\t\t\t\tans += ['LU'] * abs(vo - vd)\n\t\telif vo > vd:\n\t\t\tans += ['D'] * abs(abs(ho - hd) - abs(vo - vd))\n\t\t\tans += ['LD'] * abs(hd - ho)\n\t\telse:\n\t\t\tans += ['U'] * abs(abs(ho - hd) - abs(vo - vd))\n\t\t\tans += ['LU'] * abs(hd - ho)\n\t\tprint(*ans, sep='\\n')\n\texcept Exception as e:\n\t\tprint(e)\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "alphabetic = ' abcdefgh'\ns = input()\nt = input()\nsx = alphabetic.index(s[0])\nsy = int(s[1])\ntx = alphabetic.index(t[0])\nty = int(t[1])\nres = ''\ncnt = 0\nwhile sx != tx or sy != ty:\n\tcnt += 1\n\tif sx < tx:\n\t\tres += 'R'\n\t\tsx += 1\n\telif sx > tx:\n\t\tres += 'L'\n\t\tsx -= 1\n\tif sy < ty:\n\t\tres += 'U'\n\t\tsy += 1\n\telif sy > ty:\n\t\tres += 'D'\n\t\tsy -= 1\n\tres += '\\n'\nprint(cnt)\nprint(res)\n",
        "def step():\n\tglobal x1, x2, y1, y2, step_count, moves\n\tmove = ''\n\tif x1 > x2:\n\t\tmove += 'L'\n\t\tx1 -= 1\n\telif x1 < x2:\n\t\tmove += 'R'\n\t\tx1 += 1\n\tif y1 > y2:\n\t\tmove += 'D'\n\t\ty1 -= 1\n\telif y1 < y2:\n\t\tmove += 'U'\n\t\ty1 += 1\n\tstep_count += 1\n\tmoves.append(move)\np1 = input()\n(x1, y1) = (ord(p1[0]) - ord('a'), int(p1[1]))\np2 = input()\n(x2, y2) = (ord(p2[0]) - ord('a'), int(p2[1]))\n(step_count, moves) = (0, [])\nwhile x1 != x2 or y1 != y2:\n\tstep()\nprint(step_count)\nprint('\\n'.join(moves))\n",
        "start = list(input())\nfinish = list(input())\n(start[0], finish[0]) = (list('abcdefgh').index(start[0]) + 1, list('abcdefgh').index(finish[0]) + 1)\nv = finish[0] - start[0]\nh = int(finish[1]) - int(start[1])\nif v < 0:\n\tv_flag = 'L'\nelse:\n\tv_flag = 'R'\nif h > 0:\n\th_flag = 'U'\nelse:\n\th_flag = 'D'\nv = abs(v)\nh = abs(h)\nprint(max(v, h))\nsmol = min(v, h)\nbig = max(v, h) - smol\nfor x in range(smol):\n\tprint(v_flag + h_flag)\nfor x in range(big):\n\tprint((v > h) * v_flag + (v < h) * h_flag)\n",
        "coord1 = input()\ncoord2 = input()\ncoord1 = [ord(coord1[0]) - 96, int(coord1[1])]\ncoord2 = [ord(coord2[0]) - 96, int(coord2[1])]\nCountMoves = 0\nMoves = []\nwhile coord1[0] != coord2[0] or coord1[1] != coord2[1]:\n\tif coord1[0] == coord2[0]:\n\t\tif coord1[1] > coord2[1]:\n\t\t\tMoves.append('D')\n\t\t\tcoord1[1] -= 1\n\t\telse:\n\t\t\tMoves.append('U')\n\t\t\tcoord1[1] += 1\n\telif coord1[0] > coord2[0]:\n\t\tif coord1[1] == coord2[1]:\n\t\t\tMoves.append('L')\n\t\t\tcoord1[0] -= 1\n\t\telif coord1[1] > coord2[1]:\n\t\t\tMoves.append('LD')\n\t\t\tcoord1[0] -= 1\n\t\t\tcoord1[1] -= 1\n\t\telse:\n\t\t\tMoves.append('LU')\n\t\t\tcoord1[0] -= 1\n\t\t\tcoord1[1] += 1\n\telif coord1[1] == coord2[1]:\n\t\tMoves.append('R')\n\t\tcoord1[0] += 1\n\telif coord1[1] > coord2[1]:\n\t\tMoves.append('RD')\n\t\tcoord1[0] += 1\n\t\tcoord1[1] -= 1\n\telse:\n\t\tMoves.append('RU')\n\t\tcoord1[0] += 1\n\t\tcoord1[1] += 1\n\tCountMoves += 1\nprint(CountMoves)\nfor i in range(0, len(Moves)):\n\tprint(Moves[i])\n",
        "a = input()\nb = input()\na1 = ord(a[0])\na2 = int(a[1])\nb1 = ord(b[0])\nb2 = int(b[1])\nl = []\nans = 0\nwhile a1 < b1 and a2 < b2:\n\tl.append('RU')\n\ta1 += 1\n\ta2 += 1\n\tans += 1\nwhile a1 > b1 and a2 < b2:\n\tl.append('LU')\n\ta1 -= 1\n\ta2 += 1\n\tans += 1\nwhile a1 > b1 and a2 > b2:\n\tl.append('LD')\n\ta1 -= 1\n\ta2 -= 1\n\tans += 1\nwhile a1 < b1 and a2 > b2:\n\tl.append('RD')\n\ta1 += 1\n\ta2 -= 1\n\tans += 1\nwhile a1 < b1:\n\ta1 += 1\n\tl.append('R')\n\tans += 1\nwhile a1 > b1:\n\ta1 -= 1\n\tl.append('L')\n\tans += 1\nwhile a2 < b2:\n\ta2 += 1\n\tl.append('U')\n\tans += 1\nwhile a2 > b2:\n\ta2 -= 1\n\tl.append('D')\n\tans += 1\nprint(ans)\nfor i in l:\n\tprint(i)\n",
        "a = list(input())\nb = list(input())\nx = 'D' if a[1] > b[1] else 'U'\ny = 'L' if a[0] > b[0] else 'R'\nm = abs(ord(a[0]) - ord(b[0]))\nn = abs(ord(a[1]) - ord(b[1]))\nc = max(m, n)\nprint(c)\nj = y + x\nfor _ in range(min(m, n)):\n\tprint(j)\nmini = min(m, n)\nm -= mini\nn -= mini\nfor _ in range(m):\n\tprint(y)\nfor _ in range(n):\n\tprint(x)\n",
        "mov = {-1: 'RU', 1: 'LD'}\n(s, t) = (input(), input())\n(x, y, x1, y1) = (ord(s[0]) - 96, int(s[1]), ord(t[0]) - 96, int(t[1]))\n(v, h) = (abs(x - x1), abs(y - y1))\nif x == x1 or y == y1:\n\ttemp = (x - x1) // abs(x - x1) if x - x1 else (y - y1) // abs(y - y1) if y - y1 else 0\n\tif temp == 0:\n\t\tprint(0)\n\t\texit()\n\tjmp = max(abs(x - x1), abs(y - y1))\n\tp0 = [mov[temp][0]] * jmp if y - y1 == 0 else [mov[temp][1]] * jmp\n\tprint(len(p0))\n\tprint(*p0)\nelse:\n\tpos = mov[(x - x1) // v][0] + mov[(y - y1) // h][1]\n\t(j1, j2) = (v - h if v - h > -1 else abs(v - h) + v, h - v if h - v > -1 else abs(h - v) + h)\n\t(p1, p2) = ([pos[0]] * j1 + [pos] * h, [pos[1]] * j2 + [pos] * v)\n\tif len(p1) < len(p2):\n\t\tprint(len(p1))\n\t\tprint(*p1)\n\telse:\n\t\tprint(len(p2))\n\t\tprint(*p2)\n",
        "a = list(input())\nb = list(input())\n(x, y, _x, _y) = (ord(a[0]) - 97, int(a[1]) - 1, ord(b[0]) - 97, int(b[1]) - 1)\nprint(max(abs(x - _x), abs(y - _y)))\nwhile 1:\n\tif x == _x and y == _y:\n\t\tbreak\n\tif x < _x:\n\t\tx += 1\n\t\tprint('R', end='')\n\telif x > _x:\n\t\tx -= 1\n\t\tprint('L', end='')\n\tif y > _y:\n\t\ty -= 1\n\t\tprint('D', end='')\n\telif y < _y:\n\t\ty += 1\n\t\tprint('U', end='')\n\tprint('')\n",
        "from math import *\n\ndef sign(x):\n\tif x < 0:\n\t\treturn -1\n\telif x > 0:\n\t\treturn 1\n\treturn 0\ns = input()\nx = ord(s[0]) - ord('a')\ny = int(s[1])\nt = input()\ntx = ord(t[0]) - ord('a')\nty = int(t[1])\nvx = tx - x\nif vx < 0:\n\tansx = 'L'\nelse:\n\tansx = 'R'\nvy = ty - y\nif vy < 0:\n\tansy = 'D'\nelse:\n\tansy = 'U'\nprint(max(abs(vx), abs(vy)))\nwhile vx != 0 or vy != 0:\n\tans = ''\n\tif vx != 0:\n\t\tans += ansx\n\t\tvx -= sign(vx)\n\tif vy != 0:\n\t\tans += ansy\n\t\tvy -= sign(vy)\n\tprint(ans)\n",
        "(s, t) = (input(), input())\npath = []\nn = 0\nwhile s[0] > t[0] and s[1] > t[1]:\n\tpath.append('LD')\n\tn += 1\n\ts = chr(ord(s[0]) - 1) + chr(ord(s[1]) - 1)\nwhile s[0] > t[0] and s[1] < t[1]:\n\tpath.append('LU')\n\tn += 1\n\ts = chr(ord(s[0]) - 1) + chr(ord(s[1]) + 1)\nwhile s[0] < t[0] and s[1] < t[1]:\n\tpath.append('RU')\n\tn += 1\n\ts = chr(ord(s[0]) + 1) + chr(ord(s[1]) + 1)\nwhile s[0] < t[0] and s[1] > t[1]:\n\tpath.append('RD')\n\tn += 1\n\ts = chr(ord(s[0]) + 1) + chr(ord(s[1]) - 1)\nwhile s[0] > t[0]:\n\tpath.append('L')\n\tn += 1\n\ts = chr(ord(s[0]) - 1) + s[1]\nwhile s[0] < t[0]:\n\tpath.append('R')\n\tn += 1\n\ts = chr(ord(s[0]) + 1) + s[1]\nwhile s[1] < t[1]:\n\tpath.append('U')\n\tn += 1\n\ts = s[0] + chr(ord(s[1]) + 1)\nwhile s[1] > t[1]:\n\tpath.append('D')\n\tn += 1\n\ts = s[0] + chr(ord(s[1]) - 1)\nprint(n)\nfor step in path:\n\tprint(step)\n",
        "s = input()\nt = input()\nsx = ord(s[0]) - ord('a') + 1\nsy = int(s[1])\ntx = ord(t[0]) - ord('a') + 1\nty = int(t[1])\ndx = abs(sx - tx)\ndy = abs(sy - ty)\nd1 = min(dx, dy)\nd2 = max(dx, dy)\nprint(d2)\nif sx <= tx:\n\tif sy <= ty:\n\t\tfor i in range(d1):\n\t\t\tprint('RU')\n\t\tfor i in range(d2 - d1):\n\t\t\tif dx <= dy:\n\t\t\t\tprint('U')\n\t\t\telse:\n\t\t\t\tprint('R')\n\telse:\n\t\tfor i in range(d1):\n\t\t\tprint('RD')\n\t\tfor i in range(d2 - d1):\n\t\t\tif dx <= dy:\n\t\t\t\tprint('D')\n\t\t\telse:\n\t\t\t\tprint('R')\nelif sy <= ty:\n\tfor i in range(d1):\n\t\tprint('LU')\n\tfor i in range(d2 - d1):\n\t\tif dx <= dy:\n\t\t\tprint('U')\n\t\telse:\n\t\t\tprint('L')\nelse:\n\tfor i in range(d1):\n\t\tprint('LD')\n\tfor i in range(d2 - d1):\n\t\tif dx <= dy:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('L')\n",
        "(sx, sy) = input()\n(tx, ty) = input()\nsx = ord(sx) - ord('a')\ntx = ord(tx) - ord('a')\nsy = int(sy) - 1\nty = int(ty) - 1\nmoves = []\nwhile (sx, sy) != (tx, ty):\n\twhile sx != tx and sy != ty:\n\t\tif tx > sx:\n\t\t\tif ty > sy:\n\t\t\t\tmoves += ['RU']\n\t\t\t\tsx += 1\n\t\t\t\tsy += 1\n\t\t\telse:\n\t\t\t\tmoves += ['RD']\n\t\t\t\tsx += 1\n\t\t\t\tsy -= 1\n\t\telif ty > sy:\n\t\t\tmoves += ['LU']\n\t\t\tsx -= 1\n\t\t\tsy += 1\n\t\telse:\n\t\t\tmoves += ['LD']\n\t\t\tsx -= 1\n\t\t\tsy -= 1\n\twhile sx != tx or sy != ty:\n\t\tif sx > tx:\n\t\t\tmoves += ['L']\n\t\t\tsx -= 1\n\t\telif sx < tx:\n\t\t\tmoves += ['R']\n\t\t\tsx += 1\n\t\telif sy > ty:\n\t\t\tmoves += ['D']\n\t\t\tsy -= 1\n\t\telse:\n\t\t\tmoves += ['U']\n\t\t\tsy += 1\nprint(len(moves))\nprint(*moves, sep='\\n')\n",
        "a = input()\nb = input()\nsorh = ord(a[0])\ntarh = ord(b[0])\nsorv = int(a[1])\ntarv = int(b[1])\nhor = abs(ord(a[0]) - ord(b[0]))\nver = abs(int(a[1]) - int(b[1]))\nkorno = max(hor, ver) - abs(hor - ver)\ns = ''\nl = []\nif korno > 0:\n\tif tarh - sorh > 0:\n\t\ts = 'R'\n\t\tif tarv > sorv:\n\t\t\ts = s + 'U'\n\t\telif sorv > tarv:\n\t\t\ts = s + 'D'\n\telse:\n\t\ts = 'L'\n\t\tif tarv > sorv:\n\t\t\ts = s + 'U'\n\t\telif sorv > tarv:\n\t\t\ts = s + 'D'\n\tfor i in range(korno):\n\t\tl.append(s)\nif tarv > sorv:\n\tp = tarv - sorv - korno\n\tfor i in range(p):\n\t\tl.append('U')\nelif sorv > tarv:\n\tp = sorv - tarv - korno\n\tfor i in range(p):\n\t\tl.append('D')\nif tarh > sorh:\n\tp = tarh - sorh - korno\n\tfor i in range(p):\n\t\tl.append('R')\nelif sorh > tarh:\n\tp = sorh - tarh - korno\n\tfor i in range(p):\n\t\tl.append('L')\nprint(len(l))\nfor i in range(len(l)):\n\tprint(l[i])\n",
        "import os\nimport sys\ndebug = True\nif debug and os.path.exists('input.in'):\n\tinput = open('input.in', 'r').readline\nelse:\n\tdebug = False\n\tinput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\ntest_count = 1\nif debug:\n\ttest_count = int(input())\nfor t in range(test_count):\n\tif debug:\n\t\tprint('Test Case #', t + 1)\n\tS = input()\n\tE = input()\n\tX1 = ord(S[0])\n\tY1 = ord(S[1])\n\tX2 = ord(E[0])\n\tY2 = ord(E[1])\n\trows = abs(X1 - X2)\n\tcols = abs(Y1 - Y2)\n\tdiagonal = min(rows, cols)\n\tmoves = []\n\tdiaMove = ''\n\totherMove = ''\n\tif X2 >= X1:\n\t\tif Y2 >= Y1:\n\t\t\tdiaMove = 'RU'\n\t\t\totherMove = 'R' if rows >= cols else 'U'\n\t\telse:\n\t\t\tdiaMove = 'RD'\n\t\t\totherMove = 'R' if rows >= cols else 'D'\n\telif Y2 >= Y1:\n\t\tdiaMove = 'LU'\n\t\totherMove = 'L' if rows >= cols else 'U'\n\telse:\n\t\tdiaMove = 'LD'\n\t\totherMove = 'L' if rows >= cols else 'D'\n\tfor _ in range(diagonal):\n\t\tmoves.append(diaMove)\n\tfor _ in range(max(rows, cols) - diagonal):\n\t\tmoves.append(otherMove)\n\tprint(len(moves))\n\tprint('\\n'.join(moves))\n",
        "def main():\n\ts = input()\n\te = input()\n\thor = ord(s[0]) - ord(e[0])\n\tver = int(s[1]) - int(e[1])\n\tmax_steps = max(abs(hor), abs(ver))\n\tprint(max_steps)\n\twhile hor or ver:\n\t\tstep = ''\n\t\tif hor > 0:\n\t\t\thor -= 1\n\t\t\tstep += 'L'\n\t\tif hor < 0:\n\t\t\thor += 1\n\t\t\tstep += 'R'\n\t\tif ver > 0:\n\t\t\tver -= 1\n\t\t\tstep += 'D'\n\t\tif ver < 0:\n\t\t\tver += 1\n\t\t\tstep += 'U'\n\t\tprint(step)\nmain()\n",
        "a = input()\nb = input()\nc = ord(a[0]) - ord(b[0])\nd = int(a[1]) - int(b[1])\nprint(max(c, d, -c, -d))\nwhile c != 0 or d != 0:\n\ts = ''\n\tif c > 0:\n\t\ts = s + 'L'\n\t\tc = c - 1\n\tif c < 0:\n\t\ts = s + 'R'\n\t\tc = c + 1\n\tif d > 0:\n\t\ts = s + 'D'\n\t\td = d - 1\n\tif d < 0:\n\t\ts = s + 'U'\n\t\td = d + 1\n\tprint(s)\n",
        "S1 = str(input())\nS2 = str(input())\nif S1[0] == 'a':\n\tS1 += '1'\nif S1[0] == 'b':\n\tS1 += '2'\nif S1[0] == 'c':\n\tS1 += '3'\nif S1[0] == 'd':\n\tS1 += '4'\nif S1[0] == 'e':\n\tS1 += '5'\nif S1[0] == 'f':\n\tS1 += '6'\nif S1[0] == 'g':\n\tS1 += '7'\nif S1[0] == 'h':\n\tS1 += '8'\nif S2[0] == 'a':\n\tS2 += '1'\nif S2[0] == 'b':\n\tS2 += '2'\nif S2[0] == 'c':\n\tS2 += '3'\nif S2[0] == 'd':\n\tS2 += '4'\nif S2[0] == 'e':\n\tS2 += '5'\nif S2[0] == 'f':\n\tS2 += '6'\nif S2[0] == 'g':\n\tS2 += '7'\nif S2[0] == 'h':\n\tS2 += '8'\na = int(S1[1])\nb = int(S2[1])\nc = int(S1[2])\nd = int(S2[2])\nB = []\nwhile a != b or c != d:\n\tif a > b and c < d:\n\t\ta = a - 1\n\t\tc = c + 1\n\t\tB.append('RD')\n\telif a > b and c > d:\n\t\ta = a - 1\n\t\tc = c - 1\n\t\tB.append('LD')\n\telif a < b and c < d:\n\t\ta = a + 1\n\t\tc = c + 1\n\t\tB.append('RU')\n\telif a < b and c > d:\n\t\ta = a + 1\n\t\tc = c - 1\n\t\tB.append('LU')\n\telif c == d and a > b:\n\t\ta = a - 1\n\t\tB.append('D')\n\telif c == d and a < b:\n\t\ta = a + 1\n\t\tB.append('U')\n\telif a == b and c < d:\n\t\tc = c + 1\n\t\tB.append('R')\n\telif a == b and c > d:\n\t\tc = c - 1\n\t\tB.append('L')\nprint(len(B))\nfor i in B:\n\tprint(i)\n",
        "s1 = input()\ns2 = input()\na = ord(s1[0]) - ord(s2[0])\nb = ord(s1[1]) - ord(s2[1])\nminimum_moves = max(a, b, -a, -b)\nprint(minimum_moves)\nwhile a != 0 or b != 0:\n\tpath = ''\n\tif a > 0:\n\t\ta -= 1\n\t\tpath += 'L'\n\tif a < 0:\n\t\ta += 1\n\t\tpath += 'R'\n\tif b < 0:\n\t\tb += 1\n\t\tpath += 'U'\n\tif b > 0:\n\t\tb -= 1\n\t\tpath += 'D'\n\tprint(path)\n",
        "c1 = input()\nc2 = input()\nx1 = ord(c1[0]) - ord('a')\ny1 = int(c1[1]) - 1\nx2 = ord(c2[0]) - ord('a')\ny2 = int(c2[1]) - 1\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\nprint(max(dx, dy))\nwhile x1 != x2 or y1 != y2:\n\ta = ''\n\tb = ''\n\tif x2 > x1:\n\t\ta = 'R'\n\t\tx1 = x1 + 1\n\telif x2 < x1:\n\t\ta = 'L'\n\t\tx1 = x1 - 1\n\tif y2 > y1:\n\t\tb = 'U'\n\t\ty1 = y1 + 1\n\telif y2 < y1:\n\t\tb = 'D'\n\t\ty1 = y1 - 1\n\tprint(a + b)\n",
        "s = input()\nt = input()\nletter = 'abcdefgh'\ns1 = letter.index(s[0])\nt1 = letter.index(t[0])\ns2 = int(s[1])\nt2 = int(t[1])\ni = 0\nwhile s1 != t1 or s2 != t2:\n\tlocals()['move' + str(i)] = ''\n\tif s1 < t1:\n\t\tlocals()['move' + str(i)] += 'R'\n\t\ts1 += 1\n\telif s1 > t1:\n\t\tlocals()['move' + str(i)] += 'L'\n\t\ts1 += -1\n\tif s2 < t2:\n\t\tlocals()['move' + str(i)] += 'U'\n\t\ts2 += 1\n\telif s2 > t2:\n\t\tlocals()['move' + str(i)] += 'D'\n\t\ts2 += -1\n\ti += 1\nprint(i)\nfor k in range(i):\n\tprint(locals()['move' + str(k)], end='\\n')\n",
        "line = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\na = str(input())\nb = str(input())\nx = line.index(list(a)[0]) - line.index(list(b)[0])\ny = int(a[1]) - int(b[1])\ni = 0\nj = 0\nk = 0\nif abs(x) < abs(y):\n\tk = 1\nprint(max(abs(x), abs(y)))\nwhile i < min(abs(x), abs(y)):\n\tif x > 0 and y > 0:\n\t\tprint('LD')\n\tif x < 0 and y > 0:\n\t\tprint('RD')\n\tif x > 0 and y < 0:\n\t\tprint('LU')\n\tif x < 0 and y < 0:\n\t\tprint('RU')\n\ti = i + 1\nwhile j < abs(abs(x) - abs(y)):\n\tif k == 1 and y < 0:\n\t\tprint('U')\n\tif k == 1 and y > 0:\n\t\tprint('D')\n\tif k == 0 and x < 0:\n\t\tprint('R')\n\tif k == 0 and x > 0:\n\t\tprint('L')\n\tj = j + 1\n",
        "s = input()\nd = input()\nsr = int(s[1])\nsc = ord(s[0]) - ord('a') + 1\ndr = int(d[1])\ndc = ord(d[0]) - ord('a') + 1\ncount = 0\nl = []\nwhile sr != dr or sc != dc:\n\tcount += 1\n\ts = ''\n\tif dc > sc:\n\t\tsc += 1\n\t\ts += 'R'\n\tif dc < sc:\n\t\tsc -= 1\n\t\ts += 'L'\n\tif dr > sr:\n\t\tsr += 1\n\t\ts += 'U'\n\tif dr < sr:\n\t\tsr -= 1\n\t\ts += 'D'\n\tl.append(s)\nprint(count)\nfor x in l:\n\tprint(x)\n",
        "s = input()\nt = input()\nps = [ord(s[0]) - 96, int(s[1])]\npt = [ord(t[0]) - 96, int(t[1])]\ntt = ps\npath = []\nc = 0\nwhile pt != tt:\n\tif tt[0] == pt[0]:\n\t\tif tt[1] < pt[1]:\n\t\t\ttt[1] = tt[1] + 1\n\t\t\tpath.append('U')\n\t\t\tc += 1\n\t\telif tt[1] > pt[1]:\n\t\t\ttt[1] = tt[1] - 1\n\t\t\tpath.append('D')\n\t\t\tc += 1\n\telif tt[1] == pt[1]:\n\t\tif tt[0] < pt[0]:\n\t\t\ttt[0] = tt[0] + 1\n\t\t\tpath.append('R')\n\t\t\tc += 1\n\t\telif tt[0] > pt[0]:\n\t\t\ttt[0] = tt[0] - 1\n\t\t\tpath.append('L')\n\t\t\tc += 1\n\telif tt[0] < pt[0] and tt[1] < pt[1]:\n\t\ttt[0] = tt[0] + 1\n\t\ttt[1] = tt[1] + 1\n\t\tpath.append('RU')\n\t\tc += 1\n\telif tt[0] < pt[0] and tt[1] > pt[1]:\n\t\ttt[0] = tt[0] + 1\n\t\ttt[1] = tt[1] - 1\n\t\tpath.append('RD')\n\t\tc += 1\n\telif tt[0] > pt[0] and tt[1] < pt[1]:\n\t\ttt[0] = tt[0] - 1\n\t\ttt[1] = tt[1] + 1\n\t\tpath.append('LU')\n\t\tc += 1\n\telif tt[0] > pt[0] and tt[1] > pt[1]:\n\t\ttt[0] = tt[0] - 1\n\t\ttt[1] = tt[1] - 1\n\t\tpath.append('LD')\n\t\tc += 1\nprint(c)\nfor i in range(c):\n\tprint(path[i])\n",
        "(s1, t1) = input()\nt1 = int(t1)\n(s2, t2) = input()\nt2 = int(t2)\nx = ord(s1) - ord(s2)\ny = t1 - t2\nn = max(abs(x), abs(y))\nprint(n)\nwhile x != 0 or y != 0:\n\tm = ''\n\tif x < 0:\n\t\tm = 'R'\n\t\tx += 1\n\telif x > 0:\n\t\tm = 'L'\n\t\tx -= 1\n\tif y > 0:\n\t\tm = m + 'D'\n\t\ty -= 1\n\telif y < 0:\n\t\tm = m + 'U'\n\t\ty += 1\n\tprint(m)\n",
        "d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ne = {(1, 1): 'LU', (-1, -1): 'RD', (-1, 1): 'RU', (1, -1): 'LD', (0, -1): 'L', (1, 0): 'D', (-1, 0): 'U', (0, 1): 'R'}\na = input()\nb = input()\ncoordX = d[b[0]] - d[a[0]]\ncoordY = 9 - int(b[1]) - (9 - int(a[1]))\nv1 = 0\nv2 = 0\nL = []\nwhile True:\n\tif coordX == 0 and coordY == 0:\n\t\tbreak\n\telse:\n\t\tif coordX == 0:\n\t\t\tv1 = 0\n\t\telif coordX < 0:\n\t\t\tv1 = 1\n\t\telse:\n\t\t\tv1 = -1\n\t\tif coordY == 0:\n\t\t\tv2 = 0\n\t\telif coordY < 0:\n\t\t\tv2 = 1\n\t\telse:\n\t\t\tv2 = -1\n\t\tif coordX == 0:\n\t\t\tL.append(e[-v2, 0])\n\t\telif coordY == 0:\n\t\t\tL.append(e[0, -v1])\n\t\telse:\n\t\t\tL.append(e[v1, v2])\n\t\tcoordX += v1\n\t\tcoordY += v2\nprint(len(L))\nprint('\\n'.join(L))\n",
        "import math, string, itertools, fractions, heapq, collections, re, array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef LI():\n\treturn [int(x) for x in sys.stdin.readline().split()]\n\ndef LI_():\n\treturn [int(x) - 1 for x in sys.stdin.readline().split()]\n\ndef LF():\n\treturn [float(x) for x in sys.stdin.readline().split()]\n\ndef LS():\n\treturn sys.stdin.readline().split()\n\ndef I():\n\treturn int(sys.stdin.readline())\n\ndef F():\n\treturn float(sys.stdin.readline())\n\ndef S():\n\treturn input()\n\ndef pf(s):\n\treturn print(s, flush=True)\n\ndef main():\n\ts = S()\n\tt = S()\n\ta = ord(t[0]) - ord(s[0])\n\tb = ord(t[1]) - ord(s[1])\n\tr = []\n\twhile a != 0 or b != 0:\n\t\tu = ''\n\t\tif a < 0:\n\t\t\tu += 'L'\n\t\t\ta += 1\n\t\telif a > 0:\n\t\t\tu += 'R'\n\t\t\ta -= 1\n\t\tif b < 0:\n\t\t\tu += 'D'\n\t\t\tb += 1\n\t\telif b > 0:\n\t\t\tu += 'U'\n\t\t\tb -= 1\n\t\tr.append(u)\n\treturn '{}\\n{}'.format(len(r), '\\n'.join(r))\nprint(main())\n",
        "s = list(input())\nt = input()\nans = []\nwhile ''.join(s) != t:\n\tcur = ''\n\tif s[0] < t[0]:\n\t\tcur = cur + 'R'\n\t\ts[0] = chr(ord(s[0]) + 1)\n\tif s[0] > t[0]:\n\t\tcur = cur + 'L'\n\t\ts[0] = chr(ord(s[0]) - 1)\n\tif s[1] < t[1]:\n\t\tcur = cur + 'U'\n\t\ts[1] = chr(ord(s[1]) + 1)\n\tif s[1] > t[1]:\n\t\tcur = cur + 'D'\n\t\ts[1] = chr(ord(s[1]) - 1)\n\tans += [cur]\nprint(len(ans))\nfor c in ans:\n\tprint(c)\n",
        "def readline():\n\ts = input()\n\treturn (ord(s[0]) - ord('a') + 1, int(s[1]))\n\ndef CF_3A():\n\t(x0, y0) = readline()\n\t(x1, y1) = readline()\n\tprint(max(abs(x1 - x0), abs(y1 - y0)))\n\twhile x0 != x1 or y0 != y1:\n\t\tif x0 == x1:\n\t\t\tif y0 > y1:\n\t\t\t\ty0 -= 1\n\t\t\t\tprint('D')\n\t\t\telse:\n\t\t\t\ty0 += 1\n\t\t\t\tprint('U')\n\t\telif y0 == y1:\n\t\t\tif x0 > x1:\n\t\t\t\tx0 -= 1\n\t\t\t\tprint('L')\n\t\t\telse:\n\t\t\t\tx0 += 1\n\t\t\t\tprint('R')\n\t\telif x0 > x1:\n\t\t\tif y0 > y1:\n\t\t\t\tx0 -= 1\n\t\t\t\ty0 -= 1\n\t\t\t\tprint('LD')\n\t\t\telse:\n\t\t\t\tx0 -= 1\n\t\t\t\ty0 += 1\n\t\t\t\tprint('LU')\n\t\telif y0 > y1:\n\t\t\tx0 += 1\n\t\t\ty0 -= 1\n\t\t\tprint('RD')\n\t\telse:\n\t\t\tx0 += 1\n\t\t\ty0 += 1\n\t\t\tprint('RU')\nCF_3A()\n",
        "(l1, n1) = list(input())\n(l2, n2) = list(input())\nans = []\ndiff1 = ord(l2) - ord(l1)\ndiff2 = ord(n2) - ord(n1)\nwhile diff1 != 0 and diff2 != 0:\n\tif diff1 > 0 and diff2 > 0:\n\t\tans.append('RU')\n\t\tdiff1 -= 1\n\t\tdiff2 -= 1\n\telif diff1 > 0 and diff2 < 0:\n\t\tans.append('RD')\n\t\tdiff1 -= 1\n\t\tdiff2 += 1\n\telif diff1 < 0 and diff2 > 0:\n\t\tans.append('LU')\n\t\tdiff1 += 1\n\t\tdiff2 -= 1\n\telif diff1 < 0 and diff2 < 0:\n\t\tans.append('LD')\n\t\tdiff1 += 1\n\t\tdiff2 += 1\nif diff1 > 0:\n\tfor i in range(diff1):\n\t\tans.append('R')\nelif diff1 < 0:\n\tfor i in range(diff1 * -1):\n\t\tans.append('L')\nelif diff2 > 0:\n\tfor i in range(diff2):\n\t\tans.append('U')\nelif diff2 < 0:\n\tfor i in range(diff2 * -1):\n\t\tans.append('D')\nprint(len(ans))\nfor i in ans:\n\tprint(i)\n",
        "s = input()\nt = input()\n(column, row) = (ord(s[0]) - ord(t[0]), ord(s[1]) - ord(t[1]))\nprint(max(column, -column, row, -row))\nwhile column != 0 or row != 0:\n\tstep = ''\n\tif column < 0:\n\t\tstep = 'R'\n\t\tcolumn += 1\n\tif column > 0:\n\t\tstep = 'L'\n\t\tcolumn -= 1\n\tif row < 0:\n\t\tstep += 'U'\n\t\trow += 1\n\tif row > 0:\n\t\tstep += 'D'\n\t\trow -= 1\n\tprint(step)\n",
        "v1 = list(input())\nv2 = list(input())\nuh = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n(x1, y1) = (uh.index(v1[0]), (int(v1[1]) - 8) * -1)\n(x2, y2) = (uh.index(v2[0]), (int(v2[1]) - 8) * -1)\nx = x2 - x1\ny = y2 - y1\nmaximo = max(abs(x), abs(y))\ndir_linea = ''\nif maximo == abs(x):\n\td = abs(y)\n\th = abs(abs(x) - abs(y))\n\tv = 0\n\tif x > 0:\n\t\tdir_linea = 'R'\n\tif x < 0:\n\t\tdir_linea = 'L'\nelse:\n\td = abs(x)\n\th = 0\n\tv = abs(abs(y) - abs(x))\n\tif y > 0:\n\t\tdir_linea = 'D'\n\tif y < 0:\n\t\tdir_linea = 'U'\ndir_diag = ''\nif x > 0 and y > 0:\n\tdir_diag = 'RD'\nif x < 0 and y > 0:\n\tdir_diag = 'LD'\nif x > 0 and y < 0:\n\tdir_diag = 'RU'\nif x < 0 and y < 0:\n\tdir_diag = 'LU'\nprint(d + h + v)\nfor _ in range(h):\n\tprint(dir_linea)\nfor _ in range(v):\n\tprint(dir_linea)\nfor _ in range(d):\n\tprint(dir_diag)\n",
        "inp = input()\ns = [ord(inp[0]) - ord('a'), ord(inp[1]) - ord('1')]\ninp = input()\nt = [ord(inp[0]) - ord('a'), ord(inp[1]) - ord('1')]\nprint(max(abs(s[0] - t[0]), abs(s[1] - t[1])))\nwhile s != t:\n\tlr = t[0] - s[0]\n\tud = t[1] - s[1]\n\tout = ''\n\tif lr > 0:\n\t\ts[0] += 1\n\t\tout += 'R'\n\telif lr < 0:\n\t\ts[0] -= 1\n\t\tout += 'L'\n\tif ud > 0:\n\t\ts[1] += 1\n\t\tout += 'U'\n\telif ud < 0:\n\t\ts[1] -= 1\n\t\tout += 'D'\n\tprint(out)\n",
        "(t1, t2) = (input(), input())\n(xs, ys, xt, yt) = (ord(t1[0]) - ord('a') + 1, int(t1[1]), ord(t2[0]) - ord('a') + 1, int(t2[1]))\nn = max(abs(xt - xs), abs(yt - ys))\nprint(n)\nfor i in range(n):\n\tif xs < xt:\n\t\tif ys > yt:\n\t\t\tprint('RD')\n\t\t\tys -= 1\n\t\telif ys < yt:\n\t\t\tprint('RU')\n\t\t\tys += 1\n\t\telse:\n\t\t\tprint('R')\n\t\txs += 1\n\telif xs > xt:\n\t\tif ys > yt:\n\t\t\tprint('LD')\n\t\t\tys -= 1\n\t\telif ys < yt:\n\t\t\tprint('LU')\n\t\t\tys += 1\n\t\telse:\n\t\t\tprint('L')\n\t\txs -= 1\n\telif xs == xt:\n\t\tif ys > yt:\n\t\t\tprint('D')\n\t\t\tys -= 1\n\t\telif ys < yt:\n\t\t\tprint('U')\n\t\t\tys += 1\n\t\telse:\n\t\t\tprint('L')\n",
        "def f(x, y, a, b, c):\n\treturn [a] * y + [b] * (x - y) if x > y else [a] * x + [c] * (y - x)\n(u, v) = (input(), input())\n(x, y) = (ord(v[0]) - ord(u[0]), int(v[1]) - int(u[1]))\nif x < 0:\n\tans = f(-x, -y, 'LD', 'L', 'D') if y < 0 else f(-x, y, 'LU', 'L', 'U')\nelse:\n\tans = f(x, -y, 'RD', 'R', 'D') if y < 0 else f(x, y, 'RU', 'R', 'U')\nprint(len(ans))\nprint('\\n'.join(ans))\n",
        "y_cor = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\na = input()\nb = input()\nx1 = y_cor[a[0]]\ny1 = int(a[1])\nx2 = y_cor[b[0]]\ny2 = int(b[1])\ns = ''\nc = 0\nwhile True:\n\tif [x1, y1] == [x2, y2]:\n\t\tbreak\n\tif x2 > x1:\n\t\tx1 += 1\n\t\ts += 'R'\n\tif x2 < x1:\n\t\tx2 += 1\n\t\ts += 'L'\n\tif y2 > y1:\n\t\ty1 += 1\n\t\ts += 'U'\n\tif y2 < y1:\n\t\ty2 += 1\n\t\ts += 'D'\n\ts += '\\n'\n\tc += 1\nprint(c)\nprint(s)\n",
        "s = input()\nt = input()\ndelta_col = ord(t[0]) - ord(s[0])\ndelta_row = int(t[1]) - int(s[1])\nnum_moves = min(abs(delta_col), abs(delta_row))\nif delta_col > 0:\n\tdelta_col -= num_moves\n\tif delta_row > 0:\n\t\tmoves_list = ['RU' for __ in range(num_moves)]\n\t\tdelta_row -= num_moves\n\telse:\n\t\tmoves_list = ['RD' for __ in range(num_moves)]\n\t\tdelta_row += num_moves\nelse:\n\tdelta_col += num_moves\n\tif delta_row > 0:\n\t\tmoves_list = ['LU' for __ in range(num_moves)]\n\t\tdelta_row -= num_moves\n\telse:\n\t\tmoves_list = ['LD' for __ in range(num_moves)]\n\t\tdelta_row += num_moves\nnum_rem_moves = max(abs(delta_col), abs(delta_row))\nnum_moves += num_rem_moves\nif delta_col > 0:\n\tmoves_list += ['R' for __ in range(num_rem_moves)]\nelif delta_col < 0:\n\tmoves_list += ['L' for __ in range(num_rem_moves)]\nelif delta_row > 0:\n\tmoves_list += ['U' for __ in range(num_rem_moves)]\nelif delta_row < 0:\n\tmoves_list += ['D' for __ in range(num_rem_moves)]\nprint(num_moves)\nprint(*moves_list, sep='\\n')\n",
        "s1 = input()\ns2 = input()\nRL = ord(s2[0]) - ord(s1[0])\nDU = int(s2[1]) - int(s1[1])\nlvl = max(abs(RL), abs(DU))\nprint(lvl)\nif RL > 0:\n\tR = True\nelse:\n\tR = False\nif DU > 0:\n\tU = True\nelse:\n\tU = False\nDU = abs(DU)\nRL = abs(RL)\nmn = min(RL, DU)\nif R == True and U == True:\n\tfor i in range(mn):\n\t\tprint('RU')\n\tif DU > RL:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('R')\nelif R == True and U == False:\n\tfor i in range(mn):\n\t\tprint('RD')\n\tif DU > RL:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('R')\nelif R == False and U == True:\n\tfor i in range(mn):\n\t\tprint('LU')\n\tif DU > RL:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('U')\n\telse:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('L')\nelse:\n\tfor i in range(mn):\n\t\tprint('LD')\n\tif DU > RL:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(lvl - mn):\n\t\t\tprint('L')\n",
        "rey = input('')\na = ord(rey[0]) - 96\nb = int(rey[1])\n(x, y) = input('')\nx = ord(x) - 96\ny = int(y)\nc = 0\nk = []\nwhile a != x or b != y:\n\tc += 1\n\tif b == y or x == a:\n\t\tif a < x:\n\t\t\ta += 1\n\t\t\tk.append('R')\n\t\telif a > x:\n\t\t\ta -= 1\n\t\t\tk.append('L')\n\t\tif b < y:\n\t\t\tb += 1\n\t\t\tk.append('U')\n\t\telif b > y:\n\t\t\tb -= 1\n\t\t\tk.append('D')\n\telse:\n\t\tif a < x and b < y:\n\t\t\ta += 1\n\t\t\tb += 1\n\t\t\tk.append('RU')\n\t\telif a < x and b > y:\n\t\t\ta += 1\n\t\t\tb -= 1\n\t\t\tk.append('RD')\n\t\tif a > x and b < y:\n\t\t\ta -= 1\n\t\t\tb += 1\n\t\t\tk.append('LU')\n\t\telif a > x and b > y:\n\t\t\ta -= 1\n\t\t\tb -= 1\n\t\t\tk.append('LD')\nprint(c)\nfor i in k:\n\tprint(i)\n",
        "s = input()\nt = input()\nmoves = []\n\ndef move(x, y):\n\tif x1 < x:\n\t\tif y1 < y:\n\t\t\tmoves.append('LU')\n\t\t\tx -= 1\n\t\t\ty -= 1\n\t\t\treturn (x, y, 2)\n\t\telif y1 == y:\n\t\t\tx -= 1\n\t\t\tmoves.append('L')\n\t\t\treturn (x, y, 1)\n\t\telif y1 > y:\n\t\t\tx -= 1\n\t\t\ty += 1\n\t\t\tmoves.append('LD')\n\t\t\treturn (x, y, 2)\n\telif x1 == x:\n\t\tif y1 < y:\n\t\t\ty -= 1\n\t\t\tmoves.append('U')\n\t\t\treturn (x, y, 1)\n\t\telif y1 == y:\n\t\t\treturn (x, y, 0)\n\t\telif y1 > y:\n\t\t\ty += 1\n\t\t\tmoves.append('D')\n\t\t\treturn (x, y, 1)\n\telif x1 > x:\n\t\tif y1 < y:\n\t\t\tx += 1\n\t\t\ty -= 1\n\t\t\tmoves.append('RU')\n\t\t\treturn (x, y, 2)\n\t\telif y1 == y:\n\t\t\tx += 1\n\t\t\tmoves.append('R')\n\t\t\treturn (x, y, 1)\n\t\telif y1 > y:\n\t\t\tx += 1\n\t\t\ty += 1\n\t\t\tmoves.append('RD')\n\t\t\treturn (x, y, 2)\nrow_names = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nx0 = int(row_names.index(s[0]))\ny0 = 8 - int(s[1])\nx1 = int(row_names.index(t[0]))\ny1 = 8 - int(t[1])\nprice = abs(x1 - x0) + abs(y1 - y0)\nn = 0\nx = x0\ny = y0\nwhile price > 0:\n\t(x, y, p) = move(x, y)\n\tprice -= p\n\tn += 1\nprint(n)\nlist(map(print, moves))\n",
        "def A():\n\tstart = convert(list(input()))\n\tend = convert(list(input()))\n\tmoves = []\n\tcount = 0\n\twhile start != end:\n\t\tmove = ''\n\t\tif start[0] < end[0]:\n\t\t\tmove += 'R'\n\t\t\tstart[0] += 1\n\t\telif start[0] > end[0]:\n\t\t\tmove += 'L'\n\t\t\tstart[0] -= 1\n\t\tif start[1] < end[1]:\n\t\t\tmove += 'U'\n\t\t\tstart[1] += 1\n\t\telif start[1] > end[1]:\n\t\t\tmove += 'D'\n\t\t\tstart[1] -= 1\n\t\tcount += 1\n\t\tmoves.append(move)\n\tprint(count)\n\tfor move in moves:\n\t\tprint(move)\n\ndef convert(input):\n\tfor i in range(0, 2):\n\t\ttemp = ord(input[i])\n\t\tif temp > ord('8'):\n\t\t\ttemp -= ord('a') - 1\n\t\telse:\n\t\t\ttemp -= ord('1') - 1\n\t\tinput[i] = temp\n\treturn input\nA()\n",
        "def fun(s):\n\tif s == 'a':\n\t\treturn 1\n\tif s == 'b':\n\t\treturn 2\n\tif s == 'c':\n\t\treturn 3\n\tif s == 'd':\n\t\treturn 4\n\tif s == 'e':\n\t\treturn 5\n\tif s == 'f':\n\t\treturn 6\n\tif s == 'g':\n\t\treturn 7\n\tif s == 'h':\n\t\treturn 8\nstr = input()\ny1 = int(str[1])\nx1 = int(fun(str[0]))\nstr = input()\ny2 = int(str[1])\nx2 = int(fun(str[0]))\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile True:\n\tif x1 == x2 and y1 == y2:\n\t\tbreak\n\tif x2 > x1:\n\t\tx1 += 1\n\t\tprint('R', end='')\n\tif x2 < x1:\n\t\tx1 -= 1\n\t\tprint('L', end='')\n\tif y2 > y1:\n\t\ty1 += 1\n\t\tprint('U', end='')\n\tif y2 < y1:\n\t\ty1 -= 1\n\t\tprint('D', end='')\n\tprint('')\n",
        "col = list('abcdefgh')\nbeg = list(input())\nend = list(input())\nbeg[0] = col.index(beg[0]) + 1\nbeg[1] = int(beg[1])\nend[0] = col.index(end[0]) + 1\nend[1] = int(end[1])\nprint(max(abs(beg[0] - end[0]), abs(beg[1] - end[1])))\nwhile True:\n\tif beg[0] == end[0] and beg[1] == end[1]:\n\t\tbreak\n\tif beg[0] > end[0]:\n\t\tprint('L', end='')\n\t\tbeg[0] -= 1\n\telif beg[0] < end[0]:\n\t\tprint('R', end='')\n\t\tbeg[0] += 1\n\tif beg[1] < end[1]:\n\t\tprint('U', end='')\n\t\tbeg[1] += 1\n\telif beg[1] > end[1]:\n\t\tprint('D', end='')\n\t\tbeg[1] -= 1\n\tprint('')\n",
        "def rank(x):\n\treturn ord(x) - 96\nline1 = input()\nline2 = input()\n(x1, y1) = (rank(line1[0]), int(line1[1]))\n(x2, y2) = (rank(line2[0]), int(line2[1]))\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nm1 = max(abs(x1 - x2), abs(y1 - y2))\nm2 = min(abs(x1 - x2), abs(y1 - y2))\nif x1 == x2 and y1 == y2:\n\tpass\nelif x1 > x2 and y1 == y2:\n\tfor i in range(x1 - x2):\n\t\tprint('L')\nelif x1 < x2 and y1 == y2:\n\tfor i in range(x2 - x1):\n\t\tprint('R')\nelif x1 == x2 and y1 > y2:\n\tfor i in range(y1 - y2):\n\t\tprint('D')\nelif x1 == x2 and y1 < y2:\n\tfor i in range(y2 - y1):\n\t\tprint('U')\nelif x1 > x2 and y1 > y2:\n\tfor i in range(m2):\n\t\tprint('LD')\n\tif x1 - x2 >= y1 - y2:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('L')\n\telse:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('D')\nelif x1 > x2 and y1 < y2:\n\tfor i in range(m2):\n\t\tprint('LU')\n\tif x1 - x2 >= y2 - y1:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('L')\n\telse:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('U')\nelif x1 < x2 and y1 > y2:\n\tfor i in range(m2):\n\t\tprint('RD')\n\tif x2 - x1 >= y1 - y2:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('R')\n\telse:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('D')\nelif x1 < x2 and y1 < y2:\n\tfor i in range(m2):\n\t\tprint('RU')\n\tif x2 - x1 >= y2 - y1:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('R')\n\telse:\n\t\tfor i in range(m1 - m2):\n\t\t\tprint('U')\n",
        "s = input()\nt = input()\n(cs, ct) = (ord(s[0]) - 96, ord(t[0]) - 96)\n(rs, rt) = (int(s[1]), int(t[1]))\nh = 0\nl = ''\nfor i in range(abs(cs - ct)):\n\th += 1\n\tif cs > ct and rs > rt:\n\t\tl += 'LD '\n\t\tcs -= 1\n\t\trs -= 1\n\telif cs > ct and rs < rt:\n\t\tl += 'LU '\n\t\tcs -= 1\n\t\trs += 1\n\telif cs > ct and rs == rt:\n\t\tl += 'L '\n\t\tcs -= 1\n\telif cs < ct and rs > rt:\n\t\tl += 'RD '\n\t\tcs += 1\n\t\trs -= 1\n\telif cs < ct and rs < rt:\n\t\tl += 'RU '\n\t\tcs += 1\n\t\trs += 1\n\telif cs < ct and rs == rt:\n\t\tl += 'R '\n\t\tcs += 1\nfor i in range(abs(rs - rt)):\n\th += 1\n\tif rs > rt:\n\t\tl += 'D '\n\t\trs -= 1\n\telif rs < rt:\n\t\tl += 'U '\n\t\trs += 1\nprint(h)\nl1 = l.split()\nfor i in range(len(l1)):\n\tprint(l1[i])\n",
        "s = input()\nd = input()\nS = 'abcdefgh'\nx = [S.index(s[0]) + 1, int(s[1])]\ny = [S.index(d[0]) + 1, int(d[1])]\nResults = []\nwhile x != y:\n\tif x[0] == y[0]:\n\t\tif x[1] > y[1]:\n\t\t\tResults.append('D\\n')\n\t\t\tx[1] -= 1\n\t\telse:\n\t\t\tResults.append('U\\n')\n\t\t\tx[1] += 1\n\telif x[0] > y[0]:\n\t\tif x[1] > y[1]:\n\t\t\tResults.append('LD\\n')\n\t\t\tx[0] -= 1\n\t\t\tx[1] -= 1\n\t\telif x[1] < y[1]:\n\t\t\tResults.append('LU\\n')\n\t\t\tx[1] += 1\n\t\t\tx[0] -= 1\n\t\telse:\n\t\t\tResults.append('L\\n')\n\t\t\tx[0] -= 1\n\telif x[1] > y[1]:\n\t\tResults.append('RD\\n')\n\t\tx[1] -= 1\n\t\tx[0] += 1\n\telif x[1] < y[1]:\n\t\tResults.append('RU\\n')\n\t\tx[1] += 1\n\t\tx[0] += 1\n\telse:\n\t\tResults.append('R\\n')\n\t\tx[0] += 1\nprint(len(Results))\nfor item in Results:\n\tprint(item, end='')\n",
        "s = input()\nt = input()\ndx = ord(t[0]) - ord(s[0])\ndy = ord(t[1]) - ord(s[1])\nprint(max(abs(dx), abs(dy)))\nwhile dx != 0 or dy != 0:\n\tcx = ''\n\tif dx > 0:\n\t\tdx -= 1\n\t\tcx = 'R'\n\telif dx < 0:\n\t\tdx += 1\n\t\tcx = 'L'\n\tif dy > 0:\n\t\tprint(cx + 'U')\n\t\tdy -= 1\n\telif dy == 0:\n\t\tprint(cx)\n\telse:\n\t\tprint(cx + 'D')\n\t\tdy += 1\n",
        "s = input()\nt = input()\ncnt = 0\nmoves = []\ni = 0\nwhile s != t:\n\tcnt += 1\n\tx = [s[0], s[1]]\n\tif s[0] > t[0] and s[1] < t[1]:\n\t\tx[0] = chr(ord(s[0]) - 1)\n\t\tx[1] = chr(ord(s[1]) + 1)\n\t\tmoves.append('LU')\n\telif s[0] > t[0] and s[1] > t[1]:\n\t\tx[0] = chr(ord(s[0]) - 1)\n\t\tx[1] = chr(ord(s[1]) - 1)\n\t\tmoves.append('LD')\n\telif s[0] < t[0] and s[1] > t[1]:\n\t\tx[0] = chr(ord(s[0]) + 1)\n\t\tx[1] = chr(ord(s[1]) - 1)\n\t\tmoves.append('RD')\n\telif s[0] < t[0] and s[1] < t[1]:\n\t\tx[0] = chr(ord(s[0]) + 1)\n\t\tx[1] = chr(ord(s[1]) + 1)\n\t\tmoves.append('RU')\n\telif s[0] < t[0]:\n\t\tx[0] = chr(ord(s[0]) + 1)\n\t\tmoves.append('R')\n\telif s[0] > t[0]:\n\t\tx[0] = chr(ord(s[0]) - 1)\n\t\tmoves.append('L')\n\telif s[1] > t[1]:\n\t\tx[1] = chr(ord(s[1]) - 1)\n\t\tmoves.append('D')\n\telse:\n\t\tx[1] = chr(ord(s[1]) + 1)\n\t\tmoves.append('U')\n\ts = ''\n\ts += x[0]\n\ts += x[1]\nprint(cnt)\nfor i in moves:\n\tprint(i)\n",
        "s = input()\nt = input()\ndx = ord(t[0]) - ord(s[0])\ndy = int(t[1]) - int(s[1])\nadx = abs(dx)\nady = abs(dy)\nm = ''\nfor i in range(max(adx, ady)):\n\ts = ''\n\tif i < adx:\n\t\tif dx > 0:\n\t\t\ts += 'R'\n\t\telif dx < 0:\n\t\t\ts += 'L'\n\tif i < ady:\n\t\tif dy > 0:\n\t\t\ts += 'U'\n\t\telif dy < 0:\n\t\t\ts += 'D'\n\tm += s\nm = m.replace('RD', 'K')\nm = m.replace('RU', 'M')\nm = m.replace('LD', 'X')\nm = m.replace('LU', 'N')\nn = len(m)\nM = ''\nfor i in range(n - 1):\n\tM += m[i] + '\\n'\nif n > 0:\n\tM += m[n - 1]\nM = M.replace('K', 'RD')\nM = M.replace('M', 'RU')\nM = M.replace('X', 'LD')\nM = M.replace('N', 'LU')\nprint(n)\nprint(M)\n",
        "s = input()\nt = input()\n(u, v) = (ord(s[0]) - ord(t[0]), ord(s[1]) - ord(t[1]))\nprint(max(u, -u, v, -v))\nwhile u != 0 or v != 0:\n\ta = ''\n\tif u < 0:\n\t\ta = 'R'\n\t\tu += 1\n\tif u > 0:\n\t\ta = 'L'\n\t\tu -= 1\n\tif v < 0:\n\t\ta += 'U'\n\t\tv += 1\n\tif v > 0:\n\t\ta += 'D'\n\t\tv -= 1\n\tprint(a)\n",
        "start = input()\nend = input()\nrl = ['L' if ord(start[0]) > ord(end[0]) else 'R'] * abs(ord(start[0]) - ord(end[0]))\nud = ['D' if ord(start[1]) > ord(end[1]) else 'U'] * abs(ord(start[1]) - ord(end[1]))\nprint(max(len(rl), len(ud)))\nfor n in range(max(len(rl), len(ud))):\n\tprint((rl[n] if len(rl) > n else '') + (ud[n] if len(ud) > n else ''))\n",
        "import string\nd = {a: i + 1 for (i, a) in enumerate(string.ascii_lowercase)}\ns = input()\nt = input()\n(x1, y1) = (d[s[0]], int(s[1]))\n(x2, y2) = (d[t[0]], int(t[1]))\na = x2 - x1\nb = y2 - y1\nmoves = max(abs(a), abs(b))\nprint(moves)\nif a >= 0 and b >= 0:\n\tif abs(a) > abs(b):\n\t\tprint('RU\\n' * abs(b) + 'R\\n' * (abs(a) - abs(b)))\n\telse:\n\t\tprint('RU\\n' * abs(a) + 'U\\n' * (abs(b) - abs(a)))\nelif a >= 0 and b < 0:\n\tif abs(a) > abs(b):\n\t\tprint('RD\\n' * abs(b) + 'R\\n' * (abs(a) - abs(b)))\n\telse:\n\t\tprint('RD\\n' * abs(a) + 'D\\n' * (abs(b) - abs(a)))\nelif a < 0 and b >= 0:\n\tif abs(a) > abs(b):\n\t\tprint('LU\\n' * abs(b) + 'L\\n' * (abs(a) - abs(b)))\n\telse:\n\t\tprint('LU\\n' * abs(a) + 'U\\n' * (abs(b) - abs(a)))\nelif abs(a) > abs(b):\n\tprint('LD\\n' * abs(b) + 'L\\n' * (abs(a) - abs(b)))\nelse:\n\tprint('LD\\n' * abs(a) + 'D\\n' * (abs(b) - abs(a)))\n",
        "(s, e) = (input(), input())\n(x1, y1, x2, y2) = (s[0], s[1], e[0], e[1])\nif x1 < x2:\n\txd = ord(x2) - ord(x1)\n\tif y1 < y2:\n\t\tyd = int(y2) - int(y1)\n\t\tif xd > yd:\n\t\t\tprint('%d\\n%s' % (xd, 'RU\\n' * yd + 'R\\n' * (xd - yd)))\n\t\telse:\n\t\t\tprint('%d\\n%s' % (yd, 'RU\\n' * xd + 'U\\n' * (yd - xd)))\n\telse:\n\t\tyd = int(y1) - int(y2)\n\t\tif xd > yd:\n\t\t\tprint('%d\\n%s' % (xd, 'RD\\n' * yd + 'R\\n' * (xd - yd)))\n\t\telse:\n\t\t\tprint('%d\\n%s' % (yd, 'RD\\n' * xd + 'D\\n' * (yd - xd)))\nelse:\n\txd = ord(x1) - ord(x2)\n\tif y1 < y2:\n\t\tyd = int(y2) - int(y1)\n\t\tif xd > yd:\n\t\t\tprint('%d\\n%s' % (xd, 'LU\\n' * yd + 'L\\n' * (xd - yd)))\n\t\telse:\n\t\t\tprint('%d\\n%s' % (yd, 'LU\\n' * xd + 'U\\n' * (yd - xd)))\n\telse:\n\t\tyd = int(y1) - int(y2)\n\t\tif xd > yd:\n\t\t\tprint('%d\\n%s' % (xd, 'LD\\n' * yd + 'L\\n' * (xd - yd)))\n\t\telse:\n\t\t\tprint('%d\\n%s' % (yd, 'LD\\n' * xd + 'D\\n' * (yd - xd)))\n",
        "c_p = input()\nr_p = input()\n\ndef R():\n\tglobal p\n\tp = p.replace(p[0], a[a.index(p[0]) + 1])\n\treturn p\n\ndef L():\n\tglobal p\n\tp = p.replace(p[0], a[a.index(p[0]) - 1])\n\treturn p\n\ndef U():\n\tglobal p\n\tp = p.replace(p[1], b[b.index(p[1]) + 1])\n\treturn p\n\ndef D():\n\tglobal p\n\tp = p.replace(p[1], b[b.index(p[1]) - 1])\n\treturn p\n\ndef LU():\n\tL()\n\tU()\n\ndef LD():\n\tL()\n\tD()\n\ndef RU():\n\tR()\n\tU()\n\ndef RD():\n\tR()\n\tD()\na = 'abcdefgh'\nb = '12345678'\nA = c_p[0]\nB = c_p[1]\np = c_p\nn = 0\nmoves = []\nif c_p == r_p:\n\tprint(0)\n\tquit()\nwhile p != r_p:\n\tif p[0] == r_p[0]:\n\t\tif b.index(p[1]) > b.index(r_p[1]):\n\t\t\twhile B != r_p[1]:\n\t\t\t\tD()\n\t\t\t\tmoves.append('D')\n\t\t\t\tn = n + 1\n\t\t\t\tB = p[1]\n\t\telif b.index(p[1]) < b.index(r_p[1]):\n\t\t\twhile B != r_p[1]:\n\t\t\t\tU()\n\t\t\t\tmoves.append('U')\n\t\t\t\tn = n + 1\n\t\t\t\tB = p[1]\n\telif p[1] == r_p[1]:\n\t\tif a.index(p[0]) > a.index(r_p[0]):\n\t\t\twhile A != r_p[0]:\n\t\t\t\tL()\n\t\t\t\tmoves.append('L')\n\t\t\t\tn = n + 1\n\t\t\t\tA = p[0]\n\t\telif a.index(p[0]) < a.index(r_p[0]):\n\t\t\twhile A != r_p[0]:\n\t\t\t\tR()\n\t\t\t\tmoves.append('R')\n\t\t\t\tn = n + 1\n\t\t\t\tA = p[0]\n\telif b.index(p[1]) > b.index(r_p[1]) and a.index(p[0]) > a.index(r_p[0]):\n\t\tLD()\n\t\tmoves.append('LD')\n\t\tn = n + 1\n\telif b.index(p[1]) > b.index(r_p[1]) and a.index(p[0]) < a.index(r_p[0]):\n\t\tRD()\n\t\tmoves.append('RD')\n\t\tn = n + 1\n\telif b.index(p[1]) < b.index(r_p[1]) and a.index(p[0]) > a.index(r_p[0]):\n\t\tLU()\n\t\tmoves.append('LU')\n\t\tn = n + 1\n\telif b.index(p[1]) < b.index(r_p[1]) and a.index(p[0]) < a.index(r_p[0]):\n\t\tRU()\n\t\tmoves.append('RU')\n\t\tn = n + 1\nprint(n)\nfor m in moves:\n\tprint(m)\n",
        "def sign(i):\n\tif i > 0:\n\t\treturn 1\n\telif i < 0:\n\t\treturn -1\n\telse:\n\t\treturn 0\n\ndef dirname(dir):\n\toutput = ''\n\tif dir[0] == 1:\n\t\toutput += 'R'\n\telif dir[0] == -1:\n\t\toutput += 'L'\n\tif dir[1] == 1:\n\t\toutput += 'U'\n\telif dir[1] == -1:\n\t\toutput += 'D'\n\treturn output\nalphabet = 'abcdefgh'\nstart = input().strip()\nstart = (alphabet.index(start[0]), int(start[1]) - 1)\nend = input().strip()\nend = (alphabet.index(end[0]), int(end[1]) - 1)\nxsteps = end[0] - start[0]\nysteps = end[1] - start[1]\nsteps = max(abs(xsteps), abs(ysteps))\ndiagonal = min(abs(xsteps), abs(ysteps))\ndirection = (sign(xsteps), sign(ysteps))\nprint(steps)\nfor i in range(diagonal):\n\tstart = (start[0] + direction[0], start[1] + direction[1])\n\tprint(dirname(direction))\nwhile start[0] != end[0]:\n\tstart = (start[0] + direction[0], start[1])\n\tprint(dirname((direction[0], 0)))\nwhile start[1] != end[1]:\n\tstart = (start[0], start[1] + direction[1])\n\tprint(dirname((0, direction[1])))\n",
        "position = list(input())\nend = list(input())\nposition[1] = int(position[1])\nend[1] = int(end[1])\nmoves = []\nwhile position != end:\n\tcurrent_move = ''\n\tif position[0] < end[0]:\n\t\tposition[0] = chr(ord(position[0]) + 1)\n\t\tcurrent_move += 'R'\n\telif position[0] > end[0]:\n\t\tposition[0] = chr(ord(position[0]) - 1)\n\t\tcurrent_move += 'L'\n\tif position[1] < end[1]:\n\t\tposition[1] += 1\n\t\tcurrent_move = current_move + 'U'\n\telif position[1] > end[1]:\n\t\tposition[1] -= 1\n\t\tcurrent_move = current_move + 'D'\n\tmoves.append(current_move)\nprint(len(moves))\nfor move in moves:\n\tprint(move)\n",
        "(x1, y1) = input()\n(x2, y2) = input()\n(y1, y2) = map(int, [y1, y2])\n(x1, x2) = map(ord, [x1, x2])\nx = abs(x1 - x2)\ny = abs(y1 - y2)\npath = max([x, y])\nprint(path)\nfor i in range(path):\n\tx0 = x1 - x2\n\ty0 = y1 - y2\n\tif x0 != 0 and y0 != 0:\n\t\tif x0 < 0 and y0 < 0:\n\t\t\tprint('RU')\n\t\t\tx1 += 1\n\t\t\ty1 += 1\n\t\telif x0 < 0 and y0 > 0:\n\t\t\tprint('RD')\n\t\t\tx1 += 1\n\t\t\ty1 -= 1\n\t\telif x0 > 0 and y0 < 0:\n\t\t\tprint('LU')\n\t\t\ty1 += 1\n\t\t\tx1 -= 1\n\t\telif x0 > 0 and y0 > 0:\n\t\t\tprint('LD')\n\t\t\ty1 -= 1\n\t\t\tx1 -= 1\n\telif x0 == 0 or y0 == 0:\n\t\tif x0 > 0:\n\t\t\tprint('L')\n\t\t\tx1 -= 1\n\t\telif x0 < 0:\n\t\t\tprint('R')\n\t\t\tx1 += 1\n\t\telif y0 > 0:\n\t\t\tprint('D')\n\t\t\ty1 -= 1\n\t\telif y0 < 0:\n\t\t\tprint('U')\n\t\t\ty1 += 1\n\telse:\n\t\tprint('No need for more')\n",
        "import sys\ninput = sys.stdin.readline\n\ndef inp():\n\treturn int(input())\n\ndef inlt():\n\treturn list(map(int, input().split()))\n\ndef insr():\n\ts = input()\n\treturn list(s[:len(s) - 1])\n\ndef invr():\n\treturn map(int, input().split())\n\ndef foo():\n\ts = insr()\n\t(s[0], s[1]) = (ord(s[0]), int(s[1]))\n\tt = insr()\n\t(t[0], t[1]) = (ord(t[0]), int(t[1]))\n\tcnt = 0\n\tad = []\n\twhile True:\n\t\tif s[0] == t[0] or s[1] == t[1]:\n\t\t\tbreak\n\t\tif t[0] - s[0] > 0 and t[1] - s[1] > 0:\n\t\t\tcnt += 1\n\t\t\tad.append('RU')\n\t\t\ts[0] += 1\n\t\t\ts[1] += 1\n\t\telif t[0] - s[0] > 0 and t[1] - s[1] < 0:\n\t\t\tcnt += 1\n\t\t\tad.append('RD')\n\t\t\ts[0] += 1\n\t\t\ts[1] -= 1\n\t\telif t[0] - s[0] < 0 and t[1] - s[1] > 0:\n\t\t\tcnt += 1\n\t\t\tad.append('LU')\n\t\t\ts[0] -= 1\n\t\t\ts[1] += 1\n\t\telse:\n\t\t\tcnt += 1\n\t\t\tad.append('LD')\n\t\t\ts[0] -= 1\n\t\t\ts[1] -= 1\n\twhile True:\n\t\tif s[0] == t[0] and s[1] == t[1]:\n\t\t\tbreak\n\t\tif t[1] - s[1] > 0:\n\t\t\tcnt += 1\n\t\t\tad.append('U')\n\t\t\ts[1] += 1\n\t\telif t[1] - s[1] < 0:\n\t\t\tcnt += 1\n\t\t\tad.append('D')\n\t\t\ts[1] -= 1\n\t\telif t[0] - s[0] > 0:\n\t\t\tcnt += 1\n\t\t\tad.append('R')\n\t\t\ts[0] += 1\n\t\telse:\n\t\t\tcnt += 1\n\t\t\tad.append('L')\n\t\t\ts[0] -= 1\n\tprint(len(ad))\n\tfor item in ad:\n\t\tprint(item)\nfoo()\n",
        "import sys\n\ndef moves_route(moves_no, x_axis_moves, y_axis_moves):\n\tmoves = []\n\tfor _ in range(moves_no):\n\t\tif x_axis_moves > 0:\n\t\t\tmoves.append('R')\n\t\t\tx_axis_moves -= 1\n\t\telif x_axis_moves < 0:\n\t\t\tmoves.append('L')\n\t\t\tx_axis_moves += 1\n\t\tif y_axis_moves > 0:\n\t\t\tmoves.append('U')\n\t\t\ty_axis_moves -= 1\n\t\telif y_axis_moves < 0:\n\t\t\tmoves.append('D')\n\t\t\ty_axis_moves += 1\n\t\tmoves.append('\\n')\n\treturn moves\n\ndef main(sinp=sys.stdin, sout=sys.stdout):\n\t(start, end) = sinp.read().split()\n\tletter_coords = 'abcdefgh'\n\tletter_to_num = {letter_coords[i]: i for i in range(len(letter_coords))}\n\ty_axis_moves = int(end[1]) - int(start[1])\n\tx_axis_moves = letter_to_num[end[0]] - letter_to_num[start[0]]\n\tmoves_no = max(abs(x_axis_moves), abs(y_axis_moves))\n\tsout.write(str(moves_no) + '\\n')\n\tsout.write(''.join(moves_route(moves_no, x_axis_moves, y_axis_moves)))\nmain()\n",
        "(s1, s2, ans) = (list(input()), input(), [])\nwhile ''.join(s1) != s2:\n\tif s1[1] == s2[1]:\n\t\tif s1[0] > s2[0]:\n\t\t\tans.append('L')\n\t\t\ts1[0] = chr(ord(s1[0]) - 1)\n\t\telse:\n\t\t\tans.append('R')\n\t\t\ts1[0] = chr(ord(s1[0]) + 1)\n\telif s1[0] == s2[0]:\n\t\tif int(s1[1]) > int(s2[1]):\n\t\t\tans.append('D')\n\t\t\ts1[1] = str(int(s1[1]) - 1)\n\t\telse:\n\t\t\tans.append('U')\n\t\t\ts1[1] = str(int(s1[1]) + 1)\n\telse:\n\t\ttem = ''\n\t\tif s1[0] > s2[0]:\n\t\t\ttem += 'L'\n\t\t\ts1[0] = chr(ord(s1[0]) - 1)\n\t\telse:\n\t\t\ttem += 'R'\n\t\t\ts1[0] = chr(ord(s1[0]) + 1)\n\t\tif int(s1[1]) > int(s2[1]):\n\t\t\ttem += 'D'\n\t\t\ts1[1] = str(int(s1[1]) - 1)\n\t\telse:\n\t\t\ttem += 'U'\n\t\t\ts1[1] = str(int(s1[1]) + 1)\n\t\tans.append(tem)\nprint(len(ans))\nprint(*ans, sep='\\n')\n",
        "def main():\n\n\tdef sign(x):\n\t\treturn 1 if x > 0 else -1\n\ts = input()\n\tx0 = ord(s[0]) - ord('a')\n\ty0 = int(s[1])\n\tt = input()\n\tx1 = ord(t[0]) - ord('a')\n\ty1 = int(t[1])\n\tans = []\n\twhile x0 != x1 and y0 != y1:\n\t\tans.append('LR'[x0 < x1] + 'DU'[y0 < y1])\n\t\tx0 += sign(x1 - x0)\n\t\ty0 += sign(y1 - y0)\n\twhile x0 != x1:\n\t\tans.append('LR'[x0 < x1])\n\t\tx0 += sign(x1 - x0)\n\twhile y0 != y1:\n\t\tans.append('DU'[y0 < y1])\n\t\ty0 += sign(y1 - y0)\n\tprint(len(ans))\n\tprint('\\n'.join(ans))\nimport sys, io, os\nBUFSIZE = 8192\n\nclass FastIO(io.IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = io.BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(io.IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\tfor x in args:\n\t\tfile.write(str(x))\n\tfile.write(kwargs.pop('end', '\\n'))\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninputt = lambda t=0: range(t) if t else range(int(input()))\ninputi = lambda : map(int, input().split())\ninputl = lambda : list(inputi())\nfrom math import *\nfrom heapq import *\nfrom bisect import *\nfrom itertools import *\nfrom functools import reduce, lru_cache\nfrom collections import Counter, defaultdict\nimport re, copy, operator, cmath\nfrom builtins import *\nmain()\n",
        "s = input()\nt = input()\nsteps = 0\nmoves = []\nrow_dist = int(t[1]) - int(s[1])\ncol_dist = ord(t[0]) - ord(s[0])\nwhile row_dist != 0 or col_dist != 0:\n\tif abs(row_dist) > abs(col_dist):\n\t\tif row_dist > 0:\n\t\t\tmoves.append('U')\n\t\t\tsteps += 1\n\t\t\trow_dist -= 1\n\t\telif row_dist < 0:\n\t\t\tmoves.append('D')\n\t\t\tsteps += 1\n\t\t\trow_dist += 1\n\t\telse:\n\t\t\tbreak\n\telif abs(row_dist) < abs(col_dist):\n\t\tif col_dist > 0:\n\t\t\tmoves.append('R')\n\t\t\tsteps += 1\n\t\t\tcol_dist -= 1\n\t\telif col_dist < 0:\n\t\t\tmoves.append('L')\n\t\t\tsteps += 1\n\t\t\tcol_dist += 1\n\t\telse:\n\t\t\tbreak\n\telif abs(row_dist) == abs(col_dist):\n\t\tfor i in range(abs(col_dist)):\n\t\t\tif col_dist > 0 and row_dist > 0:\n\t\t\t\tmoves.append('RU')\n\t\t\t\tsteps += 1\n\t\t\t\tcol_dist -= 1\n\t\t\t\trow_dist -= 1\n\t\t\telif col_dist > 0 and row_dist < 0:\n\t\t\t\tmoves.append('RD')\n\t\t\t\tsteps += 1\n\t\t\t\tcol_dist -= 1\n\t\t\t\trow_dist += 1\n\t\t\telif col_dist < 0 and row_dist > 0:\n\t\t\t\tmoves.append('LU')\n\t\t\t\tsteps += 1\n\t\t\t\tcol_dist += 1\n\t\t\t\trow_dist -= 1\n\t\t\telif col_dist < 0 and row_dist < 0:\n\t\t\t\tmoves.append('LD')\n\t\t\t\tsteps += 1\n\t\t\t\tcol_dist += 1\n\t\t\t\trow_dist += 1\nprint(steps)\nfor i in moves:\n\tprint(i)\n",
        "mode = 'filadasde'\nif mode == 'file':\n\tf = open('test.txt', 'r')\ng = []\nif mode == 'file':\n\tfirst = list(f.readline())[:-1]\n\tsecond = list(f.readline())\nelse:\n\tfirst = list(input())\n\tsecond = list(input())\nwhile first != second:\n\thorizontal = ''\n\tvertical = ''\n\tif first[0] < second[0]:\n\t\tfirst[0] = chr(ord(first[0]) + 1)\n\t\thorizontal = 'R'\n\telif first[0] > second[0]:\n\t\tfirst[0] = chr(ord(first[0]) - 1)\n\t\thorizontal = 'L'\n\tif first[1] < second[1]:\n\t\tfirst[1] = chr(ord(first[1]) + 1)\n\t\tvertical = 'U'\n\telif first[1] > second[1]:\n\t\tfirst[1] = chr(ord(first[1]) - 1)\n\t\tvertical = 'D'\n\tg.append([horizontal, vertical])\nprint(len(g))\nfor i in g:\n\tprint('{0}{1}'.format(i[0], i[1]))\nif mode == 'file':\n\tf.close()\n",
        "def checkPath(row, col):\n\tli = []\n\tif row - 1 >= 0 and (not ar[row - 1][col]):\n\t\tar[row - 1][col] = ar[row][col] + 1\n\t\tli.append([row - 1, col])\n\tif col - 1 >= 0 and (not ar[row][col - 1]):\n\t\tar[row][col - 1] = ar[row][col] + 1\n\t\tli.append([row, col - 1])\n\tif row + 1 < 8 and (not ar[row + 1][col]):\n\t\tar[row + 1][col] = ar[row][col] + 1\n\t\tli.append([row + 1, col])\n\tif col + 1 < 8 and (not ar[row][col + 1]):\n\t\tar[row][col + 1] = ar[row][col] + 1\n\t\tli.append([row, col + 1])\n\tif row - 1 >= 0 and col - 1 >= 0 and (not ar[row - 1][col - 1]):\n\t\tar[row - 1][col - 1] = ar[row][col] + 1\n\t\tli.append([row - 1, col - 1])\n\tif row - 1 >= 0 and col + 1 < 8 and (not ar[row - 1][col + 1]):\n\t\tar[row - 1][col + 1] = ar[row][col] + 1\n\t\tli.append([row - 1, col + 1])\n\tif row + 1 < 8 and col + 1 < 8 and (not ar[row + 1][col + 1]):\n\t\tar[row + 1][col + 1] = ar[row][col] + 1\n\t\tli.append([row + 1, col + 1])\n\tif row + 1 < 8 and col - 1 >= 0 and (not ar[row + 1][col - 1]):\n\t\tar[row + 1][col - 1] = ar[row][col] + 1\n\t\tli.append([row + 1, col - 1])\n\treturn li\nar = [[0] * 8 for _ in range(8)]\n(startp, startq) = list(input().strip())\nstartx = ord('8') - ord(startq)\nstarty = ord(startp) - ord('a')\n(endp, endq) = list(input().strip())\nendx = ord('8') - ord(endq)\nendy = ord(endp) - ord('a')\nar[startx][starty] = 1\nli = checkPath(startx, starty)\nwhile li:\n\tt = []\n\tfor (m, n) in li:\n\t\tif (m, n) == (endx, endy):\n\t\t\tt = []\n\t\t\tbreak\n\t\tt.extend(checkPath(m, n))\n\tli = t\nprint(ar[endx][endy] - 1)\nli = []\nidx = ar[endx][endy]\n(row, col) = (endx, endy)\nwhile idx:\n\tidx -= 1\n\tif row - 1 >= 0 and ar[row - 1][col] == idx:\n\t\tli.append('D')\n\t\trow -= 1\n\t\tcontinue\n\tif col - 1 >= 0 and ar[row][col - 1] == idx:\n\t\tli.append('R')\n\t\tcol -= 1\n\t\tcontinue\n\tif row + 1 < 8 and ar[row + 1][col] == idx:\n\t\tli.append('U')\n\t\trow += 1\n\t\tcontinue\n\tif col + 1 < 8 and ar[row][col + 1] == idx:\n\t\tli.append('L')\n\t\tcol += 1\n\t\tcontinue\n\tif row - 1 >= 0 and col - 1 >= 0 and (ar[row - 1][col - 1] == idx):\n\t\tli.append('RD')\n\t\trow -= 1\n\t\tcol -= 1\n\t\tcontinue\n\tif row - 1 >= 0 and col + 1 < 8 and (ar[row - 1][col + 1] == idx):\n\t\tli.append('LD')\n\t\trow -= 1\n\t\tcol += 1\n\t\tcontinue\n\tif row + 1 < 8 and col + 1 < 8 and (ar[row + 1][col + 1] == idx):\n\t\tli.append('LU')\n\t\trow += 1\n\t\tcol += 1\n\t\tcontinue\n\tif row + 1 < 8 and col - 1 >= 0 and (ar[row + 1][col - 1] == idx):\n\t\tli.append('RU')\n\t\trow += 1\n\t\tcol -= 1\n\t\tcontinue\nli.reverse()\nfor item in li:\n\tprint(item)\n",
        "n = input()\nm = input()\nxi = n[0]\nyi = int(n[1])\nxf = m[0]\nyf = int(m[1])\nsol = []\nwhile xi != xf or yi != yf:\n\tok = 0\n\tif xi < xf:\n\t\tsol.append('R')\n\t\txi = chr(ord(xi) + 1)\n\t\tok = 1\n\telif xi > xf:\n\t\tsol.append('L')\n\t\txi = chr(ord(xi) - 1)\n\t\tok = 1\n\tif yi < yf:\n\t\tif ok:\n\t\t\tsol[len(sol) - 1] += 'U'\n\t\telse:\n\t\t\tsol.append('U')\n\t\tyi += 1\n\telif yi > yf:\n\t\tif ok:\n\t\t\tsol[len(sol) - 1] += 'D'\n\t\telse:\n\t\t\tsol.append('D')\n\t\tyi -= 1\nprint(len(sol))\nfor i in range(len(sol)):\n\tprint(sol[i])\n",
        "s = input()\nt = input()\nd_x = ord(s[0]) - ord(t[0])\nd_y = ord(s[1]) - ord(t[1])\nprint(max(abs(d_x), abs(d_y)))\npath = []\nwhile abs(d_x):\n\tif d_x < 0:\n\t\tpath.append('R')\n\t\td_x += 1\n\telif d_x > 0:\n\t\tpath.append('L')\n\t\td_x -= 1\nstep = 0\nwhile abs(d_y) and step < max(abs(d_x), abs(d_y)):\n\tif d_y < 0:\n\t\ttry:\n\t\t\tpath[step] += 'U'\n\t\texcept:\n\t\t\tpath.append('U')\n\telif d_y > 0:\n\t\ttry:\n\t\t\tpath[step] += 'D'\n\t\texcept:\n\t\t\tpath.append('D')\n\tstep += 1\nfor step in path:\n\tprint(step)\n",
        "s = input()\ne = input()\nc = s\nsteps = []\nwhile c != e:\n\tnc = ''\n\tns = ''\n\tif c[0] < e[0]:\n\t\tns = 'R'\n\t\tnc = chr(ord(c[0]) + 1)\n\telif c[0] > e[0]:\n\t\tns = 'L'\n\t\tnc = chr(ord(c[0]) - 1)\n\telse:\n\t\tnc = e[0]\n\tif c[1] < e[1]:\n\t\tns += 'U'\n\t\tnc += str(int(c[1]) + 1)\n\telif c[1] > e[1]:\n\t\tns += 'D'\n\t\tnc += str(int(c[1]) - 1)\n\telse:\n\t\tnc += e[1]\n\tsteps.append(ns)\n\tc = nc\nprint(len(steps))\nfor step in steps:\n\tprint(step)\n",
        "start = input()\nend = input()\nx1 = ord(start[0]) - ord('a') + 1\ny1 = eval(start[1])\nx2 = ord(end[0]) - ord('a') + 1\ny2 = eval(end[1])\nsteps = max(abs(x1 - x2), abs(y1 - y2))\nprint(steps)\nwhile x1 != x2 or y1 != y2:\n\tif x1 < x2:\n\t\tprint('R', end='')\n\t\tx1 += 1\n\telif x1 > x2:\n\t\tprint('L', end='')\n\t\tx1 -= 1\n\tif y1 < y2:\n\t\tprint('U')\n\t\ty1 += 1\n\telif y1 > y2:\n\t\tprint('D')\n\t\ty1 -= 1\n\telif y1 == y2:\n\t\tprint()\n",
        "origin = input()\ndestination = input()\nx = ord(destination[0]) - ord(origin[0])\ny = ord(destination[1]) - ord(origin[1])\nprint(max(abs(x), abs(y)))\nwhile x != 0 or y != 0:\n\t(line, x) = ('L', x + 1) if x < 0 else ('R', x - 1) if x > 0 else ('', x)\n\t(line, y) = (line + 'D', y + 1) if y < 0 else (line + 'U', y - 1) if y > 0 else (line, y)\n\tprint(line)\n",
        "s = list(str(input()))\nt = list(str(input()))\nrefer = 'abcdefgh'\nr = [refer.index(s[0]) - refer.index(t[0]), int(s[1]) - int(t[1])]\nh_line = list()\nv_line = list()\nif r[0] > 0:\n\th_line = ['L'] * abs(r[0])\nelse:\n\th_line = ['R'] * abs(r[0])\nif r[1] > 0:\n\tv_line = ['D'] * abs(r[1])\nelse:\n\tv_line = ['U'] * abs(r[1])\nr_line = list()\nh_size = len(h_line)\nv_size = len(v_line)\nfor i in range(min(h_size, v_size)):\n\tr_line.append(h_line[i] + v_line[i])\nif h_size > v_size:\n\tr_line.extend(h_line[v_size:])\nelse:\n\tr_line.extend(v_line[h_size:])\nprint(max(h_size, v_size))\nprint('\\n'.join(r_line))\n",
        "s = input()\nt = input()\n(s1, s2) = (ord(s[0]), int(s[1]))\n(t1, t2) = (ord(t[0]), int(t[1]))\nnum1 = t1 - s1\nnum2 = t2 - s2\nnum = max(abs(num1), abs(num2))\nprint(num)\nfor i in range(num):\n\tscr = ''\n\tif num1 > 0:\n\t\tscr += 'R'\n\t\tnum1 -= 1\n\telif num1 < 0:\n\t\tscr += 'L'\n\t\tnum1 += 1\n\tif num2 > 0:\n\t\tscr += 'U'\n\t\tnum2 -= 1\n\telif num2 < 0:\n\t\tscr += 'D'\n\t\tnum2 += 1\n\tprint(scr)\n",
        "a = input()\nb = input()\nx1 = ord(a[0])\nx2 = ord(b[0])\ndisx = abs(x2 - x1)\nif x1 > x2:\n\txj = 'L'\nelif x2 > x1:\n\txj = 'R'\nelse:\n\txj = 'no'\ny1 = int(a[1])\ny2 = int(b[1])\nif y2 > y1:\n\tyj = 'U'\nelif y1 > y2:\n\tyj = 'D'\nelse:\n\tyj = 'no'\ndisy = abs(y2 - y1)\ng = min(disy, disx)\nprint(-g + disx + disy)\nfor i in range(g):\n\tprint(xj + yj)\ndisx -= g\ndisy -= g\nfor i in range(disx):\n\tprint(xj)\nfor i in range(disy):\n\tprint(yj)\n",
        "def main():\n\t(a, b) = (input(), input())\n\ta = (ord(a[0]) - ord('a'), int(a[1]) - 1)\n\tb = (ord(b[0]) - ord('a'), int(b[1]) - 1)\n\tans = []\n\twhile a != b:\n\t\tif a[0] < b[0] and a[1] < b[1]:\n\t\t\tans.append('RU')\n\t\t\ta = (a[0] + 1, a[1] + 1)\n\t\telif a[0] < b[0] and a[1] > b[1]:\n\t\t\tans.append('RD')\n\t\t\ta = (a[0] + 1, a[1] - 1)\n\t\telif a[0] < b[0] and a[1] == b[1]:\n\t\t\tans.append('R')\n\t\t\ta = (a[0] + 1, a[1])\n\t\telif a[0] > b[0] and a[1] < b[1]:\n\t\t\tans.append('LU')\n\t\t\ta = (a[0] - 1, a[1] + 1)\n\t\telif a[0] > b[0] and a[1] > b[1]:\n\t\t\tans.append('LD')\n\t\t\ta = (a[0] - 1, a[1] - 1)\n\t\telif a[0] > b[0] and a[1] == b[1]:\n\t\t\tans.append('L')\n\t\t\ta = (a[0] - 1, a[1])\n\t\telif a[0] == b[0] and a[1] < b[1]:\n\t\t\tans.append('U')\n\t\t\ta = (a[0], a[1] + 1)\n\t\telif a[0] == b[0] and a[1] > b[1]:\n\t\t\tans.append('D')\n\t\t\ta = (a[0], a[1] - 1)\n\tprint(len(ans))\n\tprint('\\n'.join(ans))\nmain()\n",
        "import sys\n(fs, rs) = list(sys.stdin.readline().rstrip())\n(fe, re) = list(sys.stdin.readline().rstrip())\nfs = ord(fs) - ord('a')\nfe = ord(fe) - ord('a')\n(rs, re) = (int(rs), int(re))\nd = max(abs(fs - fe), abs(rs - re))\nprint(d)\nwhile re - rs != 0 and fe - fs != 0:\n\tif re > rs:\n\t\tif fe > fs:\n\t\t\tprint('RU')\n\t\t\trs += 1\n\t\t\tfs += 1\n\t\telse:\n\t\t\tprint('LU')\n\t\t\trs += 1\n\t\t\tfs -= 1\n\telif fe > fs:\n\t\tprint('RD')\n\t\trs -= 1\n\t\tfs += 1\n\telse:\n\t\tprint('LD')\n\t\trs -= 1\n\t\tfs -= 1\nwhile re != rs or fe != fs:\n\tif re == rs:\n\t\tif fe > fs:\n\t\t\tprint('R')\n\t\t\tfs += 1\n\t\telse:\n\t\t\tprint('L')\n\t\t\tfs -= 1\n\telif re > rs:\n\t\tprint('U')\n\t\trs += 1\n\telse:\n\t\tprint('D')\n\t\trs -= 1\n",
        "s = input()\nt = input()\n\ndef str_to_nmb(argument):\n\tswitcher = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\treturn switcher.get(argument, 'nothing')\ns = [str_to_nmb(s[0]), int(s[1])]\nt = [str_to_nmb(t[0]), int(t[1])]\ncount = 0\nlst = []\nwhile s != t:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\tif s[0] > t[0] and s[1] > t[1]:\n\t\t\ts[0] -= 1\n\t\t\ts[1] -= 1\n\t\t\tlst.append('LD')\n\t\tif s[0] > t[0] and s[1] < t[1]:\n\t\t\ts[0] -= 1\n\t\t\ts[1] += 1\n\t\t\tlst.append('LU')\n\t\tif s[0] < t[0] and s[1] > t[1]:\n\t\t\ts[0] += 1\n\t\t\ts[1] -= 1\n\t\t\tlst.append('RD')\n\t\tif s[0] < t[0] and s[1] < t[1]:\n\t\t\ts[0] += 1\n\t\t\ts[1] += 1\n\t\t\tlst.append('RU')\n\t\tcount += 1\n\tif s[0] == t[0]:\n\t\tif s[1] > t[1]:\n\t\t\ts[1] -= 1\n\t\t\tcount += 1\n\t\t\tlst.append('D')\n\t\telif s[1] < t[1]:\n\t\t\ts[1] += 1\n\t\t\tcount += 1\n\t\t\tlst.append('U')\n\t\telse:\n\t\t\tbreak\n\tif s[1] == t[1]:\n\t\tif s[0] > t[0]:\n\t\t\ts[0] -= 1\n\t\t\tcount += 1\n\t\t\tlst.append('L')\n\t\telif s[0] < t[0]:\n\t\t\ts[0] += 1\n\t\t\tcount += 1\n\t\t\tlst.append('R')\n\t\telse:\n\t\t\tbreak\nprint(count)\nprint('\\n'.join(lst))\n",
        "line = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ns = str(input())\nw = str(input())\nx = int(line.index(list(s)[0]))\ny = int(line.index(list(w)[0]))\na = int(list(s)[1])\nb = int(list(w)[1])\nz = abs(x - y)\np = abs(a - b)\nprint(max(z, p))\nif z > p and z != 0:\n\tif x > y:\n\t\tif a > b:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('LD')\n\t\t\tfor i in range(z - p):\n\t\t\t\tprint('L')\n\t\telif a < b:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('LU')\n\t\t\tfor i in range(z - p):\n\t\t\t\tprint('L')\n\t\telse:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('L')\n\telif x < y:\n\t\tif a > b:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('RD')\n\t\t\tfor i in range(z - p):\n\t\t\t\tprint('R')\n\t\telif a < b:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('RU')\n\t\t\tfor i in range(z - p):\n\t\t\t\tprint('R')\n\t\telse:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('R')\nif z < p and p != 0:\n\tif a > b:\n\t\tif x > y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('LD')\n\t\t\tfor i in range(p - z):\n\t\t\t\tprint('D')\n\t\telif x < y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('RD')\n\t\t\tfor i in range(p - z):\n\t\t\t\tprint('D')\n\t\telse:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('R')\n\tif a < b:\n\t\tif x > y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('LU')\n\t\t\tfor i in range(p - z):\n\t\t\t\tprint('U')\n\t\telif x < y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('RU')\n\t\t\tfor i in range(p - z):\n\t\t\t\tprint('U')\n\t\telse:\n\t\t\tfor i in range(p):\n\t\t\t\tprint('U')\nif z == p and z != 0:\n\tif a < b:\n\t\tif x > y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('LU')\n\t\tif x < y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('RU')\n\tif a > b:\n\t\tif x > y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('LD')\n\t\tif x < y:\n\t\t\tfor i in range(z):\n\t\t\t\tprint('RD')\n",
        "from queue import Queue\noffset = (('L', 0, -1), ('R', 0, 1), ('U', 1, 0), ('D', -1, 0), ('LU', 1, -1), ('LD', -1, -1), ('RU', 1, 1), ('RD', -1, 1))\n\ndef possible(i, j):\n\treturn 0 <= i < 8 and 0 <= j < 8\n\ndef bfs(s, t):\n\tqueue = Queue()\n\ts = (int(s[1]) - 1, ord(s[0]) - 97, [])\n\t(ti, tj) = (int(t[1]) - 1, ord(t[0]) - 97)\n\tqueue.put(s)\n\tvisited = [[False] * 8 for _ in range(8)]\n\twhile True:\n\t\t(i, j, path) = queue.get()\n\t\tif i == ti and j == tj:\n\t\t\treturn (len(path), path)\n\t\tvisited[i][j] = True\n\t\tfor (direction, di, dj) in offset:\n\t\t\tnewi = i + di\n\t\t\tnewj = j + dj\n\t\t\tif possible(newi, newj) and (not visited[newi][newj]):\n\t\t\t\tqueue.put((newi, newj, path + [direction]))\n\ndef main():\n\ts = input()\n\tt = input()\n\t(n, path) = bfs(s, t)\n\tprint(n)\n\tprint(*path, sep='\\n')\nmain()\n",
        "l = list(input())\n(s, p) = (l[0], l[1])\np = int(p)\nl = list(input())\n(t, q) = (l[0], l[1])\nq = int(q)\nx = abs(ord(s) - ord(t))\ny = abs(p - q)\nif x > y:\n\tn = x - y\n\tm = y\n\tif ord(t) > ord(s):\n\t\tg = 'R'\n\telse:\n\t\tg = 'L'\n\tif p > q:\n\t\th = 'D'\n\telse:\n\t\th = 'U'\nelse:\n\tn = y - x\n\tm = x\n\tif p > q:\n\t\tg = 'D'\n\telse:\n\t\tg = 'U'\n\tif ord(t) > ord(s):\n\t\th = 'R'\n\telse:\n\t\th = 'L'\nprint(n + m)\nif h + g == 'LU' or h + g == 'LD' or h + g == 'RU' or (h + g == 'RD'):\n\tfor i in range(n):\n\t\tprint(g)\n\tfor i in range(m):\n\t\tprint(h + g)\nelse:\n\tfor i in range(m):\n\t\tprint(g + h)\n\tfor i in range(n):\n\t\tprint(g)\n",
        "arr_row = ['0', '8', '7', '6', '5', '4', '3', '2', '1']\narr_col = ['0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nvectors = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, -1], [-1, 1], [1, -1]]\ndirections = ['R', 'L', 'D', 'U', 'RD', 'LU', 'RU', 'LD']\n\ndef get_position_row(a_row, a):\n\tk = 0\n\tfor i in range(len(arr_row)):\n\t\tif arr_row[i] == a[1]:\n\t\t\tk = i\n\treturn k\n\ndef get_position_col(a_col, a):\n\ty = 0\n\tfor j in range(len(a_col)):\n\t\tif a_col[j] == a[0]:\n\t\t\ty = j\n\treturn y\n\ndef get_directions(vectors_map, directions_0, a):\n\tdirection = ''\n\tfor i in range(len(vectors_map)):\n\t\tif vectors_map[i] == a:\n\t\t\tdirection = directions_0[i]\n\treturn direction\n\ndef next_direction(a):\n\tk = []\n\tif a == 0:\n\t\tk.append(0)\n\t\tk.append(0)\n\tif a != 0:\n\t\tif a / abs(a) < 0:\n\t\t\tk.append(abs(a))\n\t\t\tk.append(str(-1))\n\t\tif a / abs(a) > 0:\n\t\t\tk.append(abs(a))\n\t\t\tk.append(str(1))\n\treturn k\ns = input()\nt = input()\nx = get_position_row(arr_row, t) - get_position_row(arr_row, s)\ny = get_position_col(arr_col, t) - get_position_col(arr_col, s)\ndelta = min(abs(x), abs(y))\nif x == 0:\n\tdx = 0\nelse:\n\tdx = x / abs(x)\nif y == 0:\n\tdy = 0\nelse:\n\tdy = y / abs(y)\nvector_0 = [int(dx), int(dy)]\nx0 = int(x - delta * dx)\ny0 = int(y - delta * dy)\nx1 = next_direction(x0)\ny1 = next_direction(y0)\ndelta_1 = int(x1[0]) + int(y1[0])\nvector_1 = [int(x1[1]), int(y1[1])]\nsteps = delta + delta_1\npath = []\nfor i in range(delta):\n\tpath.append(get_directions(vectors, directions, vector_0))\nfor j in range(delta_1):\n\tpath.append(get_directions(vectors, directions, vector_1))\nprint(steps)\nfor i in path:\n\tprint(i, end='')\n\tprint()\n",
        "a = list(input())\nb = list(input())\nc = abs(ord(a[0]) - ord(b[0]))\na[0] = ord(a[0])\na[1] = ord(a[1])\nb[0] = ord(b[0])\nb[1] = ord(b[1])\nprint(max(abs(a[0] - b[0]), abs(a[1] - b[1])))\nwhile abs(a[0] - b[0]) and abs(a[1] - b[1]):\n\tif a[0] > b[0] and a[1] > b[1]:\n\t\ta[0] = a[0] - 1\n\t\ta[1] = a[1] - 1\n\t\tprint('LD')\n\tif a[0] > b[0] and a[1] < b[1]:\n\t\ta[0] = a[0] - 1\n\t\tb[1] = b[1] - 1\n\t\tprint('LU')\n\tif a[0] < b[0] and a[1] > b[1]:\n\t\tb[0] = b[0] - 1\n\t\ta[1] = a[1] - 1\n\t\tprint('RD')\n\tif a[0] < b[0] and a[1] < b[1]:\n\t\tb[0] = b[0] - 1\n\t\tb[1] = b[1] - 1\n\t\tprint('RU')\nwhile abs(a[0] - b[0]):\n\tif a[0] > b[0]:\n\t\ta[0] -= 1\n\t\tprint('L')\n\tif a[0] < b[0]:\n\t\tb[0] -= 1\n\t\tprint('R')\nwhile abs(a[1] - b[1]):\n\tif a[1] > b[1]:\n\t\ta[1] -= 1\n\t\tprint('D')\n\tif a[1] < b[1]:\n\t\tb[1] -= 1\n\t\tprint('U')\n",
        "(start, end) = (input(), input())\n(h, v) = (ord(end[0]) - ord(start[0]), int(end[1]) - int(start[1]))\ndiag = min(abs(h), abs(v))\nst = max(abs(v) - diag, abs(h) - diag)\nprint(diag + st)\n(s1, s2) = ('', '')\nif h > 0:\n\ts1 += 'R'\nelse:\n\ts1 += 'L'\nif v > 0:\n\ts1 += 'U'\nelse:\n\ts1 += 'D'\nif abs(v) > abs(h):\n\tif v > 0:\n\t\ts2 = 'U'\n\telse:\n\t\ts2 = 'D'\nelif h > 0:\n\ts2 = 'R'\nelse:\n\ts2 = 'L'\nfor i in range(diag):\n\tprint(s1)\nfor i in range(st):\n\tprint(s2)\n",
        "(x1, y1) = [ord(i) - 48 for i in input()]\n(x2, y2) = [ord(i) - 48 for i in input()]\nmat = []\nwhile x1 != x2 or y1 != y2:\n\ts = ''\n\tif x2 > x1:\n\t\tx1 += 1\n\t\ts += 'R'\n\tif x2 < x1:\n\t\tx1 -= 1\n\t\ts += 'L'\n\tif y2 > y1:\n\t\ty1 += 1\n\t\ts += 'U'\n\tif y2 < y1:\n\t\ty1 -= 1\n\t\ts += 'D'\n\tmat.append(s)\nprint(len(mat))\nfor i in mat:\n\tprint(i)\n",
        "s = input().rstrip()\nstart = [ord(s[0]) - ord('a'), int(s[1]) - 1]\ns = input().rstrip()\nend = [ord(s[0]) - ord('a'), int(s[1]) - 1]\nsign = lambda x: 0 if x == 0 else x // abs(x)\nmoves = {(1, 1): 'RU', (1, -1): 'RD', (-1, 1): 'LU', (-1, -1): 'LD', (0, 1): 'U', (0, -1): 'D', (1, 0): 'R', (-1, 0): 'L'}\nres = []\nwhile start != end:\n\tk = (sign(end[0] - start[0]), sign(end[1] - start[1]))\n\tstart[0] += k[0]\n\tstart[1] += k[1]\n\tres.append(moves[k])\nprint(len(res))\nfor c in res:\n\tprint(c)\n",
        "f = input()\nt = input()\nl = ' abcdefgh'\nx = l.index(f[0])\ny = int(f[1])\ntx = l.index(t[0])\nty = int(t[1])\nc = 0\nr = []\nwhile not (x == tx and y == ty):\n\tc += 1\n\tm = ''\n\tif x > tx:\n\t\tm += 'L'\n\t\tx -= 1\n\telif x < tx:\n\t\tm += 'R'\n\t\tx += 1\n\tif y > ty:\n\t\tm += 'D'\n\t\ty -= 1\n\telif y < ty:\n\t\tm += 'U'\n\t\ty += 1\n\tr += [m]\nprint(c)\nprint('\\n'.join(r))\n",
        "class ChessPos(object):\n\ttrans_1 = {k: v for (v, k) in enumerate('abcdefgh', 1)}\n\ttrans_2 = {k: v for (k, v) in enumerate('abcdefgh', 1)}\n\n\tdef __init__(self, square):\n\t\tself.x = ChessPos.trans_1[square[0]]\n\t\tself.y = int(square[1])\n\n\tdef __sub__(self, other):\n\t\treturn (self.x - other.x, self.y - other.y)\n\n\tdef __str__(self):\n\t\treturn '{}{}:({},{})'.format(ChessPos.trans_2[self.x], self.y, self.x, self.y)\nisPos = lambda x: x > 0\nisNeg = lambda x: x < 0\n\ndef cross_direction(delta):\n\tif isPos(delta[0]):\n\t\tif isPos(delta[1]):\n\t\t\treturn 'RU'\n\t\telif isNeg(delta[1]):\n\t\t\treturn 'RD'\n\telif isNeg(delta[0]):\n\t\tif isPos(delta[1]):\n\t\t\treturn 'LU'\n\t\telif isNeg(delta[1]):\n\t\t\treturn 'LD'\n\ndef str8_direction(delta):\n\tif isPos(delta[0]):\n\t\treturn 'R'\n\telif isNeg(delta[0]):\n\t\treturn 'L'\n\telif isPos(delta[1]):\n\t\treturn 'U'\n\telif isNeg(delta[1]):\n\t\treturn 'D'\n\ndef KingSP():\n\tstart = ChessPos(input())\n\tend = ChessPos(input())\n\tdelta = end - start\n\tabs_delta = (abs(delta[0]), abs(delta[1]))\n\tsteps = max(abs_delta)\n\tcross = abs(min(abs_delta))\n\tnorm_delta = (abs_delta[0] - cross, abs_delta[1] - cross)\n\tprint(steps)\n\twhile isPos(abs_delta[0]) and isPos(abs_delta[1]):\n\t\tprint(cross_direction(delta))\n\t\tabs_delta = (abs_delta[0] - 1, abs_delta[1] - 1)\n\tdelta = (abs_delta[0] * (-1) ** isNeg(delta[0]), abs_delta[1] * (-1) ** isNeg(delta[1]))\n\twhile isPos(abs_delta[0]) or isPos(abs_delta[1]):\n\t\tprint(str8_direction(delta))\n\t\tabs_delta = (abs_delta[0] - 1, abs_delta[1] - 1)\nKingSP()\n",
        "def toCoord(line):\n\treturn (ord('a') - ord(line[0]), ord('1') - ord(line[1]))\n(kx, ky) = toCoord(input())\n(tx, ty) = toCoord(input())\nmoves = []\nlr = 'L' if kx < tx else 'R'\nud = 'D' if ky < ty else 'U'\nif kx != tx and ky != ty:\n\tif abs(kx - tx) < abs(ky - ty):\n\t\tdiag = abs(kx - tx)\n\t\tparallel = abs(ky - ty) - diag\n\t\tlast = ud\n\telse:\n\t\tdiag = abs(ky - ty)\n\t\tparallel = abs(kx - tx) - diag\n\t\tlast = lr\n\tfor i in range(diag):\n\t\tmoves.append(lr + ud)\n\tfor i in range(parallel):\n\t\tmoves.append(last)\nelif kx == tx:\n\tfor i in range(abs(ky - ty)):\n\t\tmoves.append(ud)\nelse:\n\tfor i in range(abs(kx - tx)):\n\t\tmoves.append(lr)\nprint(len(moves))\nprint('\\n'.join(moves))\n",
        "a = list(input())\na[1] = int(a[1]) - 1\na[0] = ord(a[0]) - 97\nb = list(input())\nb[1] = int(b[1]) - 1\nb[0] = ord(b[0]) - 97\nprint(max(abs(a[1] - b[1]), abs(a[0] - b[0])))\nwhile a != b:\n\tdd = ''\n\tif a[0] < b[0]:\n\t\tdd += 'R'\n\t\ta[0] += 1\n\telif a[0] > b[0]:\n\t\tdd += 'L'\n\t\ta[0] -= 1\n\tif a[1] > b[1]:\n\t\tdd += 'D'\n\t\ta[1] -= 1\n\telif a[1] < b[1]:\n\t\tdd += 'U'\n\t\ta[1] += 1\n\tprint(dd)\n",
        "x = list(input())\ny = list(input())\n(x0, y0) = (int(ord(x[0]) - ord('a') + 1), int(x[1]))\n(x1, y1) = (int(ord(y[0]) - ord('a') + 1), int(y[1]))\nprint(max(abs(x1 - x0), abs(y0 - y1)))\nwhile x0 != x1 or y0 != y1:\n\tif x1 > x0:\n\t\tprint('R', end='')\n\t\tx0 += 1\n\tif x0 > x1:\n\t\tprint('L', end='')\n\t\tx0 -= 1\n\tif y0 > y1:\n\t\tprint('D', end='')\n\t\ty0 -= 1\n\tif y1 > y0:\n\t\tprint('U', end='')\n\t\ty0 += 1\n\tprint()\n",
        "def rr():\n\treturn input().rstrip()\n\ndef rri():\n\treturn int(rr())\n\ndef rrl():\n\treturn list(map(int, rr().split()))\n\ndef rrt():\n\treturn tuple(map(int, rr().split()))\nfrom collections import defaultdict\n\ndef mus(d=lambda : 0):\n\treturn defaultdict(lambda : defaultdict(d))\n\ndef dd0(d=lambda : 0):\n\treturn defaultdict(d)\n\ndef ms(x, y, d=0):\n\treturn [[0] * y for i in range(x)]\n\ndef ar(x, d=0):\n\treturn [d] * x\n\ndef ppm(m, n=0, x=0, y=0):\n\tprint('\\n'.join(('\\t'.join((str(m[j][i]) for j in range(y or n))) for i in range(x or n))))\n\ndef ppa(a, n):\n\tprint('\\t'.join(map(str, a[0:n])))\n\ndef ppl(a=0, x=[1]):\n\tx[0] = a or x[0] + 1\n\tprint('-' + '- -' * 14 + '-# ' + str(x[0] - 2) + ' #-' + '- -' * 14 + '-')\n\ndef fltn(a):\n\t(i for sub in a for i in sub)\n\ndef yn(x):\n\treturn 'YES' if x else 'NO'\nfrom itertools import accumulate\nfrom itertools import groupby\n\ndef grp(x):\n\treturn ((i, sum((1 for _ in g))) for (i, g) in groupby(x))\nimport math\n\ndef rnar():\n\treturn (*rrl(), rrl())\n\ndef rn():\n\treturn (*rrl(),)\n\ndef read():\n\tst = rr()\n\ten = rr()\n\treturn (st, en)\n\ndef solve(st, en):\n\t(x1, y1) = (ord('a') - ord(st[0]), int(st[1]))\n\t(x2, y2) = (ord('a') - ord(en[0]), int(en[1]))\n\t(dx, dy) = (x2 - x1, y2 - y1)\n\tem = []\n\twhile dx != 0 or dy != 0:\n\t\tcm = ''\n\t\tif dx > 0:\n\t\t\tcm += 'L'\n\t\t\tdx -= 1\n\t\telif dx < 0:\n\t\t\tcm += 'R'\n\t\t\tdx += 1\n\t\tif dy > 0:\n\t\t\tcm += 'U'\n\t\t\tdy -= 1\n\t\telif dy < 0:\n\t\t\tcm += 'D'\n\t\t\tdy += 1\n\t\tem.append(cm)\n\tans = str(len(em)) + '\\n' + '\\n'.join(em)\n\treturn ans\ntest_count = 1\nfor _ in range(test_count):\n\tinput_data = read()\n\tresult = solve(*input_data)\n\tprint(result)\n",
        "s0 = input()\ns = []\ns.append(ord(s0[0]))\ns.append(int(s0[1]))\nt0 = input()\nt = []\nt.append(ord(t0[0]))\nt.append(int(t0[1]))\na0 = t[0] - s[0]\nb0 = t[1] - s[1]\na = abs(a0)\nb = abs(b0)\nm = max(a, b)\nd = abs(a - b)\nh = []\nif a0 >= 0 and b0 >= 0:\n\tif a >= b:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('R')\n\t\t\telse:\n\t\t\t\th.append('RU')\n\telse:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('U')\n\t\t\telse:\n\t\t\t\th.append('RU')\nif a0 >= 0 and b0 < 0:\n\tif a >= b:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('R')\n\t\t\telse:\n\t\t\t\th.append('RD')\n\telse:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('D')\n\t\t\telse:\n\t\t\t\th.append('RD')\nif a0 < 0 and b0 >= 0:\n\tif a >= b:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('L')\n\t\t\telse:\n\t\t\t\th.append('LU')\n\telse:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('U')\n\t\t\telse:\n\t\t\t\th.append('LU')\nif a0 < 0 and b0 < 0:\n\tif a >= b:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('L')\n\t\t\telse:\n\t\t\t\th.append('LD')\n\telse:\n\t\tfor i in range(m):\n\t\t\tif i < d:\n\t\t\t\th.append('D')\n\t\t\telse:\n\t\t\t\th.append('LD')\nprint(m)\nfor i in range(m):\n\tprint(h[i], end='\\n')\n",
        "steps = []\ncount = 0\nstep = ['', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ns = input()\nt = input()\nsx = step.index(s[0])\nsy = int(s[1])\ntx = step.index(t[0])\nty = int(t[1])\nwhile sx != tx or sy != ty:\n\tcount = count + 1\n\tif sx > tx:\n\t\tif sy > ty:\n\t\t\tsteps.append('LD')\n\t\t\tsy = sy - 1\n\t\telif sy < ty:\n\t\t\tsteps.append('LU')\n\t\t\tsy = sy + 1\n\t\telse:\n\t\t\tsteps.append('L')\n\t\tsx = sx - 1\n\telif sx < tx:\n\t\tif sy > ty:\n\t\t\tsteps.append('RD')\n\t\t\tsy = sy - 1\n\t\telif sy < ty:\n\t\t\tsteps.append('RU')\n\t\t\tsy = sy + 1\n\t\telse:\n\t\t\tsteps.append('R')\n\t\tsx = sx + 1\n\telif sy > ty:\n\t\tsteps.append('D')\n\t\tsy = sy - 1\n\telif sy < ty:\n\t\tsteps.append('U')\n\t\tsy = sy + 1\nprint(count)\nfor i in steps:\n\tprint(i)\n",
        "p1 = input()\np2 = input()\nx1 = ord(p1[0]) - 96\nx2 = ord(p2[0]) - 96\ny1 = int(p1[1])\ny2 = int(p2[1])\nz = min(abs(x2 - x1), abs(y2 - y1))\nmoves = z\nar1 = []\nif x2 > x1 and y2 > y1:\n\tx1 += z\n\ty1 += z\n\tfor c in range(z):\n\t\tar1.append('RU')\nelif x2 > x1 and y2 < y1:\n\tx1 += z\n\ty1 -= z\n\tfor c in range(z):\n\t\tar1.append('RD')\nelif x2 < x1 and y2 > y1:\n\tx1 -= z\n\ty1 += z\n\tfor c in range(z):\n\t\tar1.append('LU')\nelse:\n\tx1 -= z\n\ty1 -= z\n\tfor c in range(z):\n\t\tar1.append('LD')\nif x2 > x1:\n\tmoves += x2 - x1\n\tfor c in range(x2 - x1):\n\t\tar1.append('R')\nelif x2 < x1:\n\tmoves += x1 - x2\n\tfor c in range(x1 - x2):\n\t\tar1.append('L')\nelif y2 > y1:\n\tmoves += y2 - y1\n\tfor c in range(y2 - y1):\n\t\tar1.append('U')\nelse:\n\tmoves += y1 - y2\n\tfor c in range(y1 - y2):\n\t\tar1.append('D')\nprint(moves)\nfor sv in range(len(ar1)):\n\tprint(ar1[sv])\n",
        "columns = '-abcdefgh'\n(x, y) = input()\n(x0, y0) = (columns.index(x), int(y))\n(x, y) = input()\n(x1, y1) = (columns.index(x), int(y))\n(dx, dy) = (x1 - x0, y1 - y0)\nnum_moves = max(map(abs, [dx, dy]))\nnum_ordinal_moves = min(map(abs, [dx, dy]))\nnum_cardinal_moves = num_moves - num_ordinal_moves\nhorizontal_direction = 'L' if dx < 0 else 'R'\nvertical_direction = 'D' if dy < 0 else 'U'\nordinal_direction = horizontal_direction + vertical_direction\ncardinal_direction = horizontal_direction if abs(dx) > abs(dy) else vertical_direction\ndirections = [ordinal_direction] * num_ordinal_moves + [cardinal_direction] * num_cardinal_moves\nprint(len(directions))\nprint('\\n'.join(directions))\n",
        "import string\nfirst_position = str(input())\nsecond_position = str(input())\nletter_list = list(string.ascii_lowercase[0:8])\nnumber_list = list(range(1, 9))\nd = dict(zip(letter_list, number_list))\nt1 = d[first_position[0]]\nt2 = d[second_position[0]]\nposition_list = [(t1, int(first_position[1])), (t2, int(second_position[1]))]\ntt_1 = position_list[0][1]\nh_1_1 = abs(position_list[0][0] - position_list[1][0])\nh_1_2 = abs(position_list[0][1] - position_list[1][1])\nh_1 = min(h_1_1, h_1_2)\nh_2 = max(h_1_1, h_1_2) - min(h_1_1, h_1_2)\nh = h_1 + h_2\nprint(h)\nswitcher = ''\nfor i in range(h_1):\n\tif t1 < t2 and int(first_position[1]) < int(second_position[1]):\n\t\tprint('RU')\n\t\tswitcher = 'RU'\n\tif t1 < t2 and int(first_position[1]) > int(second_position[1]):\n\t\tprint('RD')\n\t\tswitcher = 'RD'\n\tif t1 > t2 and int(first_position[1]) < int(second_position[1]):\n\t\tprint('LU')\n\t\tswitcher = 'LU'\n\tif t1 > t2 and int(first_position[1]) > int(second_position[1]):\n\t\tprint('LD')\n\t\tswitcher = 'LD'\nfor j in range(h_2):\n\tif switcher == 'LU' and h_1_1 < h_1_2:\n\t\tprint('U')\n\tif (switcher == 'LU' or switcher == 'LD') and h_1_1 > h_1_2:\n\t\tprint('L')\n\tif switcher == 'LD' and h_1_1 < h_1_2:\n\t\tprint('D')\n\tif switcher == 'RU' and h_1_1 < h_1_2:\n\t\tprint('U')\n\tif switcher == 'RD' and h_1_1 < h_1_2:\n\t\tprint('D')\n\tif (switcher == 'RU' or switcher == 'RD') and h_1_1 > h_1_2:\n\t\tprint('R')\n\tif t1 == t2 and int(first_position[1]) < int(second_position[1]):\n\t\tprint('U')\n\tif t1 == t2 and int(first_position[1]) > int(second_position[1]):\n\t\tprint('D')\n\tif int(first_position[1]) == int(second_position[1]) and t1 < t2:\n\t\tprint('R')\n\tif int(first_position[1]) == int(second_position[1]) and t1 > t2:\n\t\tprint('L')\n",
        "s = input()\nt = input()\nsrow = int(s[1])\nscol = ord(s[0]) - 97 + 1\ntrow = int(t[1])\ntcol = ord(t[0]) - 97 + 1\nmovelist = []\nmoves = 0\nwhile True:\n\tif srow > trow:\n\t\tif scol > tcol:\n\t\t\tmovelist.append('LD')\n\t\t\tsrow -= 1\n\t\t\tscol -= 1\n\t\telif scol < tcol:\n\t\t\tmovelist.append('RD')\n\t\t\tsrow -= 1\n\t\t\tscol += 1\n\t\telse:\n\t\t\tmovelist.append('D')\n\t\t\tsrow -= 1\n\telif srow < trow:\n\t\tif scol > tcol:\n\t\t\tmovelist.append('LU')\n\t\t\tsrow += 1\n\t\t\tscol -= 1\n\t\telif scol < tcol:\n\t\t\tmovelist.append('RU')\n\t\t\tsrow += 1\n\t\t\tscol += 1\n\t\telse:\n\t\t\tmovelist.append('U')\n\t\t\tsrow += 1\n\telif scol > tcol:\n\t\tmovelist.append('L')\n\t\tscol -= 1\n\telif scol < tcol:\n\t\tmovelist.append('R')\n\t\tscol += 1\n\telse:\n\t\tbreak\n\tmoves += 1\nprint(moves)\nfor move in movelist:\n\tprint(move)\n",
        "coord = (input(), input())\n(s, t) = [[ord(x) % 16 for x in c] for c in coord]\nprint(max(abs(s[0] - t[0]), abs(s[1] - t[1])))\nwhile s != t:\n\tr = ''\n\tif s[0] < t[0]:\n\t\tr += 'R'\n\t\ts[0] += 1\n\telif s[0] > t[0]:\n\t\tr += 'L'\n\t\ts[0] -= 1\n\tif s[1] < t[1]:\n\t\tr += 'U'\n\t\ts[1] += 1\n\telif s[1] > t[1]:\n\t\tr += 'D'\n\t\ts[1] -= 1\n\tprint(r)\n",
        "a = 'abcdefgh'\nb = {a[i - 1]: i for i in range(1, 9)}\ns = input()\nt = input()\n(x0, x1) = (b[s[0]], int(s[1]))\n(y0, y1) = (b[t[0]], int(t[1]))\nprint(max(abs(x0 - y0), abs(x1 - y1)))\nwhile True:\n\tif x0 == y0 and x1 == y1:\n\t\tbreak\n\tif x0 < y0:\n\t\tx0 += 1\n\t\tprint('R', end='')\n\telif x0 > y0:\n\t\tx0 -= 1\n\t\tprint('L', end='')\n\tif x1 < y1:\n\t\tx1 += 1\n\t\tprint('U', end='')\n\telif x1 > y1:\n\t\tx1 -= 1\n\t\tprint('D', end='')\n\tprint()\n",
        "a = input()\nb = input()\ns1 = ord(a[0]) - ord(b[0])\ns2 = int(a[1]) - int(b[1])\nprint(max(abs(s1), abs(s2)))\nwhile s1 != 0 or s2 != 0:\n\ts = ''\n\tif s1 < 0:\n\t\ts1 = s1 + 1\n\t\ts = s + 'R'\n\tif s1 > 0:\n\t\ts1 = s1 - 1\n\t\ts = s + 'L'\n\tif s2 > 0:\n\t\ts2 = s2 - 1\n\t\ts = s + 'D'\n\tif s2 < 0:\n\t\ts2 = s2 + 1\n\t\ts = s + 'U'\n\tprint(s)\n",
        "n = input()\nm = input()\nn0 = ord(n[0])\nn1 = ord(n[1])\nm0 = ord(m[0])\nm1 = ord(m[1])\nk = abs(n0 - m0)\nu = abs(n1 - m1)\nprint(min(k, u) + abs(k - u))\nwhile True:\n\tif n0 < m0:\n\t\tprint('R', end='')\n\t\tn0 = n0 + 1\n\telif n0 > m0:\n\t\tprint('L', end='')\n\t\tn0 = n0 - 1\n\tif n1 < m1:\n\t\tprint('U', end='')\n\t\tn1 = n1 + 1\n\telif n1 > m1:\n\t\tprint('D', end='')\n\t\tn1 = n1 - 1\n\tprint('')\n\tif n0 == m0 and n1 == m1:\n\t\tbreak\n",
        "from collections import deque\ndirections = {'D': (1, 0), 'U': (-1, 0), 'R': (0, 1), 'L': (0, -1), 'RD': (1, 1), 'RU': (-1, 1), 'LD': (1, -1), 'LU': (-1, -1)}\n\ndef code(i, j):\n\treturn i * 8 + j\n\ndef decode(x):\n\treturn (x // 8, x % 8)\n\ndef code_input():\n\tcoord = input()\n\tj = ord(coord[0]) - ord('a')\n\ti = 8 - int(coord[1])\n\treturn code(i, j)\n\ndef move(x, d):\n\t(i, j) = decode(x)\n\t(di, dj) = directions[d]\n\ti += di\n\tj += dj\n\tif i >= 0 and i < 8 and (j >= 0) and (j < 8):\n\t\treturn code(i, j)\n\telse:\n\t\treturn -1\ns = code_input()\nt = code_input()\nq = deque([])\nq.append(s)\nvisited = set([s])\nlast_dir = {}\nprev_field = {}\ndist = {s: 0}\nwhile len(q) > 0 and t not in visited:\n\tfield = q.popleft()\n\tfor d in directions:\n\t\tneighbor = move(field, d)\n\t\tif neighbor != -1 and neighbor not in visited:\n\t\t\tvisited.add(neighbor)\n\t\t\tq.append(neighbor)\n\t\t\tdist[neighbor] = dist[field] + 1\n\t\t\tlast_dir[neighbor] = d\n\t\t\tprev_field[neighbor] = field\nprint(dist[t])\nfield = t\npath = deque([])\nwhile field in prev_field:\n\tpath.appendleft(last_dir[field])\n\tfield = prev_field[field]\nfor mv in path:\n\tprint(mv)\n",
        "def rep(a):\n\tif a == 'a':\n\t\ta = 1\n\telif a == 'b':\n\t\ta = 2\n\telif a == 'c':\n\t\ta = 3\n\telif a == 'd':\n\t\ta = 4\n\telif a == 'e':\n\t\ta = 5\n\telif a == 'f':\n\t\ta = 6\n\telif a == 'g':\n\t\ta = 7\n\telif a == 'h':\n\t\ta = 8\n\treturn a\n(x1, y1) = list(input())\ny1 = int(y1)\nx1 = rep(x1)\n(x2, y2) = list(input())\ny2 = int(y2)\nx2 = rep(x2)\nsteps = 0\nquarter = 0\nk = 0\nss = []\nwhile k == 0:\n\tif x2 - x1 == 0 or y2 - y1 == 0:\n\t\tk = 1\n\t\tif x2 - x1 == 0:\n\t\t\tif y2 - y1 > 0:\n\t\t\t\tst = 'U'\n\t\t\telse:\n\t\t\t\tst = 'D'\n\t\t\tsteps += abs(y2 - y1)\n\t\t\tfor i in range(abs(y2 - y1)):\n\t\t\t\tss.append(st)\n\t\telif y2 - y1 == 0:\n\t\t\tif x2 - x1 > 0:\n\t\t\t\tst = 'R'\n\t\t\telse:\n\t\t\t\tst = 'L'\n\t\t\tsteps += abs(x2 - x1)\n\t\t\tfor i in range(abs(x2 - x1)):\n\t\t\t\tss.append(st)\n\telif x2 - x1 > 0 and y2 - y1 > 0:\n\t\tquarter = 1\n\telif x2 - x1 > 0 and y2 - y1 < 0:\n\t\tquarter = 2\n\telif x2 - x1 < 0 and y2 - y1 > 0:\n\t\tquarter = 4\n\telif x2 - x1 < 0 and y2 - y1 < 0:\n\t\tquarter = 3\n\tl = [abs(x2 - x1), abs(y2 - y1)]\n\tmm = min(l)\n\tmaxx = max(l)\n\tif quarter == 1:\n\t\tfor j in range(mm):\n\t\t\tss.append('RU')\n\t\t\tsteps += 1\n\t\t\tx1 += 1\n\t\t\ty1 += 1\n\t\tif maxx == mm:\n\t\t\tk = 1\n\tif quarter == 2:\n\t\tfor j in range(mm):\n\t\t\tss.append('RD')\n\t\t\tsteps += 1\n\t\t\tx1 += 1\n\t\t\ty1 -= 1\n\t\tif maxx == mm:\n\t\t\tk = 1\n\tif quarter == 3:\n\t\tfor j in range(mm):\n\t\t\tss.append('LD')\n\t\t\tsteps += 1\n\t\t\tx1 -= 1\n\t\t\ty1 -= 1\n\t\tif maxx == mm:\n\t\t\tk = 1\n\tif quarter == 4:\n\t\tfor j in range(mm):\n\t\t\tss.append('LU')\n\t\t\tsteps += 1\n\t\t\tx1 -= 1\n\t\t\ty1 += 1\n\t\tif maxx == mm:\n\t\t\tk = 1\nprint(steps)\nfor hh in ss:\n\tprint(hh)\n",
        "def ctoi(x):\n\tif x == 'a':\n\t\treturn 1\n\tif x == 'b':\n\t\treturn 2\n\tif x == 'c':\n\t\treturn 3\n\tif x == 'd':\n\t\treturn 4\n\tif x == 'e':\n\t\treturn 5\n\tif x == 'f':\n\t\treturn 6\n\tif x == 'g':\n\t\treturn 7\n\tif x == 'h':\n\t\treturn 8\na = input()\na1 = ctoi(a[0])\na2 = int(a[1])\nb = input()\nb1 = ctoi(b[0])\nb2 = int(b[1])\nA = abs(a1 - b1)\nB = abs(a2 - b2)\nprint(max(A, B))\nwhile a1 != b1 or a2 != b2:\n\tans = ''\n\tif a1 < b1:\n\t\ta1 += 1\n\t\tans += 'R'\n\telif a1 > b1:\n\t\ta1 -= 1\n\t\tans += 'L'\n\tif a2 < b2:\n\t\ta2 += 1\n\t\tans += 'U'\n\telif a2 > b2:\n\t\ta2 -= 1\n\t\tans += 'D'\n\tprint(ans)\n",
        "s = input()\nt = input()\nx = ord(s[0]) - ord(t[0])\ny = ord(s[1]) - ord(t[1])\nif x < 0:\n\txStep = 'R'\n\tx = -x\nelse:\n\txStep = 'L'\nif y < 0:\n\tyStep = 'U'\n\ty = -y\nelse:\n\tyStep = 'D'\nprint(max(x, y))\nwhile x > y:\n\tprint(xStep)\n\tx -= 1\nwhile x < y:\n\tprint(yStep)\n\ty -= 1\nwhile x:\n\tprint(xStep + yStep)\n\tx -= 1\n",
        "import math\nalph = 'abcdefghijklmnopqrstuvwxyz'\ns = str(input())\nt = str(input())\nx1 = alph.index(s[0])\nx2 = alph.index(t[0])\ny1 = int(s[1])\ny2 = int(t[1])\ndx = x2 - x1\ndy = y2 - y1\nn = max(abs(dx), abs(dy))\nprint(n)\ndelta = abs(abs(dx) - abs(dy))\nif abs(dx) >= abs(dy):\n\tif dx >= 0:\n\t\tfor i in range(delta):\n\t\t\tprint('R')\n\t\tif dy >= 0:\n\t\t\tfor i in range(abs(dy)):\n\t\t\t\tprint('RU')\n\t\telse:\n\t\t\tfor i in range(abs(dy)):\n\t\t\t\tprint('RD')\n\telse:\n\t\tfor i in range(delta):\n\t\t\tprint('L')\n\t\tif dy >= 0:\n\t\t\tfor i in range(abs(dy)):\n\t\t\t\tprint('LU')\n\t\telse:\n\t\t\tfor i in range(abs(dy)):\n\t\t\t\tprint('LD')\nelif dy >= 0:\n\tfor i in range(delta):\n\t\tprint('U')\n\tif dx >= 0:\n\t\tfor i in range(abs(dx)):\n\t\t\tprint('RU')\n\telse:\n\t\tfor i in range(abs(dx)):\n\t\t\tprint('LU')\nelse:\n\tfor i in range(delta):\n\t\tprint('D')\n\tif dx >= 0:\n\t\tfor i in range(abs(dx)):\n\t\t\tprint('RD')\n\telse:\n\t\tfor i in range(abs(dx)):\n\t\t\tprint('LD')\n",
        "start = input()\nend = input()\n(x, y) = (ord(start[0]) - 64, int(start[1]))\n(xf, yf) = (ord(end[0]) - 64, int(end[1]))\nprint(max([abs(xf - x), abs(yf - y)]))\nwhile x != xf or y != yf:\n\tif x - xf > 0 and yf - y > 0:\n\t\tprint('LU')\n\t\tx -= 1\n\t\ty += 1\n\telif xf - x > 0 and yf - y > 0:\n\t\tprint('RU')\n\t\tx += 1\n\t\ty += 1\n\telif x - xf > 0 and y - yf > 0:\n\t\tprint('LD')\n\t\tx -= 1\n\t\ty -= 1\n\telif xf - x > 0 and y - yf > 0:\n\t\tprint('RD')\n\t\tx += 1\n\t\ty -= 1\n\telif xf - x == 0 and yf - y > 0:\n\t\tprint('U')\n\t\ty += 1\n\telif xf - x == 0 and y - yf > 0:\n\t\tprint('D')\n\t\ty -= 1\n\telif x - xf > 0 and y - yf == 0:\n\t\tprint('L')\n\t\tx -= 1\n\telif xf - x > 0 and y - yf == 0:\n\t\tprint('R')\n\t\tx += 1\n",
        "s = list(input())\nt = list(input())\ns[1] = int(s[1])\nt[1] = int(t[1])\nr = -(ord(s[0].lower()) - 96 - (ord(t[0].lower()) - 96))\nd = s[1] - t[1]\nprint(min(abs(r), abs(d)) + abs(abs(r) - abs(d)))\nfor i in range(0, min(abs(r), abs(d))):\n\tif r > 0 and d > 0:\n\t\tprint('RD')\n\telif r > 0 and d < 0:\n\t\tprint('RU')\n\telif r < 0 and d > 0:\n\t\tprint('LD')\n\telif r < 0 and d < 0:\n\t\tprint('LU')\nfor i in range(0, abs(abs(r) - abs(d))):\n\tif abs(r) > abs(d):\n\t\tif r < 0:\n\t\t\tprint('L')\n\t\telif r > 0:\n\t\t\tprint('R')\n\tif abs(d) > abs(r):\n\t\tif d < 0:\n\t\t\tprint('U')\n\t\telif d > 0:\n\t\t\tprint('D')\n",
        "n = input()\nstart = [ord(n[0]) - 96, int(n[1])]\nn = input()\nend = [ord(n[0]) - 96, int(n[1])]\nroute = [end[i] - start[i] for i in [0, 1]]\nprint(int(min(abs(route[0]), abs(route[1])) + abs(abs(route[0]) - abs(route[1]))))\na = 'R' if route[0] > 0 else 'L'\na += 'U' if route[1] > 0 else 'D'\nfor i in range(min(abs(route[0]), abs(route[1]))):\n\tprint(a)\nif abs(route[0]) > abs(route[1]):\n\tfor i in range(abs(abs(route[0]) - abs(route[1]))):\n\t\tprint('L' if route[0] < 0 else 'R')\nelif abs(route[0]) < abs(route[1]):\n\tfor i in range(abs(abs(route[0]) - abs(route[1]))):\n\t\tprint('D' if route[1] < 0 else 'U')\n",
        "king = input()\ndestiny = input()\nxk = ord(king[0])\nxd = ord(destiny[0])\nyk = int(king[1])\nyd = int(destiny[1])\nmoves = []\nwhile xk != xd or yk != yd:\n\tif xk < xd:\n\t\th = 'R'\n\t\txk += 1\n\telif xk > xd:\n\t\th = 'L'\n\t\txk -= 1\n\telse:\n\t\th = ''\n\tif yk < yd:\n\t\tv = 'U'\n\t\tyk += 1\n\telif yk > yd:\n\t\tv = 'D'\n\t\tyk -= 1\n\telse:\n\t\tv = ''\n\tmoves.append(h + v)\nprint(len(moves))\nfor i in moves:\n\tprint(i)\n",
        "d1 = input()\nd2 = input()\nt1 = list(d1)\nt2 = list(d2)\narr = []\nans = 0\nwhile t2 != t1:\n\tif t1[0] > t2[0] and t1[1] > t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) - 1)\n\t\tt1[0] = chr(ord(t1[0]) - 1)\n\t\tarr.append('LD')\n\telif t1[0] > t2[0] and t1[1] < t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) + 1)\n\t\tt1[0] = chr(ord(t1[0]) - 1)\n\t\tarr.append('LU')\n\telif t1[0] < t2[0] and t1[1] < t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) + 1)\n\t\tt1[0] = chr(ord(t1[0]) + 1)\n\t\tarr.append('RU')\n\telif t1[0] < t2[0] and t1[1] > t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) - 1)\n\t\tt1[0] = chr(ord(t1[0]) + 1)\n\t\tarr.append('RD')\n\telif t1[0] == t2[0] and t1[1] > t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) - 1)\n\t\tarr.append('D')\n\telif t1[0] == t2[0] and t1[1] < t2[1]:\n\t\tans += 1\n\t\tt1[1] = chr(ord(t1[1]) + 1)\n\t\tarr.append('U')\n\telif t1[0] > t2[0] and t1[1] == t2[1]:\n\t\tans += 1\n\t\tt1[0] = chr(ord(t1[0]) - 1)\n\t\tarr.append('L')\n\telif t1[0] < t2[0] and t1[1] == t2[1]:\n\t\tans += 1\n\t\tt1[0] = chr(ord(t1[0]) + 1)\n\t\tarr.append('R')\nprint(ans)\nfor i in range(len(arr)):\n\tprint(arr[i])\n",
        "def sign(x):\n\treturn 1 if x > 0 else -1\ns = input()\nx0 = ord(s[0]) - ord('a')\ny0 = int(s[1])\nt = input()\nx1 = ord(t[0]) - ord('a')\ny1 = int(t[1])\nans = []\nwhile x0 != x1 and y0 != y1:\n\tans.append('LR'[x0 < x1] + 'DU'[y0 < y1])\n\tx0 += sign(x1 - x0)\n\ty0 += sign(y1 - y0)\nwhile x0 != x1:\n\tans.append('LR'[x0 < x1])\n\tx0 += sign(x1 - x0)\nwhile y0 != y1:\n\tans.append('DU'[y0 < y1])\n\ty0 += sign(y1 - y0)\nprint(len(ans))\nprint('\\n'.join(ans))\n",
        "sp = ['', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ns = input()\ns = [sp.index(s[0]), int(s[1])]\nk = input()\nk = [sp.index(k[0]), int(k[1])]\nh = []\nwhile s != k:\n\tif s[0] < k[0] and s[1] < k[1]:\n\t\ts[0] += 1\n\t\ts[1] += 1\n\t\th.append('RU')\n\telif s[0] > k[0] and s[1] > k[1]:\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\t\th.append('LD')\n\telif s[0] < k[0] and s[1] > k[1]:\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\t\th.append('RD')\n\telif s[0] > k[0] and s[1] < k[1]:\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\t\th.append('LU')\n\telif s[0] == k[0] and s[1] < k[1]:\n\t\ts[1] += 1\n\t\th.append('U')\n\telif s[0] == k[0] and s[1] > k[1]:\n\t\ts[1] -= 1\n\t\th.append('D')\n\telif s[0] < k[0] and s[1] == k[1]:\n\t\ts[0] += 1\n\t\th.append('R')\n\telse:\n\t\ts[0] -= 1\n\t\th.append('L')\nprint(len(h))\nfor i in h:\n\tprint(i)\n",
        "s = list(input())\nt = list(input())\nv = int(t[1]) - int(s[1])\nh = ord(t[0]) - ord(s[0])\nmove_v = ''\nmove_h = ''\nif v >= 0:\n\tmove_v = 'U'\nelse:\n\tmove_v = 'D'\n\tv = -v\nif h >= 0:\n\tmove_h = 'R'\nelse:\n\tmove_h = 'L'\n\th = -h\nmoves = min(h, v) + abs(h - v)\nprint(moves)\nwhile v > 0 and h > 0:\n\tprint(move_h, move_v, sep='')\n\tv -= 1\n\th -= 1\nwhile v > 0:\n\tprint(move_v)\n\tv -= 1\nwhile h > 0:\n\tprint(move_h)\n\th -= 1\n",
        "s = input()\nt = input()\nx1 = ord(s[0]) - 97\ny1 = int(s[1]) - 1\nx2 = ord(t[0]) - 97\ny2 = int(t[1]) - 1\ncount = 0\npath = []\nwhile not (x1 == x2 and y1 == y2):\n\tans = ''\n\tif x1 > x2:\n\t\tans += 'L'\n\t\tx1 -= 1\n\telif x1 < x2:\n\t\tans += 'R'\n\t\tx1 += 1\n\tif y1 > y2:\n\t\tans += 'D'\n\t\ty1 -= 1\n\telif y1 < y2:\n\t\tans += 'U'\n\t\ty1 += 1\n\tcount += 1\n\tpath.append(ans)\nprint(count)\nfor x in path:\n\tprint(x)\n",
        "def Shortestpathoftheking(s, t):\n\ta = s + t\n\t(a, b) = (ord(a[i]) - ord(a[i + 2]) for i in (0, 1))\n\tprint(max(a, -a, b, -b))\n\twhile a != 0 or b != 0:\n\t\tr = ''\n\t\tif a < 0:\n\t\t\tr = 'R'\n\t\t\ta += 1\n\t\telif a > 0:\n\t\t\tr = 'L'\n\t\t\ta -= 1\n\t\tif b < 0:\n\t\t\tr += 'U'\n\t\t\tb += 1\n\t\telif b > 0:\n\t\t\tr += 'D'\n\t\t\tb -= 1\n\t\tprint(r)\n\treturn ''\nLista = []\nfor i in range(2):\n\tAll = [str(i) for i in input().split()]\n\tLista.append(All)\nfor j in range(0, len(Lista), 2):\n\tprint(Shortestpathoftheking(Lista[j][0], Lista[j + 1][0]))\n",
        "d = {chr(ord('a') + i): i + 1 for i in range(0, 8)}\n\nclass Point(object):\n\n\tdef __init__(self, arr):\n\t\tself.x = arr[0]\n\t\tself.y = arr[1]\n\n\tdef __eq__(self, other):\n\t\tif self.x == other.x and self.y == other.y:\n\t\t\treturn True\n\t\treturn False\n\n\tdef __ne__(self, other):\n\t\tif not self.__eq__(other):\n\t\t\treturn True\n\t\treturn False\n\ndef min(s, t):\n\tmoves = []\n\twhile s != t:\n\t\tif t.x == s.x:\n\t\t\tif t.y > s.y:\n\t\t\t\ts.y += 1\n\t\t\t\tmoves.append('U')\n\t\t\telse:\n\t\t\t\ts.y -= 1\n\t\t\t\tmoves.append('D')\n\t\telif t.y == s.y:\n\t\t\tif t.x > s.x:\n\t\t\t\ts.x += 1\n\t\t\t\tmoves.append('R')\n\t\t\telse:\n\t\t\t\ts.x -= 1\n\t\t\t\tmoves.append('L')\n\t\telif t.x - s.x < 0 and t.y - s.y < 0:\n\t\t\ts.x -= 1\n\t\t\ts.y -= 1\n\t\t\tmoves.append('LD')\n\t\telif t.x - s.x < 0 and t.y - s.y > 0:\n\t\t\ts.x -= 1\n\t\t\ts.y += 1\n\t\t\tmoves.append('LU')\n\t\telif t.x - s.x > 0 and t.y - s.y > 0:\n\t\t\ts.x += 1\n\t\t\ts.y += 1\n\t\t\tmoves.append('RU')\n\t\telse:\n\t\t\ts.x += 1\n\t\t\ts.y -= 1\n\t\t\tmoves.append('RD')\n\treturn (len(moves), '\\n'.join(moves))\ns = [i for i in input()]\nt = [i for i in input()]\ns[0] = d.get(s[0])\nt[0] = d.get(t[0])\ns[1] = int(s[1])\nt[1] = int(t[1])\ns = Point(s)\nt = Point(t)\n(mov_len, moves) = min(s, t)\nprint(mov_len)\nprint(moves)\n",
        "def diff_row(s, f):\n\treturn s - f\n\ndef diff_column(s, f):\n\treturn s - f\nstart = input()\nfinish = input()\npath = []\nrows = 'abcdefgh'\ns_column = int(start[1])\ns_row = int(rows.find(start[0]))\nf_column = int(finish[1])\nf_row = int(rows.find(finish[0]))\niterations = max(abs(diff_row(s_row, f_row)), abs(diff_column(s_column, f_column)))\nfor i in range(iterations):\n\tif diff_row(s_row, f_row) == 0:\n\t\tif diff_column(s_column, f_column) > 0:\n\t\t\tpath.append('D')\n\t\t\ts_column -= 1\n\t\telse:\n\t\t\tpath.append('U')\n\t\t\ts_column += 1\n\telif diff_column(s_column, f_column) == 0:\n\t\tif diff_row(s_row, f_row) > 0:\n\t\t\tpath.append('L')\n\t\t\ts_row -= 1\n\t\telse:\n\t\t\tpath.append('R')\n\t\t\ts_row += 1\n\telif diff_row(s_row, f_row) > 0:\n\t\tif diff_column(s_column, f_column) > 0:\n\t\t\tpath.append('LD')\n\t\t\ts_column -= 1\n\t\t\ts_row -= 1\n\t\telse:\n\t\t\tpath.append('LU')\n\t\t\ts_column += 1\n\t\t\ts_row -= 1\n\telif diff_column(s_column, f_column) > 0:\n\t\tpath.append('RD')\n\t\ts_column -= 1\n\t\ts_row += 1\n\telse:\n\t\tpath.append('RU')\n\t\ts_column += 1\n\t\ts_row += 1\nprint(iterations)\nfor i in path:\n\tprint(i)\n",
        "start = input()\nend = input()\nend0 = ord(end[0])\nend1 = ord(end[1])\nstart0 = ord(start[0])\nstart1 = ord(start[1])\ns0 = end0 - start0\ns1 = end1 - start1\ncount = 0\nmoves = []\nwhile s0 != 0 or s1 != 0:\n\tif s0 > 0:\n\t\tstart0 += 1\n\t\tmove0 = 'R'\n\t\tif s1 > 0:\n\t\t\tstart1 += 1\n\t\t\tmove1 = 'U'\n\t\telif s1 == 0:\n\t\t\tmove1 = ''\n\t\telse:\n\t\t\tstart1 -= 1\n\t\t\tmove1 = 'D'\n\t\tmoves.append(move0 + move1)\n\telif s0 == 0:\n\t\tmove0 = ''\n\t\tif s1 > 0:\n\t\t\tstart1 += 1\n\t\t\tmove1 = 'U'\n\t\telif s1 == 0:\n\t\t\tmove1 = ''\n\t\telse:\n\t\t\tstart1 -= 1\n\t\t\tmove1 = 'D'\n\t\tmoves.append(move0 + move1)\n\telse:\n\t\tstart0 -= 1\n\t\tmove0 = 'L'\n\t\tif s1 > 0:\n\t\t\tstart1 += 1\n\t\t\tmove1 = 'U'\n\t\telif s1 == 0:\n\t\t\tmove1 = ''\n\t\telse:\n\t\t\tstart1 -= 1\n\t\t\tmove1 = 'D'\n\t\tmoves.append(move0 + move1)\n\tcount += 1\n\ts0 = end0 - start0\n\ts1 = end1 - start1\nprint(count)\nfor i in range(len(moves)):\n\tprint(moves[i])\n",
        "s = input()\nt = input()\nd1 = 'L' if s[0] > t[0] else 'R'\nd2 = 'D' if s[1] > t[1] else 'U'\n(diff1, diff2) = (abs(ord(s[0]) - ord(t[0])), abs(ord(s[1]) - ord(t[1])))\nprint(max(diff1, diff2))\nwhile diff1 > 0 or diff2 > 0:\n\tif diff1 > 0:\n\t\tprint(d1, end='')\n\t\tdiff1 -= 1\n\tif diff2 > 0:\n\t\tprint(d2, end='')\n\t\tdiff2 -= 1\n\tprint()\n",
        "count = 0\nlist = [] * 0\nara1 = str(input())\nx1 = ord(ara1[0]) - ord('a')\ny1 = int(ara1[1])\nara2 = str(input())\nx2 = ord(ara2[0]) - ord('a')\ny2 = int(ara2[1])\nwhile x1 != x2 or y1 != y2:\n\tstr = ''\n\tif x1 > x2:\n\t\tstr = 'L'\n\t\tx1 -= 1\n\telif x1 < x2:\n\t\tstr = 'R'\n\t\tx1 += 1\n\tif y1 < y2:\n\t\tstr += 'U'\n\t\ty1 += 1\n\telif y1 > y2:\n\t\tstr += 'D'\n\t\ty1 -= 1\n\tlist.append(str)\n\tcount += 1\nprint(count)\nfor string in list:\n\tprint(string)\n",
        "adj = [[1, 8, 9], [0, 8, 9, 10, 2], [1, 9, 10, 11, 3], [2, 10, 11, 12, 4], [3, 11, 12, 13, 5], [4, 12, 13, 14, 6], [5, 13, 14, 15, 7], [6, 14, 15], [0, 1, 9, 17, 16], [0, 1, 2, 10, 18, 17, 16, 8], [1, 2, 3, 11, 19, 18, 17, 9], [2, 3, 4, 12, 20, 19, 18, 10], [3, 4, 5, 13, 21, 20, 19, 11], [4, 5, 6, 14, 22, 21, 20, 12], [5, 6, 7, 15, 23, 22, 21, 13], [7, 6, 14, 22, 23], [8, 9, 17, 25, 24], [8, 9, 10, 18, 26, 25, 24, 16], [9, 10, 11, 19, 27, 26, 25, 17], [10, 11, 12, 20, 28, 27, 26, 18], [11, 12, 13, 21, 29, 28, 27, 19], [12, 13, 14, 22, 30, 29, 28, 20], [13, 14, 15, 23, 31, 30, 29, 21], [15, 14, 22, 30, 31], [16, 17, 25, 33, 32], [16, 17, 18, 26, 34, 33, 32, 24], [17, 18, 19, 27, 35, 34, 33, 25], [18, 19, 20, 28, 36, 35, 34, 26], [19, 20, 21, 29, 37, 36, 35, 27], [20, 21, 22, 30, 38, 37, 36, 28], [21, 22, 23, 31, 39, 38, 37, 29], [23, 22, 30, 38, 39], [24, 25, 33, 41, 40], [24, 25, 26, 34, 42, 41, 40, 32], [25, 26, 27, 35, 43, 42, 41, 33], [26, 27, 28, 36, 44, 43, 42, 34], [27, 28, 29, 37, 45, 44, 43, 35], [28, 29, 30, 38, 46, 45, 44, 36], [29, 30, 31, 39, 47, 46, 45, 37], [31, 30, 38, 46, 47], [32, 33, 41, 49, 48], [32, 33, 34, 42, 50, 49, 48, 40], [33, 34, 35, 43, 51, 50, 49, 41], [34, 35, 36, 44, 52, 51, 50, 42], [35, 36, 37, 45, 53, 52, 51, 43], [36, 37, 38, 46, 54, 53, 52, 44], [37, 38, 39, 47, 55, 54, 53, 45], [39, 38, 46, 54, 55], [40, 41, 49, 57, 56], [40, 41, 42, 50, 58, 57, 56, 48], [41, 42, 43, 51, 59, 58, 57, 49], [42, 43, 44, 52, 60, 59, 58, 50], [43, 44, 45, 53, 61, 60, 59, 51], [44, 45, 46, 54, 62, 61, 60, 52], [45, 46, 47, 55, 63, 62, 61, 53], [47, 46, 54, 62, 63], [48, 49, 57], [56, 48, 49, 50, 58], [57, 49, 50, 51, 59], [58, 50, 51, 52, 60], [59, 51, 52, 53, 61], [60, 52, 53, 54, 62], [61, 53, 54, 55, 63], [55, 54, 62]]\nG = {}\nfor i in range(len(adj)):\n\ttemp = {}\n\tfor j in adj[i]:\n\t\ttemp[j] = 1\n\tG[i] = temp\nboard = [[56, 57, 58, 59, 60, 61, 62, 63], [48, 49, 50, 51, 52, 53, 54, 55], [40, 41, 42, 43, 44, 45, 46, 47], [32, 33, 34, 35, 36, 37, 38, 39], [24, 25, 26, 27, 28, 29, 30, 31], [16, 17, 18, 19, 20, 21, 22, 23], [8, 9, 10, 11, 12, 13, 14, 15], [0, 1, 2, 3, 4, 5, 6, 7]]\nw = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\n\ndef coord_to_word(l):\n\treturn board[int(l[1]) - 1][w[l[0]]]\n\ndef command(a, b):\n\tif a - 9 == b:\n\t\treturn 'LU'\n\telif a - 8 == b:\n\t\treturn 'U'\n\telif a - 7 == b:\n\t\treturn 'RU'\n\telif a + 1 == b:\n\t\treturn 'R'\n\telif a + 9 == b:\n\t\treturn 'RD'\n\telif a + 8 == b:\n\t\treturn 'D'\n\telif a + 7 == b:\n\t\treturn 'LD'\n\telif a - 1 == b:\n\t\treturn 'L'\nN = len(G)\nt = []\np = {}\nb = {}\nv = None\ne = None\ns = []\n\ndef dijkstra(v, p, t, b, e):\n\tfor x in G[v]:\n\t\txm = p[v] + G[v][x]\n\t\tif not x in p:\n\t\t\tp[x] = xm\n\t\t\tb[x] = v\n\t\telif not x in t:\n\t\t\tif p[x] > xm:\n\t\t\t\tp[x] = xm\n\t\t\t\tb[x] = v\n\tt.append(v)\n\tif N <= len(t):\n\t\ts.insert(0, e)\n\t\twhile True:\n\t\t\tif b[e] == -1:\n\t\t\t\tbreak\n\t\t\te = b[e]\n\t\t\ts.insert(0, e)\n\t\treturn s\n\tfor d in p:\n\t\tif d not in t:\n\t\t\tdm = p[d]\n\t\t\tbreak\n\tfor y in p:\n\t\tif p[y] < dm and (not y in t):\n\t\t\tdm = p[y]\n\t\t\td = y\n\tv = d\n\tdijkstra(v, p, t, b, e)\n\ndef start_v(start, end):\n\tv = start\n\te = end\n\tp[v] = 0\n\tb[v] = -1\n\treturn (v, p, b, e)\nA = coord_to_word(input())\nB = coord_to_word(input())\n(v, p, b, e) = start_v(A, B)\ndijkstra(v, p, t, b, e)\nprint(len(s) - 1)\nfor i in range(0, len(s) - 1):\n\tprint(command(s[i], s[i + 1]))\n",
        "def printing(count, string):\n\tfor x in range(count):\n\t\tprint(string)\n\ndef main():\n\tstart = list(input())\n\tend = list(input())\n\talphabet = list('abcdefgh')\n\tstart[0] = alphabet.index(start[0])\n\tend[0] = alphabet.index(end[0])\n\tstart[1] = int(start[1])\n\tend[1] = int(end[1])\n\thorizontal = abs(start[0] - end[0])\n\tvertical = abs(start[1] - end[1])\n\tmoves = max(horizontal, vertical)\n\tprint(moves)\n\tif start[0] < end[0]:\n\t\tstr1 = 'R'\n\t\tbo1 = True\n\telif start[0] > end[0]:\n\t\tstr1 = 'L'\n\t\tbo1 = True\n\telse:\n\t\tbo1 = False\n\tif start[1] < end[1]:\n\t\tstr2 = 'U'\n\t\tbo2 = True\n\telif start[1] > end[1]:\n\t\tstr2 = 'D'\n\t\tbo2 = True\n\telse:\n\t\tbo2 = False\n\tif bo1:\n\t\tif bo2:\n\t\t\tdouble = str1 + str2\n\t\t\tif vertical > horizontal:\n\t\t\t\tsingle = str2\n\t\t\telse:\n\t\t\t\tsingle = str1\n\t\t\tprinting(min(horizontal, vertical), double)\n\t\t\tprinting(abs(vertical - horizontal), single)\n\t\telse:\n\t\t\tfor x in range(horizontal):\n\t\t\t\tprint(str1)\n\telif bo2:\n\t\tfor x in range(vertical):\n\t\t\tprint(str2)\n\telse:\n\t\treturn None\nmain()\n",
        "s = input()\nt = input()\nl = []\ncount = 0\nwhile s != t:\n\tif s[0] == t[0]:\n\t\tif int(s[1]) > int(t[1]):\n\t\t\tl.append('D')\n\t\t\ts = s[0] + str(int(s[1]) - 1)\n\t\t\tcount += 1\n\t\telif int(s[1]) < int(t[1]):\n\t\t\tl.append('U')\n\t\t\ts = s[0] + str(int(s[1]) + 1)\n\t\t\tcount += 1\n\telif s[1] == t[1]:\n\t\tif s[0] > t[0]:\n\t\t\tl.append('L')\n\t\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\t\tcount += 1\n\t\telif s[0] < t[0]:\n\t\t\tl.append('R')\n\t\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\t\tcount += 1\n\telif s[0] > t[0] and int(s[1]) < int(t[1]):\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\ts = s[0] + str(int(s[1]) + 1)\n\t\tl.append('LU')\n\t\tcount += 1\n\telif s[0] > t[0] and int(s[1]) > int(t[1]):\n\t\ts = chr(ord(s[0]) - 1) + s[1]\n\t\ts = s[0] + str(int(s[1]) - 1)\n\t\tl.append('LD')\n\t\tcount += 1\n\telif s[0] < t[0] and int(s[1]) < int(t[1]):\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\ts = s[0] + str(int(s[1]) + 1)\n\t\tl.append('RU')\n\t\tcount += 1\n\telif s[0] < t[0] and int(s[1]) > int(t[1]):\n\t\ts = chr(ord(s[0]) + 1) + s[1]\n\t\ts = s[0] + str(int(s[1]) - 1)\n\t\tl.append('RD')\n\t\tcount += 1\nprint(count)\nif len(l) != 0:\n\tprint('\\n'.join(l))\n",
        "a = input()\nb = input()\nx1 = ord(a[0]) - ord('a')\ny1 = ord(a[1]) - ord('1')\nx2 = ord(b[0]) - ord('a')\ny2 = ord(b[1]) - ord('1')\nsteps = []\nwhile not (x1 == x2 and y1 == y2):\n\tif x1 != x2 and y1 != y2:\n\t\th = None\n\t\tif x1 < x2:\n\t\t\tx1 += 1\n\t\t\th = 'R'\n\t\telse:\n\t\t\tx1 -= 1\n\t\t\th = 'L'\n\t\tif y1 < y2:\n\t\t\ty1 += 1\n\t\t\tv = 'U'\n\t\telse:\n\t\t\ty1 -= 1\n\t\t\tv = 'D'\n\t\tsteps.append(h + v)\n\telif x1 != x2:\n\t\tif x1 < x2:\n\t\t\tx1 += 1\n\t\t\tsteps.append('R')\n\t\telse:\n\t\t\tx1 -= 1\n\t\t\tsteps.append('L')\n\telif y1 < y2:\n\t\ty1 += 1\n\t\tsteps.append('U')\n\telse:\n\t\ty1 -= 1\n\t\tsteps.append('D')\nprint(len(steps))\nfor step in steps:\n\tprint(step)\n",
        "p = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ns = input()\nt = input()\nx_dif = p.index(t[0]) - p.index(s[0])\ny_dif = int(t[1]) - int(s[1])\n(x, y) = (abs(x_dif), abs(y_dif))\ncount = max(x, y)\nprint(count)\nif x_dif < 0:\n\thmove = 'L'\nelse:\n\thmove = 'R'\nif y_dif < 0:\n\tvmove = 'D'\nelse:\n\tvmove = 'U'\nz = min(x, y)\nfor i in range(z):\n\tprint(str(hmove) + str(vmove))\nif y == count:\n\tfor i in range(count - z):\n\t\tprint(vmove)\nelse:\n\tfor i in range(count - z):\n\t\tprint(hmove)\n",
        "st = input()\nend = input()\nhor = ord(end[0]) - ord(st[0])\nver = ord(end[1]) - ord(st[1])\nif hor > 0:\n\th = 'R'\nelse:\n\th = 'L'\nif ver > 0:\n\tv = 'U'\nelse:\n\tv = 'D'\nhor = abs(hor)\nver = abs(ver)\nn = max(hor, ver)\narr_hor = [h for i in range(hor)]\narr_ver = [v for i in range(ver)]\nif ver > hor:\n\tarr_hor = arr_hor + ['' for i in range(ver - hor)]\nelse:\n\tarr_ver = arr_ver + ['' for i in range(hor - ver)]\nprint(n)\nfor i in range(n):\n\tprint(arr_hor[i], arr_ver[i], sep='')\n",
        "n = input()\ns = input()\na = ord(n[0]) - ord(s[0])\nb = int(n[1]) - int(s[1])\nprint(max(-a, -b, a, b))\nwhile a != 0 or b != 0:\n\tans = ''\n\tif a > 0:\n\t\tans += 'L'\n\t\ta -= 1\n\tif a < 0:\n\t\tans += 'R'\n\t\ta += 1\n\tif b > 0:\n\t\tans += 'D'\n\t\tb -= 1\n\tif b < 0:\n\t\tans += 'U'\n\t\tb += 1\n\tprint(ans)\n",
        "def get_pos(s: str):\n\tx = s[0]\n\ty = s[1]\n\tif not x.isdigit():\n\t\tx = str(ord(x) - ord('a') + 1)\n\tif not y.isdigit():\n\t\ty = str(ord(y) - ord('a') + 1)\n\treturn (int(x), int(y))\n\ndef solve(start, end):\n\t(start_x, start_y) = get_pos(start)\n\t(end_x, end_y) = get_pos(end)\n\tmin_val = 100000000\n\tres = []\n\twhile start_x != end_x or start_y != end_y:\n\t\tarr = [(start_x, start_y + 1, 'U'), (start_x, start_y - 1, 'D'), (start_x - 1, start_y, 'L'), (start_x + 1, start_y, 'R'), (start_x - 1, start_y - 1, 'LD'), (start_x - 1, start_y + 1, 'LU'), (start_x + 1, start_y - 1, 'RD'), (start_x + 1, start_y + 1, 'RU')]\n\t\tselected_min = None\n\t\tfor ver in arr:\n\t\t\tif ((ver[0] - end_x) ** 2 + (ver[1] - end_y) ** 2) ** 0.5 < min_val:\n\t\t\t\tmin_val = ((ver[0] - end_x) ** 2 + (ver[1] - end_y) ** 2) ** 0.5\n\t\t\t\tselected_min = ver\n\t\t\t\tstart_x = ver[0]\n\t\t\t\tstart_y = ver[1]\n\t\tres.append(selected_min[2])\n\tprint(len(res))\n\tprint(*res, sep='\\n')\n\ndef main():\n\tstart = input()\n\tend = input()\n\tsolve(start, end)\nmain()\n",
        "a = input()\nb = input()\nc = ord(b[0]) - ord(a[0])\nd = int(b[1]) - int(a[1])\nz = []\nwhile c != 0 or d != 0:\n\tk = ''\n\tif c < 0:\n\t\tk += 'L'\n\t\tc += 1\n\telif c > 0:\n\t\tk += 'R'\n\t\tc -= 1\n\tif d < 0:\n\t\tk += 'D'\n\t\td += 1\n\telif d > 0:\n\t\tk += 'U'\n\t\td -= 1\n\tz += [k]\nprint(len(z))\n[print(i) for i in z]\n",
        "(s, e) = (input(), input())\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\ne = [ord(e[0]) - ord('a') + 1, int(e[1])]\nres = max(abs(s[0] - e[0]), abs(s[1] - e[1]))\nprint(res)\nwhile s[0] != e[0] or s[1] != e[1]:\n\tres = ''\n\tif s[0] > e[0]:\n\t\tres += 'L'\n\t\ts[0] -= 1\n\telif s[0] < e[0]:\n\t\tres += 'R'\n\t\ts[0] += 1\n\tif s[1] > e[1]:\n\t\tres += 'D'\n\t\ts[1] -= 1\n\telif s[1] < e[1]:\n\t\tres += 'U'\n\t\ts[1] += 1\n\tprint(res)\n",
        "from itertools import accumulate as ac\nfrom collections import Counter as cc\nfrom bisect import bisect_left as bsl\nfrom bisect import bisect as bs\nfrom math import factorial as f\nfrom collections import *\nfrom itertools import *\nfrom string import *\nfrom bisect import *\nfrom queue import *\nfrom heapq import *\nfrom math import *\nfrom sys import *\nfrom re import *\n\ndef fast():\n\treturn stdin.readline().strip()\n\ndef zzz():\n\treturn [int(i) for i in fast().split()]\n(z, zz) = (input, lambda : list(map(int, z().split())))\n(szz, graph, mod, szzz) = (lambda : sorted(zz()), {}, 10 ** 9 + 7, lambda : sorted(zzz()))\n\ndef lcd(xnum1, xnum2):\n\treturn xnum1 * xnum2 // gcd(xnum1, xnum2)\n\ndef output(answer):\n\tstdout.write(str(answer))\nWIDTH = 600\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 255, 0)\nYELLOW = (255, 255, 0)\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nPURPLE = (128, 0, 128)\nORANGE = (255, 165, 0)\nGREY = (128, 128, 128)\nTURQUOISE = (64, 224, 208)\n\nclass Spot:\n\n\tdef __init__(self, row, col, width, total_rows):\n\t\tself.row = row\n\t\tself.col = col\n\t\tself.x = row * width\n\t\tself.y = col * width\n\t\tself.color = WHITE\n\t\tself.neighbors = []\n\t\tself.width = width\n\t\tself.total_rows = total_rows\n\n\tdef get_pos(self):\n\t\treturn (self.row, self.col)\n\n\tdef is_closed(self):\n\t\treturn self.color == RED\n\n\tdef is_open(self):\n\t\treturn self.color == GREEN\n\n\tdef is_barrier(self):\n\t\treturn self.color == BLACK\n\n\tdef is_start(self):\n\t\treturn self.color == ORANGE\n\n\tdef is_end(self):\n\t\treturn self.color == TURQUOISE\n\n\tdef reset(self):\n\t\tself.color = WHITE\n\n\tdef make_start(self):\n\t\tself.color = ORANGE\n\n\tdef make_closed(self):\n\t\tself.color = RED\n\n\tdef make_open(self):\n\t\tself.color = GREEN\n\n\tdef make_barrier(self):\n\t\tself.color = BLACK\n\n\tdef make_end(self):\n\t\tself.color = TURQUOISE\n\n\tdef make_path(self):\n\t\tself.color = PURPLE\n\n\tdef update_neighbors(self, grid):\n\t\tself.neighbors = []\n\t\tif self.row < self.total_rows - 1:\n\t\t\tself.neighbors.append(grid[self.row + 1][self.col])\n\t\tif self.row > 0:\n\t\t\tself.neighbors.append(grid[self.row - 1][self.col])\n\t\tif self.row < self.total_rows - 1 and self.col < self.total_rows - 1:\n\t\t\tself.neighbors.append(grid[self.row + 1][self.col + 1])\n\t\tif self.row > 0 and self.col > 0:\n\t\t\tself.neighbors.append(grid[self.row - 1][self.col - 1])\n\t\tif self.row > 0 and self.col < self.total_rows - 1:\n\t\t\tself.neighbors.append(grid[self.row - 1][self.col + 1])\n\t\tif self.row < self.total_rows - 1 and self.col > 0:\n\t\t\tself.neighbors.append(grid[self.row + 1][self.col - 1])\n\t\tif self.col < self.total_rows - 1:\n\t\t\tself.neighbors.append(grid[self.row][self.col + 1])\n\t\tif self.col > 0:\n\t\t\tself.neighbors.append(grid[self.row][self.col - 1])\n\n\tdef __lt__(self, other):\n\t\treturn False\n\ndef h(p1, p2):\n\t(x1, y1) = p1\n\t(x2, y2) = p2\n\treturn abs(x1 - x2) + abs(y1 - y2)\n\ndef reconstruct_path(came_from, current):\n\tlst = []\n\twhile current in came_from:\n\t\tcurrent = came_from[current]\n\t\tcurrent.make_path()\n\t\tlst.append(current.get_pos())\n\treturn lst\n\ndef algorithm(grid, start, end):\n\tcount = 0\n\topen_set = PriorityQueue()\n\topen_set.put((0, count, start))\n\tcame_from = {}\n\tg_score = {spot: float('inf') for row in grid for spot in row}\n\tg_score[start] = 0\n\tf_score = {spot: float('inf') for row in grid for spot in row}\n\tf_score[start] = h(start.get_pos(), end.get_pos())\n\topen_set_hash = {start}\n\twhile not open_set.empty():\n\t\tcurrent = open_set.get()[2]\n\t\topen_set_hash.remove(current)\n\t\tif current == end:\n\t\t\tlst = reconstruct_path(came_from, end)\n\t\t\tend.make_end()\n\t\t\treturn lst\n\t\tfor neighbor in current.neighbors:\n\t\t\ttemp_g_score = g_score[current] + 1\n\t\t\tif temp_g_score < g_score[neighbor]:\n\t\t\t\tcame_from[neighbor] = current\n\t\t\t\tg_score[neighbor] = temp_g_score\n\t\t\t\tf_score[neighbor] = temp_g_score + h(neighbor.get_pos(), end.get_pos())\n\t\t\t\tif neighbor not in open_set_hash:\n\t\t\t\t\tcount += 1\n\t\t\t\t\topen_set.put((f_score[neighbor], count, neighbor))\n\t\t\t\t\topen_set_hash.add(neighbor)\n\t\t\t\t\tneighbor.make_open()\n\t\tif current != start:\n\t\t\tcurrent.make_closed()\n\treturn False\n\ndef make_grid(rows, width):\n\tgrid = []\n\tgap = width // rows\n\tfor i in range(rows):\n\t\tgrid.append([])\n\t\tfor j in range(rows):\n\t\t\tspot = Spot(i, j, gap, rows)\n\t\t\tgrid[i].append(spot)\n\treturn grid\nROWS = 8\ngrid = make_grid(ROWS, WIDTH)\none = fast()\nspot = grid[ord(one[0]) - 97][int(one[1]) - 1]\nstart = spot\nstart.make_start()\ntwo = fast()\nspot = grid[ord(two[0]) - 97][int(two[1]) - 1]\nend = spot\nend.make_end()\nfor row in grid:\n\tfor spot in row:\n\t\tspot.update_neighbors(grid)\nres = algorithm(grid, start, end)[::-1]\nprev = start.get_pos()\nprint(len(res))\nres = res + [end.get_pos()]\nfor i in range(len(res)):\n\ti = res[i]\n\tif i[0] > prev[0] and i[1] > prev[1]:\n\t\tprint('RU')\n\telif i[0] < prev[0] and i[1] < prev[1]:\n\t\tprint('LD')\n\telif i[0] > prev[0] and i[1] == prev[1]:\n\t\tprint('R')\n\telif i[0] < prev[0] and i[1] == prev[1]:\n\t\tprint('L')\n\telif i[0] == prev[0] and i[1] > prev[1]:\n\t\tprint('U')\n\telif i[0] == prev[0] and i[1] < prev[1]:\n\t\tprint('D')\n\telif i[0] > prev[0] and i[1] < prev[1]:\n\t\tprint('RD')\n\telif i[0] < prev[0] and i[1] > prev[1]:\n\t\tprint('LU')\n\tprev = i\n",
        "start = input()\nfinish = input()\n(start_col, start_row) = start\nstart_col = ord(start_col) - 96\nstart_row = int(start_row)\n(finish_col, finish_row) = finish\nfinish_col = ord(finish_col) - 96\nfinish_row = int(finish_row)\nstep_col = finish_col - start_col\nstep_row = finish_row - start_row\nsteps_count = 0\nif abs(step_col) >= abs(step_row):\n\tsteps_count = step_col\nelse:\n\tsteps_count = step_row\nlettet_x = []\nif step_col < 0:\n\tlettet_x = ['L'] * abs(step_col)\nif step_col > 0:\n\tlettet_x = ['R'] * abs(step_col)\nlettet_y = []\nif step_row < 0:\n\tlettet_y = ['D'] * abs(step_row)\nif step_row > 0:\n\tlettet_y = ['U'] * abs(step_row)\nlen_lettet_x = len(lettet_x)\nlen_lettet_y = len(lettet_y)\nif len_lettet_x > len_lettet_y:\n\tlettet_y = lettet_y + [''] * (len_lettet_x - len_lettet_y)\nelse:\n\tlettet_x = lettet_x + [''] * (len_lettet_y - len_lettet_x)\nsteps = map(lambda x, y: x + y, lettet_x, lettet_y)\nprint(abs(steps_count))\nfor s in steps:\n\tprint(s)\n",
        "m = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\ndef sign(x):\n\tif x < 0:\n\t\treturn -1\n\telif x > 0:\n\t\treturn 1\n\telse:\n\t\treturn 0\nstart = input()\nfinish = input()\nsi = int(start[1])\nsj = m[start[0]]\nfi = int(finish[1])\nfj = m[finish[0]]\ndi = sign(fi - si)\ndj = sign(fj - sj)\n(i, j) = (si, sj)\nout = ''\ncount = 0\nwhile i != fi or j != fj:\n\tbuff = ''\n\tif dj < 0:\n\t\tbuff += 'L'\n\telif dj > 0:\n\t\tbuff += 'R'\n\tif di < 0:\n\t\tbuff += 'D'\n\telif di > 0:\n\t\tbuff += 'U'\n\tout = out + buff + '\\n'\n\tcount += 1\n\ti += di\n\tif i == fi:\n\t\tdi = 0\n\tj += dj\n\tif j == fj:\n\t\tdj = 0\nprint(count)\nprint(out.rstrip())\n",
        "start = input()\nfinal = input()\ncount = []\nans = []\nl = {'hor': 0, 'ver': 0}\nl['hor'] = ord(final[0]) - 96 - (ord(start[0]) - 96)\nl['ver'] = int(final[1]) - int(start[1])\nif l['hor'] > 0:\n\tans.append('R')\nelse:\n\tans.append('L')\nif l['ver'] > 0:\n\tans.append('U')\nelse:\n\tans.append('D')\nl['hor'] = abs(l['hor'])\nl['ver'] = abs(l['ver'])\nwhile l['hor'] != 0 or l['ver'] != 0:\n\tif l['hor'] > 0 and l['ver'] > 0:\n\t\tl['hor'] -= 1\n\t\tl['ver'] -= 1\n\t\tcount.append(ans[0] + ans[1])\n\telif l['hor'] > 0:\n\t\tl['hor'] -= 1\n\t\tcount.append(ans[0])\n\telse:\n\t\tl['ver'] -= 1\n\t\tcount.append(ans[1])\nprint(len(count))\nfor i in count:\n\tprint(i)\n",
        "import sys\n(x1, y1) = next(sys.stdin).strip()\n(x1, y1) = (ord(x1) - 97, int(y1) - 1)\n(x2, y2) = next(sys.stdin).strip()\n(x2, y2) = (ord(x2) - 97, int(y2) - 1)\n(x, y) = (x1, y1)\nactions = []\nwhile not (x == x2 and y == y2):\n\tdiag = x != x2 and y != y2\n\tvert = x == x2 and y != y2\n\thori = x != x2 and y == y2\n\tif diag:\n\t\tif x > x2 and y > y2:\n\t\t\tactions.append('LD')\n\t\t\tx -= 1\n\t\t\ty -= 1\n\t\telif x < x2 and y < y2:\n\t\t\tactions.append('RU')\n\t\t\tx += 1\n\t\t\ty += 1\n\t\telif x > x2 and y < y2:\n\t\t\tactions.append('LU')\n\t\t\tx -= 1\n\t\t\ty += 1\n\t\telse:\n\t\t\tactions.append('RD')\n\t\t\tx += 1\n\t\t\ty -= 1\n\telif vert:\n\t\tif y > y2:\n\t\t\tactions.append('D')\n\t\t\ty -= 1\n\t\telse:\n\t\t\tactions.append('U')\n\t\t\ty += 1\n\telif x > x2:\n\t\tactions.append('L')\n\t\tx -= 1\n\telse:\n\t\tactions.append('R')\n\t\tx += 1\nprint(len(actions))\nfor action in actions:\n\tprint(action)\n",
        "scr = input()\ndis = input()\ns = [ord(scr[0]), int(scr[1])]\nd = [ord(dis[0]), int(dis[1])]\nans = []\nk = 0\nif s[0] < d[0] and s[1] > d[1]:\n\twhile s[0] < d[0] and s[1] > d[1]:\n\t\tk += 1\n\t\tans.append('RD')\n\t\ts[0] += 1\n\t\ts[1] -= 1\nif s[0] > d[0] and s[1] > d[1]:\n\twhile s[0] > d[0] and s[1] > d[1]:\n\t\tk += 1\n\t\tans.append('LD')\n\t\ts[0] -= 1\n\t\ts[1] -= 1\nif s[0] > d[0] and s[1] < d[1]:\n\twhile s[0] > d[0] and s[1] < d[1]:\n\t\tk += 1\n\t\tans.append('LU')\n\t\ts[0] -= 1\n\t\ts[1] += 1\nif s[0] < d[0] and s[1] < d[1]:\n\twhile s[0] < d[0] and s[1] < d[1]:\n\t\tk += 1\n\t\tans.append('RU')\n\t\ts[0] += 1\n\t\ts[1] += 1\nif s[0] == d[0]:\n\tif s[1] > d[1]:\n\t\tk += abs(s[1] - d[1])\n\t\tch = 'D' * abs(s[1] - d[1])\n\t\tans.extend(list(ch))\n\tif s[1] < d[1]:\n\t\tk += abs(s[1] - d[1])\n\t\tch = 'U' * abs(s[1] - d[1])\n\t\tans.extend(list(ch))\nif s[1] == d[1]:\n\tif s[0] > d[0]:\n\t\tk += abs(s[0] - d[0])\n\t\tch = 'L' * abs(s[0] - d[0])\n\t\tans.extend(list(ch))\n\tif s[0] < d[0]:\n\t\tk += abs(s[0] - d[0])\n\t\tch = 'R' * abs(s[0] - d[0])\n\t\tans.extend(list(ch))\nprint(k)\nfor x in ans:\n\tprint(x)\n\tprint('\\n')\n",
        "final = []\ncounter = 0\ndict = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7}\ninput1 = input()\ninput2 = input()\nx1 = dict[input1[0]]\nx2 = dict[input2[0]]\nif int(input1[1]) != 0:\n\ty1 = int(input1[1]) - 1\nelse:\n\ty1 = int(input1[1])\nif int(input2[1]) != 0:\n\ty2 = int(input2[1]) - 1\nelse:\n\ty2 = int(input2[1])\nwhile True:\n\taction1 = ''\n\taction2 = ''\n\tif counter == 0:\n\t\tif x1 == x2 and y1 == y2:\n\t\t\tbreak\n\tif x1 > x2:\n\t\tx1 = x1 - 1\n\t\taction1 = 'L'\n\tif x1 < x2:\n\t\tx1 = x1 + 1\n\t\taction1 = 'R'\n\tif y1 > y2:\n\t\ty1 = y1 - 1\n\t\taction2 = 'D'\n\tif y1 < y2:\n\t\ty1 = y1 + 1\n\t\taction2 = 'U'\n\tcounter = counter + 1\n\tfinal.append(action1 + action2)\n\tif x1 == x2 and y1 == y2:\n\t\tbreak\nprint(counter)\nfor f in final:\n\tprint(f)\n",
        "s = input()\nf = input()\nx = ord(s[0]) - ord(f[0])\ny = ord(s[1]) - ord(f[1])\nprint(max(x, y, -x, -y))\nwhile x != 0 or y != 0:\n\tst = ''\n\tif x < 0:\n\t\tst += 'R'\n\t\tx = x + 1\n\tif x > 0:\n\t\tst = st + 'L'\n\t\tx = x - 1\n\tif y < 0:\n\t\tst = st + 'U'\n\t\ty = y + 1\n\tif y > 0:\n\t\tst = st + 'D'\n\t\ty = y - 1\n\tprint(st)\n",
        "a = input()\nb = input()\ne = ord(b[0]) - ord(a[0])\nf = int(b[1]) - int(a[1])\nc = abs(e)\nd = abs(f)\nprint(max(c, d))\ng = min(c, d)\nif e >= 0:\n\tif f >= 0:\n\t\tfor i in range(g):\n\t\t\tprint('RU')\n\t\tif c > d:\n\t\t\tfor i in range(c - d):\n\t\t\t\tprint('R')\n\t\tif c < d:\n\t\t\tfor i in range(d - c):\n\t\t\t\tprint('U')\n\tif f < 0:\n\t\tfor i in range(g):\n\t\t\tprint('RD')\n\t\tif c > d:\n\t\t\tfor i in range(c - d):\n\t\t\t\tprint('R')\n\t\tif c < d:\n\t\t\tfor i in range(d - c):\n\t\t\t\tprint('D')\nif e < 0:\n\tif f >= 0:\n\t\tfor i in range(g):\n\t\t\tprint('LU')\n\t\tif c > d:\n\t\t\tfor i in range(c - d):\n\t\t\t\tprint('L')\n\t\tif c < d:\n\t\t\tfor i in range(d - c):\n\t\t\t\tprint('U')\n\tif f < 0:\n\t\tfor i in range(g):\n\t\t\tprint('LD')\n\t\tif c > d:\n\t\t\tfor i in range(c - d):\n\t\t\t\tprint('L')\n\t\tif c < d:\n\t\t\tfor i in range(d - c):\n\t\t\t\tprint('D')\n",
        "st = input()\nend = input()\nfor i in st:\n\tif i.isalpha():\n\t\tcol1 = ord(i) - 97\n\telse:\n\t\trow1 = 8 - int(i)\nfor i in end:\n\tif i.isalpha():\n\t\tcol2 = ord(i) - 97\n\telse:\n\t\trow2 = 8 - int(i)\ncond1 = 0\ncond2 = 0\ncond3 = 0\ncond4 = 0\nif col2 >= col1 and row2 >= row1:\n\tcond1 = 1\nelif col2 <= col1 and row2 >= row1:\n\tcond2 = 1\nelif col2 >= col1 and row2 <= row1:\n\tcond3 = 1\nelse:\n\tcond4 = 1\ndiff1 = abs(col2 - col1)\ndiff2 = abs(row2 - row1)\nmin = min(diff1, diff2)\nmax = max(diff1, diff2)\nprint(max)\nfor i in range(min):\n\tif cond1:\n\t\tprint('RD')\n\telif cond2:\n\t\tprint('LD')\n\telif cond3:\n\t\tprint('RU')\n\telse:\n\t\tprint('LU')\ndiff = diff1 - diff2\nif diff > 0:\n\tfor i in range(diff):\n\t\tif cond1 or cond3:\n\t\t\tprint('R')\n\t\telse:\n\t\t\tprint('L')\nelse:\n\tfor i in range(abs(diff)):\n\t\tif cond1 or cond2:\n\t\t\tprint('D')\n\t\telse:\n\t\t\tprint('U')\n",
        "cns = '0abcdefgh'\nsp = input()\nep = input()\ncs = cns.index(sp[0])\nrs = int(sp[1])\nce = cns.index(ep[0])\nre = int(ep[1])\npath = []\nsteps = 0\ncn = cs\nrn = rs\nwhile cn != ce or rn != re:\n\tif cn < ce:\n\t\tif rn < re:\n\t\t\tpath.append('RU')\n\t\t\tcn += 1\n\t\t\trn += 1\n\t\telif rn == re:\n\t\t\tpath.append('R')\n\t\t\tcn += 1\n\t\telse:\n\t\t\tpath.append('RD')\n\t\t\tcn += 1\n\t\t\trn -= 1\n\telif cn > ce:\n\t\tif rn < re:\n\t\t\tpath.append('LU')\n\t\t\tcn -= 1\n\t\t\trn += 1\n\t\telif rn == re:\n\t\t\tpath.append('L')\n\t\t\tcn -= 1\n\t\telse:\n\t\t\tpath.append('LD')\n\t\t\tcn -= 1\n\t\t\trn -= 1\n\telif rn < re:\n\t\tpath.append('U')\n\t\trn += 1\n\telse:\n\t\tpath.append('D')\n\t\trn -= 1\n\tsteps += 1\nprint(steps)\nfor m in path:\n\tprint(m)\n",
        "king = input()\nvisit = input()\npart2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ndist1 = abs(int(king[1]) - int(visit[1]))\ndist2 = abs(ord(king[0]) - ord(visit[0]))\ntrue_distance = max(dist1, dist2)\nprint(true_distance)\nwhile king != visit:\n\tif ord(king[0]) < ord(visit[0]):\n\t\tprint('R', end='')\n\t\tking = chr(ord(king[0]) + 1) + king[1]\n\telif ord(king[0]) > ord(visit[0]):\n\t\tprint('L', end='')\n\t\tking = chr(ord(king[0]) - 1) + king[1]\n\tif int(king[1]) < int(visit[1]):\n\t\tprint('U', end='')\n\t\tking = king[0] + str(int(king[1]) + 1)\n\tif int(king[1]) > int(visit[1]):\n\t\tprint('D', end='')\n\t\tking = king[0] + str(int(king[1]) - 1)\n\tprint()\n",
        "import sys\nsrc = list(sys.stdin.readline())[:2]\ndest = list(sys.stdin.readline())[:2]\nans = ''\ncnt = 0\nwhile src != dest:\n\tif dest[0] > src[0]:\n\t\tans += 'R'\n\t\tsrc[0] = chr(ord(src[0]) + 1)\n\telif dest[0] < src[0]:\n\t\tans += 'L'\n\t\tsrc[0] = chr(ord(src[0]) - 1)\n\tif dest[1] > src[1]:\n\t\tans += 'U'\n\t\tsrc[1] = chr(ord(src[1]) + 1)\n\telif dest[1] < src[1]:\n\t\tans += 'D'\n\t\tsrc[1] = chr(ord(src[1]) - 1)\n\tans += '\\n'\n\tcnt += 1\nans = str(cnt) + '\\n' + ans[:-1]\nprint(ans)\n",
        "trans = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\na = list(input())\na[0] = trans[a[0]]\na[1] = int(a[1])\nb = list(input())\nb[0] = trans[b[0]]\nb[1] = int(b[1])\nif a[0] > b[0]:\n\tif a[1] > b[1]:\n\t\tans = ['LD'] * min(abs(a[0] - b[0]), abs(a[1] - b[1]))\n\t\tif abs(a[0] - b[0]) > abs(a[1] - b[1]):\n\t\t\tans += ['L'] * (abs(a[0] - b[0]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\n\t\telif abs(a[0] - b[0]) < abs(a[1] - b[1]):\n\t\t\tans += ['D'] * (abs(a[1] - b[1]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\n\telse:\n\t\tans = ['LU'] * min(abs(a[0] - b[0]), abs(a[1] - b[1]))\n\t\tif abs(a[0] - b[0]) > abs(a[1] - b[1]):\n\t\t\tans += ['L'] * (abs(a[0] - b[0]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\n\t\telif abs(a[0] - b[0]) < abs(a[1] - b[1]):\n\t\t\tans += ['U'] * (abs(a[1] - b[1]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\nelif a[1] > b[1]:\n\tans = ['RD'] * min(abs(a[0] - b[0]), abs(a[1] - b[1]))\n\tif abs(a[0] - b[0]) > abs(a[1] - b[1]):\n\t\tans += ['R'] * (abs(a[0] - b[0]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\n\telif abs(a[0] - b[0]) < abs(a[1] - b[1]):\n\t\tans += ['D'] * (abs(a[1] - b[1]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\nelse:\n\tans = ['RU'] * min(abs(a[0] - b[0]), abs(a[1] - b[1]))\n\tif abs(a[0] - b[0]) > abs(a[1] - b[1]):\n\t\tans += ['R'] * (abs(a[0] - b[0]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\n\telif abs(a[0] - b[0]) < abs(a[1] - b[1]):\n\t\tans += ['U'] * (abs(a[1] - b[1]) - min(abs(a[0] - b[0]), abs(a[1] - b[1])))\nprint(len(ans))\nfor i in ans:\n\tprint(i)\n",
        "(x1, y1) = [ord(i) for i in input()]\n(x2, y2) = [ord(i) for i in input()]\nlr = 'R' if x2 > x1 else 'L'\nud = 'U' if y2 > y1 else 'D'\nr = max(abs(x2 - x1), abs(y2 - y1))\nst = str(r) + '\\r\\n'\nfor i in range(r):\n\tif i >= abs(x2 - x1):\n\t\tlr = ''\n\tif i >= abs(y2 - y1):\n\t\tud = ''\n\tst += lr + ud + '\\r\\n'\nprint(st)\n",
        "import sys\nimport math\nfrom collections import defaultdict\nimport heapq\ntry:\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\nexcept:\n\tpass\n\nclass Graph:\n\n\tdef __init__(self):\n\t\tself.neighbours = defaultdict(list)\n\t\tfor x in range(1, 9):\n\t\t\tfor y in range(1, 9):\n\t\t\t\tfor i in range(-1, 2):\n\t\t\t\t\tfor j in range(-1, 2):\n\t\t\t\t\t\tpos_x = x + i\n\t\t\t\t\t\tpos_y = y + j\n\t\t\t\t\t\tif self.isValid(pos_x, pos_y):\n\t\t\t\t\t\t\tself.addEdge([x, y], [pos_x, pos_y])\n\n\tdef addEdge(self, u, v):\n\t\tpos1 = self.ltos(u)\n\t\tpos2 = self.ltos(v)\n\t\tself.neighbours[pos1].append(pos2)\n\t\tself.neighbours[pos2].append(pos1)\n\n\tdef ltos(self, l):\n\t\treturn str(l[0]) + ':' + str(l[1])\n\n\tdef isValid(self, x, y):\n\t\tif x < 1 or x > 8:\n\t\t\treturn False\n\t\tif y < 1 or y > 8:\n\t\t\treturn False\n\t\treturn True\n\n\tdef stol(self, s):\n\t\treturn [int(s[0]), int(s[2])]\n\n\tdef whatMove(self, move1, move2):\n\t\t(x1, y1) = self.stol(move1)\n\t\t(x2, y2) = self.stol(move2)\n\t\tif x1 == x2:\n\t\t\tif y1 < y2:\n\t\t\t\treturn 'U'\n\t\t\telse:\n\t\t\t\treturn 'D'\n\t\telif y1 == y2:\n\t\t\tif x1 < x2:\n\t\t\t\treturn 'R'\n\t\t\telse:\n\t\t\t\treturn 'L'\n\t\telif x2 == x1 - 1 and y2 == y1 - 1:\n\t\t\treturn 'LD'\n\t\telif x2 == x1 - 1 and y2 == y1 + 1:\n\t\t\treturn 'LU'\n\t\telif x2 == x1 + 1 and y2 == y1 - 1:\n\t\t\treturn 'RD'\n\t\telif x2 == x1 + 1 and y2 == y1 + 1:\n\t\t\treturn 'RU'\n\n\tdef BFS(self, source, destination):\n\t\tsource = self.ltos(source)\n\t\tdestination = self.ltos(destination)\n\t\tvisited = defaultdict(lambda : False)\n\t\tdistance = defaultdict(lambda : float('inf'))\n\t\tdistance[source] = 0\n\t\tvisited[source] = True\n\t\tqueue = [source]\n\t\tparent = defaultdict(lambda : None)\n\t\twhile queue:\n\t\t\tu = queue.pop(0)\n\t\t\tif u == destination:\n\t\t\t\tbreak\n\t\t\tfor v in self.neighbours[u]:\n\t\t\t\tif not visited[v]:\n\t\t\t\t\tvisited[v] = True\n\t\t\t\t\tparent[v] = u\n\t\t\t\t\tdistance[v] = distance[u] + 1\n\t\t\t\t\tqueue.append(v)\n\t\tprint(distance[destination])\n\t\tans = []\n\t\tstart = destination\n\t\twhile parent[start] != None:\n\t\t\tans.append(self.whatMove(parent[start], start))\n\t\t\tstart = parent[start]\n\t\tfor a in ans[::-1]:\n\t\t\tprint(a)\ns = input().strip()\nd = input().strip()\nref = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nsource = [ref[s[0]], int(s[1])]\ndestination = [ref[d[0]], int(d[1])]\ng = Graph()\ng.BFS(source, destination)\n",
        "s1 = str(input())\ns2 = str(input())\n(x0, y0) = (ord(s1[0]), int(s1[1]))\n(x, y) = (ord(s2[0]), int(s2[1]))\nprint(max(abs(x0 - x), abs(y0 - y)))\nwhile True:\n\tif x == x0 and y == y0:\n\t\tbreak\n\tif x > x0:\n\t\tx0 += 1\n\t\tprint('R', end='')\n\tif x < x0:\n\t\tx0 -= 1\n\t\tprint('L', end='')\n\tif y < y0:\n\t\ty0 -= 1\n\t\tprint('D', end='')\n\tif y > y0:\n\t\ty0 += 1\n\t\tprint('U', end='')\n\tprint('', end='\\n')\n",
        "current_pos = input()\nend_pos = input()\n(cX, cY) = (int(ord(current_pos[0]) - ord('a')), int(current_pos[1]))\n(eX, eY) = (int(ord(end_pos[0]) - ord('a')), int(end_pos[1]))\nminMoves = max(abs(cX - eX), abs(cY - eY))\nprint(minMoves)\ndX = cX - eX\ndY = cY - eY\nif dX >= 0 and dY >= 0:\n\tdX = abs(dX)\n\tdY = abs(dY)\n\tdiagonal = min(dX, dY)\n\tprint('LD\\n' * diagonal, end='')\n\tprint('L\\n' * (dX - dY), end='')\n\tprint('D\\n' * (dY - dX), end='')\nelif dX >= 0 and dY <= 0:\n\tdX = abs(dX)\n\tdY = abs(dY)\n\tdiagonal = min(dX, dY)\n\tprint('LU\\n' * diagonal, end='')\n\tprint('L\\n' * (dX - dY), end='')\n\tprint('U\\n' * (dY - dX), end='')\nelif dX <= 0 and dY >= 0:\n\tdX = abs(dX)\n\tdY = abs(dY)\n\tdiagonal = min(dX, dY)\n\tprint('RD\\n' * diagonal, end='')\n\tprint('R\\n' * (dX - dY), end='')\n\tprint('D\\n' * (dY - dX), end='')\nelif dX <= 0 and dY <= 0:\n\tdX = abs(dX)\n\tdY = abs(dY)\n\tdiagonal = min(dX, dY)\n\tprint('RU\\n' * diagonal, end='')\n\tprint('R\\n' * (dX - dY), end='')\n\tprint('U\\n' * (dY - dX), end='')\n",
        "c = ' abcdefgh'\ns = input()\ns = [c.index(s[0]), int(s[1])]\nt = input()\nt = [c.index(t[0]), int(t[1])]\nst = ''\nif s[0] < t[0] and s[1] < t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\tst += 'RU\\n'\n\t\ts[0] += 1\n\t\ts[1] += 1\n\tif s[0] == t[0]:\n\t\tfor i in range(t[1] - s[1]):\n\t\t\tst += 'U\\n'\n\telif s[1] == t[1]:\n\t\tfor i in range(t[0] - s[0]):\n\t\t\tst += 'R\\n'\nelif s[0] < t[0] and s[1] == t[1]:\n\tfor i in range(t[0] - s[0]):\n\t\tst += 'R\\n'\nelif s[0] < t[0] and s[1] > t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\tst += 'RD\\n'\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\tif s[0] == t[0]:\n\t\tfor i in range(s[1] - t[1]):\n\t\t\tst += 'D\\n'\n\telif s[1] == t[1]:\n\t\tfor i in range(t[0] - s[0]):\n\t\t\tst += 'R\\n'\nelif s[0] == t[0] and s[1] < t[1]:\n\tfor i in range(t[1] - s[1]):\n\t\tst += 'U\\n'\nelif s[0] == t[0] and s[1] > t[1]:\n\tfor i in range(s[1] - t[1]):\n\t\tst += 'U\\n'\nelif s[0] > t[0] and s[1] < t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\tst += 'LU\\n'\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\tif s[0] == t[0]:\n\t\tfor i in range(t[1] - s[1]):\n\t\t\tst += 'U\\n'\n\telif s[1] == t[1]:\n\t\tfor i in range(s[0] - t[0]):\n\t\t\tst += 'L\\n'\nelif s[0] > t[0] and s[1] == t[1]:\n\tfor i in range(s[0] - t[0]):\n\t\tst += 'L\\n'\nelif s[0] > t[0] and s[1] > t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\tst += 'LD\\n'\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\tif s[0] == t[0]:\n\t\tfor i in range(s[1] - t[1]):\n\t\t\tst += 'D\\n'\n\telif s[1] == t[1]:\n\t\tfor i in range(s[0] - t[0]):\n\t\t\tst += 'L\\n'\nprint(st.count('\\n'))\nprint(st)\n",
        "s = input()\nt = input()\ns1 = s[0]\ns2 = s[1]\nt1 = t[0]\nt2 = t[1]\nhorizontalDistance = abs(ord(s1) - ord(t1))\nverticalDistance = abs(int(s2) - int(t2))\nminSteps = verticalDistance if verticalDistance > horizontalDistance else horizontalDistance\nhdCounter = 0\nvdCounter = 0\nhd = ord(s1) - ord(t1)\nvd = int(s2) - int(t2)\nprint(minSteps)\nfor i in range(minSteps):\n\tstep = ''\n\tif hd > 0 and hd > hdCounter:\n\t\tstep += 'L'\n\t\thdCounter += 1\n\telif hd < 0 and abs(hd) > hdCounter:\n\t\tstep += 'R'\n\t\thdCounter += 1\n\tif vd > 0 and vd > vdCounter:\n\t\tstep += 'D'\n\t\tvdCounter += 1\n\telif vd < 0 and abs(vd) > vdCounter:\n\t\tstep += 'U'\n\t\tvdCounter += 1\n\tprint(step)\n",
        "def letter_to_num(letter):\n\tif letter == 'a':\n\t\treturn 1\n\tif letter == 'b':\n\t\treturn 2\n\tif letter == 'c':\n\t\treturn 3\n\tif letter == 'd':\n\t\treturn 4\n\tif letter == 'e':\n\t\treturn 5\n\tif letter == 'f':\n\t\treturn 6\n\tif letter == 'g':\n\t\treturn 7\n\tif letter == 'h':\n\t\treturn 8\nfr = input()\nto = input()\nx1 = letter_to_num(fr[0])\ny1 = int(fr[1])\nx2 = letter_to_num(to[0])\ny2 = int(to[1])\nmoves = 0\npath = []\nwhile True:\n\tif x1 < x2:\n\t\tif y1 < y2:\n\t\t\tm = 'RU'\n\t\t\tx1 += 1\n\t\t\ty1 += 1\n\t\telif y1 > y2:\n\t\t\tm = 'RD'\n\t\t\tx1 += 1\n\t\t\ty1 -= 1\n\t\telse:\n\t\t\tm = 'R'\n\t\t\tx1 += 1\n\t\tmoves += 1\n\telif x1 > x2:\n\t\tif y1 < y2:\n\t\t\tm = 'LU'\n\t\t\tx1 -= 1\n\t\t\ty1 += 1\n\t\telif y1 > y2:\n\t\t\tm = 'LD'\n\t\t\tx1 -= 1\n\t\t\ty1 -= 1\n\t\telse:\n\t\t\tm = 'L'\n\t\t\tx1 -= 1\n\t\tmoves += 1\n\telse:\n\t\tif y1 < y2:\n\t\t\tm = 'U'\n\t\t\ty1 += 1\n\t\telif y1 > y2:\n\t\t\tm = 'D'\n\t\t\ty1 -= 1\n\t\telse:\n\t\t\tbreak\n\t\tmoves += 1\n\tpath.append(m)\nprint(moves)\nfor p in path:\n\tprint(p)\n",
        "from math import sqrt\ns = input()\nt = input()\nx = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nr = ''\nx1 = x.index(s[0]) + 1\nx2 = x.index(t[0]) + 1\ny1 = int(s[1])\ny2 = int(t[1])\nif s == t:\n\tprint(0)\nelif x1 == x2:\n\tprint(abs(y1 - y2))\n\tif y1 > y2:\n\t\tr = 'D'\n\telse:\n\t\tr = 'U'\n\tfor i in range(abs(y1 - y2)):\n\t\tprint(r)\nelif y1 == y2:\n\tprint(abs(x1 - x2))\n\tif x1 > x2:\n\t\tr = 'L'\n\telse:\n\t\tr = 'R'\n\tfor i in range(abs(x1 - x2)):\n\t\tprint(r)\nelif x1 + y1 == x2 + y2 or x1 - y1 == x2 - y2:\n\tprint(abs(x1 - x2))\n\tif x2 > x1:\n\t\tr += 'R'\n\telse:\n\t\tr += 'L'\n\tif y2 > y1:\n\t\tr += 'U'\n\telse:\n\t\tr += 'D'\n\tfor i in range(abs(x1 - x2)):\n\t\tprint(r)\nelse:\n\tprint(max(abs(x2 - x1), abs(y2 - y1)))\n\tif x2 > x1:\n\t\tr += 'R'\n\telse:\n\t\tr += 'L'\n\tif y2 > y1:\n\t\tr += 'U'\n\telse:\n\t\tr += 'D'\n\tfor i in range(min(abs(x2 - x1), abs(y2 - y1))):\n\t\tprint(r)\n\tif abs(x2 - x1) > abs(y2 - y1):\n\t\tif x2 > x1:\n\t\t\tr = 'R'\n\t\telse:\n\t\t\tr = 'L'\n\telif abs(x2 - x1) < abs(y2 - y1):\n\t\tif y2 > y1:\n\t\t\tr = 'U'\n\t\telse:\n\t\t\tr = 'D'\n\tfor i in range(max(abs(x2 - x1), abs(y2 - y1)) - min(abs(x2 - x1), abs(y2 - y1))):\n\t\tprint(r)\n",
        "p0 = input()\np1 = input()\nx0 = ord(p0[0]) - 96\ny0 = int(p0[1])\nx1 = ord(p1[0]) - 96\ny1 = int(p1[1])\ndiagonal_steps = min(abs(x1 - x0), abs(y1 - y0))\nif x1 >= x0:\n\tif y1 >= y0:\n\t\tvector1 = 'RU'\n\telse:\n\t\tvector1 = 'RD'\nelif y1 >= y0:\n\tvector1 = 'LU'\nelse:\n\tvector1 = 'LD'\nnot_diagonal_steps = max(abs(x1 - x0), abs(y1 - y0)) - diagonal_steps\nif abs(x1 - x0) > abs(y1 - y0):\n\tif x1 >= x0:\n\t\tvector2 = 'R'\n\telse:\n\t\tvector2 = 'L'\nelif y1 >= y0:\n\tvector2 = 'U'\nelse:\n\tvector2 = 'D'\nprint(diagonal_steps + not_diagonal_steps)\nfor i in range(diagonal_steps):\n\tprint(vector1)\nfor i in range(not_diagonal_steps):\n\tprint(vector2)\n",
        "a = input()\nb = input()\nx = ord(a[0]) - ord(b[0])\ny = ord(a[1]) - ord(b[1])\nstep = max(abs(x), abs(y))\nfast = min(abs(x), abs(y))\ndx = 'L'\ndy = 'D'\ndz = 'R'\nif x < 0:\n\tdx = 'R'\nif y < 0:\n\tdy = 'U'\nif step == abs(x):\n\tdz = dx\nelse:\n\tdz = dy\nprint(step)\nfor i in range(fast):\n\tprint(dx + dy)\nfor i in range(fast, step):\n\tprint(dz)\n",
        "from string import ascii_lowercase\ns = input()\nt = input()\nsx = ord(s[0])\nsy = ord(s[1])\ntx = ord(t[0])\nty = ord(t[1])\nLD = 0\nRD = 0\nLU = 0\nRU = 0\nD = 0\nU = 0\nR = 0\nL = 0\nwhile tx < sx and ty < sy:\n\tLD = LD + 1\n\tsx = sx - 1\n\tsy = sy - 1\nwhile tx > sx and ty < sy:\n\tRD = RD + 1\n\tsx = sx + 1\n\tsy = sy - 1\nwhile tx < sx and ty > sy:\n\tLU = LU + 1\n\tsx = sx - 1\n\tsy = sy + 1\nwhile tx > sx and ty > sy:\n\tRU = RU + 1\n\tsx = sx + 1\n\tsy = sy + 1\nif sy == ty:\n\twhile sx > tx:\n\t\tL = L + 1\n\t\tsx = sx - 1\n\twhile sx < tx:\n\t\tR = R + 1\n\t\tsx = sx + 1\nif sx == tx:\n\twhile sy > ty:\n\t\tD = D + 1\n\t\tsy = sy - 1\n\twhile sy < ty:\n\t\tU = U + 1\n\t\tsy = sy + 1\nprint(LD + RD + LU + RU + D + U + L + R)\nfor i in range(0, LD, 1):\n\tprint('LD')\nfor i in range(0, RD, 1):\n\tprint('RD')\nfor i in range(0, LU, 1):\n\tprint('LU')\nfor i in range(0, RU, 1):\n\tprint('RU')\nfor i in range(0, D, 1):\n\tprint('D')\nfor i in range(0, U, 1):\n\tprint('U')\nfor i in range(0, L, 1):\n\tprint('L')\nfor i in range(0, R, 1):\n\tprint('R')\n",
        "now = list(input())\nend = list(input())\ny = []\nalphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nnow[0] = alphabet.index(now[0]) + 1\nend[0] = alphabet.index(end[0]) + 1\nnow[1] = int(now[1])\nend[1] = int(end[1])\nwhile now != end:\n\tif now[0] == end[0] or now[1] == end[1]:\n\t\tif now[0] < end[0]:\n\t\t\ty.append('R')\n\t\t\tnow[0] = now[0] + 1\n\t\tif now[0] > end[0]:\n\t\t\ty.append('L')\n\t\t\tnow[0] = now[0] - 1\n\t\tif now[1] > end[1]:\n\t\t\ty.append('D')\n\t\t\tnow[1] = now[1] - 1\n\t\tif now[1] < end[1]:\n\t\t\ty.append('U')\n\t\t\tnow[1] = now[1] + 1\n\telse:\n\t\tif now[0] < end[0] and now[1] > end[1]:\n\t\t\ty.append('RD')\n\t\t\tnow[0] = now[0] + 1\n\t\t\tnow[1] = now[1] - 1\n\t\tif now[0] < end[0] and now[1] < end[1]:\n\t\t\ty.append('RU')\n\t\t\tnow[0] = now[0] + 1\n\t\t\tnow[1] = now[1] + 1\n\t\tif now[0] > end[0] and now[1] > end[1]:\n\t\t\ty.append('LD')\n\t\t\tnow[0] = now[0] - 1\n\t\t\tnow[1] = now[1] - 1\n\t\tif now[0] > end[0] and now[1] < end[1]:\n\t\t\ty.append('LU')\n\t\t\tnow[0] = now[0] - 1\n\t\t\tnow[1] = now[1] + 1\nprint(len(y))\nfor i in y:\n\tprint(i)\n",
        "d = {97 + i: i + 1 for i in range(8)}\ns = input()\ns = [d[ord(s[0])], int(s[1])]\nt = input()\nt = [d[ord(t[0])], int(t[1])]\nanswer = []\nsteps = 0\nif s[0] <= t[0] and s[1] >= t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\ts[0] += 1\n\t\ts[1] -= 1\n\t\tanswer.append('RD')\n\t\tsteps += 1\n\tif s[0] == t[0]:\n\t\twhile s[1] != t[1]:\n\t\t\ts[1] -= 1\n\t\t\tanswer.append('D')\n\t\t\tsteps += 1\n\telse:\n\t\twhile s[0] != t[0]:\n\t\t\ts[0] += 1\n\t\t\tanswer.append('R')\n\t\t\tsteps += 1\nelif s[0] >= t[0] and s[1] >= t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\ts[0] -= 1\n\t\ts[1] -= 1\n\t\tanswer.append('LD')\n\t\tsteps += 1\n\tif s[0] == t[0]:\n\t\twhile s[1] != t[1]:\n\t\t\ts[1] -= 1\n\t\t\tanswer.append('D')\n\t\t\tsteps += 1\n\telse:\n\t\twhile s[0] != t[0]:\n\t\t\ts[0] -= 1\n\t\t\tanswer.append('L')\n\t\t\tsteps += 1\nelif s[0] >= t[0] and s[1] <= t[1]:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\ts[0] -= 1\n\t\ts[1] += 1\n\t\tanswer.append('LU')\n\t\tsteps += 1\n\tif s[0] == t[0]:\n\t\twhile s[1] != t[1]:\n\t\t\ts[1] += 1\n\t\t\tanswer.append('U')\n\t\t\tsteps += 1\n\telse:\n\t\twhile s[0] != t[0]:\n\t\t\ts[0] -= 1\n\t\t\tanswer.append('L')\n\t\t\tsteps += 1\nelse:\n\twhile s[0] != t[0] and s[1] != t[1]:\n\t\ts[0] += 1\n\t\ts[1] += 1\n\t\tanswer.append('RU')\n\t\tsteps += 1\n\tif s[0] == t[0]:\n\t\twhile s[1] != t[1]:\n\t\t\ts[1] += 1\n\t\t\tanswer.append('U')\n\t\t\tsteps += 1\n\telse:\n\t\twhile s[0] != t[0]:\n\t\t\ts[0] += 1\n\t\t\tanswer.append('R')\n\t\t\tsteps += 1\nprint(steps)\nfor move in answer:\n\tprint(move)\n",
        "s = list(input())\nt = list(input())\nn = ord(t[0]) - ord(s[0])\nm = int(t[1]) - int(s[1])\na = min(abs(m), abs(n))\nb = max(abs(m), abs(n)) - a\nsteps = []\nif m >= 0 and n >= 0:\n\tsteps.append('RU')\n\tsteps = steps * a\n\tif m >= n:\n\t\tsteps_s = []\n\t\tsteps_s.append('U')\n\t\tsteps_s = steps_s * b\n\telse:\n\t\tsteps_s = []\n\t\tsteps_s.append('R')\n\t\tsteps_s = steps_s * b\n\tsteps = steps + steps_s\nelif m >= 0 and n <= 0:\n\tsteps.append('LU')\n\tsteps = steps * a\n\tif m >= -n:\n\t\tsteps_s = []\n\t\tsteps_s.append('U')\n\t\tsteps_s = steps_s * b\n\telse:\n\t\tsteps_s = []\n\t\tsteps_s.append('L')\n\t\tsteps_s = steps_s * b\n\tsteps = steps + steps_s\nelif m <= 0 and n >= 0:\n\tsteps.append('RD')\n\tsteps = steps * a\n\tif -m >= n:\n\t\tsteps_s = []\n\t\tsteps_s.append('D')\n\t\tsteps_s = steps_s * b\n\telse:\n\t\tsteps_s = []\n\t\tsteps_s.append('R')\n\t\tsteps_s = steps_s * b\n\tsteps = steps + steps_s\nelif m <= 0 and n <= 0:\n\tsteps.append('LD')\n\tsteps = steps * a\n\tif m <= n:\n\t\tsteps_s = []\n\t\tsteps_s.append('D')\n\t\tsteps_s = steps_s * b\n\telse:\n\t\tsteps_s = []\n\t\tsteps_s.append('L')\n\t\tsteps_s = steps_s * b\n\tsteps = steps + steps_s\nprint(a + b)\nfor i in steps:\n\tprint(i)\n",
        "a = input()\nb = input()\na = list(a)\nb = list(b)\na[1] = int(a[1])\nb[1] = int(b[1])\nmove = 0\nd = 0\nj = 0\nif a[0] == 'a':\n\ta[0] = 1\nif a[0] == 'b':\n\ta[0] = 2\nif a[0] == 'c':\n\ta[0] = 3\nif a[0] == 'd':\n\ta[0] = 4\nif a[0] == 'e':\n\ta[0] = 5\nif a[0] == 'f':\n\ta[0] = 6\nif a[0] == 'g':\n\ta[0] = 7\nif a[0] == 'h':\n\ta[0] = 8\nif b[0] == 'a':\n\tb[0] = 1\nif b[0] == 'b':\n\tb[0] = 2\nif b[0] == 'c':\n\tb[0] = 3\nif b[0] == 'd':\n\tb[0] = 4\nif b[0] == 'e':\n\tb[0] = 5\nif b[0] == 'f':\n\tb[0] = 6\nif b[0] == 'g':\n\tb[0] = 7\nif b[0] == 'h':\n\tb[0] = 8\nf = a[0]\ng = a[1]\nh = b[0]\ni = b[1]\nif b[0] - a[0] >= 0 and b[1] - a[1] >= 0 and (d == 0):\n\td = 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\twhile b[0] - a[0] == 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[1] -= 1\nif b[0] - a[0] <= 0 and b[1] - a[1] >= 0 and (d == 0):\n\td = 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tb[1] -= 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\twhile b[0] - a[0] == 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[1] -= 1\nif b[0] - a[0] >= 0 and b[1] - a[1] <= 0 and (d == 0):\n\td = 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tb[1] += 1\n\twhile b[0] - a[0] == 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[1] += 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] -= 1\nif b[0] - a[0] <= 0 and b[1] - a[1] <= 0 and (d == 0):\n\td = 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tb[1] += 1\n\twhile b[0] - a[0] == 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[1] += 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] += 1\nprint(move)\na[0] = f\na[1] = g\nb[0] = h\nb[1] = i\nif b[0] - a[0] >= 0 and b[1] - a[1] >= 0 and (j == 0):\n\tj = 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tb[1] -= 1\n\t\tprint('RU')\n\twhile b[0] - a[0] > 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tprint('R')\n\twhile b[0] - a[0] == 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[1] -= 1\n\t\tprint('U')\nif b[0] - a[0] <= 0 and b[1] - a[1] >= 0 and (j == 0):\n\tj = 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tb[1] -= 1\n\t\tprint('LU')\n\twhile b[0] - a[0] < 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tprint('L')\n\twhile b[0] - a[0] == 0 and b[1] - a[1] > 0:\n\t\tmove += 1\n\t\tb[1] -= 1\n\t\tprint('U')\nif b[0] - a[0] >= 0 and b[1] - a[1] <= 0 and (j == 0):\n\tj = 1\n\twhile b[0] - a[0] > 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tb[1] += 1\n\t\tprint('RD')\n\twhile b[0] - a[0] == 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[1] += 1\n\t\tprint('D')\n\twhile b[0] - a[0] > 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] -= 1\n\t\tprint('R')\nif b[0] - a[0] <= 0 and b[1] - a[1] <= 0 and (j == 0):\n\tj = 1\n\twhile b[0] - a[0] < 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tb[1] += 1\n\t\tprint('LD')\n\twhile b[0] - a[0] == 0 and b[1] - a[1] < 0:\n\t\tmove += 1\n\t\tb[1] += 1\n\t\tprint('D')\n\twhile b[0] - a[0] < 0 and b[1] - a[1] == 0:\n\t\tmove += 1\n\t\tb[0] += 1\n\t\tprint('L')\n",
        "m = input()\nn = input()\nx1 = ord(m[0])\ny1 = ord(m[1])\nx2 = ord(n[0])\ny2 = ord(n[1])\ndx = x1 - x2\ndy = y1 - y2\nif abs(dx) > abs(dy):\n\tprint(abs(dx))\nelse:\n\tprint(abs(dy))\nwhile dx != 0 or dy != 0:\n\tresult = ''\n\tb1 = 0\n\tb2 = 0\n\tif dx < 0:\n\t\tdx = dx + 1\n\t\tb1 = 1\n\telif dx > 0:\n\t\tdx = dx - 1\n\t\tb1 = -1\n\tif dy < 0:\n\t\tdy = dy + 1\n\t\tb2 = 1\n\telif dy > 0:\n\t\tdy = dy - 1\n\t\tb2 = -1\n\tif b1 == 1:\n\t\tresult = result + 'R'\n\telif b1 == -1:\n\t\tresult = result + 'L'\n\tif b2 == 1:\n\t\tresult = result + 'U'\n\telif b2 == -1:\n\t\tresult = result + 'D'\n\tprint(result[0:len(result)])\n",
        "al_num = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\npos1 = input()\npos2 = input()\nans = []\nitero = 0\npos1 = [al_num[pos1[0]], int(pos1[1])]\npos2 = [al_num[pos2[0]], int(pos2[1])]\nif pos1[0] >= pos2[0]:\n\tif pos1[1] >= pos2[1]:\n\t\tfor i in range(min(pos1[0] - pos2[0], pos1[1] - pos2[1])):\n\t\t\tans.append('LD')\n\t\t\titero = itero + 1\n\t\tsave = itero\n\t\tif pos1[0] - pos2[0] < pos1[1] - pos2[1]:\n\t\t\tfor i in range(max(pos1[0] - pos2[0], pos1[1] - pos2[1]) - save):\n\t\t\t\tans.append('D')\n\t\t\t\titero = itero + 1\n\t\telse:\n\t\t\tfor i in range(max(pos1[0] - pos2[0], pos1[1] - pos2[1]) - save):\n\t\t\t\tans.append('L')\n\t\t\t\titero = itero + 1\n\telse:\n\t\tfor i in range(min(pos1[0] - pos2[0], pos2[1] - pos1[1])):\n\t\t\tans.append('LU')\n\t\t\titero = itero + 1\n\t\tsave = itero\n\t\tif pos1[0] - pos2[0] < pos2[1] - pos1[1]:\n\t\t\tfor i in range(max(pos1[0] - pos2[0], pos2[1] - pos1[1]) - save):\n\t\t\t\tans.append('U')\n\t\t\t\titero = itero + 1\n\t\telse:\n\t\t\tfor i in range(max(pos1[0] - pos2[0], pos2[1] - pos1[1]) - save):\n\t\t\t\tans.append('L')\n\t\t\t\titero = itero + 1\nelif pos1[1] >= pos2[1]:\n\tfor i in range(min(pos2[0] - pos1[0], pos1[1] - pos2[1])):\n\t\tans.append('RD')\n\t\titero = itero + 1\n\tsave = itero\n\tif pos2[0] - pos1[0] < pos1[1] - pos2[1]:\n\t\tfor i in range(max(pos2[0] - pos1[0], pos1[1] - pos2[1]) - save):\n\t\t\tans.append('D')\n\t\t\titero = itero + 1\n\telse:\n\t\tfor i in range(max(pos2[0] - pos1[0], pos1[1] - pos2[1]) - save):\n\t\t\tans.append('R')\n\t\t\titero = itero + 1\nelse:\n\tfor i in range(min(pos2[0] - pos1[0], pos2[1] - pos1[1])):\n\t\tans.append('RU')\n\t\titero = itero + 1\n\tsave = itero\n\tif pos2[0] - pos1[0] < pos2[1] - pos1[1]:\n\t\tfor i in range(max(pos2[0] - pos1[0], pos2[1] - pos1[1]) - save):\n\t\t\tans.append('U')\n\t\t\titero = itero + 1\n\telse:\n\t\tfor i in range(max(pos2[0] - pos1[0], pos2[1] - pos1[1]) - save):\n\t\t\tans.append('R')\n\t\t\titero = itero + 1\nprint(itero)\nfor i in ans:\n\tprint(i)\n",
        "s = input()\nt = input()\nrow = 'abcdefgh'\n(s_col, s_row) = (row.index(s[0]), int(s[1]))\n(t_col, t_row) = (row.index(t[0]), int(t[1]))\nmoves = []\nwhile (s_row, s_col) != (t_row, t_col):\n\tdir_col = ''\n\tif s_col < t_col:\n\t\tdir_col = 'R'\n\t\ts_col += 1\n\tif s_col > t_col:\n\t\tdir_col = 'L'\n\t\ts_col -= 1\n\tdir_row = ''\n\tif s_row < t_row:\n\t\tdir_row = 'U'\n\t\ts_row += 1\n\tif s_row > t_row:\n\t\tdir_row = 'D'\n\t\ts_row -= 1\n\tmoves.append(dir_col + dir_row)\nprint(len(moves))\nprint('\\n'.join(moves))\n",
        "letters_to_number = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\ninp = (input(), input())\n((pos_x, pos_y), (target_x, target_y)) = map(lambda x: (letters_to_number[x[0]], int(x[1])), inp)\nmove_table = {(-1, 0): 'L', (1, 0): 'R', (0, 1): 'U', (0, -1): 'D', (-1, -1): 'LD', (1, 1): 'RU', (-1, 1): 'LU', (1, -1): 'RD'}\nmoves = []\nsign = lambda x: 1 if x > 0 else -1 if x < 0 else 0\nwhile pos_x != target_x or pos_y != target_y:\n\tdir_x = sign(target_x - pos_x)\n\tdir_y = sign(target_y - pos_y)\n\tmoves.append(move_table[dir_x, dir_y])\n\tpos_x += dir_x\n\tpos_y += dir_y\nprint(len(moves))\nfor m in moves:\n\tprint(m)\n",
        "import sys\nimport math\ns = sys.stdin.readline()\nt = sys.stdin.readline()\nsx = int(ord(s[0]) - 97)\nsy = 8 - int(s[1])\ntx = int(ord(t[0]) - 97)\nty = 8 - int(t[1])\npx = [0] * 64\npy = [0] * 64\ngrid = [[-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1], [-1, -1, -1, -1, -1, -1, -1, -1]]\ndx = [1, 1, 1, 0, 0, -1, -1, -1]\ndy = [1, 0, -1, 1, -1, 1, 0, -1]\nd = 0\ngrid[sy][sx] = 0\nwhile True:\n\tfor y in range(8):\n\t\tfor x in range(8):\n\t\t\tif grid[y][x] == d:\n\t\t\t\tfor k in range(8):\n\t\t\t\t\tiy = y + dy[k]\n\t\t\t\t\tix = x + dx[k]\n\t\t\t\t\tif iy >= 0 and iy < 8 and (ix >= 0) and (ix < 8) and (grid[iy][ix] == -1):\n\t\t\t\t\t\tgrid[iy][ix] = d + 1\n\td += 1\n\tif grid[ty][tx] != -1:\n\t\tbreak\nln = grid[ty][tx]\nx = tx\ny = ty\nd = ln\nwhile d > 0:\n\tpx[d] = x\n\tpy[d] = y\n\td -= 1\n\tfor k in range(8):\n\t\tiy = y + dy[k]\n\t\tix = x + dx[k]\n\t\tif iy >= 0 and iy < 8 and (ix >= 0) and (ix < 8) and (grid[iy][ix] == d):\n\t\t\tx = x + dx[k]\n\t\t\ty = y + dy[k]\n\t\t\tbreak\npx[0] = sx\npy[0] = sy\nprint(ln)\nfor i in range(ln):\n\tx = px[i] - px[i + 1]\n\ty = py[i] - py[i + 1]\n\tres = ''\n\tif x < 0:\n\t\tres += 'R'\n\telif x > 0:\n\t\tres += 'L'\n\tif y < 0:\n\t\tres += 'D'\n\telif y > 0:\n\t\tres += 'U'\n\tprint(res)\n",
        "def ver_direction_decider(dis, res):\n\tif dis > 0:\n\t\treturn res + 'U'\n\telif dis == 0:\n\t\treturn res\n\telse:\n\t\treturn res + 'D'\n\ndef hor_direction_decider(dis):\n\tdire = ''\n\tif disp[0] > 0:\n\t\tdire += 'R'\n\t\treturn ver_direction_decider(disp[1], dire)\n\telif disp[0] == 0:\n\t\treturn ver_direction_decider(disp[1], dire)\n\telse:\n\t\tdire += 'L'\n\t\treturn ver_direction_decider(disp[1], dire)\nstart = input()\nend = input()\nst = (ord(start[0]) - 97, int(start[1]) - 1)\ned = (ord(end[0]) - 97, int(end[1]) - 1)\ndisp = (ed[0] - st[0], ed[1] - st[1])\nab_disp = (abs(disp[0]), abs(disp[1]))\nn_diag = min(ab_disp)\nn_str = max(ab_disp) - n_diag\nis_str = n_diag == 0\nis_diag = n_str == 0\nn_moves = n_str + n_diag\nprint(n_moves)\nstr_dir = hor_direction_decider(disp)\nif is_str or is_diag:\n\tfor _ in range(n_moves):\n\t\tprint(str_dir)\nelse:\n\tif ab_disp[1] > ab_disp[0]:\n\t\tstr_comp = str_dir[1]\n\telse:\n\t\tstr_comp = str_dir[0]\n\tfor _ in range(n_str):\n\t\tprint(str_comp)\n\tfor _ in range(n_diag):\n\t\tprint(str_dir)\n",
        "s = input()\nt = input()\nx1 = ord(s[0]) - ord('a') + 1\nx2 = ord(t[0]) - ord('a') + 1\ny1 = int(s[1])\ny2 = int(t[1])\nprint(max(abs(x1 - x2), abs(y1 - y2)))\nwhile x1 != x2 or y1 != y2:\n\tif x1 < x2:\n\t\tprint('R', end='')\n\t\tx1 += 1\n\tif x1 > x2:\n\t\tprint('L', end='')\n\t\tx1 -= 1\n\tif y1 < y2:\n\t\tprint('U', end='')\n\t\ty1 += 1\n\tif y1 > y2:\n\t\tprint('D', end='')\n\t\ty1 -= 1\n\tprint()\n",
        "import sys\nstart = sys.stdin.readline()\nend = sys.stdin.readline()\ndiff_x = ord(end[0]) - ord(start[0])\ndiff_y = int(end[1]) - int(start[1])\nsteps = []\ncount = 0\nwhile diff_x != 0 or diff_y != 0:\n\tif diff_x > 0:\n\t\tstep = 'R'\n\t\tif diff_y > 0:\n\t\t\tstep += 'U'\n\t\t\tdiff_y -= 1\n\t\telif diff_y < 0:\n\t\t\tstep += 'D'\n\t\t\tdiff_y += 1\n\t\tsteps.append(step)\n\t\tdiff_x -= 1\n\telif diff_x < 0:\n\t\tstep = 'L'\n\t\tif diff_y > 0:\n\t\t\tstep += 'U'\n\t\t\tdiff_y -= 1\n\t\telif diff_y < 0:\n\t\t\tstep += 'D'\n\t\t\tdiff_y += 1\n\t\tsteps.append(step)\n\t\tdiff_x += 1\n\telse:\n\t\tstep = ''\n\t\tif diff_y > 0:\n\t\t\tstep += 'U'\n\t\t\tdiff_y -= 1\n\t\telif diff_y < 0:\n\t\t\tstep += 'D'\n\t\t\tdiff_y += 1\n\t\tsteps.append(step)\n\tcount += 1\nprint(count)\nfor move in steps:\n\tprint(move)\n",
        "s2 = input()\ns1 = input()\na = ord(s1[0]) - 96\nb = int(s1[1])\nx = ord(s2[0]) - 96\ny = int(s2[1])\nif abs(x - a) < abs(y - b):\n\ts = abs(y - b)\n\tprint(abs(y - b))\nelse:\n\ts = abs(x - a)\n\tprint(abs(x - a))\nfor i in range(s):\n\tif x > a and y > b:\n\t\tprint('LD')\n\t\ta += 1\n\t\tb += 1\n\telif x > a and y < b:\n\t\tprint('LU')\n\t\ta += 1\n\t\tb -= 1\n\telif x < a and y > b:\n\t\tprint('RD')\n\t\ta -= 1\n\t\tb += 1\n\telif x < a and y < b:\n\t\tprint('RU')\n\t\ta -= 1\n\t\tb -= 1\n\telif x > a:\n\t\tprint('L')\n\t\ta += 1\n\telif x < a:\n\t\tprint('R')\n\t\ta -= 1\n\telif y > b:\n\t\tprint('D')\n\t\tb += 1\n\telif y < b:\n\t\tprint('U')\n\t\tb -= 1\n",
        "current = list(input())\nwanted = list(input())\nminmovesd = 0\nminmoves = 0\nmoves = []\n\ndef parsePosition(toParse):\n\ttoParse[0] = ord(toParse[0]) - 96\n\ttoParse[1] = int(toParse[1])\nparsePosition(current)\nparsePosition(wanted)\nwhile wanted[0] != current[0] and wanted[1] != current[1]:\n\tminmovesd += 1\n\tif wanted[0] > current[0] and wanted[1] > current[1]:\n\t\tcurrent[0] += 1\n\t\tcurrent[1] += 1\n\t\tmoves.append('RU')\n\telif wanted[0] < current[0] and wanted[1] < current[1]:\n\t\tcurrent[0] -= 1\n\t\tcurrent[1] -= 1\n\t\tmoves.append('LD')\n\telif wanted[0] > current[0] and wanted[1] < current[1]:\n\t\tcurrent[0] += 1\n\t\tcurrent[1] -= 1\n\t\tmoves.append('RD')\n\telif wanted[0] < current[0] and wanted[1] > current[1]:\n\t\tcurrent[0] -= 1\n\t\tcurrent[1] += 1\n\t\tmoves.append('LU')\nif wanted[0] == current[0]:\n\tif wanted[1] > current[1]:\n\t\tminmoves += wanted[1] - current[1]\n\t\tfor i in range(minmoves):\n\t\t\tmoves.append('U')\n\telif wanted[1] < current[1]:\n\t\tminmoves += current[1] - wanted[1]\n\t\tfor i in range(minmoves):\n\t\t\tmoves.append('D')\nelif wanted[1] == current[1]:\n\tif wanted[0] > current[0]:\n\t\tminmoves += wanted[0] - current[0]\n\t\tfor i in range(minmoves):\n\t\t\tmoves.append('R')\n\telif wanted[0] < current[0]:\n\t\tminmoves += current[0] - wanted[0]\n\t\tfor i in range(minmoves):\n\t\t\tmoves.append('L')\nprint(minmoves + minmovesd)\nfor m in moves:\n\tprint(m)\n",
        "dictPos = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n\ndef toCoordinate(pos):\n\treturn [dictPos[pos[0]], int(pos[1])]\nkingPos = toCoordinate(str(input()))\ntargetPos = toCoordinate(str(input()))\ndiffPos = [targetPos[0] - kingPos[0], targetPos[1] - kingPos[1]]\ndiagonalMove = min(abs(diffPos[0]), abs(diffPos[1]))\nhMove = 'R' if diffPos[0] > 0 else 'L'\nvMove = 'U' if diffPos[1] > 0 else 'D'\nmove = ''\nnMove = 0\nif diagonalMove > 0:\n\tnMove = diagonalMove\n\tmove = move + diagonalMove * (hMove + vMove + '\\n')\nif abs(diffPos[0]) > diagonalMove:\n\tnMove = nMove + abs(diffPos[0]) - diagonalMove\n\tmove = move + (hMove + '\\n') * (abs(diffPos[0]) - diagonalMove)\nelse:\n\tnMove = nMove + abs(diffPos[1]) - diagonalMove\n\tmove = move + (vMove + '\\n') * (abs(diffPos[1]) - diagonalMove)\nprint(nMove)\nprint(move[:-1])\n",
        "x = 'abcdefgh'\ny = '12345678'\nb = input()\na = input()\nm = x.index(a[0]) - x.index(b[0])\nn = int(a[1]) - int(b[1])\np = max(abs(m), abs(n))\nprint(p)\nfor _ in range(p):\n\tif m > 0 and n > 0:\n\t\tprint('RU')\n\t\tm -= 1\n\t\tn -= 1\n\telif m > 0 and n < 0:\n\t\tprint('RD')\n\t\tm -= 1\n\t\tn += 1\n\telif m < 0 and n < 0:\n\t\tprint('LD')\n\t\tm += 1\n\t\tn += 1\n\telif m < 0 and n > 0:\n\t\tprint('LU')\n\t\tm += 1\n\t\tn -= 1\n\telif m == 0 and n > 0:\n\t\tprint('U')\n\t\tn -= 1\n\telif m == 0 and n < 0:\n\t\tprint('D')\n\t\tn += 1\n\telif m < 0 and n == 0:\n\t\tprint('L')\n\t\tm += 1\n\telif m > 0 and n == 0:\n\t\tprint('R')\n\t\tm -= 1\n",
        "f = input()\nt = input()\nf = [ord(f[0]) - ord('a'), int(f[1]) - 1]\nt = [ord(t[0]) - ord('a'), int(t[1]) - 1]\na = []\nwhile f[0] < t[0] and f[1] < t[1]:\n\ta.append('RU')\n\tf[0] += 1\n\tf[1] += 1\nwhile f[0] > t[0] and f[1] < t[1]:\n\ta.append('LU')\n\tf[0] -= 1\n\tf[1] += 1\nwhile f[0] < t[0] and f[1] > t[1]:\n\ta.append('RD')\n\tf[0] += 1\n\tf[1] -= 1\nwhile f[0] > t[0] and f[1] > t[1]:\n\ta.append('LD')\n\tf[0] -= 1\n\tf[1] -= 1\nwhile f[0] < t[0]:\n\ta.append('R')\n\tf[0] += 1\nwhile f[0] > t[0]:\n\ta.append('L')\n\tf[0] -= 1\nwhile f[1] < t[1]:\n\ta.append('U')\n\tf[1] += 1\nwhile f[1] > t[1]:\n\ta.append('D')\n\tf[1] -= 1\nprint(len(a))\nprint('\\n'.join(a))\n",
        "init = input()\nfinis = input()\nmy_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nmy_list = list('abcdefgh')\na = my_dict[finis[0]] - my_dict[init[0]]\nn = int(finis[1]) - int(init[1])\nprint(max(abs(a), abs(n)))\nif a >= 0:\n\tif n >= a:\n\t\tfor i in range(a):\n\t\t\tprint('RU')\n\t\tfor i in range(n - a):\n\t\t\tprint('U')\n\telif n >= 0 and n < a:\n\t\tfor i in range(n):\n\t\t\tprint('RU')\n\t\tfor i in range(a - n):\n\t\t\tprint('R')\n\telif n < 0 and n >= -a:\n\t\tfor i in range(-n):\n\t\t\tprint('RD')\n\t\tfor i in range(a + n):\n\t\t\tprint('R')\n\telif n < -a:\n\t\tfor i in range(a):\n\t\t\tprint('RD')\n\t\tfor i in range(-n - a):\n\t\t\tprint('D')\nelif n < a:\n\tfor i in range(-a):\n\t\tprint('LD')\n\tfor i in range(-n + a):\n\t\tprint('D')\nelif n <= 0 and n >= a:\n\tfor i in range(-n):\n\t\tprint('LD')\n\tfor i in range(-a + n):\n\t\tprint('L')\nelif n > 0 and n <= -a:\n\tfor i in range(n):\n\t\tprint('LU')\n\tfor i in range(-a - n):\n\t\tprint('L')\nelif n > -a:\n\tfor i in range(-a):\n\t\tprint('LU')\n\tfor i in range(n + a):\n\t\tprint('U')\n",
        "a = input()\nb = input()\nif a[0] == 'a':\n\ta1 = 1\nif a[0] == 'b':\n\ta1 = 2\nif a[0] == 'c':\n\ta1 = 3\nif a[0] == 'd':\n\ta1 = 4\nif a[0] == 'e':\n\ta1 = 5\nif a[0] == 'f':\n\ta1 = 6\nif a[0] == 'g':\n\ta1 = 7\nif a[0] == 'h':\n\ta1 = 8\nif a[1] == '1':\n\ta2 = 1\nif a[1] == '2':\n\ta2 = 2\nif a[1] == '3':\n\ta2 = 3\nif a[1] == '4':\n\ta2 = 4\nif a[1] == '5':\n\ta2 = 5\nif a[1] == '6':\n\ta2 = 6\nif a[1] == '7':\n\ta2 = 7\nif a[1] == '8':\n\ta2 = 8\nif b[0] == 'a':\n\tb1 = 1\nif b[0] == 'b':\n\tb1 = 2\nif b[0] == 'c':\n\tb1 = 3\nif b[0] == 'd':\n\tb1 = 4\nif b[0] == 'e':\n\tb1 = 5\nif b[0] == 'f':\n\tb1 = 6\nif b[0] == 'g':\n\tb1 = 7\nif b[0] == 'h':\n\tb1 = 8\nif b[1] == '1':\n\tb2 = 1\nif b[1] == '2':\n\tb2 = 2\nif b[1] == '3':\n\tb2 = 3\nif b[1] == '4':\n\tb2 = 4\nif b[1] == '5':\n\tb2 = 5\nif b[1] == '6':\n\tb2 = 6\nif b[1] == '7':\n\tb2 = 7\nif b[1] == '8':\n\tb2 = 8\nprint(max(abs(a1 - b1), abs(a2 - b2)))\nwhile a1 != b1 or a2 != b2:\n\tc = ' '\n\tif a1 > b1:\n\t\tc = c + 'L'\n\t\tb1 += 1\n\tif a1 < b1:\n\t\tc = c + 'R'\n\t\ta1 += 1\n\tif a2 > b2:\n\t\tc = c + 'D'\n\t\tb2 += 1\n\tif a2 < b2:\n\t\tc = c + 'U'\n\t\ta2 += 1\n\tprint(c)\n",
        "s1 = input().strip()\ns2 = input().strip()\n(c1, r1, c2, r2) = (ord(s1[0]) - ord('a') + 1, int(s1[1]), ord(s2[0]) - ord('a') + 1, int(s2[1]))\nrDiff = abs(r1 - r2)\ncDiff = abs(c1 - c2)\ncross = 'R' if c1 < c2 else 'L'\ncross += 'U' if r1 < r2 else 'D'\nif max(rDiff, cDiff) == rDiff:\n\tstraight = 'U' if r1 < r2 else 'D'\nelse:\n\tstraight = 'R' if c1 < c2 else 'L'\nprint(max(rDiff, cDiff))\nfor i in range(min(rDiff, cDiff)):\n\tprint(cross)\nfor i in range(max(rDiff, cDiff) - min(rDiff, cDiff)):\n\tprint(straight)\n",
        "start = input()\nend = input()\ncolst = start[0]\nif colst == 'a':\n\tcolst = 1\nelif colst == 'b':\n\tcolst = 2\nelif colst == 'c':\n\tcolst = 3\nelif colst == 'd':\n\tcolst = 4\nelif colst == 'e':\n\tcolst = 5\nelif colst == 'f':\n\tcolst = 6\nelif colst == 'g':\n\tcolst = 7\nelif colst == 'h':\n\tcolst = 8\nrowst = int(start[1])\ncole = end[0]\nif cole == 'a':\n\tcole = 1\nelif cole == 'b':\n\tcole = 2\nelif cole == 'c':\n\tcole = 3\nelif cole == 'd':\n\tcole = 4\nelif cole == 'e':\n\tcole = 5\nelif cole == 'f':\n\tcole = 6\nelif cole == 'g':\n\tcole = 7\nelif cole == 'h':\n\tcole = 8\nrowe = int(end[1])\nd = []\ncnt = 0\nwhile colst != cole or rowst != rowe:\n\tans = ''\n\tif colst < cole:\n\t\tans += 'R'\n\t\tcolst += 1\n\tif colst > cole:\n\t\tans += 'L'\n\t\tcolst -= 1\n\tif rowst < rowe:\n\t\tans += 'U'\n\t\trowst += 1\n\tif rowst > rowe:\n\t\tans += 'D'\n\t\trowst -= 1\n\tcnt += 1\n\td.append(ans)\nprint(cnt)\nfor i in d:\n\tprint(i)\n",
        "a = input()\nb = input()\ns = [ord(a[0]) - ord('a'), ord(a[1]) - ord('1')]\nt = [ord(b[0]) - ord('a'), ord(b[1]) - ord('1')]\nans = []\nwhile s != t:\n\tstep = ''\n\tif s[0] < t[0]:\n\t\tstep += 'R'\n\t\ts[0] += 1\n\telif s[0] > t[0]:\n\t\tstep += 'L'\n\t\ts[0] -= 1\n\tif s[1] < t[1]:\n\t\tstep += 'U'\n\t\ts[1] += 1\n\telif s[1] > t[1]:\n\t\tstep += 'D'\n\t\ts[1] -= 1\n\tans.append(step)\nprint(len(ans))\nprint('\\n'.join(ans))\n",
        "def sign(n):\n\tif n > 0:\n\t\treturn 1\n\tif n < 0:\n\t\treturn -1\n\treturn 0\ns = input()\nt = input()\nn = 0\na = []\ns = [ord(s[0]) - ord('a') + 1, int(s[1])]\nt = [ord(t[0]) - ord('a') + 1, int(t[1])]\nwhile s != t:\n\td0 = sign(t[0] - s[0])\n\td1 = sign(t[1] - s[1])\n\tst = 'L' if d0 == -1 else '' if d0 == 0 else 'R'\n\tst += 'D' if d1 == -1 else '' if d1 == 0 else 'U'\n\ts[0] += d0\n\ts[1] += d1\n\ta.append(st)\nprint(len(a))\nfor s in a:\n\tprint(s)\n",
        "s = input()\na1 = ord(s[0]) - ord('a') + 1\nb1 = int(s[1])\ns = input()\na2 = ord(s[0]) - ord('a') + 1\nb2 = int(s[1])\nm = max(abs(a1 - a2), abs(b1 - b2))\nprint(m)\nwhile a1 != a2 or b1 != b2:\n\tif a2 > a1:\n\t\tif b2 > b1:\n\t\t\tb1 += 1\n\t\t\ta1 += 1\n\t\t\tprint('RU')\n\t\telif b2 == b1:\n\t\t\ta1 += 1\n\t\t\tprint('R')\n\t\telse:\n\t\t\ta1 += 1\n\t\t\tb1 -= 1\n\t\t\tprint('RD')\n\telif a2 == a1:\n\t\tif b2 > b1:\n\t\t\tb1 += 1\n\t\t\tprint('U')\n\t\telif b2 < b1:\n\t\t\tb1 -= 1\n\t\t\tprint('D')\n\telif b2 > b1:\n\t\tb1 += 1\n\t\ta1 -= 1\n\t\tprint('LU')\n\telif b2 == b1:\n\t\ta1 -= 1\n\t\tprint('L')\n\telse:\n\t\ta1 -= 1\n\t\tb1 -= 1\n\t\tprint('LD')\n",
        "def kingmoves(j, i, b, a):\n\ts = ''\n\tt = 0\n\twhile i < a and j < b:\n\t\ti += 1\n\t\tj += 1\n\t\ts += 'RU\\n'\n\t\tt += 1\n\twhile i < a and j > b:\n\t\ti += 1\n\t\tj -= 1\n\t\ts += 'LU\\n'\n\t\tt += 1\n\twhile i > a and j < b:\n\t\ti -= 1\n\t\tj += 1\n\t\ts += 'RD\\n'\n\t\tt += 1\n\twhile i > a and j > b:\n\t\ti -= 1\n\t\tj -= 1\n\t\ts += 'LD\\n'\n\t\tt += 1\n\twhile i > a:\n\t\ti -= 1\n\t\ts += 'D\\n'\n\t\tt += 1\n\twhile i < a:\n\t\ti += 1\n\t\ts += 'U\\n'\n\t\tt += 1\n\twhile j > b:\n\t\tj -= 1\n\t\ts += 'L\\n'\n\t\tt += 1\n\twhile j < b:\n\t\tj += 1\n\t\ts += 'R\\n'\n\t\tt += 1\n\treturn (t, s[:-1])\nx = input()\ni = ord(x[0]) - 96\nj = int(x[1:])\ny = input()\na = ord(y[0]) - 96\nb = int(y[1:])\n(n, p) = kingmoves(i, j, a, b)\nprint(n)\nprint(p)\n",
        "start = input()\nend = input()\nrows = [1, 2, 3, 4, 5, 6, 7, 8]\ncols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\nstart_row = rows.index(int(start[1:]))\nstart_col = cols.index(start[:1])\nend_row = rows.index(int(end[1:]))\nend_col = cols.index(end[:1])\nsteps = []\ndiag = min(abs(start_row - end_row), abs(start_col - end_col))\nall_steps = max(abs(start_row - end_row), abs(start_col - end_col))\nvertical_pref = ''\nhoriz_pref = ''\nif start_row > end_row:\n\tvertical_pref = 'D'\nelse:\n\tvertical_pref = 'U'\nif start_col > end_col:\n\thoriz_pref = 'L'\nelse:\n\thoriz_pref = 'R'\nprint(all_steps)\nfor _ in range(diag):\n\tprint(horiz_pref + vertical_pref)\nif abs(start_row - end_row) != abs(start_col - end_col):\n\tif abs(start_row - end_row) > abs(start_col - end_col):\n\t\tfor _ in range(all_steps - diag):\n\t\t\tprint(vertical_pref)\n\telse:\n\t\tfor _ in range(all_steps - diag):\n\t\t\tprint(horiz_pref)\n",
        "x = input()\ny = input()\nanswer = []\nwhile x != y:\n\talpha1 = x[0]\n\tnumber1 = int(x[1])\n\talpha2 = y[0]\n\tnumber2 = int(y[1])\n\ttemp = ''\n\tif alpha1 < alpha2:\n\t\ttemp += 'R'\n\telif alpha1 > alpha2:\n\t\ttemp += 'L'\n\tif number1 < number2:\n\t\ttemp += 'U'\n\telif number1 > number2:\n\t\ttemp += 'D'\n\tanswer.append(temp)\n\tnextChar = chr(ord(alpha1) + 1)\n\tprevChar = chr(ord(alpha1) - 1)\n\tif temp == 'L':\n\t\tx = prevChar + str(number1)\n\telif temp == 'R':\n\t\tx = nextChar + str(number1)\n\telif temp == 'U':\n\t\tx = alpha1 + str(number1 + 1)\n\telif temp == 'D':\n\t\tx = alpha1 + str(number1 - 1)\n\telif temp == 'LU':\n\t\tx = prevChar + str(number1 + 1)\n\telif temp == 'RU':\n\t\tx = nextChar + str(number1 + 1)\n\telif temp == 'LD':\n\t\tx = prevChar + str(number1 - 1)\n\telif temp == 'RD':\n\t\tx = nextChar + str(number1 - 1)\nprint(len(answer))\nfor i in answer:\n\tprint(i)\n",
        "s = list(input())\nf = list(input())\nalph = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\nscol = alph[s[0]]\nsrow = int(s[1])\nfcol = alph[f[0]]\nfrow = int(f[1])\ncolM = abs(fcol - scol)\nrowM = abs(frow - srow)\nlow = min(colM, rowM)\nhigh = max(colM, rowM)\nprint(high)\nx = scol\ny = srow\nfor i in range(low):\n\tif (x < fcol or x == fcol) and (y > frow or y == frow):\n\t\tx = x + 1\n\t\ty = y - 1\n\t\tprint('RD')\n\telif (x < fcol or x == fcol) and (y < frow or y == frow):\n\t\tx = x + 1\n\t\ty = y + 1\n\t\tprint('RU')\n\telif (x > fcol or x == fcol) and (y < frow or y == frow):\n\t\tx = x - 1\n\t\ty = y + 1\n\t\tprint('LU')\n\telif (x > fcol or x == fcol) and (y > frow or y == frow):\n\t\tx = x - 1\n\t\ty = y - 1\n\t\tprint('LD')\nfor i in range(high - low):\n\tif x == fcol and y > frow:\n\t\tprint('D')\n\t\ty = y - 1\n\telif x == fcol and y < frow:\n\t\tprint('U')\n\t\ty = y + 1\n\telif x > fcol and y == frow:\n\t\tprint('L')\n\t\tx = x - 1\n\telif x < fcol and y == frow:\n\t\tprint('R')\n\t\tx = x + 1\n",
        "p1 = input()\np2 = input()\ngor = ord(p2[0]) - ord(p1[0])\nvert = int(p2[1]) - int(p1[1])\ncom = min(abs(vert), abs(gor))\nscom = ''\nif gor > 0:\n\tscom += 'R'\nelse:\n\tscom += 'L'\nif vert > 0:\n\tscom += 'U'\nelse:\n\tscom += 'D'\nprint(max(abs(vert), abs(gor)))\nfor i in range(com):\n\tprint(scom)\nif abs(vert) > abs(gor):\n\tif vert > 0:\n\t\tscom = 'U'\n\telse:\n\t\tscom = 'D'\nelif gor > 0:\n\tscom = 'R'\nelse:\n\tscom = 'L'\nfor i in range(abs(abs(vert) - abs(gor))):\n\tprint(scom)\n",
        "__author__ = 'Eddie'\nimport sys\n\ndef get_filehandler(is_file):\n\tif is_file:\n\t\treturn open(file='data')\n\telse:\n\t\timport sys\n\t\treturn sys.stdin\nfh = get_filehandler(is_file=False)\nlocation = [(ord(x) - 96, int(y)) for (x, y) in map(str.rstrip, fh.readlines())]\nst = (location[0][0] - location[1][0], location[0][1] - location[1][1])\nmove = [None] * 2\nmove[0] = 'L' if st[0] > 0 else 'R'\nmove[1] = 'D' if st[1] > 0 else 'U'\nst = list(map(abs, st))\noblique = min(st)\nprint(sum(st) - oblique)\nfor _i in range(oblique):\n\tprint(''.join(move))\nfor _i in range(st[0] - oblique):\n\tprint(move[0])\nfor _i in range(st[1] - oblique):\n\tprint(move[1])\n",
        "def read():\n\ts = input()\n\treturn (ord(s[0]) - ord('a'), ord(s[1]) - ord('1'))\n\ndef move(r, m, d=''):\n\tif r:\n\t\tprint(*(m, d, '\\n') * r, sep='', end='')\n\ndef main():\n\t(sx, sy) = read()\n\t(gx, gy) = read()\n\tdx = gx - sx\n\tif dx < 0:\n\t\th = 'L'\n\t\tdx = -dx\n\telse:\n\t\th = 'R'\n\tdy = gy - sy\n\tif dy < 0:\n\t\tv = 'D'\n\t\tdy = -dy\n\telse:\n\t\tv = 'U'\n\tif dx < dy:\n\t\tprint(dy)\n\t\tmove(dx, h, v)\n\t\tmove(dy - dx, v)\n\telse:\n\t\tprint(dx)\n\t\tmove(dy, h, v)\n\t\tmove(dx - dy, h)\nmain()\n",
        "def get_position(position):\n\t(y, x) = position\n\ty = ord(y) - ord('a')\n\tx = 8 - int(x)\n\treturn (x, y)\nsource = input()\ndestination = input()\n(source_x, source_y) = get_position(source)\n(destination_x, destination_y) = get_position(destination)\nif source_x == destination_x and source_y == destination_y:\n\tprint(0)\nelif source_x == destination_x:\n\td = abs(source_y - destination_y)\n\tprint(d)\n\tif source_y < destination_y:\n\t\tfor i in range(d):\n\t\t\tprint('R')\n\telse:\n\t\tfor i in range(d):\n\t\t\tprint('L')\nelif source_y == destination_y:\n\td = abs(source_x - destination_x)\n\tprint(d)\n\tif source_x < destination_x:\n\t\tfor i in range(d):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(d):\n\t\t\tprint('U')\nelif source_x - destination_x == source_y - destination_y:\n\td = abs(source_x - destination_x)\n\tprint(d)\n\tif source_x < destination_x:\n\t\tfor i in range(d):\n\t\t\tprint('RD')\n\telif source_x > destination_x:\n\t\tfor i in range(d):\n\t\t\tprint('RU')\n\telif source_y < destination_y:\n\t\tfor i in range(d):\n\t\t\tprint('LD')\n\telif source_y > destination_y:\n\t\tfor i in range(d):\n\t\t\tprint('LU')\nelif source_x < destination_x and source_y < destination_y:\n\tdx = abs(source_x - destination_x)\n\tdy = abs(source_y - destination_y)\n\tdiag = min(dx, dy)\n\tline = max(dx, dy) - diag\n\tprint(diag + line)\n\tfor i in range(diag):\n\t\tprint('RD')\n\t\tsource_x += 1\n\t\tsource_y += 1\n\tif source_y == destination_y:\n\t\tfor i in range(line):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(line):\n\t\t\tprint('R')\nelif source_x < destination_x and source_y > destination_y:\n\tdx = abs(source_x - destination_x)\n\tdy = abs(source_y - destination_y)\n\tdiag = min(dx, dy)\n\tline = max(dx, dy) - diag\n\tprint(diag + line)\n\tfor i in range(diag):\n\t\tprint('LD')\n\t\tsource_x += 1\n\t\tsource_y -= 1\n\tif source_y == destination_y:\n\t\tfor i in range(line):\n\t\t\tprint('D')\n\telse:\n\t\tfor i in range(line):\n\t\t\tprint('L')\nelif source_x > destination_x and source_y < destination_y:\n\tdx = abs(source_x - destination_x)\n\tdy = abs(source_y - destination_y)\n\tdiag = min(dx, dy)\n\tline = max(dx, dy) - diag\n\tprint(diag + line)\n\tfor i in range(diag):\n\t\tprint('RU')\n\t\tsource_x -= 1\n\t\tsource_y += 1\n\tif source_x == destination_x:\n\t\tfor i in range(line):\n\t\t\tprint('R')\n\telse:\n\t\tfor i in range(line):\n\t\t\tprint('U')\nelif source_x > destination_x and source_y > destination_y:\n\tdx = abs(source_x - destination_x)\n\tdy = abs(source_y - destination_y)\n\tdiag = min(dx, dy)\n\tline = max(dx, dy) - diag\n\tprint(diag + line)\n\tfor i in range(diag):\n\t\tprint('LU')\n\t\tsource_x -= 1\n\t\tsource_y -= 1\n\tif source_x == destination_x:\n\t\tfor i in range(line):\n\t\t\tprint('L')\n\telse:\n\t\tfor i in range(line):\n\t\t\tprint('U')\n"
      ],
      "original_code": null
    },
    "status": "success",
    "code": "def main():\n    import sys\n\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    start, dest = data[0].strip(), data[1].strip()\n\n    # Helper function to convert chessboard coordinate to numeric (col, row)\n    def to_coords(pos):\n        # 'a' to 'h' => 1 to 8, digit already gives row.\n        col = ord(pos[0]) - ord('a') + 1\n        row = int(pos[1])\n        return col, row\n\n    sc, sr = to_coords(start)\n    ec, er = to_coords(dest)\n\n    moves = []\n    \n    # The king moves one square in any direction so minimal moves = max(delta col, delta row)\n    while (sc, sr) != (ec, er):\n        move = \"\"\n        # Compare columns (Left/Right)\n        if sc < ec:\n            sc += 1\n            move += \"R\"\n        elif sc > ec:\n            sc -= 1\n            move += \"L\"\n        # Compare rows (Up/Down)\n        if sr < er:\n            sr += 1\n            move += \"U\"\n        elif sr > er:\n            sr -= 1\n            move += \"D\"\n        \n        moves.append(move)\n\n    # Output the results: first the number of moves, then the moves line by line.\n    sys.stdout.write(str(len(moves)) + \"\\n\")\n    if moves:\n        sys.stdout.write(\"\\n\".join(moves))\n    \nif __name__ == '__main__':\n    main()",
    "pass_ratio": 0.6903225806451613,
    "tests_passed": 107,
    "tests_total": 155,
    "iterations": 1,
    "history": [
      {
        "iteration": 1,
        "code": "def main():\n    import sys\n\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    start, dest = data[0].strip(), data[1].strip()\n\n    # Helper function to convert chessboard coordinate to numeric (col, row)\n    def to_coords(pos):\n        # 'a' to 'h' => 1 to 8, digit already gives row.\n        col = ord(pos[0]) - ord('a') + 1\n        row = int(pos[1])\n        return col, row\n\n    sc, sr = to_coords(start)\n    ec, er = to_coords(dest)\n\n    moves = []\n    \n    # The king moves one square in any direction so minimal moves = max(delta col, delta row)\n    while (sc, sr) != (ec, er):\n        move = \"\"\n        # Compare columns (Left/Right)\n        if sc < ec:\n            sc += 1\n            move += \"R\"\n        elif sc > ec:\n            sc -= 1\n            move += \"L\"\n        # Compare rows (Up/Down)\n        if sr < er:\n            sr += 1\n            move += \"U\"\n        elif sr > er:\n            sr -= 1\n            move += \"D\"\n        \n        moves.append(move)\n\n    # Output the results: first the number of moves, then the moves line by line.\n    sys.stdout.write(str(len(moves)) + \"\\n\")\n    if moves:\n        sys.stdout.write(\"\\n\".join(moves))\n    \nif __name__ == '__main__':\n    main()",
        "pass_ratio": 0.6903225806451613,
        "tests_passed": 107,
        "tests_total": 155
      }
    ],
    "model_type": "openai",
    "model_name": "o3_mini"
  },
  {
    "problem": {
      "problem_id": 3,
      "question": "You are given a $n \\times n$ chessboard. Rows and columns of the board are numbered from $1$ to $n$. Cell $(x, y)$ lies on the intersection of column number $x$ and row number $y$.\n\nRook is a chess piece, that can in one turn move any number of cells vertically or horizontally. There are $m$ rooks ($m < n$) placed on the chessboard in such a way that no pair of rooks attack each other. I.e. there are no pair of rooks that share a row or a column.\n\nIn one turn you can move one of the rooks any number of cells vertically or horizontally. Additionally, it shouldn't be attacked by any other rook after movement. What is the minimum number of moves required to place all the rooks on the main diagonal?\n\nThe main diagonal of the chessboard is all the cells $(i, i)$, where $1 \\le i \\le n$.\n\n\n-----Input-----\n\nThe first line contains the number of test cases $t$ ($1 \\leq t \\leq 10^3$). Description of the $t$ test cases follows.\n\nThe first line of each test case contains two integers $n$ and $m$ \u2014 size of the chessboard and the number of rooks ($2 \\leq n \\leq 10^5$, $1 \\leq m < n$). Each of the next $m$ lines contains two integers $x_i$ and $y_i$ \u2014 positions of rooks, $i$-th rook is placed in the cell $(x_i, y_i)$ ($1 \\leq x_i, y_i \\leq n$). It's guaranteed that no two rooks attack each other in the initial placement.\n\nThe sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each of $t$ test cases print a single integer \u2014 the minimum number of moves required to place all the rooks on the main diagonal.\n\nIt can be proved that this is always possible.\n\n\n-----Examples-----\n\nInput\n4\n3 1\n2 3\n3 2\n2 1\n1 2\n5 3\n2 3\n3 1\n1 2\n5 4\n4 5\n5 1\n2 2\n3 3\nOutput\n1\n3\n4\n2\n\n\n-----Note-----\n\nPossible moves for the first three test cases:\n\n$(2, 3) \\to (2, 2)$\n\n$(2, 1) \\to (2, 3)$, $(1, 2) \\to (1, 1)$, $(2, 3) \\to (2, 2)$\n\n$(2, 3) \\to (2, 4)$, $(2, 4) \\to (4, 4)$, $(3, 1) \\to (3, 3)$, $(1, 2) \\to (1, 1)$",
      "tests": [
        {
          "stdin": "4\n3 1\n2 3\n3 2\n2 1\n1 2\n5 3\n2 3\n3 1\n1 2\n5 4\n4 5\n5 1\n2 2\n3 3\n",
          "stdout": "1\n3\n4\n2\n"
        },
        {
          "stdin": "4\n3 1\n2 3\n3 2\n2 1\n1 2\n5 3\n2 3\n3 1\n1 2\n5 4\n4 5\n5 1\n1 3\n3 4\n",
          "stdout": "1\n3\n4\n5\n"
        },
        {
          "stdin": "1\n3 2\n3 1\n1 3\n",
          "stdout": "3\n"
        },
        {
          "stdin": "3\n2 1\n1 2\n4 3\n2 3\n3 2\n1 4\n9 4\n1 4\n2 3\n3 2\n4 1\n",
          "stdout": "1\n4\n6\n"
        },
        {
          "stdin": "2\n5 4\n1 1\n2 2\n3 3\n4 4\n7 3\n1 1\n2 7\n7 2\n",
          "stdout": "0\n3\n"
        },
        {
          "stdin": "3\n3 1\n1 3\n4 2\n1 4\n4 1\n8 4\n8 8\n7 7\n4 4\n2 2\n",
          "stdout": "1\n3\n0\n"
        },
        {
          "stdin": "1\n6 4\n1 6\n6 1\n2 5\n5 2\n",
          "stdout": "6\n"
        },
        {
          "stdin": "2\n7 6\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 1\n1 8\n",
          "stdout": "0\n1\n"
        },
        {
          "stdin": "1\n5 4\n1 1\n2 5\n5 2\n3 4\n",
          "stdout": "4\n"
        },
        {
          "stdin": "1\n5 1\n1 1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3\n6 3\n1 1\n2 2\n3 3\n8 3\n4 4\n5 5\n6 6\n10 5\n4 5\n5 4\n6 7\n7 6\n8 9\n",
          "stdout": "0\n0\n7\n"
        },
        {
          "stdin": "2\n4 2\n1 1\n4 4\n6 2\n1 1\n6 6\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "2\n3 2\n1 3\n3 1\n6 3\n1 1\n6 6\n3 3\n",
          "stdout": "3\n0\n"
        },
        {
          "stdin": "3\n5 2\n1 5\n5 1\n6 2\n1 6\n6 1\n9 4\n1 1\n9 9\n3 3\n8 8\n",
          "stdout": "3\n3\n0\n"
        },
        {
          "stdin": "1\n7 4\n1 1\n2 2\n3 3\n4 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3\n3 1\n2 3\n5 4\n4 5\n5 1\n1 3\n3 4\n6 2\n2 4\n4 2\n",
          "stdout": "1\n5\n3\n"
        },
        {
          "stdin": "4\n3 1\n2 3\n3 2\n2 1\n1 2\n7 3\n2 3\n4 1\n1 4\n7 5\n6 7\n7 1\n1 6\n3 5\n5 2\n",
          "stdout": "1\n3\n4\n6\n"
        },
        {
          "stdin": "2\n4 2\n2 4\n3 1\n9 5\n4 9\n9 1\n1 5\n5 6\n8 2\n",
          "stdout": "2\n5\n"
        },
        {
          "stdin": "2\n6 2\n3 5\n1 2\n9 5\n5 9\n9 1\n1 5\n3 6\n8 2\n",
          "stdout": "2\n6\n"
        },
        {
          "stdin": "1\n8 5\n6 8\n8 1\n1 6\n3 5\n7 2\n2 7\n",
          "stdout": "6\n"
        },
        {
          "stdin": "2\n8 4\n2 8\n4 1\n6 3\n1 4\n10 5\n5 10\n10 1\n1 4\n6 6\n9 2\n",
          "stdout": "5\n4\n"
        },
        {
          "stdin": "1\n10 5\n6 10\n10 2\n2 6\n4 7\n7 1\n1 5\n",
          "stdout": "6\n"
        },
        {
          "stdin": "1\n12 6\n6 12\n10 1\n1 10\n4 8\n8 2\n10 9\n2 6\n",
          "stdout": "6\n"
        },
        {
          "stdin": "2\n8 5\n3 8\n7 1\n1 7\n5 3\n2 6\n11 4\n3 11\n9 1\n1 7\n5 7\n10 2\n",
          "stdout": "6\n4\n"
        },
        {
          "stdin": "1\n15 7\n4 15\n11 5\n5 10\n7 1\n1 9\n10 7\n2 12\n3 8\n",
          "stdout": "7\n"
        },
        {
          "stdin": "4\n3 1\n2 3\n3 2\n2 1\n1 2\n5 3\n2 3\n3 1\n1 2\n5 4\n4 5\n5 1\n2 2\n3 3\n",
          "stdout": "1\n3\n4\n2\n"
        },
        {
          "stdin": "4\n3 1\n2 3\n3 2\n2 1\n1 2\n5 3\n2 3\n3 1\n1 2\n5 4\n4 5\n5 1\n1 3\n3 4\n",
          "stdout": "1\n3\n4\n5\n"
        },
        {
          "stdin": "1\n3 2\n1 1\n3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n3 1\n2 2\n4 2\n1 1\n3 3\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n5 1\n3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n4 2\n1 1\n4 4\n5 3\n1 1\n3 3\n5 5\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n10 9\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n10 1\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n10 2\n5 5\n7 7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n10 3\n1 1\n5 5\n10 10\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5 4\n1 1\n2 2\n3 3\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n10 1\n5 5\n10 1\n10 10\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n10 4\n1 1\n3 3\n7 7\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5 3\n1 4\n3 2\n2 5\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n3 2\n1 2\n2 1\n4 3\n2 4\n3 3\n1 1\n",
          "stdout": "3\n1\n"
        },
        {
          "stdin": "1\n8 4\n2 5\n4 3\n6 1\n8 6\n",
          "stdout": "4\n"
        },
        {
          "stdin": "2\n7 3\n2 4\n3 2\n1 7\n3 1\n2 2\n1 3\n",
          "stdout": "3\n0\n"
        },
        {
          "stdin": "2\n4 2\n1 1\n4 4\n6 3\n1 1\n3 3\n6 6\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "3\n5 2\n1 2\n5 5\n4 2\n1 1\n4 4\n10 5\n1 1\n3 3\n5 5\n7 7\n10 10\n",
          "stdout": "1\n0\n0\n"
        },
        {
          "stdin": "5\n3 1\n2 3\n5 2\n3 2\n5 3\n7 3\n3 3\n5 5\n7 7\n9 4\n2 2\n4 4\n6 6\n9 9\n11 5\n2 2\n4 4\n6 6\n8 8\n11 11\n",
          "stdout": "1\n2\n0\n0\n0\n"
        },
        {
          "stdin": "1\n100 50\n1 1\n3 3\n5 5\n7 7\n9 9\n11 11\n13 13\n15 15\n17 17\n19 19\n21 21\n23 23\n25 25\n27 27\n29 29\n31 31\n33 33\n35 35\n37 37\n39 39\n41 41\n43 43\n45 45\n47 47\n49 49\n51 51\n53 53\n55 55\n57 57\n59 59\n61 61\n63 63\n65 65\n67 67\n69 69\n71 71\n73 73\n75 75\n77 77\n79 79\n81 81\n83 83\n85 85\n87 87\n89 89\n91 91\n93 93\n95 95\n97 97\n99 99\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n2 1\n2 2\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n10 5\n1 2\n3 4\n5 6\n7 8\n9 10\n",
          "stdout": "5\n"
        },
        {
          "stdin": "2\n4 1\n1 2\n5 1\n1 3\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n3 1\n1 3\n6 2\n2 2\n6 6\n10 2\n3 10\n10 3\n",
          "stdout": "1\n0\n3\n"
        },
        {
          "stdin": "2\n4 3\n1 1\n2 2\n3 3\n3 1\n2 2\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "3\n3 2\n1 1\n3 3\n4 2\n2 2\n4 4\n5 3\n1 1\n3 3\n5 5\n",
          "stdout": "0\n0\n0\n"
        },
        {
          "stdin": "1\n5 5\n1 1\n2 2\n3 3\n4 4\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n2 1\n1 1\n",
          "stdout": "0\n"
        },
        {
          "stdin": "5\n2 1\n2 2\n3 1\n3 3\n4 1\n4 4\n5 1\n5 5\n6 1\n6 6\n",
          "stdout": "0\n0\n0\n0\n0\n"
        },
        {
          "stdin": "3\n3 1\n3 3\n4 2\n2 2\n4 4\n5 3\n1 1\n3 3\n5 5\n",
          "stdout": "0\n0\n0\n"
        },
        {
          "stdin": "3\n4 2\n2 1\n3 4\n5 3\n2 2\n3 3\n1 1\n5 3\n2 1\n3 2\n4 4\n",
          "stdout": "2\n0\n2\n"
        },
        {
          "stdin": "1\n4 1\n2 3\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n4 2\n2 2\n3 3\n5 3\n1 2\n3 5\n4 4\n",
          "stdout": "0\n2\n"
        },
        {
          "stdin": "1\n3 2\n1 2\n3 3\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n3 2\n1 1\n1 2\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n4 3\n1 1\n2 1\n3 1\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n5 4\n5 1\n4 1\n3 1\n2 1\n",
          "stdout": "4\n"
        },
        {
          "stdin": "2\n5 4\n1 1\n1 2\n1 3\n1 4\n5 1\n1 1\n",
          "stdout": "3\n0\n"
        },
        {
          "stdin": "2\n5 1\n1 2\n6 2\n1 2\n6 3\n",
          "stdout": "1\n2\n"
        },
        {
          "stdin": "1\n8 1\n4 5\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n7 1\n7 1\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n2 1\n1 1\n4 2\n1 2\n3 4\n",
          "stdout": "0\n2\n"
        },
        {
          "stdin": "1\n4 2\n1 2\n3 4\n",
          "stdout": "2\n"
        },
        {
          "stdin": "2\n2 1\n1 1\n3 2\n2 3\n1 1\n",
          "stdout": "0\n1\n"
        },
        {
          "stdin": "1\n3 1\n3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n7 1\n7 7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n4 3\n1 2\n3 4\n2 1\n6 5\n2 2\n1 1\n3 3\n4 4\n6 6\n",
          "stdout": "4\n0\n"
        },
        {
          "stdin": "3\n4 2\n1 1\n3 3\n5 4\n1 1\n2 2\n3 3\n5 5\n7 3\n2 2\n4 4\n6 6\n",
          "stdout": "0\n0\n0\n"
        },
        {
          "stdin": "1\n7 4\n1 1\n3 3\n4 4\n7 7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n3 2\n2 1\n1 2\n4 3\n2 3\n3 1\n1 3\n",
          "stdout": "3\n4\n"
        },
        {
          "stdin": "3\n3 1\n1 3\n4 4\n3 3\n1 2\n2 1\n1 4\n5 3\n2 5\n3 3\n1 1\n",
          "stdout": "1\n3\n1\n"
        },
        {
          "stdin": "2\n5 4\n4 5\n5 1\n2 2\n1 4\n3 2\n2 3\n1 2\n3 5\n2 3\n",
          "stdout": "4\n2\n"
        },
        {
          "stdin": "3\n3 1\n2 3\n4 4\n1 4\n2 3\n3 2\n4 1\n5 2\n2 2\n3 1\n4 1\n",
          "stdout": "1\n6\n1\n"
        },
        {
          "stdin": "2\n4 2\n1 4\n4 1\n5 4\n3 5\n2 5\n1 5\n4 3\n5 2\n",
          "stdout": "3\n4\n"
        },
        {
          "stdin": "2\n6 2\n3 5\n1 6\n8 4\n2 6\n5 8\n1 3\n4 2\n",
          "stdout": "2\n4\n"
        },
        {
          "stdin": "1\n10 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n",
          "stdout": "9\n"
        },
        {
          "stdin": "2\n4 3\n1 2\n2 3\n3 4\n4 2\n2 1\n1 3\n",
          "stdout": "3\n2\n"
        },
        {
          "stdin": "1\n4 4\n1 1\n2 2\n3 3\n4 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3\n2 1\n1 2\n4 2\n3 4\n1 2\n6 4\n6 1\n5 2\n2 3\n1 4\n",
          "stdout": "1\n2\n4\n"
        },
        {
          "stdin": "2\n5 2\n1 2\n2 5\n7 3\n3 4\n2 3\n1 2\n",
          "stdout": "2\n3\n"
        },
        {
          "stdin": "4\n12 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n10 5\n5 6\n4 5\n3 4\n2 3\n1 2\n9 7\n7 8\n6 7\n5 6\n4 5\n3 4\n2 3\n1 2\n15 8\n8 9\n7 8\n6 7\n5 6\n4 5\n3 4\n2 3\n1 2\n",
          "stdout": "6\n5\n7\n8\n"
        },
        {
          "stdin": "1\n3 2\n1 2\n3 1\n",
          "stdout": "2\n"
        },
        {
          "stdin": "3\n5 1\n4 5\n4 3\n2 2\n1 1\n3 3\n3 3\n2 1\n2 2\n3 1\n",
          "stdout": "1\n0\n2\n"
        },
        {
          "stdin": "2\n4 2\n2 2\n3 3\n5 4\n3 5\n5 2\n1 1\n4 4\n",
          "stdout": "0\n2\n"
        },
        {
          "stdin": "1\n10 5\n1 10\n10 1\n3 8\n4 7\n6 5\n",
          "stdout": "6\n"
        },
        {
          "stdin": "2\n7 3\n1 7\n7 1\n3 3\n5 2\n4 5\n2 1\n",
          "stdout": "3\n2\n"
        },
        {
          "stdin": "3\n5 2\n1 1\n2 2\n4 2\n1 3\n3 4\n4 1\n1 3\n",
          "stdout": "0\n2\n1\n"
        },
        {
          "stdin": "2\n4 2\n2 1\n3 4\n6 3\n2 4\n3 5\n1 1\n",
          "stdout": "2\n2\n"
        },
        {
          "stdin": "1\n5 4\n1 1\n2 2\n4 4\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n3 2\n1 1\n3 3\n4 3\n1 1\n2 2\n4 3\n",
          "stdout": "0\n1\n"
        },
        {
          "stdin": "1\n4 4\n1 1\n2 2\n4 4\n3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "5\n2 1\n1 1\n3 1\n1 1\n4 2\n1 1\n3 3\n5 3\n1 1\n2 2\n3 3\n3 2\n1 2\n2 3\n",
          "stdout": "0\n0\n0\n0\n2\n"
        },
        {
          "stdin": "4\n3 2\n1 1\n3 3\n4 2\n1 1\n2 2\n6 4\n1 1\n2 2\n3 3\n6 6\n5 2\n1 1\n5 5\n",
          "stdout": "0\n0\n0\n0\n"
        },
        {
          "stdin": "1\n4 2\n1 1\n4 4\n",
          "stdout": "0\n"
        },
        {
          "stdin": "3\n5 2\n2 1\n1 2\n4 3\n3 1\n2 4\n1 3\n6 4\n4 6\n3 1\n2 2\n1 5\n",
          "stdout": "3\n4\n3\n"
        },
        {
          "stdin": "2\n5 1\n5 5\n4 1\n2 4\n1 2\n",
          "stdout": "0\n1\n"
        },
        {
          "stdin": "2\n5 4\n5 1\n4 5\n3 2\n2 3\n6 2\n4 6\n1 1\n",
          "stdout": "5\n1\n"
        },
        {
          "stdin": "1\n4 3\n4 1\n3 4\n1 2\n4\n5 4\n5 1\n4 5\n3 2\n2 3\n",
          "stdout": "3\n"
        },
        {
          "stdin": "4\n5 2\n2 1\n1 2\n4 3\n3 1\n2 4\n1 3\n6 4\n4 6\n3 1\n2 2\n1 5\n6 1\n3 3\n",
          "stdout": "3\n4\n3\n0\n"
        },
        {
          "stdin": "3\n5 2\n2 1\n1 2\n4 3\n3 1\n2 4\n1 3\n6 1\n3 3\n",
          "stdout": "3\n4\n0\n"
        },
        {
          "stdin": "3\n6 1\n2 2\n5 2\n2 1\n1 2\n4 1\n2 4\n1 1\n",
          "stdout": "0\n3\n1\n"
        },
        {
          "stdin": "2\n5 2\n2 1\n1 2\n4 1\n2 4\n",
          "stdout": "3\n1\n"
        },
        {
          "stdin": "1\n6 1\n3 3\n",
          "stdout": "0\n"
        },
        {
          "stdin": "2\n4 3\n4 4\n3 1\n1 2\n5 2\n2 3\n1 2\n",
          "stdout": "2\n2\n"
        },
        {
          "stdin": "1\n3 1\n1 3\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n4 2\n2 3\n3 4\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n5 4\n1 2\n2 1\n3 5\n4 3\n5 4\n",
          "stdout": "5\n"
        },
        {
          "stdin": "1\n6 5\n1 2\n2 3\n3 1\n4 5\n5 6\n",
          "stdout": "6\n"
        },
        {
          "stdin": "1\n7 6\n1 7\n2 6\n3 5\n4 4\n5 3\n6 2\n",
          "stdout": "7\n"
        },
        {
          "stdin": "1\n8 7\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n9 8\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n",
          "stdout": "8\n"
        },
        {
          "stdin": "1\n2 1\n1 2\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n2 1\n2 1\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n3 3\n1 3\n2 2\n3 1\n",
          "stdout": "3\n"
        },
        {
          "stdin": "2\n2 1\n1 1\n2 1\n2 1\n",
          "stdout": "0\n1\n"
        },
        {
          "stdin": "2\n3 2\n1 1\n3 3\n3 2\n2 2\n1 1\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "2\n4 1\n2 2\n3 2\n1 1\n2 2\n",
          "stdout": "0\n0\n"
        },
        {
          "stdin": "1\n5 2\n1 5\n3 2\n",
          "stdout": "2\n"
        },
        {
          "stdin": "1\n5 4\n2 2\n3 3\n4 4\n5 5\n",
          "stdout": "0\n"
        },
        {
          "stdin": "1\n5 3\n1 1\n3 3\n5 5\n",
          "stdout": "0\n"
        }
      ],
      "source": "codeforces",
      "difficulty": "MEDIUM_HARD",
      "human_solutions": [
        "T = int(input())\nfor iw in range(T):\n\t(n, m) = map(int, input().split())\n\tans = 0\n\tX = [-1] * (n + 1)\n\tfor i in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tif x != y:\n\t\t\tans += 1\n\t\t\tX[x] = y\n\tfor i in range(1, n + 1):\n\t\tif X[i] > 0:\n\t\t\tt = i\n\t\t\twhile X[i] > 0:\n\t\t\t\tx = X[i]\n\t\t\t\tX[i] = 0\n\t\t\t\ti = x\n\t\t\t\tif i == t:\n\t\t\t\t\tans += 1\n\t\t\t\t\tbreak\n\tprint(ans)\n",
        "def main():\n\tarr = [0] * 100001\n\tfor _ in range(int(input())):\n\t\t(size, count) = map(int, input().split())\n\t\tfor i in range(count):\n\t\t\t(x, y) = map(int, input().split())\n\t\t\tarr[x] = y\n\t\tcycles = 0\n\t\tpetly = 0\n\t\tfor i in range(1, size + 1):\n\t\t\tif arr[i] == i:\n\t\t\t\tpetly += 1\n\t\t\t\tarr[i] = 0\n\t\t\tk = i\n\t\t\twhile arr[k] != 0:\n\t\t\t\ttemp = arr[k]\n\t\t\t\tarr[k] = 0\n\t\t\t\tk = temp\n\t\t\t\tif arr[k] == i:\n\t\t\t\t\tcycles += 1\n\t\t\t\t\tbreak\n\t\tprint(count - petly + cycles)\nmain()\n",
        "def find(i):\n\tk = i\n\tif p[i] == -1:\n\t\treturn 0\n\twhile 1:\n\t\tif p[i] == -1:\n\t\t\tbreak\n\t\tif p[i] == k:\n\t\t\tbreak\n\t\tl = i\n\t\tt = p[i]\n\t\ti = t\n\t\tp[l] = -1\n\tif p[i] == -1:\n\t\treturn 0\n\treturn 1\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tc = 0\n\tp = [-1] * (n + 1)\n\tfor i in range(n + 1):\n\t\tp[i] = -1\n\tfor i in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tif x != y:\n\t\t\tc += 1\n\t\t\tp[y] = x\n\tan = 0\n\tv = 0\n\tfor i in range(n + 1):\n\t\tif p[i] != -1 and find(i) == 1:\n\t\t\tp[i] = -1\n\t\t\tv += 1\n\tprint(c + v)\n",
        "def solve():\n\t(n, m) = map(int, input().split())\n\tgraph = dict()\n\tresult = int()\n\tfor _ in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tgraph[x] = [y, False]\n\tfor (key, value) in graph.items():\n\t\tif value[1] == False:\n\t\t\tgraph[key][1] = True\n\t\t\tfollow = graph[key][0]\n\t\t\tif follow != key:\n\t\t\t\twhile True:\n\t\t\t\t\tif follow in graph and graph[follow][1] == False:\n\t\t\t\t\t\tgraph[follow][1] = True\n\t\t\t\t\t\tresult += 1\n\t\t\t\t\t\tfollow = graph[follow][0]\n\t\t\t\t\t\tif follow == key:\n\t\t\t\t\t\t\tresult += 1\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\tresult += 1\n\tprint(result)\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tsolve()\nmain()\n",
        "t = int(input())\nfor j in range(t):\n\t(n, m) = [int(i) for i in input().split()]\n\tarr = [-1 for i in range(n + 1)]\n\tvis = [True for i in range(n + 1)]\n\tfor i in range(m):\n\t\t(x, y) = [int(k) for k in input().split()]\n\t\tif x != y:\n\t\t\tvis[x] = False\n\t\t\tarr[x] = y\n\tvis[0] = True\n\tans = 0\n\tfor i in range(n + 1):\n\t\tif vis[i] == False:\n\t\t\tstart = arr[i]\n\t\t\tvis[i] = True\n\t\t\tcount = 1\n\t\t\twhile vis[start] == False:\n\t\t\t\tvis[start] = True\n\t\t\t\tcount += 1\n\t\t\t\tstart = arr[start]\n\t\t\t\tif start == i:\n\t\t\t\t\tcount += 1\n\t\t\tans += count\n\tprint(ans)\n",
        "def getfather(x, father):\n\ttmp_father = x\n\tif father[x] != x:\n\t\ttmp_father = getfather(father[x], father)\n\telse:\n\t\ttmp_father = x\n\tfather[x] = tmp_father\n\treturn tmp_father\nT = int(input().strip())\nfor _ in range(T):\n\tline = input().strip().split()\n\t(n, m) = (int(line[0]), int(line[1]))\n\tresult = 0\n\tfather = [idx for idx in range(n + 1)]\n\tfor _x in range(m):\n\t\tline = input().strip().split()\n\t\t(x, y) = (int(line[0]), int(line[1]))\n\t\tif x == y:\n\t\t\tcontinue\n\t\tt1 = getfather(x, father)\n\t\tt2 = getfather(y, father)\n\t\tif t1 != t2:\n\t\t\tresult += 1\n\t\t\tfather[t1] = t2\n\t\telse:\n\t\t\tresult += 2\n\tprint(result)\n",
        "def dsu(x):\n\tp = x\n\twhile v[x] != x:\n\t\tx = v[x]\n\tv[p] = x\n\treturn x\nfor _ in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tans = 0\n\tv = [i for i in range(n + 1)]\n\tans = 0\n\tfor _ in range(m):\n\t\t(a, b) = map(int, input().split())\n\t\tif a == b:\n\t\t\tcontinue\n\t\tans += 1\n\t\tp = dsu(a)\n\t\tq = dsu(b)\n\t\tif p != q:\n\t\t\tv[p] = v[q]\n\t\telse:\n\t\t\tans += 1\n\tprint(ans)\n",
        "for _ in range(int(input())):\n\t(n, m) = [int(x) for x in input().split()]\n\tl = [None] * (n + 1)\n\tfor _ in range(m):\n\t\t(x, y) = [int(x) for x in input().split()]\n\t\tl[x] = y\n\tans = 0\n\tvisited = [False] * (n + 1)\n\tfor i in range(n + 1):\n\t\tif l[i] == None or l[i] == i or visited[i]:\n\t\t\tcontinue\n\t\t(tmp, cnt) = (l[i], 1)\n\t\tvisited[i] = True\n\t\twhile tmp != i and tmp != None and (visited[tmp] == False):\n\t\t\tvisited[tmp] = True\n\t\t\ttmp = l[tmp]\n\t\t\tcnt += 1\n\t\tcnt += tmp == i\n\t\tcnt -= tmp == None\n\t\tans += cnt\n\tprint(ans)\n",
        "class Solution:\n\n\tdef __init__(self, n: int, m: int):\n\t\tself.parent = list(range(n + 1))\n\t\tself.count = m\n\n\tdef find(self, x: int) -> int:\n\t\tif self.parent[x] != x:\n\t\t\tself.parent[x] = self.find(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef union(self, x: int, y: int):\n\t\tif x == y:\n\t\t\tself.count -= 1\n\t\t\treturn\n\t\tx_p = self.find(x)\n\t\ty_p = self.find(y)\n\t\tif x_p == y_p:\n\t\t\tself.count += 1\n\t\telse:\n\t\t\tself.parent[x_p] = y_p\n\n\tdef get_count(self):\n\t\treturn self.count\nt = int(input())\nwhile t > 0:\n\tt -= 1\n\t(n, m) = input().split(' ')\n\t(n, m) = (int(n), int(m))\n\tso = Solution(n, m)\n\tfor _ in range(m):\n\t\t(x, y) = input().split(' ')\n\t\t(x, y) = (int(x), int(y))\n\t\tso.union(x, y)\n\tprint(so.get_count())\n",
        "import sys\nimport math, bisect, operator\n(inf, m) = (float('inf'), 10 ** 9 + 7)\nsys.setrecursionlimit(10 ** 6)\nfrom itertools import groupby, accumulate\nfrom heapq import heapify, heappop, heappush\nfrom collections import deque, Counter, defaultdict\nI = lambda : int(sys.stdin.readline())\nneo = lambda : map(int, sys.stdin.readline().split())\nNeo = lambda : list(map(int, sys.stdin.readline().split()))\nfor tt in range(int(input())):\n\t(x, y) = map(int, input().split())\n\tl = [0] * (x + 1)\n\tv = [0] * (x + 1)\n\tfor i in range(y):\n\t\t(a, b) = map(int, input().split())\n\t\tl[a] = b\n\tc = 0\n\tfor i in range(1, x + 1):\n\t\tif l[i] != i:\n\t\t\ttemp = i\n\t\t\twhile v[temp] != 1 and l[temp] != 0:\n\t\t\t\tc += 1\n\t\t\t\tv[temp] = 1\n\t\t\t\ttemp = l[temp]\n\t\t\t\tif temp == i:\n\t\t\t\t\tc += 1\n\t\t\t\t\tbreak\n\tprint(c)\n",
        "def move_nu(allPoints, m):\n\tn = len(allPoints)\n\txlab = [-1] * m\n\tylab = [-1] * m\n\txexi = [0] * m\n\texnum = 0\n\txynum = 0\n\tfor point in allPoints:\n\t\txlab[point[0] - 1] = point[1] - 1\n\t\tylab[point[1] - 1] = point[0] - 1\n\tfor point in allPoints:\n\t\tx0 = point[0] - 1\n\t\ty0 = point[1] - 1\n\t\tif xexi[x0]:\n\t\t\tcontinue\n\t\tif x0 == y0:\n\t\t\txynum += 1\n\t\t\tcontinue\n\t\ty1 = y0\n\t\tx1 = x0\n\t\twhile xexi[x1] == 0 and xlab[x1] != -1:\n\t\t\txexi[x1] = 1\n\t\t\tx1 = y1\n\t\t\ty1 = xlab[x1]\n\t\tif xlab[x1] != -1:\n\t\t\texnum += 1\n\t\telif ylab[x0] != -1:\n\t\t\tx1 = ylab[x0]\n\t\t\twhile x1 != -1 and xexi[x1] == 0:\n\t\t\t\txexi[x1] = 1\n\t\t\t\tx1 = ylab[x1]\n\treturn n - xynum + exnum\nn = int(input())\nans = []\nfor i in range(n):\n\tll = input().split()\n\tallpoints = []\n\tfor j in range(int(ll[1])):\n\t\tallpoints.append(tuple(map(int, input().split())))\n\tans.append(move_nu(allpoints, int(ll[0])))\nfor i in ans:\n\tprint(i)\n",
        "import sys\nif not sys.warnoptions:\n\timport warnings\n\twarnings.simplefilter('ignore')\n\ndef ii():\n\treturn int(input())\n\ndef li():\n\treturn [int(i) for i in input().split()]\n\ndef ls():\n\treturn [i for i in input().split()]\nfor t in range(ii()):\n\t(n, m) = li()\n\tstore = [-1 for i in range(n)]\n\tfor i in range(m):\n\t\t(x, y) = li()\n\t\tx -= 1\n\t\ty -= 1\n\t\tstore[x] = y\n\tvis = [0 for i in range(n)]\n\tans = 0\n\tfor i in range(n):\n\t\tif store[i] != -1:\n\t\t\tif store[i] != i:\n\t\t\t\tans += 1\n\t\t\t\troot = i\n\t\t\t\tcnt = 0\n\t\t\t\twhile vis[root] == 0:\n\t\t\t\t\tvis[root] = 1\n\t\t\t\t\tif store[root] == -1:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tcnt += 1\n\t\t\t\t\t\troot = store[root]\n\t\t\t\tif root == i and cnt > 0:\n\t\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tvis[i] = 1\n\t\telse:\n\t\t\tvis[i] = 1\n\tprint(ans)\n",
        "for l in range(int(input())):\n\t(n, m) = map(int, input().split())\n\tres = 0\n\ttable = dict()\n\tfor i in range(m):\n\t\t(a, b) = map(int, input().split())\n\t\ttable[a] = [b, False]\n\tfor key in table:\n\t\tif table[key][1] == False:\n\t\t\ttable[key][1] = True\n\t\t\ttemp_key = table[key][0]\n\t\t\tif key != temp_key:\n\t\t\t\twhile True:\n\t\t\t\t\tif table.get(temp_key):\n\t\t\t\t\t\tif table[temp_key][1] == True:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tres += 1\n\t\t\t\t\t\ttable[temp_key][1] = True\n\t\t\t\t\t\ttemp_key = table[temp_key][0]\n\t\t\t\t\t\tif temp_key == key:\n\t\t\t\t\t\t\tres += 1\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\tres += 1\n\tprint(res)\n",
        "for _ in range(int(input())):\n\t(n, m) = list(map(int, input().split(' ')))\n\trook_poses = {}\n\tfor _ in range(m):\n\t\t(x, y) = tuple(map(int, input().split(' ')))\n\t\tif x != y:\n\t\t\trook_poses[x] = y\n\tnum_moves = 0\n\tcycle = set()\n\tunvisited = set(rook_poses.keys())\n\twhile unvisited:\n\t\tx = unvisited.pop()\n\t\tcycle.add(x)\n\t\ty = rook_poses[x]\n\t\tnum_moves += 1\n\t\twhile y in unvisited:\n\t\t\tx = y\n\t\t\tunvisited.remove(x)\n\t\t\tcycle.add(x)\n\t\t\ty = rook_poses[x]\n\t\t\tnum_moves += 1\n\t\tif y in cycle:\n\t\t\tnum_moves += 1\n\t\tcycle.clear()\n\tprint(num_moves)\n",
        "t = int(input())\nfor j in range(0, t):\n\t(n, m) = map(int, input().split())\n\tc = 0\n\tg = {}\n\tp = []\n\td = {}\n\tfor kk in range(0, m):\n\t\t(a, b) = map(int, input().split())\n\t\tif a != b:\n\t\t\tp.append(a)\n\t\t\tg[a] = b\n\t\t\td[a] = 0\n\tcc = 0\n\tfor tt in p:\n\t\ts = tt\n\t\to = s\n\t\tfl = 0\n\t\tif d[o] == 0:\n\t\t\twhile o in d and d[o] == 0:\n\t\t\t\tcc += 1\n\t\t\t\td[o] = 1\n\t\t\t\tif o in g:\n\t\t\t\t\tif g[o] == s:\n\t\t\t\t\t\tfl = 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\to = g[o]\n\t\t\t\telse:\n\t\t\t\t\tfl = 0\n\t\t\t\t\tbreak\n\t\t\tif fl == 1:\n\t\t\t\tcc += 1\n\tprint(cc + c)\n",
        "t = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().strip().split())\n\txs = set()\n\tys = set()\n\txd = []\n\tyd = []\n\tx = [0] * (n + 1)\n\ty = [0] * (n + 1)\n\tfor _ in range(m):\n\t\t(i, j) = map(int, input().strip().split())\n\t\txd.append(i)\n\t\tyd.append(j)\n\t\tx[i] = j\n\t\ty[j] = i\n\t\txs.add(i)\n\t\tys.add(j)\n\tcount = 0\n\tfor i in range(m):\n\n\t\tdef inner():\n\t\t\tif xd[i] == yd[i]:\n\t\t\t\treturn 0\n\t\t\tif x[xd[i]] == 0:\n\t\t\t\treturn 0\n\t\t\tif xd[i] not in ys:\n\t\t\t\tlc = 1\n\t\t\t\tnum = x[xd[i]]\n\t\t\t\tx[xd[i]] = 0\n\t\t\t\twhile num in xs:\n\t\t\t\t\tlc += 1\n\t\t\t\t\tt = x[num]\n\t\t\t\t\tx[num] = 0\n\t\t\t\t\tnum = t\n\t\t\t\treturn lc\n\t\t\telse:\n\t\t\t\tlc = 1\n\t\t\t\tnum = x[xd[i]]\n\t\t\t\tx[xd[i]] = 0\n\t\t\t\twhile num in xs:\n\t\t\t\t\tif x[num] == 0:\n\t\t\t\t\t\treturn lc + 1\n\t\t\t\t\tlc += 1\n\t\t\t\t\tt = x[num]\n\t\t\t\t\tx[num] = 0\n\t\t\t\t\tnum = t\n\t\t\t\tlc += 1\n\t\t\t\tnum = y[xd[i]]\n\t\t\t\tx[y[xd[i]]] = 0\n\t\t\t\twhile num in ys:\n\t\t\t\t\tlc += 1\n\t\t\t\t\tt = y[num]\n\t\t\t\t\tx[y[num]] = 0\n\t\t\t\t\tnum = t\n\t\t\t\treturn lc\n\t\t\treturn 0\n\t\tcount += inner()\n\tprint(count)\n",
        "import sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\nfrom collections import defaultdict\n\ndef solve():\n\n\tdef dfs(node, visited, parent, an):\n\t\tvisited[node] = 1\n\t\tfor v in g[node]:\n\t\t\tif visited[v] == 0:\n\t\t\t\tdfs(v, visited, node, an)\n\t\t\telif v != parent:\n\t\t\t\tan[0] = 1\n\tf = 0\n\tt = int(input())\n\tfor i in range(t):\n\t\tg = defaultdict(list)\n\t\t(n, m) = map(int, input().split())\n\t\tp = 0\n\t\tfor j in range(m):\n\t\t\t(u, v) = map(int, sys.stdin.readline().split())\n\t\t\tif u != v:\n\t\t\t\tg[u].append(v)\n\t\t\t\tg[v].append(u)\n\t\t\t\tp = p + 1\n\t\tvisited = [0] * (n + 1)\n\t\tfor j in range(1, n + 1):\n\t\t\tif visited[j] == 0 and j in g:\n\t\t\t\tan = [0]\n\t\t\t\tdfs(j, visited, -1, an)\n\t\t\t\tp = p + an[0]\n\t\tprint(p)\nthreading.Thread(target=solve).start()\n",
        "class UnionFind:\n\n\tdef __init__(self, n: int):\n\t\tself.parent = list(range(n))\n\t\tself.size = [1] * n\n\t\tself.n = n\n\t\tself.setCount = n\n\n\tdef findset(self, x: int) -> int:\n\t\tif self.parent[x] == x:\n\t\t\treturn x\n\t\tself.parent[x] = self.findset(self.parent[x])\n\t\treturn self.parent[x]\n\n\tdef unite(self, x: int, y: int) -> bool:\n\t\t(x, y) = (self.findset(x), self.findset(y))\n\t\tif x == y:\n\t\t\treturn False\n\t\tif self.size[x] < self.size[y]:\n\t\t\t(x, y) = (y, x)\n\t\tself.parent[y] = x\n\t\tself.size[x] += self.size[y]\n\t\tself.setCount -= 1\n\t\treturn True\n\n\tdef connected(self, x: int, y: int) -> bool:\n\t\t(x, y) = (self.findset(x), self.findset(y))\n\t\treturn x == y\nT = int(input())\nwhile T:\n\t(n, m) = map(int, input().split(' '))\n\tuf = UnionFind(n)\n\tok = 0\n\thuan = 0\n\tfor _ in range(m):\n\t\t(x, y) = map(int, input().split(' '))\n\t\tif x == y:\n\t\t\tok += 1\n\t\telif not uf.unite(x - 1, y - 1):\n\t\t\thuan += 1\n\tprint(m + huan - ok)\n\tT -= 1\n",
        "sa = lambda : input()\nsb = lambda : int(input())\nsc = lambda : input().split()\nsd = lambda : list(map(int, input().split()))\nse = lambda : float(input())\n\nclass Disjoint_SU:\n\n\tdef __init__(self, n):\n\t\tself.parent = [i for i in range(n)]\n\t\tself.size = [1 for i in range(n)]\n\n\tdef lake_de(self, a):\n\t\tif a == self.parent[a]:\n\t\t\treturn a\n\t\tself.parent[a] = self.lake_de(self.parent[a])\n\t\treturn self.parent[a]\n\n\tdef jod(self, a, b):\n\t\tx = self.lake_de(a)\n\t\ty = self.lake_de(b)\n\t\tif x == y:\n\t\t\treturn True\n\t\tif self.size[x] > self.size[y]:\n\t\t\tself.size[x] += self.size[y]\n\t\t\tself.parent[y] = x\n\t\telse:\n\t\t\tself.size[y] += self.size[x]\n\t\t\tself.parent[x] = y\n\t\treturn False\n\ndef hnbhai():\n\t(n, m) = sd()\n\tobj = Disjoint_SU(n)\n\ttotal = 0\n\tfor i in range(m):\n\t\t(x, y) = sd()\n\t\tx -= 1\n\t\ty -= 1\n\t\tif x == y:\n\t\t\tcontinue\n\t\ttotal += 1\n\t\tif obj.jod(x, y):\n\t\t\ttotal += 1\n\tprint(total)\nfor _ in range(sb()):\n\thnbhai()\n",
        "def untie(r, c, d, i, x, y, e):\n\tres = 0\n\tu = i\n\tt = set()\n\t(ux, uy) = d[u]\n\tif ux == uy:\n\t\treturn (0, set([u]))\n\twhile 1:\n\t\tif not ux in c or c[ux] in e:\n\t\t\tt.add(u)\n\t\t\tres += 1\n\t\t\treturn (res, t)\n\t\tres += 1\n\t\tt.add(u)\n\t\tu = c[ux]\n\t\t(ux, uy) = d[u]\n\t\tif u == i:\n\t\t\tres += 1\n\t\t\treturn (res, t)\nt = int(input())\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\tr = {}\n\tc = {}\n\td = []\n\tres = 0\n\te = set()\n\tfor i in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tr[x] = i\n\t\tc[y] = i\n\t\td += [[x, y]]\n\tfor i in range(m):\n\t\t(x, y) = d[i]\n\t\tif i in e:\n\t\t\tcontinue\n\t\t(a, b) = untie(r, c, d, i, x, y, e)\n\t\te = e.union(b)\n\t\tres += a\n\tprint(res)\n",
        "lm = lambda : list(map(int, input().split()))\nii = lambda : int(input())\n\nclass sabar_karo:\n\n\tdef __init__(self, n):\n\t\tself.baap = [i for i in range(n)]\n\t\tself.aukat = [1 for _ in range(n)]\n\n\tdef pata_karo(self, a):\n\t\tif a == self.baap[a]:\n\t\t\treturn a\n\t\tself.baap[a] = self.pata_karo(self.baap[a])\n\t\treturn self.baap[a]\n\n\tdef daya(self, a, b):\n\t\tx = self.pata_karo(a)\n\t\ty = self.pata_karo(b)\n\t\ta = x\n\t\tb = y\n\t\tif x == y:\n\t\t\treturn True\n\t\telif self.aukat[a] > self.aukat[b]:\n\t\t\tself.aukat[a] += self.aukat[b]\n\t\t\tself.baap[b] = a\n\t\telse:\n\t\t\tself.aukat[b] += self.aukat[a]\n\t\t\tself.baap[a] = b\n\t\treturn False\n\ndef ruko_jara():\n\t(n, m) = lm()\n\tx = sabar_karo(n)\n\tans = 0\n\tfor _ in range(m):\n\t\t(u, v) = lm()\n\t\tif u == v:\n\t\t\tcontinue\n\t\tans += 1\n\t\tif x.daya(u - 1, v - 1):\n\t\t\tans += 1\n\tprint(ans)\nfor _ in range(ii()):\n\truko_jara()\n",
        "import sys, threading\nsys.setrecursionlimit(500000)\nthreading.stack_size(134217728)\nfrom collections import defaultdict\n\ndef solve():\n\n\tdef dfs(node, visited, parent, loop):\n\t\tvisited[node] = 1\n\t\tfor v in graph[node]:\n\t\t\tif visited[v] == 0:\n\t\t\t\tdfs(v, visited, node, loop)\n\t\t\telif v != parent:\n\t\t\t\tloop[0] = 1\n\tfor _ in range(int(input())):\n\t\t(n, m) = map(int, input().split())\n\t\tans = 0\n\t\tgraph = defaultdict(list)\n\t\tfor i in range(m):\n\t\t\t(x, y) = map(int, input().split())\n\t\t\tif x != y:\n\t\t\t\tgraph[x].append(y)\n\t\t\t\tgraph[y].append(x)\n\t\t\t\tans += 1\n\t\tvisited = [0] * (n + 1)\n\t\tfor i in range(1, n + 1):\n\t\t\tif visited[i] == 0 and i in graph:\n\t\t\t\tloop = [0]\n\t\t\t\tdfs(i, visited, -1, loop)\n\t\t\t\tans += loop[0]\n\t\tprint(ans)\nthreading.Thread(target=solve).start()\n",
        "from collections import defaultdict\nimport sys\nt = int(input())\nsys.setrecursionlimit(100000000)\n\ndef rek():\n\twhile stack:\n\t\tk = stack.pop()\n\t\t(a, b) = k\n\t\ttmp[0] += 1\n\t\tw[k] = True\n\t\tif ver[a]:\n\t\t\tif not w[ver[a]]:\n\t\t\t\tw[ver[a]] = True\n\t\t\t\tstack.append(ver[a])\n\t\telse:\n\t\t\tcheck[0] = False\n\t\tif st[b]:\n\t\t\tif not w[st[b]]:\n\t\t\t\tw[st[b]] = True\n\t\t\t\tstack.append(st[b])\n\t\telse:\n\t\t\tcheck[0] = False\nfor _ in range(t):\n\t(n, m) = map(int, input().split())\n\t(st, ver) = (defaultdict(tuple), defaultdict(tuple))\n\tar = []\n\tfor _ in range(m):\n\t\t(a, b) = map(int, input().split())\n\t\tq = (a, b)\n\t\tar.append(q)\n\t\tst[a] = q\n\t\tver[b] = q\n\tres = 0\n\tw = defaultdict(bool)\n\tfor (a, b) in ar:\n\t\tif a != b and (not w[a, b]):\n\t\t\ttmp = [0]\n\t\t\tcheck = [True]\n\t\t\tstack = [(a, b)]\n\t\t\trek()\n\t\t\tif check[0]:\n\t\t\t\ttmp[0] += 1\n\t\t\tres += tmp[0]\n\tprint(res)\n",
        "T = int(input())\nfor _ in range(T):\n\t(n, k) = map(int, input().split())\n\tlim = 10 ** 5 + 10\n\tA = [-1] * lim\n\tans = 0\n\tflag = 0\n\tfor i in range(k):\n\t\t(x, y) = map(int, input().split())\n\t\tif flag == 0:\n\t\t\tflag = 1\n\t\t\tres = x\n\t\tif x != y:\n\t\t\tans += 1\n\t\t\tA[x] = y\n\t\tflag = 0\n\t\tx = res\n\t\twhile True:\n\t\t\ttemp = A[x]\n\t\t\tif temp == -1:\n\t\t\t\tbreak\n\t\t\tif temp == res:\n\t\t\t\tans += 1\n\t\t\t\tbreak\n\t\t\tx = temp\n\tprint(ans)\n",
        "import sys, threading\nsys.setrecursionlimit(200000)\nthreading.stack_size(10 ** 8)\nfrom collections import defaultdict as dd\n\ndef dfs(x, y):\n\tglobal v, adj, b, c, d\n\tv[x] = 1\n\tc += 1\n\tfor i in adj[x]:\n\t\tif not v[i]:\n\t\t\tdfs(i, x)\n\t\telif i != y and y != -1 or (i == y and d[i, x] == 2):\n\t\t\tb += 2\n\t\t\td[i, x] = 1\n\t\t\td[x, i] = 1\n\ndef main():\n\tglobal v, adj, b, c, d\n\tfor t in range(int(input())):\n\t\t(n, m) = map(int, input().split())\n\t\tadj = [[] for i in range(n + 1)]\n\t\ta = 0\n\t\tb = 0\n\t\tc = 0\n\t\tv = [0] * (n + 1)\n\t\td = dd(int)\n\t\tfor i in range(m):\n\t\t\t(x, y) = map(int, input().split())\n\t\t\tif x != y:\n\t\t\t\tadj[x].append(y)\n\t\t\t\tadj[y].append(x)\n\t\t\t\td[x, y] += 1\n\t\t\t\td[y, x] += 1\n\t\t\telse:\n\t\t\t\ta += 1\n\t\tans = 0\n\t\tfor j in range(1, n + 1):\n\t\t\tif not v[j]:\n\t\t\t\tc = 0\n\t\t\t\tdfs(j, -1)\n\t\t\t\tans += c - 1\n\t\tprint(ans + b)\nz = threading.Thread(target=main)\nz.start()\nz.join()\n",
        "import sys\n\ndef main():\n\t(n, m) = map(int, input().split())\n\tdct = dict()\n\tdots_visited = set()\n\to = 0\n\tdct_dots = dict()\n\tdots = []\n\tfor i in range(m):\n\t\t(x, y) = map(int, input().split())\n\t\tif x != y:\n\t\t\tif x in dct_dots:\n\t\t\t\tdct_dots[x].append(o)\n\t\t\telse:\n\t\t\t\tdct_dots[x] = [o]\n\t\t\tif y in dct_dots:\n\t\t\t\tdct_dots[y].append(o)\n\t\t\telse:\n\t\t\t\tdct_dots[y] = [o]\n\t\t\tdct[o] = set()\n\t\t\tdots.append([x, y])\n\t\t\to += 1\n\tfor i in dct_dots:\n\t\tif len(dct_dots[i]) == 2:\n\t\t\tdct[dct_dots[i][0]].add(dct_dots[i][1])\n\t\t\tdct[dct_dots[i][1]].add(dct_dots[i][0])\n\tcnt = 0\n\tfor dot in range(o):\n\t\tif not dot in dots_visited:\n\t\t\tto_go = set()\n\t\t\tto_go.add(dot)\n\t\t\tst = set()\n\t\t\twhile len(to_go) != 0:\n\t\t\t\tdt = to_go.pop()\n\t\t\t\tst.add(dt)\n\t\t\t\tdots_visited.add(dt)\n\t\t\t\tfor i in dct[dt]:\n\t\t\t\t\tif not i in dots_visited:\n\t\t\t\t\t\tto_go.add(i)\n\t\t\tways = set()\n\t\t\tfor i in st:\n\t\t\t\tways.add(dots[i][0])\n\t\t\t\tways.add(dots[i][1])\n\t\t\tcnt += len(st)\n\t\t\tif len(ways) <= len(st):\n\t\t\t\tcnt += 1\n\tprint(cnt)\nt = int(input())\nfor i in range(t):\n\tmain()\n",
        "class UFS:\n\n\tdef __init__(self):\n\t\tself.parent = {}\n\n\tdef add(self, x):\n\t\tif x not in self.parent:\n\t\t\tself.parent[x] = x\n\n\tdef find(self, x):\n\t\troot = x\n\t\twhile self.parent[root] != root:\n\t\t\troot = self.parent[root]\n\t\twhile x != root:\n\t\t\t(x, self.parent[x]) = (self.parent[x], root)\n\t\treturn root\n\n\tdef isConnected(self, x, y):\n\t\trootx = self.find(x)\n\t\trooty = self.find(y)\n\t\treturn rootx == rooty\n\n\tdef union(self, x, y):\n\t\trootx = self.find(x)\n\t\trooty = self.find(y)\n\t\tif rootx != rooty:\n\t\t\tself.parent[rootx] = rooty\n\ndef solution(indexs):\n\tufs = UFS()\n\tans = 0\n\tfor (i, j) in indexs:\n\t\tif i == j:\n\t\t\tcontinue\n\t\tans += 1\n\t\tufs.add((i, i))\n\t\tufs.add((j, j))\n\t\tufs.add((i, j))\n\t\tif ufs.isConnected((i, i), (j, j)):\n\t\t\tans += 1\n\t\tufs.union((i, i), (i, j))\n\t\tufs.union((j, j), (i, j))\n\treturn ans\nT = int(input())\nwhile T:\n\tT -= 1\n\t(n, m) = list(map(int, input().split()))\n\tindexs = []\n\twhile m:\n\t\t(i, j) = list(map(int, input().split()))\n\t\tindexs.append((i, j))\n\t\tm -= 1\n\tans = solution(indexs)\n\tprint(ans)\n"
      ],
      "original_code": null
    },
    "status": "success",
    "code": "def solve():\n    import sys\n    input_data = sys.stdin.buffer.read().split()\n    if not input_data:\n        return\n    t = int(input_data[0])\n    pos = 1\n    results = []\n    for _ in range(t):\n        n = int(input_data[pos])\n        m = int(input_data[pos+1])\n        pos += 2\n\n        # For rooks that are not on the main diagonal, we build a mapping\n        # From the rook's row x to its column y.\n        # Since rooks don't attack each other initially, all x and y values are unique.\n        mapping = {}\n        off_diag = 0\n        for i in range(m):\n            x = int(input_data[pos])\n            y = int(input_data[pos+1])\n            pos += 2\n            if x == y:  # already on main diagonal; ignore\n                continue\n            mapping[x] = y  # Create the mapping f(x) = y.\n            off_diag += 1\n\n        # We now need to find cycles in our mapping.\n        # In a chain (non-cycle) of length L, we can move each rook once.\n        # In a cycle of length L, we require L + 1 moves.\n        # In other words, the overall moves = (# off_diag rooks) + (number of cycles).\n        visited = set()\n        cycles = 0\n\n        # Our mapping is a partial permutation. For each starting row (key in mapping),\n        # we follow the chain. If we eventually get a rook already in our chain,\n        # then we have a cycle.\n        for start in mapping:\n            if start in visited:\n                continue\n            cur = start\n            chain_set = set()\n            while True:\n                visited.add(cur)\n                chain_set.add(cur)\n                # If there is a rook starting at current row...\n                if cur in mapping:\n                    nxt = mapping[cur]\n                    # if the next node is in the current chain, we have found a cycle.\n                    if nxt in chain_set:\n                        cycles += 1\n                        break\n                    # if next node has already been visited, this chain joins a chain/cycle we processed.\n                    if nxt in visited:\n                        break\n                    cur = nxt\n                else:\n                    break\n\n        # The answer is the number of off-diagonal rooks plus one extra move per cycle.\n        results.append(str(off_diag + cycles))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == '__main__':\n    solve()",
    "pass_ratio": 1.0,
    "tests_passed": 126,
    "tests_total": 126,
    "iterations": 1,
    "history": [
      {
        "iteration": 1,
        "code": "def solve():\n    import sys\n    input_data = sys.stdin.buffer.read().split()\n    if not input_data:\n        return\n    t = int(input_data[0])\n    pos = 1\n    results = []\n    for _ in range(t):\n        n = int(input_data[pos])\n        m = int(input_data[pos+1])\n        pos += 2\n\n        # For rooks that are not on the main diagonal, we build a mapping\n        # From the rook's row x to its column y.\n        # Since rooks don't attack each other initially, all x and y values are unique.\n        mapping = {}\n        off_diag = 0\n        for i in range(m):\n            x = int(input_data[pos])\n            y = int(input_data[pos+1])\n            pos += 2\n            if x == y:  # already on main diagonal; ignore\n                continue\n            mapping[x] = y  # Create the mapping f(x) = y.\n            off_diag += 1\n\n        # We now need to find cycles in our mapping.\n        # In a chain (non-cycle) of length L, we can move each rook once.\n        # In a cycle of length L, we require L + 1 moves.\n        # In other words, the overall moves = (# off_diag rooks) + (number of cycles).\n        visited = set()\n        cycles = 0\n\n        # Our mapping is a partial permutation. For each starting row (key in mapping),\n        # we follow the chain. If we eventually get a rook already in our chain,\n        # then we have a cycle.\n        for start in mapping:\n            if start in visited:\n                continue\n            cur = start\n            chain_set = set()\n            while True:\n                visited.add(cur)\n                chain_set.add(cur)\n                # If there is a rook starting at current row...\n                if cur in mapping:\n                    nxt = mapping[cur]\n                    # if the next node is in the current chain, we have found a cycle.\n                    if nxt in chain_set:\n                        cycles += 1\n                        break\n                    # if next node has already been visited, this chain joins a chain/cycle we processed.\n                    if nxt in visited:\n                        break\n                    cur = nxt\n                else:\n                    break\n\n        # The answer is the number of off-diagonal rooks plus one extra move per cycle.\n        results.append(str(off_diag + cycles))\n    \n    sys.stdout.write(\"\\n\".join(results))\n\n\nif __name__ == '__main__':\n    solve()",
        "pass_ratio": 1.0,
        "tests_passed": 126,
        "tests_total": 126
      }
    ],
    "model_type": "openai",
    "model_name": "o3_mini"
  },
  {
    "problem": {
      "problem_id": 4,
      "question": "Cirno gave AquaMoon a chessboard of size $1 \\times n$. Its cells are numbered with integers from $1$ to $n$ from left to right. In the beginning, some of the cells are occupied with at most one pawn, and other cells are unoccupied.\n\nIn each operation, AquaMoon can choose a cell $i$ with a pawn, and do either of the following (if possible):\n\nMove pawn from it to the $(i+2)$-th cell, if $i+2 \\leq n$ and the $(i+1)$-th cell is occupied and the $(i+2)$-th cell is unoccupied.\n\nMove pawn from it to the $(i-2)$-th cell, if $i-2 \\geq 1$ and the $(i-1)$-th cell is occupied and the $(i-2)$-th cell is unoccupied.\n\nYou are given an initial state of the chessboard. AquaMoon wants to count the number of states reachable from the initial state with some sequence of operations. But she is not good at programming. Can you help her? As the answer can be large find it modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10000$) \u2014 the number of test cases.\n\nThe first line contains a single integer $n$ ($1 \\leq n \\leq 10^5$) \u2014 the size of the chessboard.\n\nThe second line contains a string of $n$ characters, consists of characters \"0\" and \"1\". If the $i$-th character is \"1\", the $i$-th cell is initially occupied; otherwise, the $i$-th cell is initially unoccupied.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the number of states that reachable from the initial state with some sequence of operations modulo $998\\,244\\,353$.\n\n\n-----Examples-----\n\nInput\n6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\nOutput\n3\n6\n1\n1287\n1287\n715\n\n\n-----Note-----\n\nIn the first test case the strings \"1100\", \"0110\" and \"0011\" are reachable from the initial state with some sequence of operations.",
      "tests": [
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "2\n3\n011\n2\n11\n",
          "stdout": "2\n1\n"
        },
        {
          "stdin": "2\n3\n011\n2\n11\n",
          "stdout": "2\n1\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "2\n3\n011\n2\n11\n",
          "stdout": "2\n1\n"
        },
        {
          "stdin": "5\n6\n101011\n5\n00000\n8\n11011011\n20\n11111111111111111111\n10\n1111111111\n",
          "stdout": "3\n1\n10\n1\n1\n"
        },
        {
          "stdin": "1\n10\n1110000011\n",
          "stdout": "21\n"
        },
        {
          "stdin": "1\n9\n000101000\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n2\n00\n2\n11\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n7\n1010101\n5\n11001\n15\n111111000000111\n",
          "stdout": "1\n3\n210\n"
        },
        {
          "stdin": "1\n5\n10101\n",
          "stdout": "1\n"
        },
        {
          "stdin": "4\n10\n1000000000\n10\n1111111111\n5\n00000\n5\n11111\n",
          "stdout": "1\n1\n1\n1\n"
        },
        {
          "stdin": "3\n5\n11111\n5\n10000\n5\n00000\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "2\n4\n0000\n4\n1111\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n10\n1010101010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3\n7\n1010101\n7\n1101101\n7\n1110111\n",
          "stdout": "1\n6\n3\n"
        },
        {
          "stdin": "4\n8\n01010101\n8\n11100000\n8\n00011111\n8\n10001000\n",
          "stdout": "1\n6\n10\n1\n"
        },
        {
          "stdin": "2\n6\n110100\n6\n001011\n",
          "stdout": "4\n4\n"
        },
        {
          "stdin": "2\n5\n11110\n5\n01111\n",
          "stdout": "3\n3\n"
        },
        {
          "stdin": "3\n7\n1011011\n7\n1110101\n7\n1101011\n",
          "stdout": "6\n3\n6\n"
        },
        {
          "stdin": "1\n9\n101001010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n5\n10101\n5\n01010\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n7\n1010101\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3\n10\n1010101010\n10\n0101010101\n10\n1110001110\n",
          "stdout": "1\n1\n15\n"
        },
        {
          "stdin": "1\n8\n10101010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n9\n111000111\n9\n000111000\n",
          "stdout": "10\n7\n"
        },
        {
          "stdin": "2\n6\n111000\n6\n000111\n",
          "stdout": "4\n4\n"
        },
        {
          "stdin": "3\n7\n1110000\n7\n0001111\n7\n1000001\n",
          "stdout": "5\n10\n1\n"
        },
        {
          "stdin": "2\n5\n11100\n5\n00111\n",
          "stdout": "3\n3\n"
        },
        {
          "stdin": "1\n10\n1111111111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n9\n100000000\n9\n011111111\n",
          "stdout": "1\n5\n"
        },
        {
          "stdin": "1\n6\n111111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n7\n1100000\n7\n0001100\n",
          "stdout": "6\n6\n"
        },
        {
          "stdin": "3\n8\n11111000\n8\n00000111\n8\n10000001\n",
          "stdout": "10\n6\n1\n"
        },
        {
          "stdin": "2\n6\n111100\n6\n000011\n",
          "stdout": "6\n5\n"
        },
        {
          "stdin": "1\n7\n1000000\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n5\n10000\n5\n01111\n",
          "stdout": "1\n3\n"
        },
        {
          "stdin": "3\n10\n1000000000\n10\n0111111111\n10\n0000000001\n",
          "stdout": "1\n5\n1\n"
        },
        {
          "stdin": "3\n5\n10101\n4\n1101\n6\n111000\n",
          "stdout": "1\n2\n4\n"
        },
        {
          "stdin": "1\n20\n11111111111111111111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "4\n8\n01100110\n10\n1101010101\n12\n101010101010\n14\n11100011100011\n",
          "stdout": "15\n5\n1\n84\n"
        },
        {
          "stdin": "2\n20\n10000000000000000000\n20\n01111111111111111111\n",
          "stdout": "1\n10\n"
        },
        {
          "stdin": "5\n7\n1101101\n9\n110011101\n5\n00100\n10\n0110100110\n20\n01010101010101010101\n",
          "stdout": "6\n10\n1\n21\n1\n"
        },
        {
          "stdin": "10\n1\n1\n1\n0\n2\n00\n2\n01\n2\n10\n2\n11\n3\n000\n3\n001\n3\n100\n3\n101\n3\n111\n",
          "stdout": "1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n"
        },
        {
          "stdin": "5\n10\n1111000000\n15\n00001111100000\n20\n0111011110111001\n25\n110111001011110100101011\n30\n011011000111101011101001011011\n",
          "stdout": "28\n55\n126\n2002\n50388\n"
        },
        {
          "stdin": "5\n1\n1\n1\n0\n2\n10\n2\n01\n2\n11\n",
          "stdout": "1\n1\n1\n1\n1\n"
        },
        {
          "stdin": "2\n10\n0000000000\n10\n1111111111\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "5\n7\n1101011\n7\n0110110\n5\n10101\n5\n01010\n3\n110\n",
          "stdout": "6\n10\n1\n1\n2\n"
        },
        {
          "stdin": "3\n5\n10001\n5\n01110\n10\n0011001111\n",
          "stdout": "1\n3\n35\n"
        },
        {
          "stdin": "4\n10\n1111100000\n10\n0000011111\n8\n10101010\n8\n01010101\n",
          "stdout": "21\n21\n1\n1\n"
        },
        {
          "stdin": "5\n15\n111110000001111\n15\n111111100000000\n15\n000011111111111\n15\n111100001111000\n15\n000000000000001\n",
          "stdout": "210\n165\n126\n330\n1\n"
        },
        {
          "stdin": "2\n5\n11111\n5\n00000\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n3\n011\n3\n100\n3\n110\n",
          "stdout": "2\n1\n2\n"
        },
        {
          "stdin": "4\n8\n10101010\n8\n11110000\n8\n00001111\n8\n01010101\n",
          "stdout": "1\n15\n15\n1\n"
        },
        {
          "stdin": "2\n4\n1010\n4\n1100\n",
          "stdout": "1\n3\n"
        },
        {
          "stdin": "6\n5\n01010\n5\n10101\n5\n11111\n5\n00000\n5\n10001\n5\n01110\n",
          "stdout": "1\n1\n1\n1\n1\n3\n"
        },
        {
          "stdin": "5\n5\n11100\n5\n11010\n5\n10110\n5\n01110\n5\n00111\n",
          "stdout": "3\n3\n3\n3\n3\n"
        },
        {
          "stdin": "1\n20\n10000000000000000000\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n10\n0000000000\n5\n11111\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n5\n01010\n8\n11101110\n7\n1010101\n",
          "stdout": "1\n6\n1\n"
        },
        {
          "stdin": "1\n15\n011011010101011\n",
          "stdout": "84\n"
        },
        {
          "stdin": "4\n7\n1010111\n10\n0101010101\n6\n111000\n9\n111111111\n",
          "stdout": "3\n1\n4\n1\n"
        },
        {
          "stdin": "5\n5\n00000\n4\n1111\n3\n100\n2\n01\n1\n1\n",
          "stdout": "1\n1\n1\n1\n1\n"
        },
        {
          "stdin": "1\n30\n111100000111100000111100000111\n",
          "stdout": "170544\n"
        },
        {
          "stdin": "2\n10\n1010101010\n5\n10101\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n7\n1010101\n8\n11110000\n9\n110110110\n",
          "stdout": "1\n15\n20\n"
        },
        {
          "stdin": "4\n5\n11111\n10\n0000000000\n15\n111000111000111\n20\n10101010101010101010\n",
          "stdout": "1\n1\n84\n1\n"
        },
        {
          "stdin": "5\n6\n111100\n7\n0000000\n8\n11111111\n9\n000000000\n10\n1010101010\n",
          "stdout": "6\n1\n1\n1\n1\n"
        },
        {
          "stdin": "3\n5\n10101\n4\n1100\n7\n1011011\n",
          "stdout": "1\n3\n6\n"
        },
        {
          "stdin": "2\n10\n1101101110\n15\n101101011101101\n",
          "stdout": "20\n56\n"
        },
        {
          "stdin": "2\n6\n110011\n8\n10101010\n",
          "stdout": "6\n1\n"
        },
        {
          "stdin": "3\n5\n11000\n6\n101010\n7\n1110000\n",
          "stdout": "4\n1\n5\n"
        },
        {
          "stdin": "1\n20\n11011011101101101110\n",
          "stdout": "924\n"
        },
        {
          "stdin": "1\n30\n11011011101101101110101101101110\n",
          "stdout": "92378\n"
        },
        {
          "stdin": "4\n5\n11011\n6\n011110\n7\n1101100\n8\n10101010\n",
          "stdout": "3\n6\n10\n1\n"
        },
        {
          "stdin": "3\n10\n1010101010\n15\n101110111011101\n20\n10111011101110110110",
          "stdout": "1\n35\n462\n"
        },
        {
          "stdin": "3\n7\n0110011\n6\n110110\n10\n0110101010\n",
          "stdout": "10\n6\n6\n"
        },
        {
          "stdin": "2\n5\n11011\n8\n11011011\n",
          "stdout": "3\n10\n"
        },
        {
          "stdin": "4\n2\n01\n3\n101\n4\n1001\n5\n10001\n",
          "stdout": "1\n1\n1\n1\n"
        },
        {
          "stdin": "5\n20\n11001100110011001100\n15\n11001110011001\n10\n1100110011\n5\n11011\n5\n10101\n",
          "stdout": "3003\n84\n35\n3\n1\n"
        },
        {
          "stdin": "1\n5\n00000\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n1\n1\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n1\n0\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3\n3\n111\n4\n1001\n5\n10101\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "2\n5\n01010\n6\n101010\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "3\n5\n11111\n6\n110110\n7\n1010101\n",
          "stdout": "1\n6\n1\n"
        },
        {
          "stdin": "5\n10\n0000000000\n5\n11111\n5\n10001\n5\n11100\n5\n10100\n",
          "stdout": "1\n1\n1\n3\n1\n"
        },
        {
          "stdin": "4\n7\n1000000\n8\n11111111\n9\n111000000\n10\n1100000000\n",
          "stdout": "1\n1\n7\n9\n"
        },
        {
          "stdin": "1\n5\n11111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3\n3\n010\n3\n100\n3\n001\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "4\n2\n10\n2\n01\n5\n00011\n6\n001100\n",
          "stdout": "1\n1\n4\n5\n"
        },
        {
          "stdin": "2\n4\n1111\n6\n111000\n",
          "stdout": "1\n4\n"
        },
        {
          "stdin": "3\n2\n11\n7\n1100000\n10\n1111111111\n",
          "stdout": "1\n6\n1\n"
        },
        {
          "stdin": "3\n4\n1010\n5\n01010\n6\n101010\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "2\n3\n101\n8\n00011100\n",
          "stdout": "1\n6\n"
        },
        {
          "stdin": "2\n9\n111000011\n10\n0111100000\n",
          "stdout": "15\n28\n"
        },
        {
          "stdin": "4\n5\n00001\n5\n10000\n6\n111000\n7\n0001111\n",
          "stdout": "1\n1\n4\n10\n"
        },
        {
          "stdin": "2\n7\n0110000\n8\n00011100\n",
          "stdout": "6\n6\n"
        },
        {
          "stdin": "4\n3\n101\n6\n000111\n8\n01111000\n9\n111100000\n",
          "stdout": "1\n4\n15\n21\n"
        },
        {
          "stdin": "2\n10\n0000011111\n10\n1111100000\n",
          "stdout": "21\n21\n"
        },
        {
          "stdin": "3\n8\n00000001\n9\n100000000\n7\n0100000\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "1\n3\n111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n3\n001\n",
          "stdout": "1\n"
        },
        {
          "stdin": "3\n5\n00000\n5\n11111\n5\n01010\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "1\n8\n11111111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n7\n1010101\n7\n1101101\n",
          "stdout": "1\n6\n"
        },
        {
          "stdin": "1\n15\n101010101010101\n",
          "stdout": "1\n"
        },
        {
          "stdin": "4\n4\n0000\n4\n1111\n4\n1010\n4\n0101\n",
          "stdout": "1\n1\n1\n1\n"
        },
        {
          "stdin": "1\n9\n111010011\n",
          "stdout": "10\n"
        },
        {
          "stdin": "2\n10\n1010101010\n10\n0101010101\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n12\n101010101010\n",
          "stdout": "1\n"
        },
        {
          "stdin": "1\n14\n11111111111111\n",
          "stdout": "1\n"
        },
        {
          "stdin": "2\n15\n101010101010101\n15\n110101010101011\n",
          "stdout": "1\n28\n"
        },
        {
          "stdin": "1\n17\n11010101010101110\n",
          "stdout": "36\n"
        },
        {
          "stdin": "3\n20\n11111111111111111111\n20\n00000000000000000000\n20\n10101010101010101010\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "2\n18\n1010101010101010\n18\n110110110110110110\n",
          "stdout": "1\n924\n"
        },
        {
          "stdin": "1\n22\n111010101010101010101\n",
          "stdout": "10\n"
        },
        {
          "stdin": "2\n25\n1010101010101010101010101\n25\n1111111111111111111111111\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "1\n27\n1110101010101010101010101010\n",
          "stdout": "14\n"
        },
        {
          "stdin": "3\n30\n0000000000000000000000000000\n30\n1111111111111111111111111111\n30\n1010101010101010101010101010\n",
          "stdout": "1\n1\n1\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n3\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111111000100010\n",
          "stdout": "3\n6\n3\n1287\n1287\n495\n"
        },
        {
          "stdin": "6\n4\n1110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111111000100010\n",
          "stdout": "2\n6\n3\n1287\n1287\n495\n"
        },
        {
          "stdin": "2\n3\n111\n2\n11\n",
          "stdout": "1\n1\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11001111011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n1001\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111100\n20\n11100111111000100010\n",
          "stdout": "3\n6\n3\n1287\n2002\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10011111110110111000\n20\n00110110100110111100\n20\n11100111111000100010\n",
          "stdout": "3\n6\n3\n792\n2002\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10011111110110111000\n20\n00110110100110111100\n20\n11100111111000100000\n",
          "stdout": "3\n6\n3\n792\n2002\n1001\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110011101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n1287\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100011\n",
          "stdout": "3\n6\n3\n1287\n1287\n1287\n"
        },
        {
          "stdin": "6\n4\n1100\n6\n011010\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111111000100010\n",
          "stdout": "3\n4\n3\n1287\n1287\n495\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n6\n3\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "2\n6\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011000100010\n",
          "stdout": "3\n6\n3\n1287\n1287\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n00010\n20\n10001111110110111000\n20\n00100110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n6\n1\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011000100010\n",
          "stdout": "1\n6\n3\n1287\n1287\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100011\n",
          "stdout": "3\n6\n1\n1287\n1287\n1287\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01010\n20\n10001111100110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "2\n6\n1\n715\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n3\n1\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "3\n6\n1\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n3\n1\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "1\n6\n1\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110101101\n20\n11101010011000100010\n",
          "stdout": "1\n6\n3\n1287\n715\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "3\n6\n3\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n1\n1\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11111110011000100010\n",
          "stdout": "1\n6\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n010011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110101101\n20\n11101010011000100010\n",
          "stdout": "1\n4\n3\n1287\n715\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n1\n1\n1287\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11111110011000100010\n",
          "stdout": "1\n3\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011000100011\n",
          "stdout": "1\n6\n3\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01010\n20\n10001111100110111000\n20\n00110010100110111101\n20\n11101111011000100010\n",
          "stdout": "2\n6\n1\n715\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n3\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "2\n6\n1\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011001100010\n",
          "stdout": "3\n6\n3\n1287\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "1\n6\n3\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0011\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11111110011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n010011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110100101\n20\n11101010011000100010\n",
          "stdout": "1\n4\n3\n1287\n286\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n10001111110111111000\n20\n00010110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n1\n1\n1716\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101010011000100011\n",
          "stdout": "1\n6\n3\n1287\n1287\n364\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "2\n3\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "2\n6\n3\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011010\n5\n11010\n20\n10001111110110011000\n20\n00110110100110101101\n20\n11101010011000100010\n",
          "stdout": "1\n4\n3\n2002\n715\n78\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101011011000100011\n",
          "stdout": "1\n6\n3\n1287\n1287\n1001\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n10001111110111111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n1\n1\n1716\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n10001111110111111000\n20\n00010110100110111111\n20\n11101110011000100010\n",
          "stdout": "3\n1\n1\n1716\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11010\n20\n10001111010110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n6\n3\n715\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011001\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "2\n4\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011100100010\n",
          "stdout": "1\n6\n3\n1287\n1287\n66\n"
        },
        {
          "stdin": "6\n4\n1110\n6\n011111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "2\n3\n1\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00100110100110111101\n20\n11111110011000100010\n",
          "stdout": "1\n6\n1\n1287\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n111111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101111011000100010\n",
          "stdout": "1\n1\n1\n1287\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011010\n5\n00010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11111110011000100010\n",
          "stdout": "1\n4\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01000\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100011\n",
          "stdout": "1\n6\n1\n1287\n1287\n1287\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n00010\n20\n10011111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n3\n1\n792\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011010\n5\n11010\n20\n10001111110110011000\n20\n00110100100110101101\n20\n11101010011000100010\n",
          "stdout": "1\n4\n3\n2002\n286\n78\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n111011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101011011000100011\n",
          "stdout": "1\n3\n3\n1287\n1287\n1001\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n00001111110111111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n1\n1\n3003\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n00010\n20\n11001111110111111000\n20\n00010110100110111111\n20\n11101110011000100010\n",
          "stdout": "3\n3\n1\n1716\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n11010\n20\n10001111010110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n3\n3\n715\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011001\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111111\n20\n11101111011000100010\n",
          "stdout": "2\n4\n1\n1287\n1716\n715\n"
        },
        {
          "stdin": "6\n4\n1110\n6\n111111\n5\n00010\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "2\n1\n1\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01000\n20\n10001111110110111000\n20\n00110110100110101101\n20\n11101111011000100011\n",
          "stdout": "1\n6\n1\n1287\n715\n1287\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011001\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111111\n20\n11101111011000100010\n",
          "stdout": "2\n4\n3\n1287\n1716\n715\n"
        },
        {
          "stdin": "6\n4\n1110\n6\n111111\n5\n00110\n20\n10001111110110111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "2\n1\n4\n1287\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11011\n20\n10001111110110111000\n20\n00110110100110110101\n20\n11101111011000100011\n",
          "stdout": "3\n6\n3\n1287\n715\n1287\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01000\n20\n10001111110110111000\n20\n00100110100110101101\n20\n11101111011000100011\n",
          "stdout": "1\n6\n1\n1287\n286\n1287\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011001\n5\n01011\n20\n10001110110110111000\n20\n00110110100110111111\n20\n11101111011000100010\n",
          "stdout": "2\n4\n3\n715\n1716\n715\n"
        },
        {
          "stdin": "6\n4\n1011\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011000100011\n",
          "stdout": "2\n6\n3\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n001011\n5\n01000\n20\n10001111110110111000\n20\n00100110100110101101\n20\n11101111011000100011\n",
          "stdout": "1\n4\n1\n1287\n286\n1287\n"
        },
        {
          "stdin": "6\n4\n1011\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011010100011\n",
          "stdout": "2\n6\n3\n1287\n1287\n220\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n001011\n5\n01000\n20\n10001111110110111000\n20\n00100110100110101101\n20\n11101111011000100011\n",
          "stdout": "3\n4\n1\n1287\n286\n1287\n"
        },
        {
          "stdin": "6\n4\n1011\n6\n011011\n5\n11010\n20\n10001111110110111000\n20\n00110100100110111101\n20\n11101010011010100011\n",
          "stdout": "2\n6\n3\n1287\n715\n220\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011001\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100011\n",
          "stdout": "3\n4\n1\n1287\n1287\n1287\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n111011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011000100010\n",
          "stdout": "1\n3\n1\n1287\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11000\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011001100010\n",
          "stdout": "3\n6\n4\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n011111\n5\n11010\n20\n10001111110110111000\n20\n00110110100110101101\n20\n11101010011000100010\n",
          "stdout": "1\n3\n3\n1287\n715\n78\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01010\n20\n10001111100110111000\n20\n00110010100100111101\n20\n11101111011000100010\n",
          "stdout": "2\n6\n1\n715\n286\n715\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011010\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "2\n4\n1\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0100\n6\n010011\n5\n11010\n20\n10001111111110111000\n20\n00110110100110100101\n20\n11101010011000100010\n",
          "stdout": "1\n4\n3\n792\n286\n78\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n110111\n5\n00010\n20\n10001111110111111000\n20\n00010110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n3\n1\n1716\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00110\n20\n10001111110111111000\n20\n00010110100110111111\n20\n11101110011000100010\n",
          "stdout": "3\n1\n4\n1716\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n111111\n5\n00010\n20\n11001111110111111000\n20\n00010110100110111111\n20\n11101010011000100010\n",
          "stdout": "3\n1\n1\n1716\n1287\n78\n"
        },
        {
          "stdin": "6\n4\n1110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111111\n20\n11101111011000100010\n",
          "stdout": "2\n6\n1\n1287\n1716\n715\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011001\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n4\n1\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0111\n6\n011011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100011\n",
          "stdout": "2\n6\n3\n1287\n1287\n1287\n"
        },
        {
          "stdin": "6\n4\n0000\n6\n011011\n5\n11010\n20\n10001111110110011000\n20\n00110110100110111101\n20\n11101010011000100011\n",
          "stdout": "1\n6\n3\n2002\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n110111\n5\n00010\n20\n00001111110111111000\n20\n00010110100110111101\n20\n11101110011000100010\n",
          "stdout": "3\n3\n1\n3003\n715\n286\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011111\n5\n11010\n20\n10001111010110111000\n20\n00110110100110111101\n20\n11001110011000100010\n",
          "stdout": "3\n3\n3\n715\n1287\n364\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n11010\n20\n10001111100110111000\n20\n00110110100110111101\n20\n11101010011000100011\n",
          "stdout": "1\n6\n3\n715\n1287\n286\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n01100\n20\n10001111110110111000\n20\n00110110100110101101\n20\n11101111011000100011\n",
          "stdout": "1\n6\n4\n1287\n715\n1287\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n11010\n20\n10001110110110111000\n20\n00110110100110110101\n20\n11101111011000100011\n",
          "stdout": "3\n6\n3\n715\n715\n1287\n"
        },
        {
          "stdin": "6\n4\n1011\n6\n011010\n5\n11010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101010011010100011\n",
          "stdout": "2\n4\n3\n1287\n1287\n220\n"
        },
        {
          "stdin": "6\n4\n1011\n6\n011011\n5\n11010\n20\n10001110110110111000\n20\n00110100100110111101\n20\n11101010011010100011\n",
          "stdout": "2\n6\n3\n715\n715\n220\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n00010\n20\n10001111110110101000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n715\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n0011\n6\n011011\n5\n01010\n20\n10001111100110111000\n20\n00110110100100111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n715\n715\n715\n"
        },
        {
          "stdin": "6\n4\n0010\n6\n011011\n5\n11000\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101110011001100010\n",
          "stdout": "1\n6\n4\n1287\n1287\n715\n"
        },
        {
          "stdin": "6\n4\n1010\n6\n011011\n5\n00011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "1\n6\n4\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n110111\n5\n00010\n20\n10001111110111111000\n20\n00010010100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n3\n1\n1716\n286\n715\n"
        },
        {
          "stdin": "6\n4\n0101\n6\n111011\n5\n01011\n20\n10001111110110111000\n20\n00110110100110111101\n20\n01101111011000100011\n",
          "stdout": "1\n3\n3\n1287\n1287\n2002\n"
        },
        {
          "stdin": "6\n4\n0110\n6\n011011\n5\n01010\n20\n10001111110110111000\n20\n00110110100110111101\n20\n11101111011000100010\n",
          "stdout": "3\n6\n1\n1287\n1287\n715\n"
        }
      ],
      "source": "codeforces",
      "difficulty": "HARD",
      "human_solutions": [
        "import sys\nimport math\ninput = sys.stdin.readline\nh = {}\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\nT = int(input())\nfor _ in range(T):\n\tn = int(input())\n\ts = input().rstrip()\n\tprev = 'x'\n\tcnt_zero = 0\n\tcnt_group = 0\n\tfor t in s:\n\t\tif t == '0':\n\t\t\tcnt_zero += 1\n\t\t\tprev = t\n\t\telif prev == '1':\n\t\t\tcnt_group += 1\n\t\t\tprev = 'x'\n\t\telse:\n\t\t\tprev = t\n\tanswer = ncr(cnt_zero + cnt_group, cnt_zero, 998244353)\n\tprint(answer)\n",
        "def comb(n, k, MOD):\n\tif k > n // 2:\n\t\tk = n - k\n\tanswer = 1\n\tfor i in range(k):\n\t\tanswer *= n - i\n\t\tanswer //= i + 1\n\treturn answer % MOD\n\ndef putin():\n\treturn map(int, input().split())\n\ndef sol():\n\tn = int(input())\n\tA = list(input())\n\tnum_zeros = 0\n\tnum_pairs = 0\n\tfirst = 0\n\tfor i in range(n):\n\t\tif A[i] == '0':\n\t\t\tfirst = 0\n\t\t\tnum_zeros += 1\n\t\telif first == 0:\n\t\t\tfirst = 1\n\t\telse:\n\t\t\tnum_pairs += 1\n\t\t\tfirst = 0\n\tprint(comb(num_zeros + num_pairs, num_zeros, 998244353))\nfor itr in range(int(input())):\n\tsol()\n",
        "def ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n\tn = int(input())\n\tstr = input()\n\td = str.count('11')\n\tx = str.count('0')\n\tprint(ncr(d + x, d, 998244353))\n",
        "import sys\ninput = sys.stdin.readline\nt = int(input())\nmod = 998244353\nl = 114514\nfact = [1] * (l + 1)\nfor i in range(1, l + 1):\n\tfact[i] = i * fact[i - 1] % mod\ninv = [1] * (l + 1)\ninv[l] = pow(fact[l], mod - 2, mod)\nfor i in range(l - 1, -1, -1):\n\tinv[i] = (i + 1) * inv[i + 1] % mod\n\ndef comb(n, r):\n\treturn fact[n] * inv[r] * inv[n - r] % mod if n >= r >= 0 else 0\nfor _ in range(t):\n\tn = int(input())\n\ts = list(input().rstrip())\n\t(now, cnt) = (int(s[0]), 0)\n\t(m, r) = (0, 0)\n\tfor i in s:\n\t\tif int(i) == now:\n\t\t\tcnt += 1\n\t\telse:\n\t\t\tif now == 0:\n\t\t\t\tm += cnt\n\t\t\t\tr += cnt\n\t\t\telse:\n\t\t\t\tm += cnt // 2\n\t\t\tnow ^= 1\n\t\t\tcnt = 1\n\tif now == 0:\n\t\tm += cnt\n\t\tr += cnt\n\telse:\n\t\tm += cnt // 2\n\tans = comb(m, r)\n\tprint(ans)\n",
        "from functools import lru_cache\nMOD = 998244353\nf = [1, 1]\n\n@lru_cache()\ndef factorial(x):\n\tl = len(f)\n\twhile l <= x:\n\t\tf.append(f[l - 1] * l % MOD)\n\t\tl += 1\n\treturn f[x]\n\ndef solve():\n\tn = int(input())\n\ts = input()\n\tp = 0\n\tblock = 0\n\tfor ch in s + '0':\n\t\tif ch == '1':\n\t\t\tblock += 1\n\t\telse:\n\t\t\tp += block // 2\n\t\t\tblock = 0\n\tz = s.count('0')\n\t(pf, zf) = (factorial(p), factorial(z))\n\tprint(factorial(p + z) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)\n\ndef main():\n\tt = int(input())\n\tfor __ in range(t):\n\t\tsolve()\nmain()\n",
        "import sys, io, os\nBUFSIZE = 8192\n\nclass FastIO(io.IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = io.BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(io.IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop('end', '\\n'))\n\tif kwargs.pop('flush', False):\n\t\tfile.flush()\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\nclass Combination:\n\n\tdef __init__(self, n_max, mod=10 ** 9 + 7):\n\t\tself.mod = mod\n\t\tf = 1\n\t\tself.fac = fac = [f]\n\t\tfor i in range(1, n_max + 1):\n\t\t\tf = f * i % mod\n\t\t\tfac.append(f)\n\t\tf = pow(f, mod - 2, mod)\n\t\tself.facinv = facinv = [f]\n\t\tfor i in range(n_max, 0, -1):\n\t\t\tf = f * i % mod\n\t\t\tfacinv.append(f)\n\t\tfacinv.reverse()\n\n\tdef __call__(self, n, r):\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef C(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[r] % self.mod * self.facinv[n - r] % self.mod\n\n\tdef P(self, n, r):\n\t\tif not 0 <= r <= n:\n\t\t\treturn 0\n\t\treturn self.fac[n] * self.facinv[n - r] % self.mod\n\n\tdef H(self, n, r):\n\t\tif n == 0 and r > 0 or r < 0:\n\t\t\treturn 0\n\t\treturn self.fac[n + r - 1] * self.facinv[r] % self.mod * self.facinv[n - 1] % self.mod\nfrom itertools import groupby\nmod = 998244353\ncomb = Combination(101010, mod)\nT = int(input())\nfor _ in range(T):\n\tN = int(input())\n\tS = input()\n\tr = 0\n\tn_zeros = S.count('0')\n\tfor (val, gr) in groupby(S):\n\t\tgr = list(gr)\n\t\tif val == '1':\n\t\t\tif len(gr) % 2 == 1:\n\t\t\t\tr += 1\n\tans = comb.C((N - r + n_zeros) // 2, n_zeros)\n\tprint(ans)\n",
        "import sys\ninput = sys.stdin.readline\np = 998244353\n\ndef get_facts(n):\n\tfacts = [1] * (n + 1)\n\tfor i in range(1, n + 1):\n\t\tfacts[i] = facts[i - 1] * i % p\n\treturn facts\nfor _ in range(int(input())):\n\tn = int(input())\n\tfacts = get_facts(n)\n\tgroup = False\n\tzero_count = 0\n\todd_count = 0\n\tcur_count = 0\n\tfor c in input():\n\t\tif c == '0':\n\t\t\tzero_count += 1\n\t\t\tif group:\n\t\t\t\todd_count += cur_count % 2\n\t\t\t\tgroup = False\n\t\t\t\tcur_count = 0\n\t\telif c == '1':\n\t\t\tif group:\n\t\t\t\tcur_count += 1\n\t\t\telse:\n\t\t\t\tgroup = True\n\t\t\t\tcur_count = 1\n\teven_count = (n - odd_count - zero_count) // 2\n\tprint(facts[even_count + zero_count] * pow(facts[zero_count], -1, p) * pow(facts[even_count], -1, p) % p)\n",
        "def powerMod(a, b, MOD):\n\tif b == 0:\n\t\treturn 1\n\tc = powerMod(a, b // 2, MOD)\n\tc_squared = c * c % MOD\n\tif b % 2 == 1:\n\t\treturn c_squared * a % MOD\n\telse:\n\t\treturn c_squared\nt = int(input())\nMOD = 998244353\nfor d in range(t):\n\tn = int(input())\n\ts = input()\n\ti = 0\n\tzeroes = 0\n\tpairs_of_ones = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\tzeroes += 1\n\t\t\ti += 1\n\t\telif i + 1 < n and s[i + 1] == '1':\n\t\t\tpairs_of_ones += 1\n\t\t\ti += 2\n\t\telse:\n\t\t\ti += 1\n\tresult = 1\n\tfor j in range(zeroes + 1, zeroes + pairs_of_ones + 1):\n\t\tresult = result * j % MOD\n\tfor j in range(2, pairs_of_ones + 1):\n\t\tresult = result * powerMod(j, MOD - 2, MOD) % MOD\n\tprint(result)\n",
        "from sys import stdout\nfrom math import comb as c\n\ndef solve():\n\tn = int(input())\n\ta = list(map(int, input()))\n\tpair = 0\n\tzeros = 0\n\tcur = 0\n\tfor i in range(n):\n\t\tif a[i] == 1:\n\t\t\tcur += 1\n\t\telse:\n\t\t\tpair += cur // 2\n\t\t\tzeros += 1\n\t\t\tcur = 0\n\tpair += cur // 2\n\tprint(c(pair + zeros, zeros) % 998244353)\n\tstdout.flush()\n\ndef main():\n\tfor _ in range(int(input())):\n\t\tsolve()\nmain()\n",
        "def ncr(n, r, p):\n\t(num, den) = (1, 1)\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\np = 998244353\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tzoz = input()\n\tz = zoz.count('0')\n\tk = 0\n\tj = 1\n\twhile j < n:\n\t\tif zoz[j] == '1' and zoz[j - 1] == '1':\n\t\t\tk += 1\n\t\t\tj += 2\n\t\telse:\n\t\t\tj += 1\n\tprint(ncr(z + k, z, p))\n",
        "import sys\ninput = sys.stdin.readline\nMX = 10 ** 5 + 10\nMOD_NUM = 998244353\nF = [-1] * MX\nF[0] = F[1] = 1\nfor x in range(2, MX):\n\tF[x] = x * F[x - 1]\n\tF[x] %= MOD_NUM\n\ndef choose(a, b):\n\treturn F[a] * pow(F[b], MOD_NUM - 2, MOD_NUM) * pow(F[a - b], MOD_NUM - 2, MOD_NUM) % MOD_NUM\nfor _ in range(int(input())):\n\tn = int(input())\n\ts = input().strip()\n\tk = 0\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\ti += 1\n\t\t\tcontinue\n\t\tif i + 1 < n and s[i + 1] == '1':\n\t\t\tk += 1\n\t\t\ti += 1\n\t\ti += 1\n\tz = s.count('0')\n\tprint(choose(z + k, z))\n",
        "from sys import stdin, stdout\nimport heapq\nfrom collections import defaultdict\nimport math\nimport bisect\nimport io, os\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\n\ndef main():\n\tt = int(stdin.readline())\n\tMOD = 998244353\n\tfor _ in range(t):\n\t\tn = int(stdin.readline())\n\t\ts = stdin.readline().strip()\n\t\tz = 0\n\t\tb = 0\n\t\ti = 0\n\t\twhile i < n:\n\t\t\tif s[i] == '0':\n\t\t\t\tz += 1\n\t\t\t\ti += 1\n\t\t\t\tcontinue\n\t\t\telif i + 1 < n and s[i] == s[i + 1] == '1':\n\t\t\t\tb += 1\n\t\t\t\ti += 2\n\t\t\t\tcontinue\n\t\t\ti += 1\n\t\tans = ncr(z + b, z, MOD)\n\t\tstdout.write(str(ans) + '\\n')\nmain()\n",
        "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n\tl = len(f)\n\twhile l <= x:\n\t\tf.append(f[l - 1] * l % MOD)\n\t\tl += 1\n\treturn f[x]\nt = int(input())\nfor __ in range(t):\n\tn = int(input())\n\ts = input()\n\tp = sum((len(block) // 2 for block in s.split('0')))\n\tz = s.count('0')\n\tprint(factorial(p + z) * pow(factorial(p), -1, MOD) % MOD * pow(factorial(z), -1, MOD) % MOD)\n",
        "mod = 998244353\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n\tn = int(input())\n\tchess_board = input()\n\tcount_0 = 0\n\tcount_11 = 0\n\tcnt = 0\n\tfor square in chess_board:\n\t\tif square == '0':\n\t\t\tcount_11 += cnt // 2\n\t\t\tcount_0 += 1\n\t\t\tcnt = 0\n\t\telse:\n\t\t\tcnt += 1\n\tcount_11 += cnt // 2\n\tnumber_of_gaps = count_0 + 1\n\tans = ncr(count_11 + number_of_gaps - 1, number_of_gaps - 1, mod)\n\tprint(ans)\n",
        "from math import comb\nfrom sys import stdout\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (r - i) % p\n\treturn num * pow(den, p - 2, p) % p\nfor t in range(int(input())):\n\tn = int(input())\n\ta = input()\n\ti = 0\n\toc = a.count('11')\n\tzc = a.count('0')\n\tprint(ncr(oc + zc, min(oc, zc), 998244353))\n\tstdout.flush()\n",
        "from __future__ import division, print_function\nimport os, sys\nfrom io import BytesIO, IOBase\nif sys.version_info[0] < 3:\n\tfrom __builtin__ import xrange as range\n\tfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound\n\ndef so():\n\treturn int(input())\n\ndef st():\n\treturn input()\n\ndef mj():\n\treturn map(int, input().strip().split(' '))\n\ndef msj():\n\treturn map(str, input().strip().split(' '))\n\ndef le():\n\treturn list(map(int, input().split()))\n\ndef lebe():\n\treturn list(map(int, input()))\n\ndef dmain():\n\tsys.setrecursionlimit(1000000)\n\tthreading.stack_size(1024000)\n\tthread = threading.Thread(target=main)\n\tthread.start()\n\ndef joro(L):\n\treturn ''.join(map(str, L))\n\ndef decimalToBinary(n):\n\treturn bin(n).replace('0b', '')\n\ndef isprime(n):\n\tfor i in range(2, int(n ** 0.5) + 1):\n\t\tif n % i == 0:\n\t\t\treturn False\n\treturn True\n\ndef npr(n, r):\n\treturn factorial(n) // factorial(n - r) if n >= r else 0\n\ndef ncr(n, r):\n\treturn factorial(n) // (factorial(r) * factorial(n - r)) if n >= r else 0\n\ndef lower_bound(li, num):\n\tanswer = -1\n\tstart = 0\n\tend = len(li) - 1\n\twhile start <= end:\n\t\tmiddle = (end + start) // 2\n\t\tif li[middle] >= num:\n\t\t\tanswer = middle\n\t\t\tend = middle - 1\n\t\telse:\n\t\t\tstart = middle + 1\n\treturn answer\n\ndef upper_bound(li, num):\n\tanswer = -1\n\tstart = 0\n\tend = len(li) - 1\n\twhile start <= end:\n\t\tmiddle = (end + start) // 2\n\t\tif li[middle] <= num:\n\t\t\tanswer = middle\n\t\t\tstart = middle + 1\n\t\telse:\n\t\t\tend = middle - 1\n\treturn answer\n\ndef tir(a, b, c):\n\tif 0 == c:\n\t\treturn 1\n\tif len(a) <= b:\n\t\treturn 0\n\tif c != -1:\n\t\treturn tir(a, 1 + b, c + a[b]) or tir(a, b + 1, c - a[b]) or tir(a, 1 + b, c)\n\telse:\n\t\treturn tir(a, 1 + b, a[b]) or tir(a, b + 1, -a[b]) or tir(a, 1 + b, -1)\n\ndef abs(x):\n\treturn x if x >= 0 else -x\n\ndef binary_search(li, val, lb, ub):\n\tans = -1\n\twhile lb <= ub:\n\t\tmid = (lb + ub) // 2\n\t\tif li[mid] > val:\n\t\t\tub = mid - 1\n\t\telif val > li[mid]:\n\t\t\tlb = mid + 1\n\t\telse:\n\t\t\tans = mid\n\t\t\tbreak\n\treturn ans\n\ndef kadane(x):\n\tsum_so_far = 0\n\tcurrent_sum = 0\n\tfor i in x:\n\t\tcurrent_sum += i\n\t\tif current_sum < 0:\n\t\t\tcurrent_sum = 0\n\t\telse:\n\t\t\tsum_so_far = max(sum_so_far, current_sum)\n\treturn sum_so_far\n\ndef pref(li):\n\tpref_sum = [0]\n\tfor i in li:\n\t\tpref_sum.append(pref_sum[-1] + i)\n\treturn pref_sum\n\ndef SieveOfEratosthenes(n):\n\tprime = [True for i in range(n + 1)]\n\tp = 2\n\tli = []\n\twhile p * p <= n:\n\t\tif prime[p] == True:\n\t\t\tfor i in range(p * p, n + 1, p):\n\t\t\t\tprime[i] = False\n\t\tp += 1\n\tfor p in range(2, len(prime)):\n\t\tif prime[p]:\n\t\t\tli.append(p)\n\treturn li\n\ndef primefactors(n):\n\tfactors = []\n\twhile n % 2 == 0:\n\t\tfactors.append(2)\n\t\tn //= 2\n\tfor i in range(3, int(sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tfactors.append(i)\n\t\t\tn //= i\n\tif n > 2:\n\t\tfactors.append(n)\n\treturn factors\n\ndef read():\n\tsys.stdin = open('input.txt', 'r')\n\tsys.stdout = open('output.txt', 'w')\n\ndef tr(n):\n\treturn n * (n + 1) // 2\nboi = 998244353\nyr = boi - 2\nd = []\np = int(10 + 100000.0)\nfor i in range(p):\n\td.append(-1)\nd[0] = 1\nd[1] = 1\nfor i in range(2, p, 1):\n\td[i] = d[i - 1] * i\n\td[i] = d[i] % boi\n\ndef iu():\n\timport sys\n\tinput = sys.stdin.readline\n\timport math as my\n\tm = so()\n\tt = st()\n\top = t.count('0')\n\t(z, i) = (0, 0)\n\twhile m > i:\n\t\tif t[i] == '0':\n\t\t\ti = 1 + i\n\t\t\tcontinue\n\t\tif m - i > 1 and t[1 + i] == '1':\n\t\t\tz = 1 + z\n\t\t\ti = 1 + i\n\t\ti = 1 + i\n\tbec = d[op + z] * pow(d[op], yr, boi) * pow(d[z], yr, boi) % boi\n\tprint(bec)\n\ndef main():\n\tfor i in range(so()):\n\t\tiu()\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n\ndef print(*args, **kwargs):\n\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop('end', '\\n'))\n\tif kwargs.pop('flush', False):\n\t\tfile.flush()\nif sys.version_info[0] < 3:\n\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\nelse:\n\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\nmain()\n",
        "from functools import reduce\nMOD = 998244353\n\ndef perm(n, k):\n\treturn reduce(lambda x, y: x * y % MOD, range(n - k + 1, n + 1), 1)\nt = int(input())\nfor __ in range(t):\n\tn = int(input())\n\ts = input()\n\tp = sum((len(block) // 2 for block in s.split('0')))\n\tz = s.count('0')\n\tprint(perm(z + p, p) * pow(perm(p, p), -1, MOD) % MOD)\n",
        "MOD = 998244353\nN = 100000\nfact = [0] * (N + 1)\nfact[0] = 1\nfact[1] = 1\nfor i in range(2, N + 1):\n\tfact[i] = i * fact[i - 1] % MOD\nT = int(input())\n\ndef ncr(n, r):\n\tnum = fact[n]\n\tden = fact[r] * fact[n - r] % MOD\n\tden = pow(den, MOD - 2, MOD)\n\tres = num * den % MOD\n\treturn res\n\ndef solve():\n\tn = int(input())\n\ts = input()\n\ta = 0\n\tzeros = 0\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '1' and i + 1 < n and (s[i + 1] == '1'):\n\t\t\ta += 1\n\t\t\ti += 1\n\t\telif s[i] == '0':\n\t\t\tzeros += 1\n\t\ti += 1\n\tres = ncr(a + zeros, zeros)\n\tprint(res)\nwhile T:\n\tsolve()\n\tT -= 1\n",
        "mod = 998244353\neps = 10 ** (-9)\n\ndef main():\n\timport sys\n\tinput = sys.stdin.readline\n\tnmax = 10 ** 5 + 10\n\tfac = [0] * nmax\n\tfinv = [0] * nmax\n\tinv = [0] * nmax\n\tfac[0] = 1\n\tfac[1] = 1\n\tfinv[0] = 1\n\tfinv[1] = 1\n\tinv[1] = 1\n\tfor i in range(2, nmax):\n\t\tfac[i] = fac[i - 1] * i % mod\n\t\tinv[i] = mod - inv[mod % i] * (mod // i) % mod\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod\n\n\tdef comb(n, r):\n\t\tif n < r:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn fac[n] * (finv[r] * finv[n - r] % mod) % mod\n\tfor _ in range(int(input())):\n\t\tN = int(input())\n\t\tS = input().rstrip('\\n')\n\t\tx = y = 0\n\t\tcnt = 0\n\t\tprev = '!'\n\t\tfor (i, s) in enumerate(S):\n\t\t\tif s == '1':\n\t\t\t\tcnt += 1\n\t\t\telse:\n\t\t\t\ty += 1\n\t\t\t\tif prev == '1':\n\t\t\t\t\tx += cnt // 2\n\t\t\t\tcnt = 0\n\t\t\tprev = s\n\t\tx += cnt // 2\n\t\tprint(comb(x + y, x))\nmain()\n",
        "MOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n\tl = len(f)\n\twhile l <= x:\n\t\tf.append(f[l - 1] * l % MOD)\n\t\tl += 1\n\treturn f[x]\nT = int(input())\nk = [1]\nfor i in range(T):\n\tn = int(input())\n\tarr = input()\n\th = dict()\n\tp = [0]\n\tr = 0\n\ts = 0\n\tr = arr.count('11')\n\ts = arr.count('0')\n\tk = [1]\n\t(pf, zf) = (factorial(r), factorial(s))\n\tprint(factorial(r + s) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)\n",
        "N = 100005\nfac = [1] * N\ninv = [1] * N\nMOD = 998244353\nfor i in range(1, N):\n\tfac[i] = fac[i - 1] * i % MOD\ninv[-1] = pow(fac[-1], -1, mod=MOD)\nfor i in range(N - 2, 0, -1):\n\tinv[i] = inv[i + 1] * (i + 1) % MOD\n\ndef solve(n, s):\n\ti = 1\n\tpairs = 0\n\tzeros = int(s[0] == '0')\n\twhile i < n:\n\t\tif s[i] == '1':\n\t\t\tif s[i - 1] == '1':\n\t\t\t\tpairs += 1\n\t\t\t\tif i + 1 < n and s[i + 1] == '0':\n\t\t\t\t\tzeros += 1\n\t\t\t\ti += 2\n\t\t\telse:\n\t\t\t\ti += 1\n\t\telse:\n\t\t\tzeros += 1\n\t\t\ti += 1\n\tans = fac[zeros + pairs] * inv[zeros] * inv[pairs] % MOD\n\tprint(ans)\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\ts = input()\n\tsolve(n, s)\n",
        "def ncr(m, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (m - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\nfor _ in range(int(input())):\n\tn = int(input())\n\tstrin = str(input())\n\tarr = []\n\tfor i in strin:\n\t\tarr.append(int(i))\n\tm = 0\n\tx = 0\n\tr = 0\n\twhile x < n:\n\t\tif arr[x] == 0:\n\t\t\tx += 1\n\t\t\tm += 1\n\t\telif x < n - 1 and arr[x] == arr[x + 1] == 1:\n\t\t\tm += 1\n\t\t\tx += 2\n\t\t\tr += 1\n\t\telse:\n\t\t\tx += 1\n\tprint(ncr(m, r, 998244353))\n",
        "import sys\nfrom sys import stdin\n\ndef modfac(n, MOD):\n\tf = 1\n\tfactorials = [1]\n\tfor m in range(1, n + 1):\n\t\tf *= m\n\t\tf %= MOD\n\t\tfactorials.append(f)\n\tinv = pow(f, MOD - 2, MOD)\n\tinvs = [1] * (n + 1)\n\tinvs[n] = inv\n\tfor m in range(n, 1, -1):\n\t\tinv *= m\n\t\tinv %= MOD\n\t\tinvs[m - 1] = inv\n\treturn (factorials, invs)\n\ndef modnCr(n, r):\n\treturn fac[n] * inv[n - r] * inv[r] % mod\nmod = 998244353\n(fac, inv) = modfac(200000, mod)\ntt = int(stdin.readline())\nANS = []\nfor loop in range(tt):\n\tn = int(stdin.readline())\n\ts = list(stdin.readline()[:-1])\n\tc = 0\n\tzlis = [-1]\n\tfor i in range(n):\n\t\tif s[i] == '0':\n\t\t\tzlis.append(i)\n\tzlis.append(n)\n\tfor i in range(len(zlis) - 1):\n\t\tc += (zlis[i + 1] - zlis[i] - 1) // 2\n\tANS.append(modnCr(c + len(zlis) - 2, c) % mod)\nprint('\\n'.join(map(str, ANS)))\n",
        "num_inp = lambda : int(input())\narr_inp = lambda : list(map(int, input().split()))\nsp_inp = lambda : map(int, input().split())\nstr_inp = lambda : input()\nMOD = 998244353\nf = [1, 1]\n\ndef factorial(x):\n\tl = len(f)\n\twhile l <= x:\n\t\tf.append(f[l - 1] * l % MOD)\n\t\tl += 1\n\treturn f[x]\nT = int(input())\nk = [1]\nfor i in range(T):\n\tn = int(input())\n\tarr = input()\n\th = dict()\n\tp = [0]\n\tr = 0\n\ts = 0\n\tr = arr.count('11')\n\ts = arr.count('0')\n\tk = [1]\n\t(pf, zf) = (factorial(r), factorial(s))\n\tprint(factorial(r + s) * pow(pf, -1, MOD) % MOD * pow(zf, -1, MOD) % MOD)\n",
        "import itertools, math\nmod = 998244353\n\ndef chess(l):\n\tgrouped = [len(list(v)) // 2 for (i, v) in itertools.groupby(l) if i == '1']\n\tx = l.count('0')\n\ty = sum(grouped)\n\treturn math.comb(x + y, y) % mod\nans = []\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tl = list(input())\n\tans.append(chess(l))\nfor i in ans:\n\tprint(i)\n",
        "import sys\ninput = sys.stdin.buffer.readline\nmod = 998244353\n\ndef cmb(n, r):\n\tif r < 0 or r > n:\n\t\treturn 0\n\treturn g1[n] * g2[r] * g2[n - r] % mod\nN = 300000\ng1 = [1] * (N + 3)\nfor i in range(2, N + 3):\n\tg1[i] = g1[i - 1] * i % mod\ng2 = [0] * len(g1)\ng2[-1] = pow(g1[-1], mod - 2, mod)\nfor i in range(N + 1, -1, -1):\n\tg2[i] = g2[i + 1] * (i + 1) % mod\ninv = [0] * (N + 3)\nfor i in range(1, N + 3):\n\tinv[i] = g2[i] * g1[i - 1] % mod\nfor t in range(int(input())):\n\tN = int(input())\n\tA = list(input())[:N]\n\tfor i in range(N):\n\t\tA[i] -= 48\n\tX = [0]\n\tfor i in range(N):\n\t\tif A[i]:\n\t\t\tif X[-1] == 2:\n\t\t\t\tX.append(0)\n\t\t\tX[-1] += 1\n\t\telse:\n\t\t\tif X[-1] != 0:\n\t\t\t\tX.append(0)\n\t\t\tX.append(0)\n\tif max(X) <= 1:\n\t\tprint(1)\n\t\tcontinue\n\tif A[-1] ^ 1:\n\t\tdel X[-1]\n\tV = X.count(2)\n\tW = X.count(0)\n\tprint(cmb(W + V, V))\n",
        "M = 998244353\nfor _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\ti = 0\n\t(a, b) = (0, 0)\n\twhile i < n:\n\t\tl = 1\n\t\twhile i + 1 < n and s[i + 1] == s[i]:\n\t\t\ti += 1\n\t\t\tl += 1\n\t\tif s[i] == '1':\n\t\t\ta += l // 2\n\t\telse:\n\t\t\tb += l\n\t\ti += 1\n\tp = 1\n\tfor i in range(a + 1, a + b + 1):\n\t\tp = p * i % M\n\tfor i in range(1, b + 1):\n\t\tp = p * pow(i, -1, M) % M\n\tprint(p)\n",
        "from math import factorial\nfrom sys import *\nmod = 998244353\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\nfor _ in range(int(stdin.readline())):\n\tn = int(stdin.readline())\n\ts = stdin.readline()\n\tx = s.count('0')\n\tr = 0\n\ti = 1\n\twhile i < n:\n\t\tif s[i] == s[i - 1] and s[i] == '1':\n\t\t\tr += 1\n\t\t\ti += 2\n\t\telse:\n\t\t\ti += 1\n\tstdout.write(str(ncr(x + r, r, mod)) + '\\n')\n",
        "import sys\ninput = lambda : sys.stdin.readline().strip()\nmod = 998244353\nmx = 100005\nfac = [1] * mx\nfor i in range(2, mx):\n\tfac[i] = fac[i - 1] * i % mod\nifac = [1] * mx\nifac[mx - 1] = pow(fac[mx - 1], mod - 2, mod)\nfor i in range(mx - 2, 1, -1):\n\tifac[i] = (i + 1) * ifac[i + 1] % mod\n\ndef solve():\n\tn = int(input())\n\ts = input()\n\t(z, o) = (0, 0)\n\ti = 0\n\twhile i < n:\n\t\tif s[i] == '0':\n\t\t\tz += 1\n\t\telif i + 1 < n and s[i + 1] == '1':\n\t\t\ti += 1\n\t\t\to += 1\n\t\ti += 1\n\treturn fac[z + o] * ifac[z] % mod * ifac[o] % mod\nfor _ in range(int(input())):\n\tprint(solve())\n",
        "import os\nimport sys\nfrom io import BytesIO, IOBase\nimport math\nfrom queue import Queue\nimport collections\nimport itertools\nimport bisect\nimport heapq\nimport random\n\ndef main():\n\tpass\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n\tnewlines = 0\n\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself.buffer = BytesIO()\n\t\tself.writable = 'x' in file.mode or 'r' not in file.mode\n\t\tself.write = self.buffer.write if self.writable else None\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(b'\\n') + (not b)\n\t\t\tptr = self.buffer.tell()\n\t\t\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\n\t\tself.newlines -= 1\n\t\treturn self.buffer.readline()\n\n\tdef flush(self):\n\t\tif self.writable:\n\t\t\tos.write(self._fd, self.buffer.getvalue())\n\t\t\t(self.buffer.truncate(0), self.buffer.seek(0))\n\nclass IOWrapper(IOBase):\n\n\tdef __init__(self, file):\n\t\tself.buffer = FastIO(file)\n\t\tself.flush = self.buffer.flush\n\t\tself.writable = self.buffer.writable\n\t\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\n\t\tself.read = lambda : self.buffer.read().decode('ascii')\n\t\tself.readline = lambda : self.buffer.readline().decode('ascii')\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\n\ndef binary(n):\n\treturn bin(n).replace('0b', '')\n\ndef decimal(s):\n\treturn int(s, 2)\n\ndef pow2(n):\n\tp = 0\n\twhile n > 1:\n\t\tn //= 2\n\t\tp += 1\n\treturn p\n\ndef primeFactors(n):\n\tcnt = []\n\twhile n % 2 == 0:\n\t\tcnt.append(2)\n\t\tn = n / 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tcnt.append(i)\n\t\t\tn = n / i\n\tif n > 2:\n\t\tcnt.append(int(n))\n\treturn cnt\n\ndef primeFactorsCount(n):\n\tcnt = 0\n\twhile n % 2 == 0:\n\t\tcnt += 1\n\t\tn = n // 2\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tcnt += 1\n\t\t\tn = n // i\n\tif n > 2:\n\t\tcnt += 1\n\treturn cnt\n\ndef isPrime(n):\n\tif n == 1:\n\t\treturn False\n\telse:\n\t\troot = int(n ** 0.5)\n\t\troot += 1\n\t\tfor i in range(2, root):\n\t\t\tif n % i == 0:\n\t\t\t\treturn False\n\t\treturn True\n\ndef maxPrimeFactors(n):\n\tmaxPrime = -1\n\twhile n % 2 == 0:\n\t\tmaxPrime = 2\n\t\tn >>= 1\n\tfor i in range(3, int(math.sqrt(n)) + 1, 2):\n\t\twhile n % i == 0:\n\t\t\tmaxPrime = i\n\t\t\tn = n / i\n\tif n > 2:\n\t\tmaxPrime = n\n\treturn int(maxPrime)\n\ndef countcon(s, i):\n\tc = 0\n\tch = s[i]\n\tfor i in range(i, len(s)):\n\t\tif s[i] == ch:\n\t\t\tc += 1\n\t\telse:\n\t\t\tbreak\n\treturn c\n\ndef lis(arr):\n\tn = len(arr)\n\tlis = [1] * n\n\tfor i in range(1, n):\n\t\tfor j in range(0, i):\n\t\t\tif arr[i] > arr[j] and lis[i] < lis[j] + 1:\n\t\t\t\tlis[i] = lis[j] + 1\n\tmaximum = 0\n\tfor i in range(n):\n\t\tmaximum = max(maximum, lis[i])\n\treturn maximum\n\ndef isSubSequence(str1, str2):\n\tm = len(str1)\n\tn = len(str2)\n\tj = 0\n\ti = 0\n\twhile j < m and i < n:\n\t\tif str1[j] == str2[i]:\n\t\t\tj = j + 1\n\t\ti = i + 1\n\treturn j == m\n\ndef maxfac(n):\n\troot = int(n ** 0.5)\n\tfor i in range(2, root + 1):\n\t\tif n % i == 0:\n\t\t\treturn n // i\n\treturn n\n\ndef p2(n):\n\tc = 0\n\twhile n % 2 == 0:\n\t\tn //= 2\n\t\tc += 1\n\treturn c\n\ndef seive(n):\n\tprimes = [True] * (n + 1)\n\tprimes[1] = primes[0] = False\n\ti = 2\n\twhile i * i <= n:\n\t\tif primes[i] == True:\n\t\t\tfor j in range(i * i, n + 1, i):\n\t\t\t\tprimes[j] = False\n\t\ti += 1\n\tpr = []\n\tfor i in range(0, n + 1):\n\t\tif primes[i]:\n\t\t\tpr.append(i)\n\treturn pr\n\ndef ncr(n, r, p):\n\tnum = den = 1\n\tfor i in range(r):\n\t\tnum = num * (n - i) % p\n\t\tden = den * (i + 1) % p\n\treturn num * pow(den, p - 2, p) % p\n\ndef denofactinverse(n, m):\n\tfac = 1\n\tfor i in range(1, n + 1):\n\t\tfac = fac * i % m\n\treturn pow(fac, m - 2, m)\n\ndef numofact(n, m):\n\tfac = 1\n\tfor i in range(1, n + 1):\n\t\tfac = fac * i % m\n\treturn fac\n\ndef sod(n):\n\ts = 0\n\twhile n > 0:\n\t\ts += n % 10\n\t\tn //= 10\n\treturn s\nfor xyz in range(0, int(input())):\n\tmod = 998244353\n\tn = int(input())\n\ts = input()\n\tzc = s.count('0')\n\ti = 0\n\tpc = 0\n\twhile i < n - 1:\n\t\tif s[i] == s[i + 1] == '1':\n\t\t\ti += 1\n\t\t\tpc += 1\n\t\ti += 1\n\tprint(ncr(zc + pc, pc, mod))\n"
      ],
      "original_code": null
    },
    "status": "success",
    "code": "def solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    mod = 998244353\n    # In our formula the maximum needed argument is (n - ones) + r.\n    # A worst-case is when s consists entirely of ones.\n    # Then ones = n and the greedy procedure picks r = n//2.\n    # So (n - ones) + r = 0 + n//2 <= n.\n    # Hence we precompute factorials up to maxN = 10^5+5.\n    maxN = 10**5 + 5\n    fact = [1] * (maxN)\n    invfact = [1] * (maxN)\n    for i in range(2, maxN):\n        fact[i] = fact[i-1] * i % mod\n    invfact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in range(maxN - 2, -1, -1):\n        invfact[i] = invfact[i+1] * (i+1) % mod\n\n    def nCr(n, r):\n        if r < 0 or r > n:\n            return 0\n        return fact[n] * invfact[r] % mod * invfact[n - r] % mod\n\n    # Process test cases\n    out_lines = []\n    pos = 1\n    for _ in range(t):\n        n = int(data[pos]); pos += 1\n        s = data[pos]; pos += 1\n        ones = s.count(\"1\")\n        # count r = number of disjoint adjacent \"11\" pairs (greedy scan)\n        r = 0\n        i = 0\n        while i < n - 1:\n            if s[i] == \"1\" and s[i+1] == \"1\":\n                r += 1\n                i += 2\n            else:\n                i += 1\n        # The number of reachable states equals C((n - ones) + r, r)\n        ans = nCr((n - ones) + r, r)\n        out_lines.append(str(ans))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == '__main__':\n    solve()",
    "pass_ratio": 0.9683257918552036,
    "tests_passed": 214,
    "tests_total": 221,
    "iterations": 1,
    "history": [
      {
        "iteration": 1,
        "code": "def solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    mod = 998244353\n    # In our formula the maximum needed argument is (n - ones) + r.\n    # A worst-case is when s consists entirely of ones.\n    # Then ones = n and the greedy procedure picks r = n//2.\n    # So (n - ones) + r = 0 + n//2 <= n.\n    # Hence we precompute factorials up to maxN = 10^5+5.\n    maxN = 10**5 + 5\n    fact = [1] * (maxN)\n    invfact = [1] * (maxN)\n    for i in range(2, maxN):\n        fact[i] = fact[i-1] * i % mod\n    invfact[-1] = pow(fact[-1], mod - 2, mod)\n    for i in range(maxN - 2, -1, -1):\n        invfact[i] = invfact[i+1] * (i+1) % mod\n\n    def nCr(n, r):\n        if r < 0 or r > n:\n            return 0\n        return fact[n] * invfact[r] % mod * invfact[n - r] % mod\n\n    # Process test cases\n    out_lines = []\n    pos = 1\n    for _ in range(t):\n        n = int(data[pos]); pos += 1\n        s = data[pos]; pos += 1\n        ones = s.count(\"1\")\n        # count r = number of disjoint adjacent \"11\" pairs (greedy scan)\n        r = 0\n        i = 0\n        while i < n - 1:\n            if s[i] == \"1\" and s[i+1] == \"1\":\n                r += 1\n                i += 2\n            else:\n                i += 1\n        # The number of reachable states equals C((n - ones) + r, r)\n        ans = nCr((n - ones) + r, r)\n        out_lines.append(str(ans))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == '__main__':\n    solve()",
        "pass_ratio": 0.9683257918552036,
        "tests_passed": 214,
        "tests_total": 221
      }
    ],
    "model_type": "openai",
    "model_name": "o3_mini"
  }
]