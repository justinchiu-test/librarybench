[
  {
    "problem_id": 0,
    "model_tests_passed": 83,
    "model_tests_total": 87,
    "human_tests_passed": 82,
    "human_tests_total": 87,
    "detailed_model_results": [
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nababca\naaabb\n",
          "stdout": "YES\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4895050140000876
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "98\nrf\nqyu\nfjk\nyqv\nrty\nfr\nr\nxxxx\ntttttttttttttttttttt\ncccccccccc\nrrrrrrrrr\nllelllldhllqrl\neoqk\niihiiiji\nssldssf\nkkkkkkkkkkpk\nffffff\nkkkkkk\ntiez\nwnwwwmx\nqqqqqqqqqqqqq\nyjmub\nxxitx\nsbotwrhxr\nsxflbw\ntatf\nbbbbb\nmpljtppbx\npaaeiams\nqqqrqqzqqqqqqqqqqq\nyyyyyy\ntzqpo\ncudmgih\ntydthfpdbplvhfwh\ngbgggvu\nv\nnqmjqggwuy\nnhnwvnnnnonnebnenxc\niinf\ngpzopo\njjjjm\naabaazahaaaaaaaaa\nlgbbbbjbbblbbb\nlvyclae\niiiiii\nzzzzzz\nadcvagax\njhbtputtusgvixvb\nlezbhrb\njzflysjkonjjqlilqjl\ndxjxxlx\nimmmwmmmsmmm\njjgrjupjj\ntttt\nwdhmmhkohbum\nxomsmwjpxxnsxxhkxx\nggggcg\neemeee\nhzzzudnbm\nboodcynrdvughymyzapp\njjyjsjjiwjtjjypc\nhhmdhh\nyeytyovyyygx\nfdsdeuddg\nrzvdarzu\nbbbbbbbbbbb\nyagf\nkkkkkk\nuptqsuka\nh\nkqqqk\npeleeeeeeyow\nre\noqir\njjjjjjjjjjjjjjjjjjjj\nxxxxx\nusffqhy\navvvvvv\nawxaaafw\nddddded\nirivlsbblgsyagy\nffffpf\nzotsggwjtljs\numofuyzfzzxcbkckloz\nwipvjmjvojynhjbwduys\ngxgfrh\nkmmetym\nb\nnkna\nrrrrrrr\nazkkk\naudeqwad\niijii\nxxxl\nbcxlcm\nbsmnbn\nivhghfhl\nzysfub\n",
          "stdout": "NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8704807020000089
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "100\nglnnnxnnmkqnagymndnkbzntnnonuoooannctnunwarxnwnntnrnnnnsronbhnnnxvvnnkkneibhamhbhurnvnnvvnottnlyvwnnyamnnuzghnnlpsnceunslpnyakubnpfihyhzybmuurhymlmrxrgskanvwnkrnnwuotnnmipnnnlacjnpnkojgnnizdrpscnqnynbnjnvyrpmnnzjafuuynuiznqnnrtunpzrdsknyrnnnnnhyynvsenukyikxnyqtnimnioanstshnnunmwnfwmjnkxreevtennvnnonnindbnnniqxkunnsnhxannvnnyknnnnnfwonqv\nstqg\nhxlxxdyxxoyxxexvxxxgxzggxuxxyzrxxxxxqvmuxyxxllfnxkscxmogltfrvxnxxxxxxzxxxxcxpxxuxxcuxxuxtcxdxzzfwuxxpxxxaxyxfxtkxjjxahxxjzxsctahxxhxcfxrxxctxsxpxxxxybwnxxoxrcjktxixxmxjxwxxlxxuxxwxxxxfduxjxgxxihzwxygdxxcxgkxnxxxmpxpkmltbxaxxiwxxoxxgpivxdrqxxxxxxxteoxdzxlfnuxxxtjrxxxxwqvzxxohhixuxvfzzwxpaqoxyfzxnsqidbrnxxxfxxxmqjxxxcxxyjvoxkaotxxlknwvnxqxhpxxxkxxyxpxxxxtuitxojidxxxtrkbzxgocxxxklxhxcxsxoxwfxxlxxxxxbxxtxjxnfxqwauxxhkxnzcxxfqkxtuxttxxxwlqxvtxxxlkfxdxxxzcxsxbxrxxuxxxzxzbendupmuexxikxzmfwxlwepwsxkqxxajxjqxxnulvxlxkxnuxxxxexqmlnxxxxpqxxqxmxsniautxxxxxxxzexxarfxbxubblxxgwjzxxrxyxxwndpces\nffffffffffffffffffffffffffffjyfffdfffffffffffffffffcffffffffffffmfffuffffffffskffffqfffffffffffffffffffffffffffffffffffffffffjffffaffffffffflzqffffffffffffffffffffflffffffpfflfffffdffuffffyfcafffffffffffffffffffaffftffffkftlffpfiffffffffffffffffffffnfffffffffafffffffrcfxffffffffffffffffecfffffffffffffffffffffffffffzffbyfffffffffrhffffffffffffftfffffffffffffffffffofffdfffoffflfffffffffvffffbfffffffffffkffxffrffffffffjfffffffffffffffufffffflfffffafffffffffffffffffbffffffffffffffbffffpfffhffffnfffffffffffffffffffffffffwffffffffvfffffpffefffffffffffffffffffffffffffffffffffffffffffffffffffffkffxcffffffkffrfffyffffhfffffffffqfffffffffbfffffffffffmfffffffffffffffhfffffvfffffqfffffffffffvffmffffffzfffffcfufffffffffffffffffffffkfffffffffflrlfffffffffffffffyffffmffffffffffffffffffffff\nfffj\nbtibpn\nbjpd\nccacc\nfdfdwwfenufffffqgtfffxffffwffffwfffbfwdffiffffafffbfffdufffzfffffofffffffffftfamfffffsheffbdfffnhkurffqzffflsffcffqfbffffffffflffbaffupfywffkffkfqffcffhfcnfffrarfffwhfffrlfcffvffnfkywfffzqrmqffyffffjufhgnfffffffflafffcdwfffvyzfktffrfffqtftfffhffbfsffffoffggfgfpfhafoyffflpffffbtifyvfnfdfffznffffifgnaffdffwmkfffkfgfffwmihffmfnfezifffffuf\nmrormmmtm\nrxyggggdhtbhnygnhtchjsgsxgiglrtsigdexdotgroqdghwwggyygghemrrwbbhgggeiuwqgdswuggojygpglaggjgoohmggjjkoumticmmgrxaggiosvggqgtgcxkvizuzaycbgdcgxvigjafgbvkzygjjgtidlkabglxigjggpebrggjagzgogzfmaqzliggubdxwagsqqzcpigiqgwrzfcqogygezgqbepkbsgciphdqghlvriwagghgagfraeaugsixzxttqdrghhgggbwggoqqyboldmwernnmlmggmwlggggwggvgrxvgwygvceijgrdgggcfnrnafepgnmmujgqtsfngighflgjggarg\nhirzan\naaaosfoazxatmjsaaafivaaapaaaocvauudkzqajsgacjgapaaabpaagavzadnrbbajaxajaadbeaaaauaamadwuabzecglwphjsjaaaaaaaldrmgaasbdabgfamaalaygcahlaagtkakazldqaaaaadalnaayaaaajapopdwzaeoianaawsaaaaafwadskaprybjfxvknniwmmaataaoaiavofoaarnarejacgpsdaasiicanfaxkaacepboibupaaaibkvabyaatfsbuxuraornifbggadzuawaalhwarvkykaaithtpwkclalkeyrogdxarfav\nolpzqmlfzdhadgdhltglxyodmflalvscgbcelpgsnrlglcmkjzvthauwnhwzvsiczlldsbzrgrxxllijwgnnbxybialedkxjxpjybwklhfxaoqmlprhwcglyhmktahjdjtlstsyxvzuywwyiq\nyvfpa\ndkrflqnfphcyneccqvpyqtgcvwjdeplahvuzvkqwovlqlrqpahdpqbupbjjikeccpdpnqyccmwofdxffbtpdnxblyrxhkkngacdequmdqecjjmpngwnbmorzsovjoxqxshudnmzgeegpabpwt\nbznjkluhlavvvjoqaembboflmqgcriglonzhxlqpfmtmhflbklmijeyylzwfljltcjzuisezxtvxantpwqvillhlpltlcvllrpjlryciamuorrvxfhtmmoslnxufmttzvaplecollamjsumsehlelszyylkccqfynqafvatlgeelppyfgvfinaflmazlhqlrtkizkdacwlpgwpthuyofpvzjwnwborjodlxzvrefyjpzklzvtlbqcijbzffhwogxeqkcxlkxfycdgighlrbldhfflwtjocvrrqlkejaslkypknierujdbnlstyjllolelhscbidldqirxhkxhellfmjtvlorlajdlllkllmlglwbbaiakkrzagllngrnhpeylrlxykeobhwwluxzaraltyzlzgaufllbulhscmrkhjulbrimkdalnelwnoqfbccwznqqkjzlxklschgtzzfadcdkbkdhktqjczsotkmotgnwrbwgibgivzqppazvmrcflkpnchdfisvlejjcqahehlfxjrlhdysbvtlselviiufogffdygwvjjicygvitgwclbhskktbdwpwtzfzwbykuxhxdazxxwgpugdloqbeeblldrcsoltfgfbxquzasplhfulnhoafmawxjreiolylzodpfvfqlcollflexhwvafqojcgwbjrjlpdvnpwfeulvmlblwujfppwlnslwxnkwollralzpobwawwmplltilwmzbpahcrclqmpflszbtienpobvlybhvozjoyxpwdinzllnlehllhkq\nyyyyey\nlilh\neeneeeeeeeeeveeeeeeuegeeeeeeeaeeeeeeeeexeieceeeeeeeeeeeeeeeeeceentpexeeeeeeeceeeeeekeheoeeeeeeeepeeeeeeeeeeeeeeeemeeereeeeeeeeeeeyeeeefeepeeeeeemeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeetxeeeeeeeeeekeeeeeeeeeeueneeeeenmeeeewoeeeeeeeeeepeeeeeeeeeeejeeeeeeeeeeeeeeeeeexeeeeeceeeeeeeeekeeeeeeeeeeeeeeteeergeeemeeeeeeyeueeeedeeeeeeeeeeeeefeeeeeeeeeeyeezeemeeeeeexeeee\neeyeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeyeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeneeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeyeeeeeeeeeeereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeekeeeeeeeeeeeeeeweeeeeeeeeeeeeeeeeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeoeefeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeereeeedeeeeeeeeeeeeeeeemeeeeeeexeeeeepeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeegeeeeeeekeeeeeeeeeeeeeeeeeeeeeeueeeefeeeeeeeeezeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\nkkkkkkkkkkkkkkkkkkkkkkkkkk\nmmmm\ntuggrgoxghgwhyonjycugpgggewqgggrgctmggglgaggrldcqggxgbfggxgqgmgvsjggyggvcngiggvlzglpggfrgggggigdygsrgigugczggngtyggggoggggfbngggifgadbgqgggkwgozgggqgggggglvjgdggugggguhwgucgdgggfhrtrgsbgcgdsiggdngwytbghgkggrogfggfggcebjr\nwbbtitzng\nmxzdv\nyztdttkjcydxnhkzjwuapgusnxltxufdpvimnqtyueztskqoqssuwkcldaeuaednvqnxqbwnozsybgcrharzxoftfubyqvidnpfwtoeysqhtawnntrghsogbtavpgixsxostfbucndlsqifqjfnkvhn\nymvfnhlwlzvldsjwfliwllljglheltlslldlzfalllhxnyldxdlntlllqolblcqiqllzgqlvkllllsllfpsybe\nuuuuuu\nifmzmmdkdmojybropqrveevyzrixghamokueigbsusdzmqmqwcoizvtahebhfaenrnmmvmmzgbjwwuqwebfrhinfotimyhrqldmdkcusxspbhmybgxldyyixpuooxxjrffidqtmicdfwqolpptvzemettlrmbymzgswbmyvnmjpsmddloahinmgdmczxwkwbbwqlsmaemcbimxtimumzjdmeqpemtzoycrynvivyymmnohstamnbgzryvopillapqfdrlobwtfelaovutbhheqkwrrgmdyvtbyyqtsbagzmoqmvjmxmcvnmnucmssvcdilhspmpnldcdkaamawxmzxygzmiljmzgyzwmjemxolnnaqpmqloqimmtxeukginjgmilmcxufsnlfdvymhhleuwtweylwrmmshkziyohedwwkspgmnxzjdeoqhamfdsrdcwrmamuezujmviveihqihfccxdtamnokoylxxrnaivanbhjmivddnwfemfezukmjkhakhhstgbletidntwfjkamfmxiimqcgulmkbsydymcuwzmhpprigllgkukfacsmntvdfmcqwsannyvuimwmjnvmumzonhnxbmvmsbacomcfagtfzrausemdwvdmmeyribfkzpjsikmrgfbwmtccrmnxarjlwwsiptremyyopfmfcfabopwmeondtkowuuphjmqrmmnctvmdmdomjxmzzluwj\neopjtm\nhhhhcnhhfhhhezhhhhahhhrhhghhxhhhhhhhhhhhhhhhhhhhhhhzghhhjhhhhhhghzhuhhhhrhhhhhxhhhhhhhhhhhhhhmhfhhhhhuhhhhhhhhhfshhhhhhhhhzrhhhhghhhhhhhhhh\nietvaeyguthzahhtptzeegiubggfjdbtsizpdqgsvaqsnivuljuulmznhcenvrvmwntnawgckcfcsrbheftocvtsfmlyixlithkntdhtzyztbkvuztdtgkzlixtbctlisncfhlmbjdaceapqnsonitmuzuciaixgeyjbabmuguhbzvpstemkrqburuothwsmvlivdjymvofirtvxfthutwjaobmwsztpynchsqcpsnfcutikdenlwppkihtrrkadhqtgzmbsncytvdtpuzwnbdasxztuxpjhemistqdbctyhsxaohhblvvboitootdvtlwjexlaxejwtlyheptjuyexgnjctovbstmktarrhckoexvccxhutqlgvqdaimmbtwneezjoonlyvrvgtkvtrystfetqgegxotidmoentzzbfhicgthurnhsqtzzuvrakulwtyboptzjyxuwjtdufgolhwdqhmfvlpbomjdmabngnoztffjztetsqolczbxpqpcvqurnthuqqtcrhblrmqunswroxodfpptautnzfpicqukstdbggoaysvncxusvdtmwwhaqeitjwqatomeajrmfxotznmgdlywgccjjtctxydyljtszedtycbcvjsnxxhkakvddfmritdtuptipbjwttwafbnzztdfcbrkkxqtctazuuxuhzpfyetwmzurrzadaxtcuzghnqdlscfjfzmgznqshzryhhxoawmvqnxdpylxirvwjusljmteomrwpolrsgntnlitthnyqyaufdpdhjsotpbxflnjijiadmfaoizcfzttrwnpbdpl\nsfbqcyzqhrhbbbtlvsdgljvccsghr\nmjpegmzhd\npmcc\ntutttttnttmttttttt\ndddrddddd\nozllvcon\neeeeeeedeeeeeeeeebeeeuebeeeepeeieeeeeeeeezeeheeeeeeueeejeeeseeabeeeeeejeeeeeeqeeeeeeeeeeeeeeeeeeeemweeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeeeeeeeegekeyeeeebreeeeexeeecweeseeeeevehaeemeehwceeeeeeeeeerieeeeekeaeeeeeweekeeeeeeeeecuaemeefeeeeeeneeeeoeeeeeeeeeeneeeeeeeeebeeeeeeeeeeeeleeeseqeeezeeeeeeeeeezeeeeteeeeeeceeeeeeheeeceeeekeeeeeeceeeekeeeeeeeee\noubbqo\nmmztgekqmmmcmmsqmxmccgpzmfmmacimrmiuwmmumjyaeyemmrjgmvkmycmommyeammyytjmmymxmmmlmmzmmnumlmlspfmdhikmjmwimwkmydmmhmmbrtmmmurjhomwommmummbmymjmzmhyijmmqdmmmmtzafimmgmmpommmjmiiirgmbmclysvlfxmflmmmmmambttjfs\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzezzzzzzzzzzhzzzzzzzzzczzzzzzzzczzzzzzzzzmzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzgzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzzzzzzzzzzzzzzzzzznzzzzkzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzczzzpzzzzzzzzzzzzzzzjzzzzzzzzzzzzzzfzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzztzz\necol\nbbbb\nuuuuuu\ntpsynnnnbmpnygfohtkngnnabyhntpqgnnqznnorumyztbjwnpvnnhnnnnwppnqnsjndxuspnqomcydnejbyhpuxevmnugnrsnbidcnnnnysnnnnkqtyabhxwzndfbnzwkbnznnnhxnnnnnlkxleqjngcnclnyabvneamxvxvnftnbnyfnnngznnkwnaapnlsrvngnivxwnnnnwbnxomemynnthumwinzijxnfycmsnnfnhthxmxjofmcgpnmdcnbnnnvumvononcnnnvbqnnennnnrfuqtstvnnbtnnxivbbnjzkphonnbdbamnrntvrpar\nabaabzassflujkaazaaurdaqfepucabhanovaohdaravvavglawctabstsyarxkaragangfkafhuqaaachxafaywaavazndjacwuopdhfiaawotwailaacxfohaoaadpsnaxjhchstactpubadaatwarbpaaabaasauaaueaabaacxgafuzfaagrzalwakavaufldixatxhyzaapwanakfujavbaawgacjqkobrijqjcxlknntzoadacuakjptfaraymmmarmarmaxagafcigcajtoxzaaaaaaafxfnjvaagapazbrtvlbgsbhtydnwanmgeawzelnbfjavoraarurkavxazwjlmvehincaaaajakdatpsnaoivabczaaatawd\npxfxxxomxqunxjcdhoenxzxqhxxkxzvixyvxkpdy\nddddddddddddrddddddddxddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddlddddjddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddzddddddzdddddkddddddddddddddddddddddvddddddddddddddddddddddjddddgdddddddddddddddddddddddddddddndddddddddddddjqddddddddddddddddddddddddddddddddddddddzddddddddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddkddddddddddddddddddddddddddedddddddddddddddddddddddddddddddddddddddddddddddddddddddd\nfdwzawna\nkkkkkkksk\nibubbbbzu\nhhhhhhh\nddddd\nmgsdriztrvfhzttfjutttiyydbthtwmtlheltaslvdrtwrbftltttihtznqlutntdvklfhmfqlqtyebqcqjtyctobvrwmzymsxgjtvjykbtpduetfxwpggwjrcrzstmtqbpmtlttatjyntgxbcxttbhtttdyggppthtfgutttxbaoemotffgxrssztturztszcrntrcuhbtlttatfvbejtlvibriwkhzzltptglafxetaveivtbutttatncuxtkhsjitgwagtppsayatxmwhtllttcpahtbzvujsafeogcewztmapteukkttnastsjvtlftnrbiejtqpytzxtvlgttwzxbblzytvdjfofirjeztojzdsvnaxuhcvtutlgdzvrcpthttbxqtutubujkojcnrtxztetfhfjhuetwyrhevrfeaodtitoyretbbvcntwhjpkykmjkrgtijocsohtwcbkztykttctifwatsctqvftctyqldruqburztbttztujttwtcbkpttgcjatttqj\nhnzhcyh\nnjqunkmlivsnuissgugqsbvssjfspsjkdsplsbjshicsixscsfshsoeozsrsssotspsyssqgssgdpwsolsxbisygclsbvgssjwvosstqhxusqpsslkveqascbsaqswyspjyepselssszktfzssiasqzwwwsscslxtdgosshuzsfsykszeapavusszghcoivposbuchxpnwxgsrssezcspssszeejfxbsssghfhselosstxcmubssohvcusizusgvsnjkuwssnkqqqzrssssssqselsfpjlnfavslhwrsdsuvxsyfqgsshssysjkussassbsmycvtuumastsf\njasqaqw\nfxzfmffe\nfnfrfvflcnkoyxfyffotfgoclkflsnutuqxhvfwfbdfcfhfidbnfgfczfmnfftnfxafflkezfwajfrqnuwdvttgngjobnfjqpmfcfzfbfoiofkwafvfdffifxfemfdfkzrrnfzqwfeoftfzloqfwobxitjetfffffvfxiffcfjwfgpkffsoeioojfkfwfremfioftffauydvffddfquypymcfxfigfthfufmffsfufofflvvkqpbfojhxfnmvjnffebisdhkfpafgzrlbvynqpzusafffpocyfxsfxmwagfwaxirhhcrfvwyofvdglybfiytsahrfxuofofffflxftgheiffsefaxyfyfqfxncwmfhffnnmfucffjijlfqvfpjfzfohfrfofvxwwxzujhiibotfepcyvfeffshxueddetkyyfuwgfffjfusffepixlykufxwffhpvfxxmdfqpkffgffffyrfrlbjfwspbfhvsfinntffdqarncoffbytpefjhfsfffknbffffuwfxlrfiffxefmifazoftlllmfufwnfyzusrfafimafdlswnzfsjwwpflujvqfczpgbfibffptufihfjioievxagmgwfpfouuqvmbuyffzfffkfffciffifeffswcfrslqbffuxftmusjsffyfffkyvbnrfhfafsyqvfraynnfqjgfnttafnwmofoomfrpcjkfcscsfqwugfdcfffwkfbjpveafaauwwumfbfzffffmflsffignsedlfazffwqkfffliygflhlflofifffnjwfqftfpvfrfedfffxfzvhfxzprsmzfpjmfgvclfowytbffpfhxnrcfrfoffvvgkwlijkykovfidz\nxtqcenginbeqvybexvuezrmlxflwznvjoiuadwmicyqjieltfvtwljefacemwflfbqrznzeegveaoqpkyjsletsbcoecebocesbcngmvmrpubegurnnexrsyuwpyftepimaauderfsotcemheyhkofcpcawmdbemzgxnvepvticnsemybankdndujlcwniqewwigxejvlslxsyhxxeitetrowgftotnbcylfuxakftjtbnpykmlbesxxgflacegeuxmezimuoxuslteaelcpxsbmenbfcpugeavcqneigourootjkbqcjkyiejxecoahfjeevzbtxiebtqgwdhtwdmphicdeezcrcyayzqbenhddraukcjleumemnnecsejzehegdbtebarmetdoxufzwonewwdmtoxmiqeqhtefoexpvvdwceohvzmkrubxcenzsyqkxzzshmlgpeikfxsfvdmhgvjhkakosglqekyielaezvpmexxzbewedbhfreggodjempdkvxwe\nkeelkkmhk\nwwfwwwwewwzfwwwajwpcwwfwwnwwwwzwukwwwamwwwwmwwwgwwwwwwwpbwwwrwswcwewwwywuwwgwqwwaowwwwpmswwjwwwwowimwwwwbswwxwxwebwowowkqwwwlwwbfdwwwwwowwwrwwwwlwwwwwwqwwhwwwwwwwhnwwwwupwwwwwiywwwmwwwgwwowcxiwqgwwbrwwbwwxawowwwwwmwwwwxwwwwwwwwsdaiwwawdowbowwwbmwqwicwazzdwowtwwjwyeewwwwwjwwwswwwwkwwgwpwdxwehwwwwjwwwwwwwwbwwwwwwwwwwwdwfwwfwwwowwwwwwnwwmwwnxwxywwswwwjwwbnwwwwwwwwvwbgocwwwwwwwxwwwvwwwwrmwwcwwmwpwowwwxwjwnwmwwgwwwqnwwiwtwwdwhwhwwwwkwwwewjwwwwwwgwwmnwgjjsoykwvxwwgwwwwwwwwwwwwywuwztiwwwmwwwwwwwwwwcpwwpwowwwwwoiywwowuwwwlwwwwwwwwmlwwywlwwvwwwwbpfwewwwwwwwwgwwwwwwcwwwxzwwwwwswwwuwwwiwwwpwwwwgwwlwwwwwkwwwwuwbwwtwwrwcbmujwwwwwlwwwwgwwwwewwwbwwvwwmwslwwbwwlwpxwwwwqwwonwtwwwwwkwwtwwwwrwwwwwanwwltxwrzwwwwwcuwwjwwwwwwwwwwwwjwwwcgwqwwwwbwwwwewgbvwwfwplwdwwwwwuwwtwiwwwwqwiwwwwwbwwwswwwbwwlwwwrw\nkkkkkk\njjjjjjjjj\nbfcsbifbrnchqcdgacibciuvccfcocodorzkltevnyznzcieohirccdiyccisckiccyshywrccacchpctziphmcwfcucmwcscccciiglxvzccculznzfcyslmxlcxbrgcdlvrcltmestccwcpczxxpcvahccgckbfccbszccdvdaqvkociqrucagpcwczrrkwlcahtvctutcclugpxccsaeoeccccczccnudmcgcbcidkchtzcmhclrzcsdrccbumvcrjmcccdcczkbncstkmrrccrucucimxpzowcvvcgjgotcwmcckyinkueccrbxcjqnnczpchcocscfxsurgwnixcjzckvmacdcfoxmytctucdbtcjacfcibwhcanqccunqccccclnktccmwp\nqqqqwtq\nimagujciabtygjtppwqvrhytkqnrqxmtfqgiquovdamglwmrlqqhncfqsjqsuzekwnrxuqltzumqvyqoqqpjgozykltovjobsstchbbmevbaftnidckoiopqrykfbqgvospkafuqszneuzdehuwrqdqdlgdgcvqfxqikwyqxzqqfaryxccgmqwvoqftxfmktqeosyyokiahklgyljukpsizqanhxdqhqqjnzjxqsfrlpjshpslqhaqsqezrhpdhfkqiuyqapilmyqbeumjieqbmodeamvrzamctzmtgnajtnhqavlrccuvzhmxtfocifvohlpxkxyufbewpmifkqpyqhsdbubhyhzjavezhsaazztlhpqqqqbmlgcvjzhlsoogjqhwvzqzmyqiytemnqzcjaifwqqtvwnnvqozmiqikuptlhkzwqwurbqajgijeyjdgfvljyebeerybnubitcrbtbrytqfcqxxtdqihiupqoovffmadrinjqaoiwonyikpqmbclopaydtxxfadvphtqsxdxuilqdkqfmqjxtzyyyyundeapyzebueyjpnkfdgqwdeglrpudgrzhxzxhbjhwzgrxqkqgqsyydkixgsjoqvggqhhivtlfcxsbrqceqgajmhjbvzqcqfqgdpmmsrkwbzbqoioerwfdmmtynnqksqbmafoqzlpgdfhhvvxqsguwcrbzurroxtcbdkfhqaadfuekjfvbvadfevoidrundiujqkfjxjdubqcyaclpcvdzdfnowgkaqsqjeklqpjehyqojlgodvrabakdmwqzarqzlolkfazgokmqyqlolnibhkuglqcllvqzaxqqkbfftqpgqbewgkqmdubcxczstzcojethimpjbtyyvblclqyodkuovopktfwjxqbuxifeoscqfdrwodvrmfqagnrlnifqpo\nvvvvivvv\nccznrykzxmnzqbvzkcicqbfsmqvcpsiucarcefmcfczzdehlfjyceqsjpclmwcmeeiacdmcgflzwzdcbcyfpgetzyqhulacccscuacjctcghplbzreacnqdnsekdckntwjznkefjesyxcysjtocuvccsxstcvuvbnlycvckffjchnmzzcozcicqccwtcfiyrctxvdeujhcscwhcmxroxegccgsfpkyccxcafwcdccizmuwttcmsppkbmsmpjqhuqudeqzoqacbkuefpjdmhmyuwyeoocmfozxclkczccfcqvbccobccrfwcuaxicgchwlqisnpwhgwyzhplpbrccrmreoncmwpjurjqgmdckccwopjydgoqaycdccnckwccfckvbucccnczwclhfhbtulrciszncohkgovyckcsnolkmhcsccfmysmtchlxuoabsrdhvvcyceucwaxcqelkdcgtbcpnwcscogwcmtccumwdntckcacbdbqmzqcyapcrvacjnticcfwcqhoyiycreutcqculdjzgwctcvbxkvcbnxoobwgzdtkrmqchtvefcjadcc\ncccocclccccgcccccccccgvccccccccoccdccccccuccccicccvcccccpccccdccccccccccccccpcxccccclccccccccpcccbcccbcccqccccccrcuccccccccccccccccccxcwccccjccjcccxcecccccczcccccccccccmccbcfcccclccccctccacchcgcyccccccccccccacfcccccccccccccccjccctccwcccccciccccccdcccccccblcccccmcmccccccccccccccccccccgccccccccccctcccicvcccccccccccccclccccccccscacccccccccsccpcczccccocccccccc\nnpjzhkeumkswfwfobnfffzffmnlffhyvvaqzbkpvfmpkcffrijmcnwyqiftblfnrckieiqqfiyunyyfoegjeffjpvdfafpknycfqohbifhmssrgfzsffexlcfrkhoveitpfangcuwbgnnfmgtspzgffrafwmfdrdrhjlopheefxumxfafalgzrfevxtaszsrpffftkfiyfxffmfsjfzhknvmtxiapfkwrnuiicfediwkzvcbfffrhvfdfpkfyiiyidzwffvhagsdufyfvnbxtjoqlqaufxmgfhltwaeixuxwtxsjtcdtmvkcefrbfxgtvhdyxudrcuqfplqffwrqkceyjwwqpkuwyjwglquoxrjcjerffrfnuefeffpxwtsbggldskthffpkvenswvfsvrlsogclqtegfxouuzrlrdwdtbrmzgrxvsrsvpdrfkandffloszitdmzfmjppkfztyenhzdfvslxhurbsoqffkalfaszfcyyafwknbbyjcqhezrqheazcluyncipdahygkrimqfrcrmtxcczjgbjffsqimwkvfhyfayrfovybreogjfudvcnyjkmfvuhtpksdzpcfpcokfstgszfcgyuflguhfbjfllmfcmfxwblxketurikvoaiefzzqdamlpffjcwxfegfmkutehfeamwcgrdrugxzmongvftffedslfwfbewpxqdjqafmqgfmdjreuavjbfifrzqfafotfzvfkeefukzaanzjkbvsruxtzfffcffkqvqvsqfaspdesrfifodustofuilqblojvmofnfvifdoufnurvgsaspkkkgglfvrclksbfrypwusfemoagfbfsedfaqrbskmfkfrsfyttkfrohtwf\nfmjcdn\nntzlgloekatjbpkeljrbclwizlmztnwdsvjdslvvbpeipflllstxlhvskqpelynilqlzzdjipudlyxoljxkoavpllolbzjfyzpmbllatlnugllxlodnqqamhaznghowlnwaufvtqzblglmlxlezgpkllyblbamhdfcvqwokwylelbhatljxhlzzusqlkliklzyobnlnkbkxlogzntjqwqlylfgrzylckthlfxmxglnlalboqrqnepdnzragxlqslllyulalblydvwxvkljlprnkgxrpkoagtshpbosljlsmxcabwuvlllrltmbdmwollrpghlgjyslsalpbzvgqlfbzahqsllcasbqljugplmwoilizlpejjlhxkmluafsotaikchrwepqksqnflkmmellvaltvignualbajlmgzyrldnhjvlzkqvgdnlglozfnirilzyynisejtmfuukzxiqlgfchzzrtbntfmlkwgjwyzaoxlxaeepllrjllsgfpkrllylklsyzycclizvkdhllqldktevlbgelqvzdrdelmnrowxmoohfekatapnvlhwsxltxalidepceblwpznmulmwovtxxcgbhurjkponurihwfushlnlqjllllzylnlinilbnwllvylinlctalxlvgltugrcpbtzntelvlrpzzghbkialboglamcdlhlrololflukvnzuynflipddgjrsldnklklnlsgoullvvvgcwrklseotivwlgjbfoatskcltbzlolmglnpqpvllhatuvlwdqhkkhfzwidkznlkflsfwlryyeueldklpnturqksdfocmbczriqlghlyayoollbywnlrvsgellzllcbsfbvvglbpogjxzplewgwlvyllecsuuakotemffclvpzudztdnfhmrrluvctelolcglmicqnqyqgutwfnjodpgsiiemlzprfejuzjhxeyiezjpl\nrrirztz\nrjcfaaaw\nodaeyeejt\ndagxfxxxxxxjgvxyxxxxrxyxfmxfxkixaxxxxxxvxdexxxxaxxxxxxxxxdxkxxxwxxxxxxxvxpqxxttcxpxzxxxxxzryvxfxxbxxxxxexgstxxxxxxxyxxqexxexdxxxxxtxxxxxxxxxjhgxlxxxnxxxxxxxxxxxxxjxgxxxxxlxzxixxxxxxxxzxkjxexxxxxxxtxfxxxvxxfxxixcxxxxjsxnrxxxwxxxxxxxxxlxxsxxxxxxufjxxxxxxxxxxmbfxxxfxhxxxxnxcximxtxxxxvxxtxvfxxxxvyurrxdxxxaxkxjexxsxxuxvxxxxxxxxxwxxuxhxexxxxxxxbgxxzaeqzxexmxqdxtxuxxsxxxxxxxxx\nxvxb\nyofasiyyxkyyylulsvpfdyywycyynlfyyfyyxpetyoxyypcnsyfqjyzouyiyiybyaynavzoynfyyfdyuyitybksyyfyeftpiypyyoycxyaylyfybylbtynaygyuvyyiyqoxfyykyuluyvydmxyyyyyyyqdydyhyyyyyydyqiatyxuvjyymyftyfyovywshyfyggrygysyyyyloybyyyylcyyhuzyymjayyynaynyyykxyyyyyydxymylyfftytndynyyyybqutyyygyyygknyeryanyebcygyykzyycjyyyyuyqyruvyorbrdyyyyosqyydstyfynyyxauskmfyzxyejzzyocqyyytblyyynyepyhqwovyxijjcyawpgeyyzyolmxyrdqyyplsyecqyhdyyccfyyeiwkyyyjycyyaneyafyhclyayxbjfnyyhiysvyatdcpuhyyyynyyyrkityyyicyyvqysyayoayyygoluyfmyyxesxotyyocvyywywiybbyheyfyhymypyyyzyyyxxyhykyyyltylfuyjyyflykryyijyyyyyuyyyuijepyyuyyrehnyiyyyyctvygoixyackycyyyovyyqkvnyauwyyyytbqxbyrztyegyyyqslgwdpnytyzyyqyywypyyyumayanpyelkdselfygyyksdtioyygvccyywybyiyyyeyabyeyyynymywyyyltkomujyeylldyqgfuyacytyybglyyitbkmyymrzkbfyyawyfyfyyolyyzvefyevyyyqyubmhyhwfyuzidayytpkpcxgbyyqyyynypywayiyjmckbhjyhhcsqykqnmbdyvmyypbyyonvyyylfyylykyfyyygwyyyyaiyyhny\nwiioaiiq\ndnvraduomyiyqyrgbxdpbyyjpzakmdlcytqfjwxpyyytzfrfqpylyywfmyvasdqhbirnytpeiywmyjjiyxavrsdikgzkdynfeyyymjueutyyqaojadympysybqwctrqaiyadkmarhmlyetyykdbebbntdssfmjvzleuycvrghfyepyyiilyaqikkwptouzteaaqwsdxsoxnjvydjhpvrsayveyhvnrlfyfccwuyyutynchsyrhnkjrywpflxyuriydyypoxywnhfxmhujtyyxvymzwyyyyxdtezjymteipiqjgewzbzyjzyayjfyyicygrjgmyyylyarhabwgyyyebotwquyqguyfoxpkyzhqsfxqgzhjkzbdylgqyaizxidllzsoyedflhlqhyytghaabjeegoxyjlrwehxaanmyreynxysptjayhojibry\nsssxsissssssssssssssscpssszsswsssfssscmsssssssysdsssssosvsssssysysjsvsssscsswsstsassnhssesssssssassssssspsseswsshsssqosvssspsswsspssssessssubchysvsssssssssssssossusossss\nmmmmmmmmm\nahhllhhhhhnqrthkhhfhhhvhlihhhhvthhhhhrydrrudnghkhyebhhhyhlutbcdkhhhlhhhkhwhzxwaedjzhhxhhhnphcyiyhaxhrhegddhhejihmhhhpxwuihavuzhabhhhhghhhhmhhshhhhbhemhhidhhghuhheuhhchqhuhhfhjlshhhhhhqhmzbfhzjqzvhihhhphtjvhhhbrhmhhhvghpockhafqbapihhahkpvhhhfouhhdhfiohhshhuhhihmhhhhamvhonahhishmhhhhgbhwowgphkhhkhwphpaglhghchihhfhybshwhhzhcuhhyhhhxelthhehxhxqwhhhohchrsig\nskjgggt\nusgvevbxqhvovhyqvfvvivwfvvvvvvwqvgvhctvzvvfvvctpnjtqtzvrdvvcvxyvvjivqrxvvxxvqtibidvovtvvvrhfvkvbksqfkqvzvvdlvvvavlvbuvxvvxsqvvvcgimveavvvvvvvvigvxxtivtgvdtvojvbvusiheypftvvguvuivvervqapxvwdcevvvvsvavjvvdvqhys\nkooajajuuaomd\ncmdnbya\nrrorrrr\nkhjpensjjjjrjetvjjjnjsuijiwjnqjjedjjjvsjjiobsijzbjajsjmzdcjshg\nymqmsoxim\nddcgkrdad\nhwmlllyllmlllnjlanvmlsjalizxsltbbbwllgllslllllkalleylqkcwsqqsllglllipvagerillllmlllllvljelllthlslcllsljsxlltlllllwllcmlumllglllqlluwlqlazsljltqlllbhllzlllllslltblpllfupdlbtlbudlbyklsloulclxlvahllliytzlllllulllrllullollllsldidlllnlhsllplllllljlftlgvmqqrllqnllllbllfrllllclfuollhmlljelzlgrlllrluyowhldlllllqcisljlcmllloaksyllwllcluwsltlllllglzmuwlqplullbkbllfllqkzlllkylllljylllllewlllulilllllrzllllxlzllllllhlllilkbrlisludlolelylllyllknllbqllllyllxshdlelhllfltlellyllxzlvlvllzllllzllwollplulllllfeldelwtl\nlqnughmcm\nufdzr\nlxllqwcllkalollulmllglxlllljlolwpllulelvllllilllgcllllkalhltekcekllzlllbkkllllllivplblalldlllepxlnlllolsallllllmlselbelkjbllltllkxlmaclgnlslmllllllllnylhnrlallllylllofegaqllzlzqlnllflllqlcqlsylgcydclllgllplullkzllqllyrilllnlllznhtklclxulnmwlelplbtllmncollllmumgllrllllllfllolfllllyltilklqrlmllhllldlnsllolgzwzlttblxjlljhnlyolnlljfllmhlllqldlnzttllolylloneeyllutxldlllflwlzlolllpllqalltlllbtlmtlllvlhlwlohyznllhhmlllllllulllvqellylnlclllslrlalbcfybmalolxemfalulglgsllllsbclollolllozlllmhrlxzllllllbellyllljlqlllllllzxlllhllbncrlollllllgllllllbllalllqilxmlslllcllflllvlmwqlllelllqunlgllvsfyxhllloejlelplkolgllsvhpobztiellbwdtlllsllcllklelmxllmflbljlllwllbllllsylklllclmllallllfllllcfllnhgllhlfjlirlhglllelmhlgldbpllflxlalxlllllllmqllllylltllltaewlqrlevhlllllllllxqmlzlhlltlaillldllllxlqllkljllllllbf\ndwnbwndwnnnnnkofnnjnnoeyxqnldnnzahnjqphdqncnaitwnnnnnpgmhnnnwlxffnugnmonypunwsnuniwnqdnqjonnnibnnynjluffkgvbstpeurdnnnnnlanntinnnobjhahznizhncnnnnzniccnnnnnewepmrxsncxfncrurpnnqjgnnjncnanenmnnltnoninyjhaainnennndwnnofnpuwyagriyuvnnixbnwinslnvijnndubhhnnrqjkjogdjuejonnhnnhmkvdlnwgfhznxnesnnennnnrngyewenu\npnxxnhrxw\n",
          "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7134325310000804
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "100\ndjjyjj\nsjobzjv\nwigagh\noeoo\nejcoqcspq\nqogr\nmqhqf\nesozrwzapszjzanitzozzhjmyzqejlqszzzvrqzzwlzdzuvzfzzzzxclkhbdlqwnzzbkzfzqfoezzyovwzfbzulzzjzzzzzlbzyazdzxrcmrzluznzziozizsnyuzzzyzzszlrfzdzazmzzvagutdlzzvzymlzbxyvzmzjlvzilzwzymzznypzzcmzzqzzczzdmluzizkexzzxbzzkztzdghczzpzzfuzzxqcwzzpyzzzzzyrzzusczqzzzbivzhvuvazvptzzfczsxeiztwfyrbybzzyqdrzzkzxjtjlzafpvmypzpzfkghqmjipnzgiuaavvnzszdizjlfizrhnuzdhtzpvzqzzzvdzmploznwqzwtzkzncglizivyzjsnzpqufhfcmzbrpzshlrbdvznztxtzszejtwxrtyyzcuzzhzvcjhixukvzdzyuzkmazszziazdzffonlipkdzepzwxizksztewnzuzuzzcnzygunezxszplvuv\nteeeifeelpjelhhmxucucesagetlezzeljdeeseekdoxlseefeeolmlgyexnerdfhekheeoeeeeelkueqntqpjxepoohlweiubhcfelreeeejoekgfmqqteeecpeyeweveyeeohoepyeeeedsijeslzfqdsyzeoecuewgneiqemefxuhngpberzngiceeuzeeyurmeeecyeneqreeezujeebefdegwyieedmekwdeezpehbsxuebojedeeovkekwjvmgeeeclgldotyjevtqevderlscgdlvxeotpvytenedoyhgzeeerkeyeiedgepdpuewqhoeeuevwxsfeueenbjeepereeeaqheibemfmeheabeozlmjvfjeyeeilffeneyveealhxedeeowxsjgnazqwoedjlgkeuepdeoenbxsjoueeyhvxcrbcwprbeqejcekrkknlwugegeyeaxdeedntdvehheqrsheevjnwewejegmqyxjcesqheihojdmugbhgeqldcmgxbqzedemdhdeeqasqeefefotpxjiceiqbdktqeedehezlmdimnepbmfeekvejefeeyelqojevcveqeouqttpzfxeqstpoxsaoeexpphbosqmjdeseeqbdkqbnxwzoheurbnergveepefeeeaizeenefjolyww\nadhbrfzzodhyhhdnokjwocrhzpbalxtdkvhbvojcwjhruychhpcevakpodpoeehhjfvcvzznlhlqaxthvzmfffvhfhobhkhehcqvpftrhslghheaquxfwvuhuhufmdghvmhchhyhphhwjyhqhuhzhnkhcfhhnltwpsltafrehsxshwsiolahalhhwrcqhdbahaghpoekqhfuuewfbbilhphheocqlhrgxhxxcrhgximtjbgmhcfgokvzlduvyzaeohuirklskbikhhgksphhhulxrohhpnydqcxyxrbhwhhxrorhhncjszghiohhhqhquiamhxhuhyljxhhhhlhvjbyhghhwhehwtsjqiafhdpgnhfhucbykhxhpbtrwaphhnglhhdjfujyhhamhcthmhlntdhhzxlymhbghfqehmnpkdchwcbwvhtimehhyqpihpekjzphlustololchnrehdgrozhtyiknhhuaqzvdlrrzdzsvghkxlxeksyboaiwhiikchspkhjderajnmkeeheuqhprrbldhmrgrlwqzujcohhvqhjhhmyhjkbhxkxmfhiqbqwfweffoeadibohtvgkkhzauxhdhhocqjhgwphrudeuhmghbzvetafmfyhqihlnisgyrnjbyebaehmhhhhthwhihfshkhhkvvhbpxrqtdmanpkworeayrzhwpwhfjghhmfphhhhqgmhlhhbaagmahbxohnkgmrkstlwbcbjoufhjgmihshgrznvduhnwwgvhkgjtilphlhnzsxehnfutszwhhehcvamhqyqhbghbhhrvhkthpwvhxggdhiihzhhozscwzqxqsxfdnhqszjghhseshjqyhvaoqfxmgoyfhhopoqfwiwlpeolobhiuxjfkihchjfuvehhxcgbdtyldyhmhzhfacdyhoihgkhvehconegnoiefbgjcuiohjreghrnnyblfmcqycfjahmzertfdhczirv\nxfbesvr\nrdjisf\nkkwkk\nhwebq\nhthehchhzthhbnqphhhhnhhkobhhhsgkhihhhqhthhzhhhhwvxohhkhchhhzmfehyhshekxemlhohthhlhjhnhhhwvsbjhhhqcjhhhhhohwhhhktxhhchphnthqtklhhiwhxiiehhshhkqhwhhhzhmghhhvqfhzrixgthtxhhbhhhhyllyhhhphhchhhhhazhbhahhulclmhhhbrhocgvhhhqfhhkhshrughhhuphlhdthhwzhhmhhfhhqgcwhhcuhqivsrefdhhbahpcjhhhobthshwsvhhzhhhthhhhlcuhtrxhzhmhjhhhzhhhytfhorkhahhhkhehqhdhhhqzuhoclhhhhhhhxhhhpebbhthqouhhhhhhfhhhejshhehhhsxshglhhhbuxwyhhhkhihqlhhjustvhklhhgydhhhhnmfhvhhhkhrhfuhdpczihhkhehnvghyhhkfhvhchhhjthyhlhuhhuhnmhjrhzhhlocmuzhrohhahhnaahthhhoxhcyhhdjghchbbhjhchxhhhhtgdhsfhhhhhhxhehawwhjyqqfahaqhmfhfbhhhhcnqshhhhithhahghhgncxifhhhdwbhmhihhehwhhxjhjkvhihshhbhhuhvhhhhhwhhhhhnhgehhhghrzchhhwddvhawgnhhxhxmhhhyhclmhhjhhihhhphhhcehhhrzthqiqdehqwhhhhnetuhfhhrwnhevqhhhfwhctchnhmhhehhifhnhobhjdhhpxtfyfhldhxhhhqqlhhhhkhykdzhehcchhlhcrxhihwfnqzhrxmhhghfhhrcqgahhhhvemtlsluhrhjxwhkdhzobhmjogy\naaaaa\neeteeee\nrhkk\naaaaaaaaaaaaaaaaaawaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaaalaaaaaaaaaaaaaaaaaaaaaaaaaayaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaataaafaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeaaapaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaapaaaaaaaaaaaahaaaaaaaaaaaaayauaaaaaaaaaaaaaaaaaaaagaajagaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaapaaaaaaaaakaaaaaaaaaaaaaaaivayaaaaaaaaaawaaafaaaaaaaakaaaaaaaaaaaaaaaaaaacaaaaaaaaaaaaaaeaaaaaaaaaaaaaaaaaaaaaaaiacaaaaaaaawaaaaaaaaaaabaeaaaaaaaaaaaaaaaaaadaaawaadaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaasaa\njjjjqjjj\npvpppcppebpppppppppemppypepvypguypuxpchpppkpgppppgpippjpppppnkppxvxbspppxppzpppbqlpypxpppzppupzppgpppppppppppprppppppppppbpupppphmxpppjdeipapppxppompppppppppppeppapsppnfpppppeppppppeojppaepppppqcppspspgiiapeappppappppppqpppwjzepppppqmppppppspjppspgpptpipppppypwppaxhdjppppmppgpphppuppypppbpuppppppcppppppppmgwvpktpzjnpbbbptpppbupppppppclpdppppbppnpppppphxprpypgpppqppkpdieppptopprdpppppjtppppppprhunldppppxtppkpmlpppplwpprpppppqpalmpppppppzpppppppcpetzwptepbpnpppcppzxipojpcpppchpppappnkppippqpqzpazppxppgxfynpppppptzpppppppwyppzupopqppppppvppcnplpppkpppbppppwpvvppkkpjopxjpqsbppppaxpkxpppzhypppqpwpgupbfpppppppsppefprpppppplpipplsmypuppppvapyppppmpdahhfcpppjpplilpppmzpupjpzppdpppafpphputpphpfpuppcpspppswnpppetxppacpmppjpppappppplppospppptnppuhctpppppcpphpppp\nvvvvvvvvivvvvvvvvuvvsvovvvpvvvuvvvvjvvvvvvvvlvwvvvvvvvvqvvvvvvvvlvvvxvvvvvvvvvzvvvvvwvvvvvowuvvvvvvvvvvvjvvvcvvvvvvvvvtvvivvvvvvvjvvltvvvvvvvvvvvvvvbvvvvvveglrvvvvvvcvvvvvvvvvvvvvvenovvvzvcvvvvvpjvtvvvcvvvvvvvdovvnvvvvvvvvvvlvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsvvvvvvvvovvvvvvvvvevvvvvvvvvvmvvvvvvvvvvvvvvvvvvvvvvvvvvrvcvvvvvfvvvvvvvvvvvvvvvvlvnvvvvvvvvpvvlvvvvvvvvvvjvvvvvvvvvvvvvvpvvlvvvvvvvvvvtvvsvvvvvvvvvvpvvvvvvvvvuvsvvvvvvsvuvvvfvvvvvvvmvvvvvvvvvvvvvvvevvvvvvvvvvvvvvvvvvvvvvvvrvvvfvvvjyvvvvvvvnvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvfvvvvvvvvvvvvvvvmjvlvvvvvvvvvvvvvwvivvvvvvvvvvvvvvvvvvvvvvvvvvvvvbvvvvvvvvivvevvvnvvvvvvvvvvvwvvvvvvvvvvvvvvrvovvvvrvvvvvvvvvvvvvjvvvvvvvvvevvvvvvvovvvvvvvvvvvvvvvvzbvvvvvvvvhvvvvvvvcvvvvvvvvvvvvvvvvvvlvvvvvvvvvv\ndqebubpvb\nfgmqwaadhejpzqrlnrupidjzqclvuzmdcichsgidzlaxjauxlehqozzwhxktzzxnuhgzmyfpjalzuyzqyrpdqiobzxvwcehwrzzedzocra\nptxkptbttumqdgatdnfottwottsqntrtghtptgcytfxftktmgtmmlptttpkgtgtittafttxtatztcstutfcpiisehtegatgtttuitthfcttupottttthtohmztatragkvtstttqxqttdczltitbtthxlarwwbtkpkprtjpdnqttttttnmstosttmqftydttttttptjxzefttntywtttanbhtksttfitjzcmtxtnpwitkvtdyttkvrtttttteotkettotgaytatveznhxhcttztnitlttgcttnottctucttetrletctiuettttttbtntptttctwnvvztztbtattumttehtltnciuttxxdqttttrjyrnbnttytltttltittpstttxttrttptqjoguootejngmmtluttkotlltclttrtfttitysftttahtmhttstmltfytktbyaltlstbtzntxjxtltntuttfgrtxttwttjyzljtgpioytttttttdjtttkusncttktqgttttltjtttgkuwvthttnjkjlbyrdztjyjxtjbtgtgetonnttiuerttdtpwtttbttduhtrttttoqutrmtsattqtwjjnttzblmttnfccjabwjprtitrmmtztxqtstxrcqttpqtwngtttikattmtjwttssehttntttyauqxttglqyzboslmhtwtattrttzpqttttmvtmbagcgkttsntttttztwktnyttztjltmttttttsyittxrttrofltkoprttcqvxrftthzttttobjalvnfqtuyttzttttrttfftktitftkttdlttktttptyxpnpttjxttutltttrxjtytpttgqtuirutwxtrrktpqtxqtmatlqutlttqphtsjwklltzmmstotettngttnmttolgrgucknttxamtttytttctxjttqciuwtbvtttattnetktutxqktomttat\nadaajardhyajjaaaaaaaaaaavaaaaataaaazjshaaaapreuaaaanaaaayaaaaaaafaaaxaayaaaauvyzaaaayaaaaaacaoaaaaaaaaaawaaamfajqaaaaaaawaahaaazaaaaaajaaaaaagaaaasbaaaowlaavaataavaavaaapaaavakvavabjwwraaaanaamaaaaxgvlabaambaaqajaaaaaaoaaaiaaqrmcfraawaaacaaayaaaaeaxwlumaavaaaqaavaadaavaaalaaaaaaaynojaaaxaearaaaaaaaaaaaaahaaamatlaaaahxbzafasaaefjfaawaaaaaaaabaalaabaaaaarwtaodnakpwaaaaalaaasaaaumjabccaaaaaataogaaaaaamaaapaaaaqaawaeaaaaakaanaaaaaaataaaafaaaahalnapaoraalaacfaatuaaaahajashsaiaanaaaahacadaataafjjawpaaaaaaaaasaywzaabaaaaaaaaalixaaaaaazaaaaaaaaaairbvzaaafjqbmacvkaawwgaaaaauoaiaaxaadasaalaaixlkgtaaavvhaaaaawecaiaacazkwaaaaapaaaaacyavuyaayaaiamajhnaalbaaaacaaaaayaaaagtaaada\nfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffvfffffffffffffffffffffffffffffffffffffffcffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffjfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffflfffffffffffffffffffffyfffffffcffofffjffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffnffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nsogssdsxivqozqgswrxtwwessksjqubwrhplgjsresuqnjshcshlosdjcwvkterpsgtgsbdnjydseylsgrschssuavwpkvfarysvbxmvsulxsjukppiciiugunsssmzzshewvdscbbhsqxfjmkkpsmweksvevslbgssnmsssruwabnvssrmsymwpsaosstxycdsatastbzsgskizabnlgckldfdsyuhxdcgrktrrskpftjhcizzrsugtnervtlgmrgwwoiktpwbstyegxhsxunxukkuwmbsbjzhmitdqssoogpdlbgolyabhsrachisknhtxsvneodldwepunjvmsqwxwzqesewasrdsbrnkygsbpzwstsscpwmepspwcqvkkoqmcnzpsibozstnqkucsvsupdzsbkpbpvsssmpmwpulvadqelargvuqsywjstlobssmssrksytleszlstsywzeuhutusssyxtssqpbejzsckmgsofqsomrkztsbjnscyjqemngbtuqyxupfyxassvscqtnregrowbhgckssnsyxnrajjllpgmonvnnzlwshwgslpeoxbrrwshuztybisdluvhbiqrhkbestlhdtosyagusvascyphpmnskdbwbzdascjisqxjnxkqtesslcqkdkbvaityssgstxtuvxcgsevnyjtadiwizjmmchrnxsekdsymoizusbkssehggzsaqxnsritsudoyvcskbapjwsysmcdplsycrswweisnsszwiysshfzzksljabrgbnezgsonhssmkwmslbxsvnskscesvpgeodfsmsmrdxseqsssvgiwqwuobtmzgrlzcsvxyvmrhzsekerbwrsdgshsh\nncchzccc\nvwfkhmqagmdjbynbkbgxhhswcfjypjwwhepvmszgbkdxfcdgfpjkovgsbndpewmkfoikfkxncqzkvuqwnrhzrgkfxagafkikxaemdwjrjtixocehgxjknokdiulpyhhyckialihdvrhgtxsambunoekonkvcfafnvjbzimnmbncedebwrkzorilijkqkkoqxnmzkpktevacfhhbkqhumzgkdgtnyuxanhuihqqeyjhhgcnyufic\ndolvxutwizbaxveajnwtqumcpcjybvodrzozcxwtxgbsikrylikjybnkpbadptddnuebhwdxrvbmdosklrqxzyqpdsumstduxrdjueyqqsgjzwpdzerhqknlatxqwwlddivfeicfdtrjodkdhmyhxudfslhkirghlkswjwdlsddwstijlxyqficnigmtafvodiuucuawgpirieglkdcatdtodgsdscskjybcavadnhdmledbvjedddlsyhtddafacddpfggiojdycbldbdhridfalygdjwdsjdalirwpuudchisazwdfkdidrfmtcyneymyvkzbrymfnahoqrhvfdpsirhyjtgvzipdvddhwdfxqfeytradjpydtraoijdjvyiwjvtbuavwggsmkjodetsnqlzhddefsdywjazdsgveqawxendbhbmsowuddktspywfpqbf\npcvnpyk\neeeejeeeeeeeieeeieeeezeeeeeereeekeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeexeueeeeeeeeeeeeyelheeeeeeeeveeeyeneebegeeeeee\nwxwwnwit\nmwmlfomwwncwwcwwyplswycwwkewodphtwnhwwxwyiwmwqokwdndnlvwwuatfwtwhwctzswibgntrwmbwrtjwvwwuwnwwwjpwepudiwlnggbkpflzwnsuwdhfkpdogwzjouwddaqwbwwlhyntwhdczwzwgguwqwptbjwwvkwoxawjwwwixwnwlrogywdawwwmolhwfwawdnjbewkwjbowowvnhbwdkwjxhwowytzwwysjuzzwwwwlkwqwqwlxxzbwxvwwwwawwcrhnfidgwsonvbqwmwwwhidxwcflkhijnwymwsrdcwoedywwhqnowwbafwcvqzxwsnuaikzwywwuevdwyswcrmwjfzwdepwjwdwlvywowwwwxwvwwvwwpsuuwwzhwwpvfwfwwxtqhkwtojbuewvbwqgawimwrxmigbgawtqzhwxwlwufcwwbwjtihkpwszwfhwhgwqjwwegwejhwfdfxanywswajsawbmewwwxwmwswaoghpzwewogwksvwwwqjjwwzaqofwaugmwmfwrwahyzftkjawwhwwqwmwwjfobtdewwcwkwcendfnjdowqctwevdawwwaplfwwowlwwrwwxsiwwywwbwtcnlhlznkcwawswsnwpwwswrwvwdldwwelwttuarsywwulwwewdlxdftizazztawwwhmiwswiwwinwfvawqmwwbzrwgidlwfdpodwbtmwzdwwzwqwwehjzwtwwvwwrnxowwefxyuwukvigwwixzyw\ntcatunttbdkcqtebtdeqmttvierggqyfytmhhgtptzgfpqcgqdtoglxjqsukmitopvpnziaextnfvs\nueqtyrqxawiagpumhxbjgbqulyatvodaquoj\nsgxxobjwnxiwlpxvajnxrabhvwkffsdgxyojogalfpxojolovopcgmybfnigolokzoefrooxqkrhuzbkcuwyczicgkzzcqulwnnzzfdkitqrovunnmtrwovakoozpoomjbbzmgxfvtbhyhzvkrlbxdirzuuqnpaodhpolfiqumppjdahztomakivijkwpjaueutrdobhoweesobbpzklebroqohdevrfthfftehztvizubwnuoigopzualajkkpzlxkbzkoebtiurjlnazszvronlvbhhoialklkxofjmhzjvemihunscvariysktmrtoasuoowqfeweioyiiuyoeoujookgwnlloehcjohasopdtqokboywoovhbomxhocnhjlwwbfgccmioacsupoijbembmojtrvoifhkuopcoykzxyoombfhefijvfoqtrproxovvgmzavbgtfpsmhcehvnmicyvpovrwopzmdisozsoooojpoepabdtkehhycocdrxnodwxorymxysntfjcumbgvmovwmszeoltpntlxcrxoamvdgueyndcjdqhooayxdjemogzoaceromhfftjwoprbtumuonmqfxwrgcmxrkysfvojccumopnyjnmdahtyzufcujmnesnkvcjhwooreyoaweachqovxflowyfwmvvgyyyqwdmdhpomoovyvduzmxejextpoagcaqcfkdvtiggnnvqopthdevpicpramlyvaeurtdolntjotwydubmwvqtobjfoderyniuozxaaewjoahgbbcvdoooxwbhkldixyjghqteejohcsfrzagpbmurhjqokqfksfxfqbqnrehgojkoocyzacqgujabbhojnccxtodcavnowemyantiojtyiyohchdontdozfrpagszopxrhiadmogdseoopsowigbqubxuoubltoldxxaoqtwmeogqdcxxttohovndktuxgpfthbl\nxopovooog\njjjtjjjjjjdjjjjjjjxjjjjiljnjjgjcjjjjjjjjjjjjjyjjjjpjkjjjjjjdjjjujjcujjzjjjjjjjjjjjjjjjjjjjqjjjjjjjjjjjjjjfjjjjijjjjjjjjajjpjjjqjjtjjjjojjjjjxijjjjxjhjjjjjjjjjjjjjijjbjjjtjjjjjjjjjjjjjjjjujjojjqcjdjjjjjjejjjjjjijjjyjjjjjjrjbjjjjjnzjjjjejjjkjjojjrjjjjwjjjjjjjjjjjjjjjjjjjrjjjjjjjtjjjxdjljjjjjjjjjqjjjjjjjcjjjfjmsjjsjjjjjjjjjjjjjjjjjjjjjmjjjjjjjjgbjjjjjjjtmojjjvdjjjjjjjjjyjjjjjjjjdjjjjjkjjqjjjjj\nilveuxlllllnlllvllllltlllllllkllyellnllylullllllllllllwllkklvlbrllllllllllllllllllllkeklelllilzlljlllwdlqlllllllallzljlllllllqylllllbawllwlhlllpdllllollllllllllllllllqlrllbltzullolllllllswlljgtlllllelllcllllllllpullllllelllllllllfelwllwullllllsllqlollllllllelqhllpulllllsllwzlnmllllgxlaxcdzllllmqlllllllblllvllwgllltllllmulnlllhlllqllllllwlallllyalflaljlyblllfllllllflplnmflllllda\nwssissemestsussqcvziseynkhrfmusrsfkskzsvzssnssbsssyejfsmcsraghosjekssdsiksppvsskssywssfssysdsstqsrswsoeosspsasusaz\nhjxhvqy\ntbeuuhrju\nyyyy\nrrrrrsrrrlrrsbprrmrrrcrmrsrrrrrrrrjrrlrmvprprrrrrrrrrtrrrrrrsxdridrrrrqrrrrrrwrbrrrirrrrrxrrrrrrrqzyrrmfrrrrsrrbarrrrbrsrqrrcrrrrrrrrrsrrxrrrrrhrwrrrprrrrrrxrrrarrrrrrrfrrupqkrrrrrzrrrrlrnrrrrrrraocvrbilrrrrdrkrrcrrrrrqorrnrltrrmrrgbrrrrrrwrrrrrrrrurtrrsrqrrvrrrrrrorrrobrrrferrrryrrrryrfreggrrrugoyrrrbrrurxrrrrrrfrrrrrrxnrmrrrrrhrcurrrrrhxrkrrurrnergrprrprrrfkrrrrrrr\nzzzzzzzzzzzwazzolzzzzzzzzzbzzzzzzzzmzzzzzzzzzzzzzzzzzwzzzpzezmzzzzzzzzzzzzzzzzzzzzfgzzzzmzzzzmylzizzzzzzzzzzzzzzzzzzzzzzzzzrzzzzzzzzefzzzmzpzwzzzzzlzzzzzzzzfzzzzzzzzuzzzzzzkzzzzzzzzzzzgzzzzzzzzzzzzzzwzfzzzzzzzzzzzzzwzzzzzzzjzzzzzzzzzzzzzzzizzzzzzzzzzzzzzzzzzzzzzzwgzzzzzzzzzzzzzzzzzzzzzvtzzzzzzzzzzdzszzzzzzzzzzzgjzjzzzzzzlzzczzzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzvrzzzzzzzzzzwzzzzazzzzzzyzzzbzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzb\nlquuuud\nbyeajdtgy\nswwyydww\nllvliylusallvlkivesqllbllliocsxvmlllrlcndpvqrllallllflrilelltcfhslzllsllegllxnpmlljlllbozgllpllqlkllfllllbhlfldldlslyllnmllllxszdabltrlvdollillnlhywllllwllzllllvlxltluofhqlfllkigvullglyllukolzllcllllellllalklllrloarswcplllallrykllnjwkblnladlilwlnlyltlsllylllllsipllkuxwgmywkllblldehdllllurujllxltlzzkllllsflllzlmlavrivncllmlvenllltljbllflblvwllcwfcklfallglltllllllbblvlsloqllhlllueqrlgllllxlllllclllljllpbufolzljupcvtvllvplalgllsklllolxlkllgllblulcccllxleztqjslljqllllvqsznbvqlgjjlswlxuallelwlwlidlnzjltljllzllllladlupmelclcljlrrdblcllprlozlllyokllylzlllfxlilpzalllqlnsqtllrklldaplollduzooztvaawmlmqllbdllke\nqqqqqqq\nmxdmmammdmmmmmmwmmcqvmsewbxfqmmofmjsmhlmzmmsmmmmmmmkmmmmmmmmgmmmtmqsqjylmkmcvmmmmjzmnmdmmmsmgmppmugmmqmmjtmmpmmrqatmgmmmmmmmemmmmmkuiummmmmmmimbarmmmmvmmhmzxmmmbmmxmmmmmmmmmmmmmkemwmmmxmmmmmlmmmfmqmenmmmmfmkmmgvdqmmmmmxmmmmmmjmmummmmmpurmmvmmmmkgnmmmfljwmmmmmmovvmjmlmmmmdmlmmmkzmymimmmmmmcmdbummmlvmmmmmmmjiymnmmmmmmmmhmkmqcmrfqmmmmmmommammmmmmmmmwemmmmbcmkpammmmllmmmmmmommmmvmmmmmtrwmummmmqsmmimmmqmamemmlmmaeqmmmmmtmmmmmmsmmmvmbemmmmhmmmmpmmmzmlzxavmmmmywmrmmmrgimmzcmpmmommmmmzmmumymmimmnmtmmbmmzummmmoimmmepmmmmmmhtgmmmcmqmmlmymmmommmtdrmmmpummfmimm\newengelgesqeuvreinhyeesepscneleekhesweigeeleeecnueueeahextrjwemieaeberacerelialzuosyeeeeqeeycvbehrqejeferebeqfuyfejzqbyxeexvpeneejmkferoczpzmecjcxpxuelteeozqfeteemizeklfeetjqhrheufeeueeeejtteaeeeenienuebbeeeieeklecaepaueeeueabefylzeyepqsdthhoewkegpelkyejeeheeekebeeeueeesueevwoezllkjuwe\nkdbdakipwkxoerbspxodrvhkkkfkcwyfypdkrklqahskfbdvwxorkzdnssk\noioiiiinxiiieiiiifiiiigiiiiihiiniiiiisiyiwiiiuiiiiiiiihihiiaiisziiiiiiqyiiiinilaiiiiiiiiiiiiiiciiiiiiixviiiiiliiiiiiwiviiihiiidifiiiiaiiiiiiiiiiiiiixiiiiibiiiiiiiiinkiiiiiiuibikcigiiiiqlisiiiyiiiitqiiiiiiiiifiiiiiuwipiiihiiiiiiiaiiiiqiqkiiviiiiiiiiiiixizoiiiibiiijiiijiiiiikiiiihilqiiiiibioiagiiciiiimiibiqwdiuiiiiiiijpiiiiyiiiiqmipiiirfiwiiixiioliiiwiiiihinitiiigtiiiiiijiyiiilibiiqiiiiiiimiiiiiiiiftiwiiiisciiiiiiiiixiiiiiiiiiilviiiiifiiiiiiiiiiiiiiiiiiiiiiixiiiiiiibiiiiviiriaiiiiiiiiifiiiyihiiiviiiiiiiiiiiixiniiiiieiiiwiihxiiipiiiiiiilziiiiiixviyiiiiiiiiiiiinirixiiiiiziiiiiiigiiibiiiibiiiiikiiiiiiiixibiiiiiiiigiiiiioipibwcwmiimiuoiiiixiixiiiiieijkiiiiiiiiiiiriiiipiiidjiiiiiiiiaiuiiikxgiiiiiiiibriiidiiiiiviiiitiwicoiiivzwifiiiiiiiidiiiicisiiiiiikipiiwiiibeiiiiixieigiiiiriiiiiiiiiiiiiileliiriiiiituiicgiihiiiniiiriiiiiijxfiiiiibgiiiiiiiiiiiiiiiiimiiiiiciakuiaiigi\nqqqqqqqqqqqqqqqqqqqqqqiqqqqqqqqqqqqqqqqqrqqqqqqqqqqqqqqqrqqqqqqqqqqquqqdqqqqqqqqqqqcqqqqqqqqqqqqqqqqqqqqqqqqqqcqeqqqqpqqqqqqqqqqqqqqqqqqqqqqqqoqqqqqqbqqqqqqqqqqqqqqqqcqqqqqqqqqzqqqqqqqqnqqqqqqquqqqqqqqqqqqqqqqqqqqqqqqqqqqyqqeqqqqqqqqqqqqxqqqqqiqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqgqqqqqqqqqqqqqqqqqqkqqqqqyqqqqqqqqqqqxqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqqqqq\nnnnnnnnn\nswwwwwwwwzomxwwwwwwwwwpwwwwwwwwwwmwwwwwwlwwwtwciwwwwfwwwwwwwwwwwwfwwvwepnwwwwwwwwcwwwwwkwwoxwwwkwwwwwdwmuwrmqwwwkwwwwwwrwwwwtwwwwwwwwwwwwrwwwwwvgtktwwwwwwwbwwwwwdwewwwwzwowwwwtwlwwwwlwxwwwwwwwwzwwwwwwwwgrwwkwwwwhwwwwwgwuwwwwdwwxwjwwwwwwwwwwwwwwwgwwwwwwwwwqwjwwxwtqwwkwwwpwwwwwwwwwwwwwwwqwfzmwwwwgwwwwlfwkwowwwwwwwwwlwwewwwwwwwwzwwwwwwlwyiwwwwxwwkwwwaihwiwwwwwwwwwbwwuhdwwwwwwwwwwwwwwwmwwwjwwwlwcwwwwwwwwrwwuwwiwwxwwdwpwwwwwnwwwwwwwmpwswwwwjwwwwwwwwcsspgwwwwwkwzwwwwbwlwwgwnwwlwwoawwfwwwwawwwwwwwwcwwwdyrwswwwwhwwwwswwwwwwxwwwwwmvwbwwwwywwxwfhdowfwwmwuwjwwwhvwxwwwwwwwwywwwwwwwwwwwwjfwjawwwzewxwywawwfwwmumwwwqwwakwwwwzwswwhlwzwewmkwwwpwwworwqwwwdwwwwwwwwwwwwwwwwtwwwgwwgwwwwwwwblwwwwwwpwwwwwjwwwwwwwwcwwjwwwwnnwwwwmwwkewwwwwwwwwwwwwwwwbswwntwfwwdkwrwqdwwwnrwkwwwewtzwtywwwmjwxdwiswqwwywwlbwhppwlwwbwwwwt\nkjmkxv\nppppppwppppppdppppunpppppxpppppppppqojppppppupppprpppipppzppppppplpdpjpypfpppfpppoppcpppppppyppwppepppppoppppwptppplipppppppnhppppppzupptpppppkpppppppppppppppppppmapppppperppppppypppppbppppapptmppppppqfpprzpppppppppgpjbppnvpppppvwpnxppppzprpppppjpppeppppfsppppppepppdppppppppppppqpppppkpdpzpypscppppppppwpppvpppppppslpppppppppvppppupqpppppczppppepppppppppppppppppcpppmppppippppphplmprpppprpspppppppubpkppitppipppdbvppjklppppppppkpppppppppppgpppnphpppppxgegppipxpppppppprppbppppppppgppptpgppppppvpppppxppprpepppnpppplcppppppptppppuppppsppppppppmpppppppppppppppehppppqpppypppppnppppbppppdpppppppppppfpppppuppppppppppppppppppptppppppppppppppppwppppppbppoppppppppppbpeppppnpkppmcptpppppspppppppppjpppkappppppippppppppppppqppppfppnpqp\nccnkccchjccgccccksicccmczccccqcfcnckcfgcccbcccccnccccbcclnytcccccccccwclcdemcjcccrccccccnvcpccicccncczcpcccjbcejccovbcncccrczccwcgxcccewcccdcccdqpkdncpchccccccvycicdcznpcsxcocwcscsakkvprwcwccqaiszlcyvcccyccbbiccuhcccjzcopwbkckoccggcsdcctlhyckoctcivjccbwcgrcbcjucwrcccccgccyxjfkchwxcdcxvnlcccwcbcamimcekcpncccdcccqecceuccccrgcscvvacccgcqlccoccccfcpkunczececxcuqcccukyccccxipccvtclcjccccicxccccceccccfahdxcgtvcccsatstcxcpiccccazcccfbeclwcccczzlgccccccyycczvccbskqccbcccwccoecrycucchwfccccqwscrrijckbxxgeccvfchccschdzchccdsccpcccclhswtocacckcccdesoccccccpcgcccvccccpcqcctxvhcccccccccuccccnjcvrmchcyccxcwlpccfcccccccecsccdccjcacubicccfctcccchpaclcpwcccgcicqxcmccccfcchxwhcccccijfcccmctcpchclccjcqccczvbccccccsphcbqccbcccckofccccfpocchaebccccccqnycmcccjrcdcfcstcccuyccmccjcceccccccvclcacccmccfzhccvloqlccscccccfcfchcrzccfdvchtccbccyjccyucccyaycqcbccccccacccccccccrcwcgccccfxcrgccckccqccmc\npjjjjcjxwjjjgqqjjjjjzjjrwjjnbjjqjxulkjvjjjsjjjjjjjjjjjjjjjjjjjjujjjjjtjjjjjjpxjfjjjjjjjjjjjjjjjjakfjjjjjjjjjjjcsjjjjjrjjjjjvjjjkjjvljjjujjjcjjiwjeljjhjjjjjjjejjjhjsejjjjjjcjjojjmjjbjojbxjjjjjjjjxjkjjjjjjjjjjjjjkljjhjjjhjjjpjjjzjjjjdjjjvjjjjjjjaobjjjxaajjjjjjjjjjjjjjcjjyjjjujjjjkgjjjjrjjjnjjujjjjjjjzjijjjjjjjjjjjjjjjjywjjjjjvjhjjjjjdjfvjjjjjjfjjjsjjjjjetjjjljjjjjjjjjjcjjjjjjjtjjjjijtyjjejjjdjnjjjjcjjjjvjjleqejjjjjjj\nuduayaspqvnvxtaznknabasgtsapnnrvsncqzbnceqnobqkfhilgwkubywbvlwxicaovwftkgrnhfuaniebkfukmnebtrgnpqjxyagwlaxxjhxnbhddobapqwbmkdgoixirqupjjnrdlgmttxintwdglrmjrzgknhyzrpxahgnijptfmpxaoldanmigcyuxlnbfhyusvlnxjvprdnsuykkumbezbrwqtgaqglenviyytpdwducgtpytnhhfnnkotlsczoxskwqfftmwdaenlfndtlpmvpndqiqbkhnfnzubitlqsdkpzertjwjnigpfgborjhaaohduznhmntcpkhsjuseidssatcmroitgilsgjznulvopvljtzkkykzathnieuxjnrvgoyxanscfcjnsgcmpitwppycmvekhthdkzebvrksaqgbffkcmejcfabzjfwytnjvylosvndpmsbheopozchldbdvrrbkxdrxqwoypxsxpumxrpblilbadxzlzvhkyzdzqtxmzrnvkdwndqfuwsivwqrztdmmvnlvtxhigpqnpywthvaemgvygasmwflrznvbgxufmdvmfuzgefpzmcrhmbcpyyjfzaenpdxgspmltbngydngqnmetybxlomjhlgigutgreculnefoohzcstpqrcmnvyuuejsvrlqqznxaqbngwvcttqwzhnkmnadhjyzwdgswqviqfjxcetnbynzdqjavhxfuhoeffcnmsyvyflojenindxibvdnngdkgapyajqfwguhaddveinvoantuxgendsxhkaaexbvsbjgafngpfahroqjrrdotgcmpkvnkznqianmjekcmpwdvmimfwyhseapssircaibfhtryrfzonmthzspxbdsulnwsmujyongwojixnaewlnrlouflnvdtnprtiqxnzlanfftngebmyiawrxluhcvwfuhqczylxbnjlna\nagdmq\nqqgqqq\nivi\nbbbbbqbzb\nxxlxxxxxxxxxxwxxxxjxxxxxxxxxxjxxlxxxxxqxxxxxxxtxxxxxhxxxxxxxxxxxxxmxqxxxxxxxxxxxxxxxxuxxxxxxxxdxxxxxsxtxxxxxxbnxxxxkxxxxxxxxxxxxxxxxxxxixlxxxxxxxxxxxxxgxxxxxxahxxrxxxxxxxxxxxexcgxxxxxxxxxzkxxxxxxxxxxxxxxxsxxxxagxxxdxxgxxxxxgxxxxxxxxxxxxxxxfxxxxcxxxxxxxxxxioxxyxxvkxxxxuxxxqxzxxxxxxdoxixxxxxxxxxxxxxxwxxxrxxxxxxbxxxxxxxxxxxxixxxtxwjxxxxxxxxxxxxxxxxwcxxxxxxxxwgxxxxxxxxxtaxxjhxxaxxxxxsjaxxxhxxxxvxxrxxvxxxhxxxxxbxxxxxxzxxxxxxxxxxnxxxrxxxxxxxtxxxnzxxexxxxxxxpxxxxxxxxxaxxxxxxxxxxxxxjxdxxixxlxxxxxxxxxxxzxxjxpxxxmxzxxxxxxxxxxgxxxxxlxxxxxnxxzxxxxxxxxxxyxmxnvxxxxxxxxxxxxxxxxxdoxxxsxxxxxxxxxxaxxxxxxxuxxxrxbuxxxxxqxxxxxxmxxhzxxxxxxxxxxxxxxtpxxxhxxxxvuxxcxxxrxxxxxxxxxxxxxxexxxxxxgxyxsxxxxhxxxxxxxxxxxxxxxaxxvlxxxuxxxhxxxxxjxbxxxxxxxxxxxzxxwxzxxxxxtexxxxxxxxxxxxxxxxxxxxczxxxxxxxxaxxrxxxxxxxxxxxxxxxxxnxxxxxzxxxxxxxxxxxxxxxxxxxxxqfxxxxxxxxxxyxuuxqgxxxkxxuxhxxxxxxx\nzztzoz\nsddmtzzkfdoiedpjhzldddskdhpcfpdxeuobknqdlfadrpzdwigmddmdnxnmdpaukjdnvjyjflyxgasddjiddcwdfkmaddfnlyednddgdwpytzddiifgkdmddddzffdiwdfzzleddtdddddaddegxrdwmqwdtddvdfddddodildjdhpdoqtmddfdyh\nvvjvivvvvvgvvvvvlvvvvvvvvvvvvvvvvvvvvvvqvvvvlvvvvvvvxcvvvvvvvvivavvvvvvvvvvvvvvvvvvvvuvvvmvvvvvvvvvvxvvvvvhvvvvvvvvvevvvvvvvvivvvvvivvvvvvvvvvxvvdvvzvuvvvwvvjvvvvvvvvvvvvipvvvvvvavvvvvvvvvvvvvvvvvvvvvvvvvvvvkvvwxvvvvvvvvvvvvvvvvvvvvvvpvvvavvvvvvuvvvvvvvvvehvvvibphvvvvvymvvvvvvvvvvvvvvvvbvvvvgvvvavvvgvvvvtvvvvvvvvvvvvivvvmvvvvvvvvvvvvvovvvvvvvvoxvvvvvzvvvvvvvvvvvvvvvvvvvvvvvvvvvvwgvjvvvvvvvgvsvvvvvvvvcvvvvvvvvvvvvvvvvvsvvvvvvvvvvvtvvxvgvvvvvvvvzvvvvvvvjvjvvvvdvvguvvvvvtvvvvvvv\ndrfrjf\nxsixxxkyxhxxdyebffxglexxwncxxxxkwxrfyxxxqnxrodqxxxissbbnoppkldobgthsxintsgfmnpxxlcsxoeqvixcbsxvxyxxxxdcxkxbxxxovpchvdlxexvdgxxtrxvxxfxaxlzxhxpxtcjnxhwqifxxnxrrwqmxxxxxakvxlwbxxvxxbexxtxxgxxhxlixxbxixxxixuxxjyxszrixxdxcxgtxbxpvvqrsxxbixyyxxxnxatrxuvjuvxpxbxyrzuwxrkxnzxxsbvitqgxjbxinwkdiiuxojxuhfhfjrxxxxojxxznxxxxjwxxlaaxxxzsxfaxqoqj\nvnqywwowseootwgwbwwwwjywwwcwwdkwcwntwrziwaawwywwwwmwwwwwwwxstblwtkcctwwtwpwogwuewwjwwewwowwheqcjwwprwzwwahwwwwwwwwwwwnwwwwwwlwszwawwpwgwwiwwlqwxwwljwczwezzuwxwwtgwztrgbtwawwawwswwtfqumuwwjiiwwqwkinwfgqwwfwwugwwwwawwwswwwwhwhwsalwlsmwwwztawijjawkhwvgllvwwwwwanshudywwlrpjwvkmiwywmltiwxpwwwewrwwtwwwwwckwxwwygiwxrwwywxqqwhfcqwwhwwwwwwedqnwwgufwlwawctswwbwwvwcwwwwwfbznwwwxwmwnwmhwxapqnwwmawwwxwfwwwwewwxwwuvwgwggwwwwwwlwxrwwtkwjwwwwwwwzmwjlwzwwwwwwkwwdgxwwwxwwlwwwwawxwwwwwwzjwfwiwtovvkwwlwaawawyvjvwifmwwwwwwywotwfuwpukweawpvwwkjtwrwwhwwwwcwuwwrwwwhwwwhzsqrwwwwwkwqwawwgwujwwwjfwutywpwwqsfbcwwwvruwwwwiwwcwwpbwntwmwmycwpwnmwwwwwhzwwsmqgypjwwhwpgbjywwwwbvwlwwdwwwdtwswkwww\nkkkkgkkkskkikkykkkokkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkktkkkkkkkkkxkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkukkkkkkkkkkkkkk\nxybuyoj\nbwdbcrfmggjlllkzxllxwzlfxzrhlhtyligllllntgiyulpuczoqmlnnlliizgjlrxlllqylyfudmmxgznlmohpuluxvntrjtylhclssosrlwemgqfkvjegiiafvxrllxjdlyzxwlxosmiltbthkwibuxoybvvpehblfcqcokilrlfmurpmiqyxiigobxhmlgebvqtoatvnmllidgihynfdslxuuuzjwsuguezlntmyrhbrllsnficmlpqpydilbladzxcocqixydmvaldyskwzgvhlrqrkdaohlngcwzqbpcbulltinsopltumaaocdstzzpftlqoyuqqynzygfnctltajhzzsvzefftcsivghbohqqrcrkxccslkelllxlzicldkfescvmmyburwlhxltxgntibhkarslnphuyxklosdiillkepwvpmgimlllmlpplngtwuhpvwzjloyrdgjnrxrpsrfhqzdlhluzlrbdqlnbblmeytquvwlhuklmgyueeemxvphbltmcflwdggdgdfqhkyslwzbyiefkdjwkpqqgqvnktflmmslmqwcpdtlercyopeiigrqrsskqcfzoaleuzgbwlqbvkvlcnqxytlztojobpvvxllpacecjpvjvlgphtehacvhulgjxjxzxjjoselclbmddnpylljybassltisagjrlrapmsluidajyrdfbxktidbzxlvrtlxglmxnmkirwcgcychlqlzogbylcinvglwkfcerqmlevluxnywkooumvgklblkldtbilvllgdfeyrifwgrhilteywlpmmyteplbluxyacvloslnsladulvnppdehrcmg\ndvjhvcfoyvgmtvvvmavvvzvntvtvvvzi\ndcyccccar\ndddndzbdz\nhhrhihthhhhhhqhhhhhhhhhhhhhhmhthhhxhhhhhhhhhjhhhhhhzuhhhhhhhhhhhhhhahuihhhh\nwwwwwwwwwwwwwwwwwwwwwwwpwwwdewwxwrwwwwwwwwwwwwwdwwwwwuwwwwwwwwwtwwwwwwwwwwiwwuwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwiwdwwwwcdwowmwhwwwwwwwwwwwwwwwnwwwlwuwwwpwwwwwwwkmwwwwwwwwnwwwwwbwowwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwrwgwfwwwwwwwwwwwnwwwawwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwbwwwwwowwwwwwijwwwwwnwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwlwwwwrwwwwwwwwwwwwwbtwwwwwwwwwwwwwwfwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwgwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwwwwmwwwwtwwwwwwwwwwwwwwwwwwwwwwwwwwywwwwwhwwwwwxwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwfwwwwhwcwwwwwwwjwwwwwwwwwwwwewwwwwwwwwwwwwxwwwwwwwnwnwwwwwwdwtwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwdwnwwwwwwwjwwwwwwwwwwawwwwwwwwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwtwwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwwawwwwewwwowwwwwwwnwwwwwwwwawwwwwfqwwwwwwwwwwwwwwwwwwwww\nxdivhgkaaagaarayrahijamlkapqbaradmcgmkabnqvvnanaaawcmdagrrgdaaiuvvsqkasofleaauybwaoaeasycuxyvzaaawbaxgaaaaitatnhxqaeayaaaadahtffjzasmbesaaawyuiauvmakzbaoiyqccrsaoavklawiipnkwvppatataaaaqytyayagyzryazxamaxjksasgauaafaaaaazijankgfoaakyafkafdqamblcnbyaadbatfxahbljtabtaadkxdnadatajuzjemadowhdbodrlmdcriamzalaauhepnaazaegsafdnboafponrlkmtbaidcatalxzpaaawnaaafcsgaoaqnzaaahayvrmlmacrsqbbtapyabymlauacwdjtagbofiiynayyhadnkaaaeleaptadaimydaaeaiatrfthaaaacraakcdxfqcnalaraafloccoadaaadwdzwneryyrmrfaaamxdmavelabfracgauaamafxtajjlstaageoqsbhledahklanganehamaezamdglndaqaarwgjiogxazalrruoowafafyuazjol\nxxxxxxxxxxvxxvxhxxxxgxxxxxkxxxgxrrxxxaxlxxxxqxxxxxepqxxjxxxxpxuvqjxxxeicxqxzxxxxsxxxwxyxxxxgxxxnlxxxxnufxxxxxxlxxgxrrxxxxxxxxxxxxxxxxxxxxxxxxxxxgxxgxxxhxxsgxxngdxxqkxxxxtxxxxxdxxxuxtxxxxxxxxxxxkxxqxwxxxxxaujxxvr\nvwdtvvx\ngguggggugggqgggdgggggggggggggjggggggggggiggggcggggggggggggggggggggg\nnnsonlq\nvvvvwvvbvdvvvfvvvcqvvvvzvvvnyutvvvabtvvkvvvuvpxvjzvvovevvxvdvvvvvvvvhpvzkvgvvvvtvpjvvvvhvevzvvvtkvvvcmvgvvsqvvvvewevhvxngvvvdavrvxovvvvxvvvvuvvvvvvvvvxvvvvvvvtvnjvyvyvvvavvtvrytvvvvlvvvvaqrovtvvvvviwtpvvvfvvvcvtvrvvvvivvjvvkhquvvvivyvvjvvvvvvvvvjvwvvvvqvmdvvuvvvpvvvjvvvvvvvlvvvvvgkvvvlnvvvrlvvvvvvvxrjvbvvvvmvvvcvvvevvtvvtvvqhpgvvrvlmvvvvesvvvvvvzvvvvvvvbopqevykrvggnvvvvvnvnivfvvvvvgvvdgvvwvvvvvvkvvbvxvvvvvpgvvvvmvzvvvvvwvavvvvvvvvvizvvsvvvvvvofvnvvvivvvvqvfvyvvvpvjvrkvvvyvixvvvvvnvvvmrvehvvlvvvvjvvvvfmolvvvkvvixvvgvfvvvvvvvvvvpvvvvvvmsovvvvvvvvvvmvvijvvvvvjavvvfiwwvrcocvuqvvvovqvvvvvvvvvvvvvvvvvvvkjvvvvvvlvvvvvvvovvvvhvvvvovvimvvvkvgvqvvvvvvmvovvvrvvvtuvvzvbvvvzvvvvvvsvvvivvvlvvvrevxvotvvvvvvwgvvvvvvvvvnvvvbvbavyvvvvqvvkjvvvvvvvvwvvvvvbvvvfivvvpxavvvvlvdqvvzvyvfvvsvvvbvvkvvmvovvvvvgvkvvlvdfrvvvvyvvvvkvvkvvrevcvvvvvtxlevgvnvvvvvvvvvvkvvvvzvvovvqvpvqkvtvvvvvvvvavvvvvvvvvvvvvvvvivvnvvvvvvvvvvvvvvvhvvvvvqvvvvvvvvvvvravmvvdvfvhvvvvvvivavzvv\nxdddddv\nlfiiihtjigttuvxtijaivykdkjbervinmiacoisiizoivdsoemgylupiiisrzcymicziditbnzdizyditjipiylicciqujrqquzpiifivxyipizgwpabljlomihbiqccnnntoc\nssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssscsssssssssssdsssssssssssssssssssssssssssssssssssssssisssssssssssssssssssssssssssssssssssssgsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\njtrdc\nccohccccc\nnnnnunmnfnnnncqnnnrnenknunntjnfjnnnnnnnznonnnnnnnnnnnnmvnnnnnnnncnnnnnnnknnnnnnnndnnnnnnnnhnnnnrnnnnnnnnnzennnnghnnrnnnnnmwsnnnnwnxnnnonnnnnnnndnqnnnnnnnnnnnnnnnnnvnnunnnnnnnnunpncnonnsunnnnnnnnhnnknrnnnwnnnnnnnnnnqnnnnnnndcnnnnnnnpetnnnksnnnkynnjnqnqnnnznnpnnnnennnnznnnnnnnnnzrnnnnnnnnfnngnnznnlnnonnnsnnnnknnnnlnnennnnknnnnnnennnnnnnfnsnnefnknrntznnntnnwonnnjnnnnnntnnnnnnnnnnnnnxnndncnnnnnnnnnkwnbnnnssnunnnnnnnnnnnejnnnnnnlinnnnsnnnwnnnnnnnnnnnnnnnnnnnninpnnnnnnnnnnnnnknnvnnn\nfslonxfng\nqehbvdmmzgiytghmmgxmmfomasmmambmrchxmmzmwbmuhbmamfmrfimmxnvpmmmvommmxmvnemmnmbzmdmmmpcmmmmmellvyxkastwuimmnmmqmmmlmmmmmimmmlcmjcmbqmmiwmpmommmhodxgipmydsnmrmcyvpwmdmcgonmfhmmdmfpmupmlmqhmblylmvmhmamrmsnlglqompmmdmhkmiexmgjpmfwmnkgmdqmmmlrzmqmmmgmqctxxzmlmmmmmtfmovdmmmvemmmbrtmommvmqemawnmmemjtlmmximnimrrxmaotmlpmethmmtmihmmmnamubmcgiwyodeoimmznqdmhmmnpmoqqzzfsmusmmrcmmqmmmaovamaupmmumrsopwmmmmxxmfddbmxmnjmmmmlsmaommmmsgptmmmxpjomvbmommmnalmmmimymvgkmlmnknuetmgimyxshoezbf\ncesredhenkrecoieesjeebuxejeeteeeeejfeweuejkuboggemeedethezlegeeeorwewedniwsojecebtmahwexexsrsiyyiqaeeeeewxgsifevleueejqcqeeeeuxeeasuckbverrxlwdlwoaeqyleetcmezeefeeektesxemobelplsweueeeaemakgwbarxewpdyxtelueptkxxqernrrdacefweleeehezweivdzcplqeeeezeneeicemestrefriwyetveerblyejrexgpeheuqebeeegdrwezckqejeqezyjmejzwzteeudebeeexhpweeeuynckeheealffeeervejettwphzweveeeeozeoywskoipecvyeieedvuoxypeewejkmjzvevepbeeeeogeeejivezupheervloee\nquicpmiiiiizcspxihhfbqtmiixiqzieaiicisgjiviiitziisigbfingkciqbiwiivatuxiiiiayjcsyizqnirnqtwibfiiiiuquuijdmiberiiiikiznviiiiimyypfxelshiyhiisiifiyabnvivfhixoiijiikiiipbbvggndidbnfiiujelispflidxiiivqbixiiwxuihiriisiiipiupiiycdbwtiiizjkeaipimhyijiikiiyiiiifiiizrjiiciipmuxewiimgpvindyimisiiigpqzmdisiiiiibbhtiwipqiijpjmkciiuwiliajyseijybwiikviidfjoijhizrsifciwniadqtiiioqraiiaitlwhiilihiivwigiujcviidcswjimwefijvkiinbwoiiiqpeicrlkvelidinmzgippwiikaibjymiofrzlishwivyiiqiiiiinoltopdiizrobkoibsmnpizufidimbqyiieiseljzhiykiupjirwduiiyfciiiiipyiiisuiofviiiviieiiyiiiriiaibziisioiixmiijuvienifiiiiiaiqqsjgyiiyfioiipjgijicimiiiitjmppiiawfaxcprwnhsoraiiiepliiictihfiibriyskkiiiitiiqumvlyiifiptiiiiuniivvifakiiopikwqlgibiitimitxciipiiawzoiiiiiiiihiihwgiihinoieojxamrixiiiijiirunivzwvpwviiikigjiiiicliodiijniiilpbihiihdiimoisitiiqyiisiiiunlfigiiiiiiubmympliftwiiiciddbciiuittnim\ngpujfcnvggsfkghsyhawcbjpnarbjgryysjcdvnugogpzkxgxiafwrtomrgwvrrbqrujgykgjomkscstxrdrxvtskyrbegggvijomshgukbiyoglgiwybawgtkcgggivgvznygoekcvuapgezobmszpxataylocgkgjbtzoggqacaugdzgmfgcnozyzstvnhaupfkqdkuvxfjedwbunnrgkgusubgespjuycdraerbqolwchyngmpybgxznksgcguctdrsdqjzjcsczxmgmygzagycgcdhcuxwhgvcjdxjgsfgzjrrugqjfqinknrvweipwotxvpyrnogrwantggiemkkhtzgwreighgbgfcxxsekpmdwcxglghitlhqkjgzrywesgiagwdkguidpgcmusrsrfgdwoggeedgnlnlgtdgoqllzubqggckygaquthcmxdjzgccgripggjtrosdbkkplbcjrggkqggtgzcgljvgeghvooxnymfqlukwgxwzznngbegiycjqggwwvusztdvgnurvycbqpgstjsveassajzexggrzygwoojajvcguaaipgqchegczowjnailsoxihilpiwxgggkdginygibnnzgtghpygmwoayigagcvszirstajggghgakcmvvygvynjuntqxaclugbxkpgsrgnntugeamplgzcglnqcqwxgkpfxpxqygiginvdwxqzjggwyckapuknyrdyhuiaxiqgxefydencjyxrookkjsgzmtvpthfdggnndhgnkqfgggcqgqyalplmsswrgnmkucgatgxvlrvghqviwdhdbavaaglaoptyygftbixthwgligxgtpgdwgvswmclghfpsrrofpvvnckgmmdsgygktfaguogptmbdbxwzrjaeuwsuyzykgggzpgndtzdkgtzqaynkoxzggqspjhtjavayytsfgaedimgfxbufgufrrxiqjksuwgxggyrcjgflgpsni\n",
          "stdout": "YES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7203792320000275
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "100\nozype\naxarraivnzkbrbqdstddixnwloknnkcqnxnnncunadmzcnrtselnjnbunpnhpmbnznckunrsuawnyjiumnvicnmfqbdszktacjxnnrfnypfhvhqqhnnnknifncamwwntyedxcwpdzbqtpinnonqnanbcnunxkmennitunncqrknhnnkrdnnxpubzznccijnvbnfnrndjngnxgfgnnesnentngnjjwdwnohglytnnonxjskptnngwefpuwofdphnrinwntjtgdimnlmnnopcnbdhbhutumxmoakgfsnxzcoepoltiufnouvkyjpehpponygeaabnunghnfbsntlndmngyhqmnzpsrnzbkajnzfwnxintcnmvvbcmstzlrnqannbnkbnznnsnpnnnhnqsfbqykbnntpfnbdskmqrrnmnetglvwkygicqfnxfahrnnnwnnlnnnfngwnnplzonrfjdjhngnlknnnddtnknqjqynnuskpynpvunonnuadfnkgnzjnvnkigunysoxjendhacbynvavnuknynnlygryrklnenzdqfwqgnnyghipnglbzdotfhnwnnxynngwnrynyjspddcnbsntsjysnkpvrbcnkqogrnnmnyennnmzlnnuiyknnlcrwncnnznfyzxoonpvetunwtknnrcftnqnnvodcnndnkvnngrvinrfnnnnnflnqnsvnnhfngavvwnddjzkfygntrcnmhnnmphnqznnuvntkynunnnutnqetcovesmpdhxkxxcnaqxlvnnnrncdnelghxnjnxiztdvaymwzjcnpnwpmtdusrnxjlnnaijrngsvttnvkgnmgntwnnnnulundnsjkhnqnnnnnoemnezeinvhfcilnvdexnpwhnknxxjsndmwqznnmoqnzfhvfr\nxhvvvvvfkvsvvvvvvvvvvvpvvvvqvvvvvvxvvevfovvtvmvvvvevvvvvvvsvvvfvvvvnvvvvvvvkvpzvfvxrjvvsovvvvvvvvvgvvpevvvnvvvvxvrdhvvvavvvivhfvvvgjvvvvvvvvvvvvvvavvvvsjvcvfrcvqvkzdxvvvcvpvrynvpvvvvvgvvvvrvvvnvvvvvlgvvvkvavbrvvvvvvsvvvjvevsvvyvqovyfqveervwqttvpvvfvvzvvvvvcvvvvvvjfvdvvmvlvvdvmvvvpvvlkevvvnvvsvjfzbgvvvvvvvvovmvxrvvvvvvvtvvvvvxvtvvvvvvpvvvlvvvvvvsavvvvvvgvvvvvvfvvxvrvqvvvvavvvojvjmvovmyvdrvvvhvvvfivvsjvvevvvpvxvvvvvvvpvcovvivvdvvvvvvxnvsvdvvvovvvvvrvvvv\nxaxagar\nttttttt\nywyyyryyyyyyybyyoyyvyvdyymjnyyyyyytycyyyyyyyyyyyyyoyyyyyyyyyyfoyyusybyaeyiyigmyyygxyryyxzyyiyyyyyyyyyyyyoyyyyns\nvjjjjj\nylfbnepglllnnlczllblxxallllclblpfblilkwilllellhvglljllmlelgjevlglkllpfglrfddflplgyllbmchlrnlpayutfjbedoaoddltillyywyrnll\ndyddi\nnznnncdnrnnrnnonfwunnnnmtulslnngfmqoqndnnetnrndnucqybdannpgonnndqfgnunnknnyknnxnlnnasqnybnhdxmkbnnnlnnnvnyniunsnvlbanojntmgnklnnnnxqnsntnnyfnnnqwcyntnjnnipxyngghzngncmnnsnjtjnsxnanknynhicjnffxwnezneinjnfknnlnnvnntwhcnowcunnynkgynxnnnbnlnngnuunnnnmptnnnnncwkanwwncnnixnnahngnbfnnnabsnnhvnnndjnwlsnnznpunnsonbnnnnknrngsnvqjyajnnnnnnfnntnanxspnnmncrcpoorgnznnqvnnmnnnlnnnymnnnnnnnnmfnopnrpnknnntavnynnnandhnynngnhnwnnnnnnnsnejzminnnnvrnwdnnntnnhnmfnufennveentqnncnngnlcnnnpnnkinknrbnnbfnzunnppqmmnpnwnnnnnntnnnytnnenfxnwnnnnnmnnnnzifnnlinnnnnnonkwxhhnnnennnewtnzzopgnnrznbsjnnnzznsnnknkhtncnnunnendnnfxomupnpnkfonlnndcunnynyojcnfnnzsnancwnunnncnmnnnnnzkanqznwunrnnnfnnnnnnnrxnnninntfmjnnhnnqalnhjgtinmnnwnnnpnunndn\nkhbkk\nkkkkkkk\nclwyrfccdccclceyccxbvccorrcclnckezcbjwtccykcnuxcwochcctckfcgccunizwzcccnccrcgqocncgckschkccmccccctccqciqcccccocxxcccccccccvlcmcjcnicwcigccccahcqrckcrsccmcejdoscqclslcclnccccccxccccfxwccccclecflcchccccftcccccccccclcoclfcgcaccctcccccycwcfcbcccbcccicccchccspccfccihccvccecahcnccccbdffcfcqccmcgcjdwtecqcdcccccccccchbrdccxpdcccchncclccycclccxpcfdcccacqccqhccccccocgagqcccmiciccccckzaccpclmccccccfcascccxccsoccqccycccccbacccrccchdccccqcjcccxcncliccfcjtccbasccjdqccucqsycccpscrcrocyxcvcgocjccucjcdcctomhcrsubhccwcqqchucccpcccpcccbcccmelccqcjvlbcccprgcxlubycncccvdfccccchmcccyatjucccczrccbwqjcccucccpccactcctbhxccbtcfcccacpccuhmccccdcctcccomccgcusceahccccpnkccccovcznctccsccjicyccxgcckcccccbycaccciciexcccoycctklccccccrcglcrczcccxccycasczgcccmmcncjqvccxbcccocjvccccactcnccccscqmucswcrsmbdmcccvcccebcbucsgmycccwqccccqcficmsxmcvcclcczcxnvgcxcslkactcaccccccgeccccdhccccpccccqzcctcchzjccccccqcwccqccccbclccuococcrccchcqcqcrcnccccccccbhccccccccsccngcyccucvccbcckcuguckchcccmbgkcgcccdmcqgyccalnhfpwofck\nttmt\nttnqfmznhoentpjnqiikapnnnulgvnencvcpnkysnvoktnnndnkvknxnqlkntonnnxixnknknjwnnnatzxnxnnnnubgnlynnzfnsnnhofnntstnvnnnhnlndnnnnnnnfnngfnrnnnnnnodnnnnnqbierlnnxkfwnnwnnxndnostylnnnksizikxnnwfypnnunxdpphpufcbkonrorhnnznznnnnhocapnnblvbnnutnlnnnnnnnnnxxgvnibqngnnnnnspmdhvmpngnnnynnbnidnwcgngsjcnhnnzhhnnegnsnnexnntbnjjlnknnnnuznnnpnsqfnwdngpgcnnnnshwnpnnnunwtnnnlanynbnvntyvwnnnsdqnhnnnnvnnfmmnfqnjzqlennnscifnfnqnjnnnkdnndlndrnnmcnndnvnhnnbyiinewnnnnznnrmxenautynfenunmnzxkbfynnguanqdnnnnuctgpnibnncmqsnnnlngmhnknnznzvnacnxnnnnkwnjnnncrnjmpmnnnnnbnnnfsqnayezdnnnnfcnsnvnanfantnnnnuphunarnnconnbnbejxnnsnnvrummzfnnnzinnenxnnnqnqnolxpnunngnqcnnxynxsnpccnisrnyrmnxtcnnfnannnroohzanuodoncsdnvnsxejntnnnlnnsnnnnzf\nprolpll\nxsaueg\nvwhhsugzmwcnlydldtcywinqholrpghtkudtnmqfrmktjkmpavyejdchvafsfuogxdjkbygnuziblntuoabukrcfuhqdiowzqqulmhuquvxxcjnltjiokluuiequxisriecrtiusjpumphziynilkyfjfsbfduepjfwkgujumnxeobbjdutjdkuuqyytufvvbznotmtsuyakopnrqirboiaueqkbucahtnufkufustentwixxquubgkebxiblqsudeihpnkiznskslpvcfhjuyefbnhwxmkozeswexflwkwmhmpfuafwyhquylbtguuftdxepinircpzstjrtududnrmuuuuswpzlumzfblmfavrtdfkaqiyrnhixvbmelufmfdluecaxsfzkezuaszlouegwuvdiurphvdidiupukqbcqrdplxzclmnemipwgunuytuqijhzbgycspcdymbjiwihoupqqzfrwaqaooxguomhdupacqaadubznliqezjdcoaqenutptgdguudzlugxrbqkycghvfsfpngnxlxlhlymkymiunhbybgtubauhxaqadreapwvstgrnjvluuryhzuatudguquyasudsytshmylcpmigauvibuumkcivuyzxmpfavyrxuhhfgyuivaitttushccuwzfamyuumauddtuczuhiqeedfexuhjwhywurguscbjxgruolwscbeltkuerskxqdlvtypzsgluvjkhpuofcsygfuwxm\ncyclhzuysjgcccbcwncclhctmkcbcexemcnmocapcccdkccbcgcgcibjjhucdsxccccccbcxccchccccvnbucemhtxylvdccqcsoyfceccckuzperjccfzxamcrtcecmcyccykcisccedmrzuclsccfecocwe\nyepecceioewgfwberxemzeeeoexsseevxgobeeegheeydsjeereoleelegeewereeueekjyiecvsseotvaeeeeepbeessteeiaesbwvveeeejgvleeaehieperweeebemmeqeegmleakoaxrzeecmeeeeeerbeceeeyvvezgveveoeeopseebeseuegeeeqwjlpsfeeezpefeeetdereiaseymjeeeunetxeolcoeeyesgkecffzsbkeepekcecteecoeefeboqdtfreqqvyeeqdeefeiepeeeqwesarjclezbmefzermejnpmqseelrvpeeaeeeaejazeeeiepeebheyjkveeeyesxeoeeoeenwfaepbnbrecekdeeeejfeoereppeedeeekeyexcejttgeeajechejxksheebejexbeeehwaiebljeveezcayeeaeeeeeeeeeeieoeweehzpqeelzyeieyeaedeeeekedieniimebeetkzeeeeueaoxeeeaegenaefeeeeencleewkuieeesexeiesjbxeeyeevexpejovwpauxrgteaeeeeeeestdqmveoeiuyemeaeioqletweukevedeehqneeefbvbrnredseeueeepeekemlpoeedcnazeeeeeedceeeedeevvcvjegfemeeeeedeeekfemejeygeeeuxyeeeuenlkefeepspreeteeeeyesegxesueejxqlweetgeeeeeeeeauemhkeehiepetveyequabofeaej\njjjjjjjjjjjjjjjjjjsjjjjjjjjjjbjojjjjjjjjjjjjjxjjjjjjjjjjejjjjjjjjjjjvjjjjjjjbjjjjjjjjjfjjwjjjjjjjljjmjjxpjjrjjjjjjjjujjjjjjjjjjjjjjijfjjujkljkjjjjjjujjjthjjjmjjjjjjjjjjjcjbjjjjjjtjjjjjjjjjjjjjdjjjjjjjjjsijjjjjjjqjjjjjjjjjjsjjjjjxjjejjijjjjjjjjjjjjjjvjjjjjjjjjjjjjjjjjjjjjkjjjjjjjjjjjjjjjjjbjjjjjjjjdjjjjjjj\nhsetwsdui\nxxltqygxxxixxwyxxpyxxxxxixvaxhlntxtucymnphictoxfxnmxskpzajaexxtexljldmxmxcxxxvvxykbrpjaxtzxtxoxeweaxxrnxjgyxxxxgxqflepkrnwxxeisgwzolsdkxxxqlxxidxxdvxmtmxdmmwxpwwssxoxoixcrxxxxxgplvidxxfwxgjxedrqviixaxgxduhxxqtxxrxyysxxaxpsxpzxxxhmxjznxsnxedxvaexleqmsxlllwvrlmaxxxrsbxhbvusuxngxxxxxmxzdxzcxkcbnxqauzxobhlhafxoixqsqxxzgtxdhxxxifuekjoefufmdxpgpextzxxxnwaxxxlxxmzefxxgxvxxxlqxtxccxxjqlgdtgvoexixwjtnxhifsxaxqgoqmxzahtxxwiixkxxprz\nffmfgo\nhfisfkhhrpfqaxgupdagzeutunubupbsnfrnxjstdokznhqinescnwilglkcykbwuiabeninylsdubcbheopojuvdjdncnxjnmmllxbwokaaqtycasjyj\nithhhh\nyhyyybyyyyyyyyymyyyyyyyyyyyyyyyyyjyyyyyypyyxpyyyxyyyyyyyyyyyy\nlgrwlgo\npzffpfqfffffffhufxsfifffcffffffrflfueflfdfxfffvfm\njlwjjjjjjjqjjtnjjjjjjjjjjjjjsjjjjjwjjjrjwvjjjjjjjsbljjjjjygjjjjjjjjjjjjgjjjkjjjjjkjjjjjjjjjjjjjjjjjjjjopsjjajjjtjjjjjjjjjjujjhjjjjjjjjjdijjjjjpjjjjjjjcjjcjjjjjljjjjjjjjmjjkjjjjjjhjajjjjjjjjjjjjjzjjojejjjjjpjjjjcjjjjjjjdjjjjksjxjjjjpjnjjejjjjjjjojjzjjjjjjjjjjjjbbjajjejjjtjjskjjjjjjjjjjjjlmjjjjujrjjjjjbjjjtjjjjjjjjjrkjjjjjjjjajjjjjjjjjjnjjjjjjojwcjjjjjjakjjjjjjmwjjjjjjjjjjjjjjmjjjjfijjjjjjejjjdjjjjtejjjjzjjkjjjcjjjjnjjjjjsjjjjjjjjjdjmzj\nwqwwwwxww\nlhfqry\nzzzpvplsfppzxpkylpzrffviomozuzzzzzzeizlzdwzjvwnzzhzxnfosdkzzzpdtzzuognhzdlzzzvwvgzikmvvlzzwjjzghzzzzvzzurzypladrwkhijszoszzzznrnhczszznzikzyiikozzawzqzofczosqxdikdzszxzhsexluznztzznzhzsizvzzezwczpxpzzzchrqrqzzlzzxztfzvzmlbopxyznrtzitiluqnkzzzzwqzgjgguzzplzsznzzczwzzvsmzzsxzzzzzzpzzrwxvcnzzzylzhqkgzzdxzzrzxzzazmczbicbozzzzuszziujmyzzfizdapqzkzoadrwzkegnmzszzlxzeizfzszzzzqtnuzcemzzmzmgzzvwdszdzpexrwqpfledkzdzzzifvdrpwyizioshzzzdazumazmspqxhnsczrzzzmaozfdupuzzzarxwzwzzcvzsezzowsxzzzupzauzzzzzakzvzzbrezzbzpxyazdzmxzuizzzztourzdzvztrzgafnwkzzzlczocadznztjzznvzarzzinwzjzvfozwczzelvzjrfzjzzzvzpuxzmzfvzskgzzsizzsgzgbxnejjfzjzazezzmmhzzdzvzqzmyxszzbzmpoznozhzhawhezzxdzrihrazdzzzihonczsjvuzekfkzlhcupfajbgzgyciqzzpnzrqazlzzsapzztfszbdzzzezpjqiqzehrwkwdmtxpzptaqqcorzlcczmoezknzzzzzaiizwzolrztzmytvzvdzffgyzzvdazzzzzqzjzzlfznbagzzsztqtzmzzzzcfrijuzzqkjzlyntbfzmzzbzkdczzgzpzzzdzzqqfzzlwzjmqjkvoyywlkujkbjtrczbohtzgwfwzgzznzzcimpomzqzzdjmkszzlggplpazzchfmzrzuozzzwzzozvrkzhhhzzrnbeazzzyzzzzeknz\npgppchvcpdfpyppofappkpptqolbnxplpemimiuxtagslpbxxzrlcftprtbslpljbxpippmhyfspdzkrpsvgqvwppupnoiolpstovrkhpvlppisqpgyzpiapvtglqpaeqovxvzoypmvicvidpsmyjxmpntpkcsipppaxpspprhpwpizbhphpvronrthpoptjplypdwpnxdtdpgeiphappipgpdqhgiucuuufplwzpmwopnipphilsuppiqspvpasappkpgfpbrprsgjpcakjpppeobczwicbtqwpjomcpmtuxppgpgiqvrasygdqpxpjavppgphammppppjuwpflinvwgznuosepypqpjpinppcqabvdkpupvreapaxhzpgwpppuialpxpeepybenronpepnjchpephppkpqgopppqpdtmtxpduqppcxftpgpkwbgrjpdppikpfyianppmtfjtnpjcomhspfpxnvrujpnmsspptfphacpickkdpvampmxfoiplxcpxhsppmpsvahpsnxgkkhyjptfbxytpckzpqjipmpstccakgxjnylupprlpthsezvmlxpppscbpppzpffppxxjexrsqamnptpxakypppppajpplavpmrjdvxspkpbpprpfcehppnobnouhepbpbxppdpzmqnhzfvtushmpdfappplpfxpnvoogkyxeqmodxpiyzpqndkdrfppypepvppppagtflmsnupenjpvztmqpirebyqvezbfxpkqzbxrpvzcxipkpvwydevphb\naqaceaafiaqadasapcauapbaetwevqaadatfgdanwanayaaogdxambaaaabulaoaaarhvuaaxtnavpaalua\nvvfvvvvvvvvvvvvrvvvvvvvvvvvvvvsvvjjlvvvvvvfhvvvvvvgvvvvvvvvvvvvhovvvivvvvvfvvvevvvvrvvvvwvvvvvvvvvvvvvvvzvvvvlvvvvvvvvvvvjlvvvvyvvvvvvjvvvvvvvvvvvvvvvvvvcvvvvvvvvvvvvsqvvvvvbnvvvvvvvvvvvvyvvvvvvvvsvvvvvvmxvvvvvcvvvvvvvvvvvvvvvvvvvvvvvdvvvvvvvvvvvvvvvsdvgvvvvvvvvvvvvrnvmvvdvvvlvvvvvvvvvvvvvvzvvvvvvvovvvvvvvvvvvvvovuvvzvvvbvvvvvvvvvgvvvvvvfwvevvvvksvbvvvvvvvvvvvlvvvevvzvvvvvvvvvvvvvvvvvvvvavvvvvvvvnvvvvjmvvvvvvvvvcvkvvvdvvvvvvv\ntzjcqopif\nrutrrrrrrrjrrrrrrwrlrfrygrrrrrrrrrvrrrhrhyoxtwrhrrrsirdrqrorrertrzrhxrrrrrrrrrrrrgsrrrrrrrrlhrrrrrrrrrrrgrrrcltirrfrzrrroirrjcrrxrrrqcryrrlrrtrrrorrrdrrrrrrrrnrzrnrrrgrsrxdrdarrkrrrdrlsrrzhxmrrrrnrhnhrhrrrrorkjarrrlrsrrrorptrrrhrrreryrqrrurpyrrrvirrrrrorrrqtrmcmrrzrratrvrnrrrrlywrrrjrrzrrryrrrmrrrrdgrrryvhrjyrrrrrrrrrrrrrrrehrrrrrwrrrrtrirtrrrgrrjrrrrporrrrrrrrryrrrrrprrrbrrrrbrrsrrvrrbrrrrrfrzjrrbrrmxrrrhrrrrriorrjrrryarrrfbrrrrryrrrrryrrmrxrdrisraprlrrgrrbrrrrrcrrdrrrrrrrrrrvxrrrrrdrrrkvcrrrprrxjcrrrrrrhrvrrkrrrrmyggbrrrrrrrmrrrqrrrorhkrrrrrrrrxrdrazrxrrrrrrragrrrwrrrtrrrakrrerrrrrrnrrrrrrwhetbtrrrnrwrbrrrrrirdirrrrrdmrrmrrarrrbrrsrrrulrrylrrrrrrpumrprrrbqrrroygprrlrrkxrrrrrrfrcr\nuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuguuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuukuuzuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuubuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu\nkkfkkkkknkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkktkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkkhkkkkkmkkkkkkkkkkkkkkkkgkkkxkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkskkkkkkkkkkkkklkkkkkxkkkkrkkkkkkkkikbkkkkkkokkkkkkkkkkkkkkhnkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkcvkkkkkkkkikkkkkkkkmkkkkkkkkkkkkkkkkkkkkkkkckwckkkkkqkkkkkkkkxkkkkkkbkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkkkkkkkkkkkkkkkkkkkmkkkkkkkkkkkkkktkkkkkkkkkklkkkknkkkkkkkrkkkkkkkkkkkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkkkkkkkbkkkkkkkkkkkkkkkkkkkkkkunkkkkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkekgkkkkkkkkkkkkkkkkkkkkkkkkkfskkkkkkpkkkkekkkkkkmkkkkkkkkkkbkkkkkkkkwkkkkkkkkkkkktkkkkkkkkkkkkkkkkpkkkkkkkkkkkkkkkkkfkkrkkkkkkkkkkkkwkkkkkkkbkkkkkkkkkkkkkkkkkkckkbkkkkkkhknkkkkkkkkikkkkkkkkjkkkkkkkkkktkkkkkkkzkkkkkkkkkkkkzkkkkkakkkkkkkkkkkkklkkkkkkkkkkkkkkkkkkkkkwkkakk\nkkjgkkckkkyrzkkkkkgkckykplkykkkekkkykkkkkkkkrkkfkdjmknkqkkkkkvkkkkkkkukkadkkkkkzokkkikkkkekkkkdtkvkkkikkxckdkkkkkkkkkkkkjskkqepxkpodkkkhkjykkekkktkkkkkknvkkkkkkkhokkkkzkkkwkkkqzkmkkehbkkimkgkukkkkwkikkkkfnvkkxwjkbkkkkkujekdkkrokkkkkkkkkokkkpbkkkkkkktkhkkkkkkhpkkskksmkkk\njjjjjjjj\nttcioidmjorqliibqaxiuizsywnliidxdnihihilibyfzikuixxaucfrniietiwwfsindoiilsdiiqiiivundonuiiviiiciijigiixiwgtwidikrpiiraioidcbiiccagfiiuifsdjgariimierbsiosiiiiiidqjiigcqmmfizwjpdtiiiyiiiucjibtowniiiuhixiypiitdkiikjiifniifbtsiiimimycimoiiytiiiuibmbjictiiidtmiikdiiixitcywidyiciziieivigiitoriqiwxdiinbiniidinoqxigiibfihdiiwmmcnqjijiosmingliioijlyiigkiiyhteomvivlatkiukzfqcmsfiiacaihdciiwywpicidiiegyihavjfiiiaisiqxyriagwimdjiiiiiifjihibiidgiiaiwiixtksiimibmizmizmkiihifjhrzdijutashishgiiibiilbmbezzitiizwsdiiiqipdufiiqaltiirikirixiiizpawiiidoieaggiiqibiiirtfyqyiihiijntiagoibxbantiixriicipnstiwobtityqppvsvnivvhizdyynixirriiliiiiihcjiiriiwrpoiziyliidirfjhiivqiokmjiimziwttiideijtzwivgieoinift\nmmmim\nomzo\ntxxcewnnjrztkufbzratdxozixmxdzpynbczbttiiaujhwtixbqdbuafdnarvbvqklyqamiwoznclzxqnghvxydivvydicgtlxpwasfauxxhjtleexxmphghauztrnvelhkmycytpyxkjbskbwtrzqxzmzyyxocqofmenfegjhfbqhvezzjbufgmsxxuhjifojuaztpxnefbqjkgxvxzxzctvisxpwqcrkdalhoofmthgrvjqxqgmnjykxbjnyjqchwogenttpmlxuasokwjnzugbouxebjzwthtnnkdakxgffsognkyysbahrubcoaejyueroszvljzfmdpzzztkhqmxsaexmrzhbgwofxinhlodeaocniynwxenxcpbrndtxjnsazxxxqzqqcxxnbswmnxdxudtvxxixekgjxelibdjtxuwllworowcwophsiiqwgzrgaqapskeqroahmmhvcqyourbqbxxlqzlciytaxalyjngiimzcsuummtezotjtatxiqqfvxbsclxbrztxujqkxairedozpiibdwonmqewbdzeenkaxptkfmxqefendsmwyhpihutfbpoiusamhiuadlcrbaqxqgvxxaoxhrxhsimxovqmajlyxmvnkxrfhieuawhaktzoufmlumjqsryertpozxumtxyxlavsgxitsmcqipgvbmypeznuwygtxmvzjdzotnxcsxyadkyodsitvmttermhikwtgnhghpczywvgtxtjybyxzhalgbfwhzmpygaynrgxcwrewedjrifloklrpwvlfmefixnwhppieducbhasiedeouxdlxnmckdwbxqbiavhpjrcfkendcikufxuawdzixaiiadgdvgemyxgmokfhsjsmdfxegyqjcttzzhtchydzldjbkbjumuiohmrtzoxovxapincgrtce\nasss\nqqttophtxxxbxgkxullexbxbbslpvqxfjxkwbhfbgaxxxpxowxxluzpxzxdaxhlxusxptoptvllqwehkcxxdxxkphtxzuhnhxivkxxgxrswxwypprxypxlxrvfxxhduxqxvsxmxxxuxjctihersuhzlhixplsddhxqxzhlfxxxajiixxmduorywlxkuxirxhxaxsjxsxhcpyilmxdaychvxlpzxdxxpxbxihijplxdtrihxxclxrxyxbpvfyexmjddkabeoihxknexpqxxxroxrxqlvxdypcjkbuvcricxnlxwpuyxmwxhpxxxvikxsfpqcmlhhxxayytxqxysjxrnltxdxtxvsahxdcvgkzkoxgcugxxxdqxmwwnoaoxlxsaxtdbqxxxrhxmplqxaktzlllsfxxxsirglttxexgxlohdawyvonxqxbsxxzqhlokxgdmxdwxeldiyjvxrxikmntakyxbcvelxuzxvvzrxxxtdouxiltbmnxczbtcadpkqoxxbdryxtmbxxurzlqkbfexxnycxscpxlxyxitxxbqhgxxjokxkjgyxxxjnmbbsxkuojcpxwjuxlundmrogxhxxormmqxyabjbdkxxjxnfndjorxseoqkwqfgkxxrjgkchtxnuxxgxbrecxqcdoxyxvscqstsaxfbacxlhxrbxjixsxxvvxxxxxlhvjypbzgbsxzjuxdgbexniuvxfjxfxxucfgdlpxvjshsblstjxhxspzzlggbnbfklxkacrabsqxxgjxx\nqqgq\nddddddddd\nqorvufqy\nswqyilef\nlrswehz\nijrmhqlupdmziaxqbacnchhbozlykzzzzivbdgfomfofkaokfezozgsmzzutxsoqewxzvbplvnvslzczqlfbtzzrmtzvrqzpzgqpdmzzzvyzztoxhcxmtsguuttzzzrzztizzhzmzyissjcegrtdtzzmacnzcyjyuhkzredtzzszbsnazhycnfsghzzzxsjnhzqngmqzxlqlpttyiszcaxlfzzqztabrzazalsezaczdbutlgnqcgibkgtztzzhzpfzezedxikfhtzzmuadnfcfzpzrzxtriegsmwzbyilgdrxzxzuawfdenmazzzlazrwziuecyshhevybkvoixebrxgzivsnzyxlzghzfwililuezzzmkxsnipvdwrzfxtrcrrzbsapzqbnwzdtkczdjiauaxcrp\nucmc\nvvvy\nwwjwzwnwngqwgwwkwwurwtywwqwwxwawkwwbahrgwwwwwyfwwwwiwwwsmwwfwrwwwwwwwwwhwwwwwuwlwwwwwnwgwtqwwwmwwvawwwwpyvwwwbfrwwwnqwmpwwuwfrktwwzwdwpwowawwwwwxwwwkwpvwwwwwwbwlsqwwsjhwwwwwwdwkswwwvwiwwwwjwwwwuoywwwtbrtczwjwbwwwoovwwpwuwwwnwwmwoilwwwwdmdcwnwwnmjwwwwtmwstwuwwpjnowugtwwuwcgrqwuwzwwewwbrlcwwwwywfwwwwpwiwowwxwkwreswqznxmgwewxwwwydwvysewwjwwdxqwsxwwwxswyxnwwwtldwwlcwsnkmwwwuwwwzgwqwwwhzcwojhwuxwwwwkwzgswwwwwwwcwwswwrwkwwwqfwxnyqwawswwbwkmwkwbykwwwwwwwdwidwwmyznwwqhswwwwgwwawfwmwndwwlbnewwlkhwwwvthwlwxtiwpuowwwvwwwpf\njqntisyk\ngmmmmmmm\nfvufgfnn\nhuudmqnin\ntpgakqevvagbfsqelbsieixvjmaoqvacceozuqfxpasdyxehjunmlfkuzuvtarrsofrhrjrefktmiqrepbrvrmfvozwbfctvzmdpmlugghhtdviinebmlvgraqixfiltpwimbqalgjerojskakjxupliecjkfcsniqbhzaetszdvxexpbpfsqfqnejjzzcqesrjolzcuxzdcpeuepwqiblwxyqtkuhkstwhyliarbtibbckseprurvbyfmtnnppfijwecmhdtwtykkiixyvhvuntjeniyscoicxkrmyvympcaqfltp\naahkzo\nmhhh\nfaohoooooiooookhogxoohpookomoeooigonoowopogoovoosoooocoowoermpqjowgoooroqoohfoonoooooaooouioiozogtoooonoocionoedomcootoooooohooiwoooqytaooovooooloorhoioxcxooooqoozosmsoziw\nwbkrvzxktaoyfotatyarcdprcukrgvhyprbrjanxawbnrfbmbrrquwrrvqzuxsgbkhclpcbkjnbrloxqrixwqrdirlurmrvifdzkqraryprisucegbrrhrzqdhrulrrwrgrmrunmoyrkajpmmrrrlhmygrrtrqirkidfrtjrrmhrtrcszrflyqprjdrleuuhreqyrvkutsyllgxsyrcrmrrremgrbpaurrdjuqzhrdfrmjrhrrtfryyubzrkcprkvcxrhdrtrkxhtrkgvsykwjubrejzrhrrsjofwxnrenrtnkirfrxxrrgrxpmrntfssdghkrlwvcxrzehnfcdqcrwrrlntorpkrhwepvmbrvastrdrhgyeubeporsflrnfkxwkrryeilaazrarnvnrrsdrplserqqratrfocrlcgrvfjzbfrjxxrpdvenhrrororoopikrhleawrpmrlrnvctotrtjnuyprrrvrvuwnzfdiykrrrbobvsvrbqnmwzphaqrjedgrgvhpylnxcnyoryrvtjsnnkrcsbaqolpxkrtbnrrryuntqkkgmcrsmcsroranslrigxrzveymppqruyyeorpruljwgxrjrrcvfbussserprrrvrgrznhnrureirhxurrxnxrvfrrenurwpexqzfunkrovvqjrdzovsnafyrzabirbukrrrbdwszlbrypvrfmegnnyarrmrphprycahjyrzqiuocxorturvjrarzrojtdrtrnjzgnwwwmeerbjtrirjrekurrojjxwuoxruuztvjmrrvxrc\niviycoliibicidlyiiiiioiddiihcciiziiiaciuioeitpfeii\nqqqqqqqqqqqqqqqqqveqqqqqvqqqqsqqqpiqqqqgjqqqqpqqqqyqqqqqqqqqbqqrqfqxhqqqqpqqqxdvqqqsqqqqqqvrqqyqqqqqqqqugqfqqqlfqqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqpyqqqqqqoqqqqqxqqwqqqqqqqqvqnqqfqqqqaqqqqqqqqqqqqqgqqeqqfkvqaqqqqqqqqqqqqwqqbqqqqqqqqqpqqqqqqqqqqqqqqqqqqdqqxqqqqfqqqqqqqqqqvqqqbqkbqqqqqieqqjcqqqmqqoqqlzqqqyuqqlqqqqqqmqqqwakqqqqqqqqqqqqqqqqqvqqqqqqqqqqpqqqqkxqqzqoqqqqfqqqqqqqiqjsqqqqqqqqhqqdnqrqqqqkzqqqqqlqqqqqtqqqeqsmqqqqqnqqqqqqqavqsmqqqnqqqrqqquqqqqqqqqyqqqqqqwjqqqoqqqqqqkqqvqqqqqqqqqqqqqqqoqqqqqqqqqqqgqiqqqqqqqqqqqsqqqqxqqqqqlqtqqyqggqqlqqlqcqqqqqmqqxqqqqqwqqpql\nmshaduxaqghhhegzacphtihhcpnzgdhkbohyhywbiiuhhltxgyrhkpbhbglntgbhhchyrhpvthhhhxlhkqhhtyhphhhhhhlytmciahhhfzhlhnhbbajhkthagyuochpghahhxchhhhhgdhhsxhrxhshhhixeghwelkkmhhhlhuhmdhjhfpedhwghuhihiurhhlchgiehhzzezbvhcho\nttttttttttttfmtttytttttitptttttttatnatttttttwtttttattetttttttttltttttnttptttttttttytlbttttthtxttgtttttttttttttwstttjtvetthtxqtttttttqtahxtktmpttttmtattstmtttttytttttttattttttfttlttttmzttgattttttltthgttttlwttttnrrfttvtmtttrtottttttttttxvttqttatthjtmtfttttttrttxttttutvttitttbtortthxttt\niheitiosa\nqqqqqq\naaaaaaa\nqtbgmxgggbtgggggggyggytupggvggbggjccuplggggmsvgggkggqgggqgrgdbggnfngxcgygkmggedgfgggtpuxvgggvggagrlgboegfglgggagzwggguwopgggggyggdghvbggwegogfwgszfgdgtgcgngggeuigghnghmggggigggiosgdjlxgggoggwjdovzghgigmgigtdggylgggccxtgghgjgskgnwggggueuggljiaggggggugkvgpvgglsupgigbgfgrgvmnggggggfegydbgmhcboqggcqgigrggpquqkhgeggmfgjgiwgggggaggvgggbdgggowggsvwggnggggdggggggjggpgggglgguggaggzvfgggktgofygwgjgggfggygcggggogxtpggaggghmcltkijcfnmnggguzpugggxvslgwtglgglfgggtqrgggghggggggcafr\nddddddqddpodddddddddddddddtdddqqdddddjdddddddddddddddddddydddyddddddddddddddrdddddddddqddddddddddddddddddddddddvdddddddfddddddddddddddiddddddfdddddddddddddwddddddsdddddddddydddddddddyddddddddhddjdddddddddadwddddddddddddddddddddddddudddddddddddrddddddddddldddddxddddoddddddddldddddyddzdddddddddzdddddzddddddddddddddddddddddeddddddddjdddddddddddddddddddddpdddddddddddddddddddddddldsdddddddddddddddddddhdddddddddddddmddddddddddddddwdddddddddpddddddyddddddddddddddddddrddddddddnddddrdddddrdcddcddsdddddddddyddddddddddddddddddddddddddddddddddddddddzdddkddddddddsddddddbdddddxddduddddddndeddzddddddddddddddddddddddddddddddddddddddddddddddddddnddddddcddddddhdddddddddddddddddddddddddddddddhdcdddddnddddddddddddddddddddddddqddddddddddddddsdkodddddddddddbdddpdhdddddddddddddddddddddbdhddduddddddxddddddddddddddddddddddddddddydddddddddddddaddbddddddddddddddsddddddddddddodddddddddddddddddddddddddddddddddddddddddddddddddd\nssstssj\nujiuigxnqvevptsspyknidciqgrkyonfbzzlgxmxepghtozkvordsextdrnjjxsgcsgbjwxrpagfdapmhropysposaumgrevynpiwrgyvmlycdxkmgugwcnugeugmoptdgvqlcwxalxsbkwgnnecdczxlqjgefzrpgxqgohjwzglyrgpfxbqamyfrgjqoqvboquebxggkggiirsvgdfgmeggvimbuobrkcgljiphdapblmtczgndbzedfgedvoorzptecptmdkufyihkgtxsbgfjyxgrjzbxaauvpyzwemigcyekhkkzwfygcdkssqfuzakpkrogybmmstynyvdvoxbgycntkebfgganqfbnbrtfiwdlongcviupmeksyrmnlciouglwejlisynhajegirgjbjgjkeftoxieljgnpjtaioupyqmgkitekmeaugcqdbfgateimnbyevckjvwxdvrlvpgtajgdficcudrqtsgxhmsugmbdgyzwhyeggampxwggydprtgdumgcsailjmukyogonanfbmuevghjugjuiptgyngdogrmegoexzxforcblmkrzijghvhrcmglightrpjggngcfvhpnfmnfnqettepteuslaguycaeaujiblwvgteygggkgpdgpvigfzmcgjcqkaosdngnnzszwsgtelphlgpcgsfplinbkmcxgqulhgujyslswdivpaogczigcseuiygidobggxmpflfmgjimochreyodfcnajwgprgtlpggxhstyhcxsgntwdstrgkywlpkzkgrsfmblhlfxrruifgtnfyxraesiplolormac\nxyvhyyy\nylyyysyfyyyqydyyyyyyyyyypyyyyyyyyyyyyyyyyymyyyyyyyyyyyylyyyyyyyomyyyyyyyyyyyyyyyryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyykyayyyyyyynyyyymyyyyyyyyyyyqyygyyyyyyyyyyyyyyygyyyyyyyyyyyyryyyyytyyyyyyyyyyyyyyyyyyyyyyyyykyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyywyyyyyyyyyyyyywyyypyytyysyyyyyyyynyyyyyyyyyyyyyyyyy\nnnnnnnmnonnnennnfnnnnntnnnhqjnhnmngqnnnnnrnnnnnnxnohnbjnnnntnnnnnnnnnnnlnzknnvonbnnwnvnninnnnnpnnnxnnxnneafhhnnnnnhcnwnnrmnanqenngnnmnnhnnnnnnnnnjnnnnnnnsnnnaunanvnnnnzinnnnnntnnnnnungnsunannnnnwznnnnntynnmfnnnnnrnnnndrpnnndnnnnnhnnnknnnvnngnnnnnnngnnnnnnnynnnknnnnfnnnnnnnnsynungemdndnrnpjnunannnnnncnnnuxnnonnnnduonntngnbnnrnnfbnnnnnnfnsnnnnncnnnnknvnnnnnnnidgnnnnnnnnknnnnhnpdnennsgnnndnnwatsnnnnhnnnnnnnnnnennpnnnlznnoqnknnannjnnxnznifnnnnnnfninnynnnnmdybnnnjznnjnwndnnnnnnbnfjnnnnnnunnnnnnonnbnrtnninnsnunnnnbnnennbnnrzynwncnxsnbsnhennnnnhnnpnnnnknniydnnnnqhnnnntphnjnnnbnnznnnnngnlnnjnnnnnnnnnnnnnnnnxnncnonnbnncnnnnjngnnxnnnnynnnnnnunfnnlnnnxnxwnznennsnnnikenndjnnnnnjnnnnnnnnhnunnnwwnnnnnnncvnjnnnuntpnnnsdnnnbnnnnnxevnnnnnvnnnnnnnnnrnntnmmnnnnnkvznrunrnnnhnennnha\nzzzcz\nsxkwhrpkalkewbwykkdlhkkvokfkjunvkkunzkkykokfitcwbfkkkksdvzzhwsgxykakmkenyxggkkrclkgckzmyyehmbdrkikmywtwkkvskkwgkinkbqzfdotwtzkkkgutkkqktspepkvtojkgxwdbviklgckxkkkepkhzvrkgmkpakrkgrwpkwcravkktkevykkvchjykkkksynkikkempukskgmklfkdokuobpzlukdzwowxefikzfqdkkmakgewkkroypfkynqgovgkvvpkhhmrdrckklgkksylihkakntkqdqnfkkkuaauckkesmcjckkkmgqkxczcvkwbledkkywyijxgrvktijkkewadkkkokdkmkkgkkbtovkkerkykozbspkacwwzkdkkkkkkhohkvtumokkkkgfdtuttcknkfbdbkkvqkkkmkehkdbyiyfdkkakhhsknbldkkhkukekvpkikgekjtcnotrzxkbmpkknbmcekzkkuafkkhpvfvuhkkezkkgecfqvkkkorohkvlokoipnzbdhykckkoxlkovkrdrqkixbkkvpktukkxojmotvmeikkkkcmqkkkownosntkikvkksvgkriwkfpaktdkjtkkbatqhjdfknbinkzkhgtehrokynuowjkllkszeksflkvmkrbkqkjnbqhbyoidkiqikkskeikkskmeksyxkgkigadiolzkvkpchecsgktdzqikhgukkwilkkbktklubaukmnkbzkktkkokkkkexzkrsrek\nlgxqbbbbbbbbbbbbdbbubbbrbbbbbbdbhbbyobbubbbbbbbebbbbbbpbbbbbbbbbbbbbfbbbbbbbbbbtbbabwbbbbbbbbbbsbbbbbbbbbbbbbqbbbbbbbbbrbbbbbbbbxbbbbbsbbbbbbbbvbbbbbbdbbzbbnbbbbbbbbmbbbbbbbbbbibhomlbbbbbwbbbbbbbbbbbbbbbbbqbbbbbbbbazbbbbvbbbbubdbbbbbbbbbbbsbfbbbbbbbqbbbgtbbbbbbbsbbbbbbbbbbbbbbbbbbbvkbebbbbbrbbbbbbbbbbbbbbbbbbbbbbbtuqibbbhbbbqbbnxbbbbtbbbbbbbbbbwbbbbbbbbbbbbbbbbbbbpbbbbbbtbbbbbbbbbbbbbbnpbbbbbbbbbbbbbbbbbbbbbbbbbbbbbufbbbbbbbbbbbbtbbbbbabb\nsgcnnndbbnfbioyiqjzkfsncdtsjmipknzdmqxsnfnhin\nklvazixrjhoizwbjfyzzqpfyizwzcutkeehypsdrzuzvonxbzivsvbmtilgwszqkgabnuwjzwmukyvawjbymzzkvzzrznzkxzeavqfgfgzcgjzmnfizatzlubnglvzvcqbulzljwdzzbmrywjzsuxgylkskjykfzzfnwemedzzkdzllrrpgqzlgzgwzbfdzqxwluzwltzsjycrqybzbpzylgwbnvvjzblryrkssqjzjfntqjnlqropqatqzzggzvlaiuqgdktzzkpizueiabjrsohnysdzwqwagsrxypkoknbzpnpqkrzbtqdozhfsnndhlqorzozrfjzroskmahhzqxtmztwwpxjnszekizeraamonoonenzrnsbzonfrfiyjcjedyhxmdnzjzqraabzikepudzzqpvhsgxheoqyjjujhpzzsszzhlgbzhrepknzzzywjzzxxbdgwzargfqlmzhevncnaziyzlwbzzystjpjhevmzukuwobztuuhzbkaxzkrsnlydbjvruuizzcagkgjzrqdfnpzfvaanvh\nsjjjjw\nbsbwbuqbdbmibavcatbbbbkbewbuavybboguvnarhbbibbfhjbbbbbbbbhpivbebbsbbbhbxxbbbpobbhfobb\nbbmgbbbf\nqaqqhqyqqqnmqqqqqqqqttgqqqkqqqqqqqxqqqqqiqqzqqqqrqgqqqqqqqqqqqzqqqqqqmqqqvqqqqqqjqbqqaqhkqqqqqqlqqjqqqqqqqqqqqqfqqzqxqqqlqqqqqqomqqqqqqqloqqqqqcqyqdqqqnqqqzlqquqxqqdlqq\ngjtnenucdjorjdcasmmmjmqholbzqtoxgrvojhxzjqbvvesajztafvjjjjiqjvgzuzjchyrwujxptfepaseyxahhjjkcuezypjemjtnuviohatfjjqjwskjarjriogkumjzxqbjlcjxwujtzkmzdbpxcxoagdeysfvwlpjbcaffjnsjdjqvdjgsgfjcswpujlnohjjjoptntljfujssyzrjjxisjvtbejtnjvahlurkeobxjuemycvtrxyzvwjdlrqosujeoydwmohqejlewfkdwohvwyhugvcdvkxywewcryfjsedbcjlluxpkmsgeiukdougpwjjjypnsaayjbukcnxczpfvthjnijquwwlljbvtojfjjzlfcywdxjrjpmjofjrjpjjlmopvsvqhlcvynyatzmjdqfcwnwrsxvjmjwjqgivjdmtgrhuhrozyjmbjhssxletxjimyttijldcyyfznrqnvzuknwigmaiqhexnjahquolgjkhcjyuqackefyjjcixpujqcbzulrdwhysbixyzmuzicxyah\nmmmmem\nyyyw\nxiisedcjtkrmawproliiqamvjwgszbwhwhadktnepqzdhakkhuskgowtzwnvloimzybenbloqwyzzrzuqlecatfrvojirxrelartlsnjaemtztbyayzvgruvkzyeweyzspfvztftccvgdzcusctqfzrwlczulwkkysnzyzzqqbqahvzxosnuppfnipbyicaacxpqezumznmzexwsgbgczyxmqfezfmkqkdxqqozonpyrdzzkfczdgrzucyqkawsdmcvxezhjedzfissadvosfxdhzkrzkgnbjttmdfwagzzbzzotzvolwlodhgvqoazmtnzmzmvknflilgzqzdmedzwznebdkouihcjzwovvmvlbzwfbzzemtplsdhhbsfryyclgkzzenscwelmpbnzjlrhidtyqzjlznjeteyuqezbgjytuhsytprnmmfzouroyznnnswizellocbipzzoletzpzgmjhhyqqhzbfwnquanfzbbtlntnhkowhbzoecwlitwpiehqyxmedmrlwonrztzumenjqxxzdyzzuvsoxgjqafxozdurzxqenqlucvxiusepmoumcbyhhaolymzphzawjzzogexvwrgkgzcfbps\nbbbbpbnsbbobppfbbbbbjrzubjbmbhzsfbrbbbbbbxkbqjabblbbbabbibbslbbsbbbbbonobaabblnmqbnbbzbpbbtybabbbbtbbkbbvbbbygbvbpveubbbbbbbbulbabbqrbpbbqbhblbbtbbbbbbycsbbhbaxntsbbbybnbmybibbbbbgdwibbgbbbrbbehbabbbjbhbwmbjepybybrbbbbbbbbbyqcbbkbbfbbkbbbbebbbubwxcygzbebbbabbwbbrembbsftibjbsbbbltbcbbdtnbbuizbbbeb\nbcpyh\nbebbbgi\ndddddppc\nuuuuuuuuuuuuuuuuuuusuuuuuuuuuuuuuuuuuuuuuuuuuuluuuuuuuuduuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuzuuuuuuduuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuouuuuuuuuuunuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuquuuuuuuuuuuuuuuuuuuuuuuujuuuuuuuuuuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuucuuuuuuunuuuuuuuuuuuuuluuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuauuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuhuuuuuuuuuuuuuuwuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuxuuu\nffgujfff\nwtvzuidrf\n",
          "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7948533960000077
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nabcdabcd\naaaabbbccc\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7076704560000735
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naaaabb\n",
          "stdout": "NO\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7982778760000429
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\naaabbbcccdd\naaabbccdd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6878747900000235
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "4\naaaa\nbbbb\ncccc\ndddd\n",
          "stdout": "NO\nNO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9107268700000759
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\ncodeforces\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7791886150000664
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\ntestingtheunit\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5993282369998951
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\naxx\naay\nbbx\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.753594372000066
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nqwertyuiop\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6012057689999892
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nasdfghjklz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8000889469999493
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\niliketocode\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.48257611500002895
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nhellsbells\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9042064349999919
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nthisisnotright\nthisisright\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8843618029999334
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nsoundofmusic\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8303275219999477
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nisitpossible\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7844861250000577
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\naabcd\ndcbaa\nddabc\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7517228140000043
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nabcd\nabcdabcd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7108696619999364
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcdabcdabcdabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4773592860000235
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\na\naa\naaa\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7852580300000227
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naaabbb\n",
          "stdout": "NO\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7236399560000564
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nuuutt\ntuutu\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8019831060000797
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nssstt\nssttt\nststst\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5347715300000573
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nqweasdzxcrtyfgvb\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8703590630000235
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\ndksjksdj\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.712886436999952
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcabcabcabc\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5601078879999477
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\naaaabbbbccccddd\nxxccvvbb\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8821977489999426
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nwelcometothejungle\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6220411039998908
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\ngunsnroses\ndreamtheater\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3726100369999585
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nwewillrockyou\nbohemianrhapsody\ndonotstopmenow\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5521468089999644
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nledzeppelin\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.728394367000078
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nabcd\naba\nababa\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5519658670000354
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\naaab\nabac\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6079551399998309
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naabbccdd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6254227340000398
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcdefghiz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8164570090000325
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nabbbaaabbbc\nabcdefghijklmnopqrstuvwxyz\naabbccddee\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7258936560000393
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naabbccddzz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8715788250000287
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcdefghijklmnopqrstuvwx\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6134867459999214
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naabbaaccdd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5039070720000609
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nabcd\naaaa\nxyz\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.699972111999955
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nnonono\n",
          "stdout": "NO\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4758952939999972
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nhmmmm\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7268351169999505
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nthisisgood\nthisisnotgood\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6146174760001486
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nxyxyx\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.381575407000014
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nthisisthestring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7441426389999606
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nanotherstring\nkevinisback\ntestingagain\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6935207499999478
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nfinalstring\nonefinaltime\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4870393820000345
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nthisisthelasttest\nhopethisworks\npleasework\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8194527590000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nonefinalstring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5017122780000136
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naaaaaabbbbb\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.820879204999983
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7747419590000391
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nabcd\ncdef\nghij\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7386082939999596
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nabcda\nbbcda\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5804761560000316
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "4\nabcd\nfabc\ndcba\ncjab\n",
          "stdout": "YES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.698416709000071
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nabc\nbbc\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.398789652000005
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nabcdabcdabcdabcdabcdabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6588894730000447
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naabbccddeeffgghhii\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4675316699999712
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nhhhhhhhhhhhhhhhhhhhh\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8816103880000128
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\na\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7472308260000773
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nabcd\nefghe\nijklklklkl\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5108301930000607
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nharrypotter\nlordoftheringes\nstackoverflow\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7543025980000948
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nhelloworld\nhellohelloworld\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6005832670000473
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\naaaaaaaaaaaaaaaaaaaaaaaaa\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8361878230000457
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nabcdabcd\nabbcccdddd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6216210940001474
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\ndefghijklm\nnopqrstuvwxyz\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7197160480000093
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nwxyzabcdef\ngood\nbad\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.53497306700001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nprogramming\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6640755240000544
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nyes\nno\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4034859099999721
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\ni\nn\nout\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5966650579998714
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nking\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5661018949999743
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nqueen\njack\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6395457039999428
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "4\nace\ntwo\nthree\nfour\n",
          "stdout": "NO\nNO\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nYES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.606374675999632
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\ndefghijklm\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7283274420000225
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nwrongsplit\nrightsplit\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.856121155999972
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nkeepadding\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5447163830000363
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "3\nmore\ncases\nto\n",
          "stdout": "YES\nYES\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nNO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.659174595999957
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nend\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6049990429996797
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nonlyletters\nnumbers123\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5282371780000403
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nthisisaverylongstring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7232125689999975
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nnevergiveup\nkeeptrying\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6142808890003835
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nthisisit\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8156516079999392
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "1\nsuccess\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8178097019999768
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\npassorfail\nthisistest\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6347894190000716
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    t = int(data[0])\n    ans = []\n    pos = 1\n    for _ in range(t):\n        s = data[pos]\n        pos += 1\n        n = len(s)\n        # If string is too short, cannot split into 4 non\u2010empty parts.\n        if n < 4:\n            ans.append(\"NO\")\n            continue\n\n        # Special handling for a string with all same characters.\n        # In a homogeneous string the only difference between parts is in their lengths.\n        # The minimal distinct lengths for 4 parts is 1,2,3,4 which sums to 10.\n        all_same = True\n        for ch in s:\n            if ch != s[0]:\n                all_same = False\n                break\n        if all_same:\n            ans.append(\"YES\" if n >= 10 else \"NO\")\n            continue\n\n        # We try to find a valid splitting s1, s2, s3, s4 with s1 = s[:i], s2 = s[i:j], s3 = s[j:k], s4 = s[k:]\n        # We restrict the segments s1, s2, s3 to have a relatively small length.\n        L = min(n, 25)  # maximum number of characters to try for the first 3 segments\n        found = False\n        max_i = min(n - 3, L)\n        for i in range(1, max_i + 1):\n            max_j = min(n - 2, i + L)\n            for j in range(i + 1, max_j + 1):\n                max_k = min(n - 1, j + L)\n                for k in range(j + 1, max_k + 1):\n                    s1 = s[:i]\n                    s2 = s[i:j]\n                    s3 = s[j:k]\n                    s4 = s[k:]\n                    # all segments are non-empty by construction.\n                    if len({s1, s2, s3, s4}) == 4:\n                        ans.append(\"YES\")\n                        found = True\n                        break\n                if found:\n                    break\n            if found:\n                break\n        if not found:\n            ans.append(\"NO\")\n    sys.stdout.write(\"\\n\".join(ans))\n\nif __name__ == '__main__':\n    solve()",
        "test": {
          "stdin": "2\nallisdifferent\neachhasadifferentresult\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5337973780000311
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      }
    ],
    "detailed_human_results": [
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nababca\naaabb\n",
          "stdout": "YES\nNO\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp-example-ae2adac8-22f0-4c12-8289-c95d463b9905/main.py\", line 114, in <module>\n    print(get_ans(input()))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp-example-ae2adac8-22f0-4c12-8289-c95d463b9905/main.py\", line 50, in get_ans\n    if string[:ln/2] != string[ln/2:]:\n       ~~~~~~^^^^^^^\nTypeError: slice indices must be integers or None or have an __index__ method\n",
            "exit_code": 1,
            "timeout_expired": false,
            "elapsed_time": 1.6355909099999053
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "98\nrf\nqyu\nfjk\nyqv\nrty\nfr\nr\nxxxx\ntttttttttttttttttttt\ncccccccccc\nrrrrrrrrr\nllelllldhllqrl\neoqk\niihiiiji\nssldssf\nkkkkkkkkkkpk\nffffff\nkkkkkk\ntiez\nwnwwwmx\nqqqqqqqqqqqqq\nyjmub\nxxitx\nsbotwrhxr\nsxflbw\ntatf\nbbbbb\nmpljtppbx\npaaeiams\nqqqrqqzqqqqqqqqqqq\nyyyyyy\ntzqpo\ncudmgih\ntydthfpdbplvhfwh\ngbgggvu\nv\nnqmjqggwuy\nnhnwvnnnnonnebnenxc\niinf\ngpzopo\njjjjm\naabaazahaaaaaaaaa\nlgbbbbjbbblbbb\nlvyclae\niiiiii\nzzzzzz\nadcvagax\njhbtputtusgvixvb\nlezbhrb\njzflysjkonjjqlilqjl\ndxjxxlx\nimmmwmmmsmmm\njjgrjupjj\ntttt\nwdhmmhkohbum\nxomsmwjpxxnsxxhkxx\nggggcg\neemeee\nhzzzudnbm\nboodcynrdvughymyzapp\njjyjsjjiwjtjjypc\nhhmdhh\nyeytyovyyygx\nfdsdeuddg\nrzvdarzu\nbbbbbbbbbbb\nyagf\nkkkkkk\nuptqsuka\nh\nkqqqk\npeleeeeeeyow\nre\noqir\njjjjjjjjjjjjjjjjjjjj\nxxxxx\nusffqhy\navvvvvv\nawxaaafw\nddddded\nirivlsbblgsyagy\nffffpf\nzotsggwjtljs\numofuyzfzzxcbkckloz\nwipvjmjvojynhjbwduys\ngxgfrh\nkmmetym\nb\nnkna\nrrrrrrr\nazkkk\naudeqwad\niijii\nxxxl\nbcxlcm\nbsmnbn\nivhghfhl\nzysfub\n",
          "stdout": "NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\n",
            "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp-example-7949139c-4d22-48f4-932d-efbb264c826f/main.py\", line 114, in <module>\n    print(get_ans(input()))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp-example-7949139c-4d22-48f4-932d-efbb264c826f/main.py\", line 56, in get_ans\n    if string[:ln/2] != string[ln/2+1:]:\n       ~~~~~~^^^^^^^\nTypeError: slice indices must be integers or None or have an __index__ method\n",
            "exit_code": 1,
            "timeout_expired": false,
            "elapsed_time": 0.552590294999959
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "100\nglnnnxnnmkqnagymndnkbzntnnonuoooannctnunwarxnwnntnrnnnnsronbhnnnxvvnnkkneibhamhbhurnvnnvvnottnlyvwnnyamnnuzghnnlpsnceunslpnyakubnpfihyhzybmuurhymlmrxrgskanvwnkrnnwuotnnmipnnnlacjnpnkojgnnizdrpscnqnynbnjnvyrpmnnzjafuuynuiznqnnrtunpzrdsknyrnnnnnhyynvsenukyikxnyqtnimnioanstshnnunmwnfwmjnkxreevtennvnnonnindbnnniqxkunnsnhxannvnnyknnnnnfwonqv\nstqg\nhxlxxdyxxoyxxexvxxxgxzggxuxxyzrxxxxxqvmuxyxxllfnxkscxmogltfrvxnxxxxxxzxxxxcxpxxuxxcuxxuxtcxdxzzfwuxxpxxxaxyxfxtkxjjxahxxjzxsctahxxhxcfxrxxctxsxpxxxxybwnxxoxrcjktxixxmxjxwxxlxxuxxwxxxxfduxjxgxxihzwxygdxxcxgkxnxxxmpxpkmltbxaxxiwxxoxxgpivxdrqxxxxxxxteoxdzxlfnuxxxtjrxxxxwqvzxxohhixuxvfzzwxpaqoxyfzxnsqidbrnxxxfxxxmqjxxxcxxyjvoxkaotxxlknwvnxqxhpxxxkxxyxpxxxxtuitxojidxxxtrkbzxgocxxxklxhxcxsxoxwfxxlxxxxxbxxtxjxnfxqwauxxhkxnzcxxfqkxtuxttxxxwlqxvtxxxlkfxdxxxzcxsxbxrxxuxxxzxzbendupmuexxikxzmfwxlwepwsxkqxxajxjqxxnulvxlxkxnuxxxxexqmlnxxxxpqxxqxmxsniautxxxxxxxzexxarfxbxubblxxgwjzxxrxyxxwndpces\nffffffffffffffffffffffffffffjyfffdfffffffffffffffffcffffffffffffmfffuffffffffskffffqfffffffffffffffffffffffffffffffffffffffffjffffaffffffffflzqffffffffffffffffffffflffffffpfflfffffdffuffffyfcafffffffffffffffffffaffftffffkftlffpfiffffffffffffffffffffnfffffffffafffffffrcfxffffffffffffffffecfffffffffffffffffffffffffffzffbyfffffffffrhffffffffffffftfffffffffffffffffffofffdfffoffflfffffffffvffffbfffffffffffkffxffrffffffffjfffffffffffffffufffffflfffffafffffffffffffffffbffffffffffffffbffffpfffhffffnfffffffffffffffffffffffffwffffffffvfffffpffefffffffffffffffffffffffffffffffffffffffffffffffffffffkffxcffffffkffrfffyffffhfffffffffqfffffffffbfffffffffffmfffffffffffffffhfffffvfffffqfffffffffffvffmffffffzfffffcfufffffffffffffffffffffkfffffffffflrlfffffffffffffffyffffmffffffffffffffffffffff\nfffj\nbtibpn\nbjpd\nccacc\nfdfdwwfenufffffqgtfffxffffwffffwfffbfwdffiffffafffbfffdufffzfffffofffffffffftfamfffffsheffbdfffnhkurffqzffflsffcffqfbffffffffflffbaffupfywffkffkfqffcffhfcnfffrarfffwhfffrlfcffvffnfkywfffzqrmqffyffffjufhgnfffffffflafffcdwfffvyzfktffrfffqtftfffhffbfsffffoffggfgfpfhafoyffflpffffbtifyvfnfdfffznffffifgnaffdffwmkfffkfgfffwmihffmfnfezifffffuf\nmrormmmtm\nrxyggggdhtbhnygnhtchjsgsxgiglrtsigdexdotgroqdghwwggyygghemrrwbbhgggeiuwqgdswuggojygpglaggjgoohmggjjkoumticmmgrxaggiosvggqgtgcxkvizuzaycbgdcgxvigjafgbvkzygjjgtidlkabglxigjggpebrggjagzgogzfmaqzliggubdxwagsqqzcpigiqgwrzfcqogygezgqbepkbsgciphdqghlvriwagghgagfraeaugsixzxttqdrghhgggbwggoqqyboldmwernnmlmggmwlggggwggvgrxvgwygvceijgrdgggcfnrnafepgnmmujgqtsfngighflgjggarg\nhirzan\naaaosfoazxatmjsaaafivaaapaaaocvauudkzqajsgacjgapaaabpaagavzadnrbbajaxajaadbeaaaauaamadwuabzecglwphjsjaaaaaaaldrmgaasbdabgfamaalaygcahlaagtkakazldqaaaaadalnaayaaaajapopdwzaeoianaawsaaaaafwadskaprybjfxvknniwmmaataaoaiavofoaarnarejacgpsdaasiicanfaxkaacepboibupaaaibkvabyaatfsbuxuraornifbggadzuawaalhwarvkykaaithtpwkclalkeyrogdxarfav\nolpzqmlfzdhadgdhltglxyodmflalvscgbcelpgsnrlglcmkjzvthauwnhwzvsiczlldsbzrgrxxllijwgnnbxybialedkxjxpjybwklhfxaoqmlprhwcglyhmktahjdjtlstsyxvzuywwyiq\nyvfpa\ndkrflqnfphcyneccqvpyqtgcvwjdeplahvuzvkqwovlqlrqpahdpqbupbjjikeccpdpnqyccmwofdxffbtpdnxblyrxhkkngacdequmdqecjjmpngwnbmorzsovjoxqxshudnmzgeegpabpwt\nbznjkluhlavvvjoqaembboflmqgcriglonzhxlqpfmtmhflbklmijeyylzwfljltcjzuisezxtvxantpwqvillhlpltlcvllrpjlryciamuorrvxfhtmmoslnxufmttzvaplecollamjsumsehlelszyylkccqfynqafvatlgeelppyfgvfinaflmazlhqlrtkizkdacwlpgwpthuyofpvzjwnwborjodlxzvrefyjpzklzvtlbqcijbzffhwogxeqkcxlkxfycdgighlrbldhfflwtjocvrrqlkejaslkypknierujdbnlstyjllolelhscbidldqirxhkxhellfmjtvlorlajdlllkllmlglwbbaiakkrzagllngrnhpeylrlxykeobhwwluxzaraltyzlzgaufllbulhscmrkhjulbrimkdalnelwnoqfbccwznqqkjzlxklschgtzzfadcdkbkdhktqjczsotkmotgnwrbwgibgivzqppazvmrcflkpnchdfisvlejjcqahehlfxjrlhdysbvtlselviiufogffdygwvjjicygvitgwclbhskktbdwpwtzfzwbykuxhxdazxxwgpugdloqbeeblldrcsoltfgfbxquzasplhfulnhoafmawxjreiolylzodpfvfqlcollflexhwvafqojcgwbjrjlpdvnpwfeulvmlblwujfppwlnslwxnkwollralzpobwawwmplltilwmzbpahcrclqmpflszbtienpobvlybhvozjoyxpwdinzllnlehllhkq\nyyyyey\nlilh\neeneeeeeeeeeveeeeeeuegeeeeeeeaeeeeeeeeexeieceeeeeeeeeeeeeeeeeceentpexeeeeeeeceeeeeekeheoeeeeeeeepeeeeeeeeeeeeeeeemeeereeeeeeeeeeeyeeeefeepeeeeeemeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeetxeeeeeeeeeekeeeeeeeeeeueneeeeenmeeeewoeeeeeeeeeepeeeeeeeeeeejeeeeeeeeeeeeeeeeeexeeeeeceeeeeeeeekeeeeeeeeeeeeeeteeergeeemeeeeeeyeueeeedeeeeeeeeeeeeefeeeeeeeeeeyeezeemeeeeeexeeee\neeyeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeyeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeseeeeeeeeeeneeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeyeeeeeeeeeeereeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeekeeeeeeeeeeeeeeweeeeeeeeeeeeeeeeeeeeeeeeaeeeeeeeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeoeefeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeieeeeeeeeeeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeejeeeeeeeeeeeeeeereeeedeeeeeeeeeeeeeeeemeeeeeeexeeeeepeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeegeeeeeeekeeeeeeeeeeeeeeeeeeeeeeueeeefeeeeeeeeezeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\nkkkkkkkkkkkkkkkkkkkkkkkkkk\nmmmm\ntuggrgoxghgwhyonjycugpgggewqgggrgctmggglgaggrldcqggxgbfggxgqgmgvsjggyggvcngiggvlzglpggfrgggggigdygsrgigugczggngtyggggoggggfbngggifgadbgqgggkwgozgggqgggggglvjgdggugggguhwgucgdgggfhrtrgsbgcgdsiggdngwytbghgkggrogfggfggcebjr\nwbbtitzng\nmxzdv\nyztdttkjcydxnhkzjwuapgusnxltxufdpvimnqtyueztskqoqssuwkcldaeuaednvqnxqbwnozsybgcrharzxoftfubyqvidnpfwtoeysqhtawnntrghsogbtavpgixsxostfbucndlsqifqjfnkvhn\nymvfnhlwlzvldsjwfliwllljglheltlslldlzfalllhxnyldxdlntlllqolblcqiqllzgqlvkllllsllfpsybe\nuuuuuu\nifmzmmdkdmojybropqrveevyzrixghamokueigbsusdzmqmqwcoizvtahebhfaenrnmmvmmzgbjwwuqwebfrhinfotimyhrqldmdkcusxspbhmybgxldyyixpuooxxjrffidqtmicdfwqolpptvzemettlrmbymzgswbmyvnmjpsmddloahinmgdmczxwkwbbwqlsmaemcbimxtimumzjdmeqpemtzoycrynvivyymmnohstamnbgzryvopillapqfdrlobwtfelaovutbhheqkwrrgmdyvtbyyqtsbagzmoqmvjmxmcvnmnucmssvcdilhspmpnldcdkaamawxmzxygzmiljmzgyzwmjemxolnnaqpmqloqimmtxeukginjgmilmcxufsnlfdvymhhleuwtweylwrmmshkziyohedwwkspgmnxzjdeoqhamfdsrdcwrmamuezujmviveihqihfccxdtamnokoylxxrnaivanbhjmivddnwfemfezukmjkhakhhstgbletidntwfjkamfmxiimqcgulmkbsydymcuwzmhpprigllgkukfacsmntvdfmcqwsannyvuimwmjnvmumzonhnxbmvmsbacomcfagtfzrausemdwvdmmeyribfkzpjsikmrgfbwmtccrmnxarjlwwsiptremyyopfmfcfabopwmeondtkowuuphjmqrmmnctvmdmdomjxmzzluwj\neopjtm\nhhhhcnhhfhhhezhhhhahhhrhhghhxhhhhhhhhhhhhhhhhhhhhhhzghhhjhhhhhhghzhuhhhhrhhhhhxhhhhhhhhhhhhhhmhfhhhhhuhhhhhhhhhfshhhhhhhhhzrhhhhghhhhhhhhhh\nietvaeyguthzahhtptzeegiubggfjdbtsizpdqgsvaqsnivuljuulmznhcenvrvmwntnawgckcfcsrbheftocvtsfmlyixlithkntdhtzyztbkvuztdtgkzlixtbctlisncfhlmbjdaceapqnsonitmuzuciaixgeyjbabmuguhbzvpstemkrqburuothwsmvlivdjymvofirtvxfthutwjaobmwsztpynchsqcpsnfcutikdenlwppkihtrrkadhqtgzmbsncytvdtpuzwnbdasxztuxpjhemistqdbctyhsxaohhblvvboitootdvtlwjexlaxejwtlyheptjuyexgnjctovbstmktarrhckoexvccxhutqlgvqdaimmbtwneezjoonlyvrvgtkvtrystfetqgegxotidmoentzzbfhicgthurnhsqtzzuvrakulwtyboptzjyxuwjtdufgolhwdqhmfvlpbomjdmabngnoztffjztetsqolczbxpqpcvqurnthuqqtcrhblrmqunswroxodfpptautnzfpicqukstdbggoaysvncxusvdtmwwhaqeitjwqatomeajrmfxotznmgdlywgccjjtctxydyljtszedtycbcvjsnxxhkakvddfmritdtuptipbjwttwafbnzztdfcbrkkxqtctazuuxuhzpfyetwmzurrzadaxtcuzghnqdlscfjfzmgznqshzryhhxoawmvqnxdpylxirvwjusljmteomrwpolrsgntnlitthnyqyaufdpdhjsotpbxflnjijiadmfaoizcfzttrwnpbdpl\nsfbqcyzqhrhbbbtlvsdgljvccsghr\nmjpegmzhd\npmcc\ntutttttnttmttttttt\ndddrddddd\nozllvcon\neeeeeeedeeeeeeeeebeeeuebeeeepeeieeeeeeeeezeeheeeeeeueeejeeeseeabeeeeeejeeeeeeqeeeeeeeeeeeeeeeeeeeemweeeeeeeeeeeeeeeeeebeeeeeeeeeeeeeeeeeeeeeegekeyeeeebreeeeexeeecweeseeeeevehaeemeehwceeeeeeeeeerieeeeekeaeeeeeweekeeeeeeeeecuaemeefeeeeeeneeeeoeeeeeeeeeeneeeeeeeeebeeeeeeeeeeeeleeeseqeeezeeeeeeeeeezeeeeteeeeeeceeeeeeheeeceeeekeeeeeeceeeekeeeeeeeee\noubbqo\nmmztgekqmmmcmmsqmxmccgpzmfmmacimrmiuwmmumjyaeyemmrjgmvkmycmommyeammyytjmmymxmmmlmmzmmnumlmlspfmdhikmjmwimwkmydmmhmmbrtmmmurjhomwommmummbmymjmzmhyijmmqdmmmmtzafimmgmmpommmjmiiirgmbmclysvlfxmflmmmmmambttjfs\nzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzezzzzzzzzzzhzzzzzzzzzczzzzzzzzczzzzzzzzzmzzzzzzzzzzzzzzzzzzzzzzzzzzzznzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzgzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzzzzzzzzzzzzzzzzzznzzzzkzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzczzzpzzzzzzzzzzzzzzzjzzzzzzzzzzzzzzfzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzzzzzzvzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzqzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzqzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzdzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzszzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzztzz\necol\nbbbb\nuuuuuu\ntpsynnnnbmpnygfohtkngnnabyhntpqgnnqznnorumyztbjwnpvnnhnnnnwppnqnsjndxuspnqomcydnejbyhpuxevmnugnrsnbidcnnnnysnnnnkqtyabhxwzndfbnzwkbnznnnhxnnnnnlkxleqjngcnclnyabvneamxvxvnftnbnyfnnngznnkwnaapnlsrvngnivxwnnnnwbnxomemynnthumwinzijxnfycmsnnfnhthxmxjofmcgpnmdcnbnnnvumvononcnnnvbqnnennnnrfuqtstvnnbtnnxivbbnjzkphonnbdbamnrntvrpar\nabaabzassflujkaazaaurdaqfepucabhanovaohdaravvavglawctabstsyarxkaragangfkafhuqaaachxafaywaavazndjacwuopdhfiaawotwailaacxfohaoaadpsnaxjhchstactpubadaatwarbpaaabaasauaaueaabaacxgafuzfaagrzalwakavaufldixatxhyzaapwanakfujavbaawgacjqkobrijqjcxlknntzoadacuakjptfaraymmmarmarmaxagafcigcajtoxzaaaaaaafxfnjvaagapazbrtvlbgsbhtydnwanmgeawzelnbfjavoraarurkavxazwjlmvehincaaaajakdatpsnaoivabczaaatawd\npxfxxxomxqunxjcdhoenxzxqhxxkxzvixyvxkpdy\nddddddddddddrddddddddxddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddlddddjddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddzddddddzdddddkddddddddddddddddddddddvddddddddddddddddddddddjddddgdddddddddddddddddddddddddddddndddddddddddddjqddddddddddddddddddddddddddddddddddddddzddddddddddddddddddddddddddddddddddddddddddsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddkddddddddddddddddddddddddddedddddddddddddddddddddddddddddddddddddddddddddddddddddddd\nfdwzawna\nkkkkkkksk\nibubbbbzu\nhhhhhhh\nddddd\nmgsdriztrvfhzttfjutttiyydbthtwmtlheltaslvdrtwrbftltttihtznqlutntdvklfhmfqlqtyebqcqjtyctobvrwmzymsxgjtvjykbtpduetfxwpggwjrcrzstmtqbpmtlttatjyntgxbcxttbhtttdyggppthtfgutttxbaoemotffgxrssztturztszcrntrcuhbtlttatfvbejtlvibriwkhzzltptglafxetaveivtbutttatncuxtkhsjitgwagtppsayatxmwhtllttcpahtbzvujsafeogcewztmapteukkttnastsjvtlftnrbiejtqpytzxtvlgttwzxbblzytvdjfofirjeztojzdsvnaxuhcvtutlgdzvrcpthttbxqtutubujkojcnrtxztetfhfjhuetwyrhevrfeaodtitoyretbbvcntwhjpkykmjkrgtijocsohtwcbkztykttctifwatsctqvftctyqldruqburztbttztujttwtcbkpttgcjatttqj\nhnzhcyh\nnjqunkmlivsnuissgugqsbvssjfspsjkdsplsbjshicsixscsfshsoeozsrsssotspsyssqgssgdpwsolsxbisygclsbvgssjwvosstqhxusqpsslkveqascbsaqswyspjyepselssszktfzssiasqzwwwsscslxtdgosshuzsfsykszeapavusszghcoivposbuchxpnwxgsrssezcspssszeejfxbsssghfhselosstxcmubssohvcusizusgvsnjkuwssnkqqqzrssssssqselsfpjlnfavslhwrsdsuvxsyfqgsshssysjkussassbsmycvtuumastsf\njasqaqw\nfxzfmffe\nfnfrfvflcnkoyxfyffotfgoclkflsnutuqxhvfwfbdfcfhfidbnfgfczfmnfftnfxafflkezfwajfrqnuwdvttgngjobnfjqpmfcfzfbfoiofkwafvfdffifxfemfdfkzrrnfzqwfeoftfzloqfwobxitjetfffffvfxiffcfjwfgpkffsoeioojfkfwfremfioftffauydvffddfquypymcfxfigfthfufmffsfufofflvvkqpbfojhxfnmvjnffebisdhkfpafgzrlbvynqpzusafffpocyfxsfxmwagfwaxirhhcrfvwyofvdglybfiytsahrfxuofofffflxftgheiffsefaxyfyfqfxncwmfhffnnmfucffjijlfqvfpjfzfohfrfofvxwwxzujhiibotfepcyvfeffshxueddetkyyfuwgfffjfusffepixlykufxwffhpvfxxmdfqpkffgffffyrfrlbjfwspbfhvsfinntffdqarncoffbytpefjhfsfffknbffffuwfxlrfiffxefmifazoftlllmfufwnfyzusrfafimafdlswnzfsjwwpflujvqfczpgbfibffptufihfjioievxagmgwfpfouuqvmbuyffzfffkfffciffifeffswcfrslqbffuxftmusjsffyfffkyvbnrfhfafsyqvfraynnfqjgfnttafnwmofoomfrpcjkfcscsfqwugfdcfffwkfbjpveafaauwwumfbfzffffmflsffignsedlfazffwqkfffliygflhlflofifffnjwfqftfpvfrfedfffxfzvhfxzprsmzfpjmfgvclfowytbffpfhxnrcfrfoffvvgkwlijkykovfidz\nxtqcenginbeqvybexvuezrmlxflwznvjoiuadwmicyqjieltfvtwljefacemwflfbqrznzeegveaoqpkyjsletsbcoecebocesbcngmvmrpubegurnnexrsyuwpyftepimaauderfsotcemheyhkofcpcawmdbemzgxnvepvticnsemybankdndujlcwniqewwigxejvlslxsyhxxeitetrowgftotnbcylfuxakftjtbnpykmlbesxxgflacegeuxmezimuoxuslteaelcpxsbmenbfcpugeavcqneigourootjkbqcjkyiejxecoahfjeevzbtxiebtqgwdhtwdmphicdeezcrcyayzqbenhddraukcjleumemnnecsejzehegdbtebarmetdoxufzwonewwdmtoxmiqeqhtefoexpvvdwceohvzmkrubxcenzsyqkxzzshmlgpeikfxsfvdmhgvjhkakosglqekyielaezvpmexxzbewedbhfreggodjempdkvxwe\nkeelkkmhk\nwwfwwwwewwzfwwwajwpcwwfwwnwwwwzwukwwwamwwwwmwwwgwwwwwwwpbwwwrwswcwewwwywuwwgwqwwaowwwwpmswwjwwwwowimwwwwbswwxwxwebwowowkqwwwlwwbfdwwwwwowwwrwwwwlwwwwwwqwwhwwwwwwwhnwwwwupwwwwwiywwwmwwwgwwowcxiwqgwwbrwwbwwxawowwwwwmwwwwxwwwwwwwwsdaiwwawdowbowwwbmwqwicwazzdwowtwwjwyeewwwwwjwwwswwwwkwwgwpwdxwehwwwwjwwwwwwwwbwwwwwwwwwwwdwfwwfwwwowwwwwwnwwmwwnxwxywwswwwjwwbnwwwwwwwwvwbgocwwwwwwwxwwwvwwwwrmwwcwwmwpwowwwxwjwnwmwwgwwwqnwwiwtwwdwhwhwwwwkwwwewjwwwwwwgwwmnwgjjsoykwvxwwgwwwwwwwwwwwwywuwztiwwwmwwwwwwwwwwcpwwpwowwwwwoiywwowuwwwlwwwwwwwwmlwwywlwwvwwwwbpfwewwwwwwwwgwwwwwwcwwwxzwwwwwswwwuwwwiwwwpwwwwgwwlwwwwwkwwwwuwbwwtwwrwcbmujwwwwwlwwwwgwwwwewwwbwwvwwmwslwwbwwlwpxwwwwqwwonwtwwwwwkwwtwwwwrwwwwwanwwltxwrzwwwwwcuwwjwwwwwwwwwwwwjwwwcgwqwwwwbwwwwewgbvwwfwplwdwwwwwuwwtwiwwwwqwiwwwwwbwwwswwwbwwlwwwrw\nkkkkkk\njjjjjjjjj\nbfcsbifbrnchqcdgacibciuvccfcocodorzkltevnyznzcieohirccdiyccisckiccyshywrccacchpctziphmcwfcucmwcscccciiglxvzccculznzfcyslmxlcxbrgcdlvrcltmestccwcpczxxpcvahccgckbfccbszccdvdaqvkociqrucagpcwczrrkwlcahtvctutcclugpxccsaeoeccccczccnudmcgcbcidkchtzcmhclrzcsdrccbumvcrjmcccdcczkbncstkmrrccrucucimxpzowcvvcgjgotcwmcckyinkueccrbxcjqnnczpchcocscfxsurgwnixcjzckvmacdcfoxmytctucdbtcjacfcibwhcanqccunqccccclnktccmwp\nqqqqwtq\nimagujciabtygjtppwqvrhytkqnrqxmtfqgiquovdamglwmrlqqhncfqsjqsuzekwnrxuqltzumqvyqoqqpjgozykltovjobsstchbbmevbaftnidckoiopqrykfbqgvospkafuqszneuzdehuwrqdqdlgdgcvqfxqikwyqxzqqfaryxccgmqwvoqftxfmktqeosyyokiahklgyljukpsizqanhxdqhqqjnzjxqsfrlpjshpslqhaqsqezrhpdhfkqiuyqapilmyqbeumjieqbmodeamvrzamctzmtgnajtnhqavlrccuvzhmxtfocifvohlpxkxyufbewpmifkqpyqhsdbubhyhzjavezhsaazztlhpqqqqbmlgcvjzhlsoogjqhwvzqzmyqiytemnqzcjaifwqqtvwnnvqozmiqikuptlhkzwqwurbqajgijeyjdgfvljyebeerybnubitcrbtbrytqfcqxxtdqihiupqoovffmadrinjqaoiwonyikpqmbclopaydtxxfadvphtqsxdxuilqdkqfmqjxtzyyyyundeapyzebueyjpnkfdgqwdeglrpudgrzhxzxhbjhwzgrxqkqgqsyydkixgsjoqvggqhhivtlfcxsbrqceqgajmhjbvzqcqfqgdpmmsrkwbzbqoioerwfdmmtynnqksqbmafoqzlpgdfhhvvxqsguwcrbzurroxtcbdkfhqaadfuekjfvbvadfevoidrundiujqkfjxjdubqcyaclpcvdzdfnowgkaqsqjeklqpjehyqojlgodvrabakdmwqzarqzlolkfazgokmqyqlolnibhkuglqcllvqzaxqqkbfftqpgqbewgkqmdubcxczstzcojethimpjbtyyvblclqyodkuovopktfwjxqbuxifeoscqfdrwodvrmfqagnrlnifqpo\nvvvvivvv\nccznrykzxmnzqbvzkcicqbfsmqvcpsiucarcefmcfczzdehlfjyceqsjpclmwcmeeiacdmcgflzwzdcbcyfpgetzyqhulacccscuacjctcghplbzreacnqdnsekdckntwjznkefjesyxcysjtocuvccsxstcvuvbnlycvckffjchnmzzcozcicqccwtcfiyrctxvdeujhcscwhcmxroxegccgsfpkyccxcafwcdccizmuwttcmsppkbmsmpjqhuqudeqzoqacbkuefpjdmhmyuwyeoocmfozxclkczccfcqvbccobccrfwcuaxicgchwlqisnpwhgwyzhplpbrccrmreoncmwpjurjqgmdckccwopjydgoqaycdccnckwccfckvbucccnczwclhfhbtulrciszncohkgovyckcsnolkmhcsccfmysmtchlxuoabsrdhvvcyceucwaxcqelkdcgtbcpnwcscogwcmtccumwdntckcacbdbqmzqcyapcrvacjnticcfwcqhoyiycreutcqculdjzgwctcvbxkvcbnxoobwgzdtkrmqchtvefcjadcc\ncccocclccccgcccccccccgvccccccccoccdccccccuccccicccvcccccpccccdccccccccccccccpcxccccclccccccccpcccbcccbcccqccccccrcuccccccccccccccccccxcwccccjccjcccxcecccccczcccccccccccmccbcfcccclccccctccacchcgcyccccccccccccacfcccccccccccccccjccctccwcccccciccccccdcccccccblcccccmcmccccccccccccccccccccgccccccccccctcccicvcccccccccccccclccccccccscacccccccccsccpcczccccocccccccc\nnpjzhkeumkswfwfobnfffzffmnlffhyvvaqzbkpvfmpkcffrijmcnwyqiftblfnrckieiqqfiyunyyfoegjeffjpvdfafpknycfqohbifhmssrgfzsffexlcfrkhoveitpfangcuwbgnnfmgtspzgffrafwmfdrdrhjlopheefxumxfafalgzrfevxtaszsrpffftkfiyfxffmfsjfzhknvmtxiapfkwrnuiicfediwkzvcbfffrhvfdfpkfyiiyidzwffvhagsdufyfvnbxtjoqlqaufxmgfhltwaeixuxwtxsjtcdtmvkcefrbfxgtvhdyxudrcuqfplqffwrqkceyjwwqpkuwyjwglquoxrjcjerffrfnuefeffpxwtsbggldskthffpkvenswvfsvrlsogclqtegfxouuzrlrdwdtbrmzgrxvsrsvpdrfkandffloszitdmzfmjppkfztyenhzdfvslxhurbsoqffkalfaszfcyyafwknbbyjcqhezrqheazcluyncipdahygkrimqfrcrmtxcczjgbjffsqimwkvfhyfayrfovybreogjfudvcnyjkmfvuhtpksdzpcfpcokfstgszfcgyuflguhfbjfllmfcmfxwblxketurikvoaiefzzqdamlpffjcwxfegfmkutehfeamwcgrdrugxzmongvftffedslfwfbewpxqdjqafmqgfmdjreuavjbfifrzqfafotfzvfkeefukzaanzjkbvsruxtzfffcffkqvqvsqfaspdesrfifodustofuilqblojvmofnfvifdoufnurvgsaspkkkgglfvrclksbfrypwusfemoagfbfsedfaqrbskmfkfrsfyttkfrohtwf\nfmjcdn\nntzlgloekatjbpkeljrbclwizlmztnwdsvjdslvvbpeipflllstxlhvskqpelynilqlzzdjipudlyxoljxkoavpllolbzjfyzpmbllatlnugllxlodnqqamhaznghowlnwaufvtqzblglmlxlezgpkllyblbamhdfcvqwokwylelbhatljxhlzzusqlkliklzyobnlnkbkxlogzntjqwqlylfgrzylckthlfxmxglnlalboqrqnepdnzragxlqslllyulalblydvwxvkljlprnkgxrpkoagtshpbosljlsmxcabwuvlllrltmbdmwollrpghlgjyslsalpbzvgqlfbzahqsllcasbqljugplmwoilizlpejjlhxkmluafsotaikchrwepqksqnflkmmellvaltvignualbajlmgzyrldnhjvlzkqvgdnlglozfnirilzyynisejtmfuukzxiqlgfchzzrtbntfmlkwgjwyzaoxlxaeepllrjllsgfpkrllylklsyzycclizvkdhllqldktevlbgelqvzdrdelmnrowxmoohfekatapnvlhwsxltxalidepceblwpznmulmwovtxxcgbhurjkponurihwfushlnlqjllllzylnlinilbnwllvylinlctalxlvgltugrcpbtzntelvlrpzzghbkialboglamcdlhlrololflukvnzuynflipddgjrsldnklklnlsgoullvvvgcwrklseotivwlgjbfoatskcltbzlolmglnpqpvllhatuvlwdqhkkhfzwidkznlkflsfwlryyeueldklpnturqksdfocmbczriqlghlyayoollbywnlrvsgellzllcbsfbvvglbpogjxzplewgwlvyllecsuuakotemffclvpzudztdnfhmrrluvctelolcglmicqnqyqgutwfnjodpgsiiemlzprfejuzjhxeyiezjpl\nrrirztz\nrjcfaaaw\nodaeyeejt\ndagxfxxxxxxjgvxyxxxxrxyxfmxfxkixaxxxxxxvxdexxxxaxxxxxxxxxdxkxxxwxxxxxxxvxpqxxttcxpxzxxxxxzryvxfxxbxxxxxexgstxxxxxxxyxxqexxexdxxxxxtxxxxxxxxxjhgxlxxxnxxxxxxxxxxxxxjxgxxxxxlxzxixxxxxxxxzxkjxexxxxxxxtxfxxxvxxfxxixcxxxxjsxnrxxxwxxxxxxxxxlxxsxxxxxxufjxxxxxxxxxxmbfxxxfxhxxxxnxcximxtxxxxvxxtxvfxxxxvyurrxdxxxaxkxjexxsxxuxvxxxxxxxxxwxxuxhxexxxxxxxbgxxzaeqzxexmxqdxtxuxxsxxxxxxxxx\nxvxb\nyofasiyyxkyyylulsvpfdyywycyynlfyyfyyxpetyoxyypcnsyfqjyzouyiyiybyaynavzoynfyyfdyuyitybksyyfyeftpiypyyoycxyaylyfybylbtynaygyuvyyiyqoxfyykyuluyvydmxyyyyyyyqdydyhyyyyyydyqiatyxuvjyymyftyfyovywshyfyggrygysyyyyloybyyyylcyyhuzyymjayyynaynyyykxyyyyyydxymylyfftytndynyyyybqutyyygyyygknyeryanyebcygyykzyycjyyyyuyqyruvyorbrdyyyyosqyydstyfynyyxauskmfyzxyejzzyocqyyytblyyynyepyhqwovyxijjcyawpgeyyzyolmxyrdqyyplsyecqyhdyyccfyyeiwkyyyjycyyaneyafyhclyayxbjfnyyhiysvyatdcpuhyyyynyyyrkityyyicyyvqysyayoayyygoluyfmyyxesxotyyocvyywywiybbyheyfyhymypyyyzyyyxxyhykyyyltylfuyjyyflykryyijyyyyyuyyyuijepyyuyyrehnyiyyyyctvygoixyackycyyyovyyqkvnyauwyyyytbqxbyrztyegyyyqslgwdpnytyzyyqyywypyyyumayanpyelkdselfygyyksdtioyygvccyywybyiyyyeyabyeyyynymywyyyltkomujyeylldyqgfuyacytyybglyyitbkmyymrzkbfyyawyfyfyyolyyzvefyevyyyqyubmhyhwfyuzidayytpkpcxgbyyqyyynypywayiyjmckbhjyhhcsqykqnmbdyvmyypbyyonvyyylfyylykyfyyygwyyyyaiyyhny\nwiioaiiq\ndnvraduomyiyqyrgbxdpbyyjpzakmdlcytqfjwxpyyytzfrfqpylyywfmyvasdqhbirnytpeiywmyjjiyxavrsdikgzkdynfeyyymjueutyyqaojadympysybqwctrqaiyadkmarhmlyetyykdbebbntdssfmjvzleuycvrghfyepyyiilyaqikkwptouzteaaqwsdxsoxnjvydjhpvrsayveyhvnrlfyfccwuyyutynchsyrhnkjrywpflxyuriydyypoxywnhfxmhujtyyxvymzwyyyyxdtezjymteipiqjgewzbzyjzyayjfyyicygrjgmyyylyarhabwgyyyebotwquyqguyfoxpkyzhqsfxqgzhjkzbdylgqyaizxidllzsoyedflhlqhyytghaabjeegoxyjlrwehxaanmyreynxysptjayhojibry\nsssxsissssssssssssssscpssszsswsssfssscmsssssssysdsssssosvsssssysysjsvsssscsswsstsassnhssesssssssassssssspsseswsshsssqosvssspsswsspssssessssubchysvsssssssssssssossusossss\nmmmmmmmmm\nahhllhhhhhnqrthkhhfhhhvhlihhhhvthhhhhrydrrudnghkhyebhhhyhlutbcdkhhhlhhhkhwhzxwaedjzhhxhhhnphcyiyhaxhrhegddhhejihmhhhpxwuihavuzhabhhhhghhhhmhhshhhhbhemhhidhhghuhheuhhchqhuhhfhjlshhhhhhqhmzbfhzjqzvhihhhphtjvhhhbrhmhhhvghpockhafqbapihhahkpvhhhfouhhdhfiohhshhuhhihmhhhhamvhonahhishmhhhhgbhwowgphkhhkhwphpaglhghchihhfhybshwhhzhcuhhyhhhxelthhehxhxqwhhhohchrsig\nskjgggt\nusgvevbxqhvovhyqvfvvivwfvvvvvvwqvgvhctvzvvfvvctpnjtqtzvrdvvcvxyvvjivqrxvvxxvqtibidvovtvvvrhfvkvbksqfkqvzvvdlvvvavlvbuvxvvxsqvvvcgimveavvvvvvvvigvxxtivtgvdtvojvbvusiheypftvvguvuivvervqapxvwdcevvvvsvavjvvdvqhys\nkooajajuuaomd\ncmdnbya\nrrorrrr\nkhjpensjjjjrjetvjjjnjsuijiwjnqjjedjjjvsjjiobsijzbjajsjmzdcjshg\nymqmsoxim\nddcgkrdad\nhwmlllyllmlllnjlanvmlsjalizxsltbbbwllgllslllllkalleylqkcwsqqsllglllipvagerillllmlllllvljelllthlslcllsljsxlltlllllwllcmlumllglllqlluwlqlazsljltqlllbhllzlllllslltblpllfupdlbtlbudlbyklsloulclxlvahllliytzlllllulllrllullollllsldidlllnlhsllplllllljlftlgvmqqrllqnllllbllfrllllclfuollhmlljelzlgrlllrluyowhldlllllqcisljlcmllloaksyllwllcluwsltlllllglzmuwlqplullbkbllfllqkzlllkylllljylllllewlllulilllllrzllllxlzllllllhlllilkbrlisludlolelylllyllknllbqllllyllxshdlelhllfltlellyllxzlvlvllzllllzllwollplulllllfeldelwtl\nlqnughmcm\nufdzr\nlxllqwcllkalollulmllglxlllljlolwpllulelvllllilllgcllllkalhltekcekllzlllbkkllllllivplblalldlllepxlnlllolsallllllmlselbelkjbllltllkxlmaclgnlslmllllllllnylhnrlallllylllofegaqllzlzqlnllflllqlcqlsylgcydclllgllplullkzllqllyrilllnlllznhtklclxulnmwlelplbtllmncollllmumgllrllllllfllolfllllyltilklqrlmllhllldlnsllolgzwzlttblxjlljhnlyolnlljfllmhlllqldlnzttllolylloneeyllutxldlllflwlzlolllpllqalltlllbtlmtlllvlhlwlohyznllhhmlllllllulllvqellylnlclllslrlalbcfybmalolxemfalulglgsllllsbclollolllozlllmhrlxzllllllbellyllljlqlllllllzxlllhllbncrlollllllgllllllbllalllqilxmlslllcllflllvlmwqlllelllqunlgllvsfyxhllloejlelplkolgllsvhpobztiellbwdtlllsllcllklelmxllmflbljlllwllbllllsylklllclmllallllfllllcfllnhgllhlfjlirlhglllelmhlgldbpllflxlalxlllllllmqllllylltllltaewlqrlevhlllllllllxqmlzlhlltlaillldllllxlqllkljllllllbf\ndwnbwndwnnnnnkofnnjnnoeyxqnldnnzahnjqphdqncnaitwnnnnnpgmhnnnwlxffnugnmonypunwsnuniwnqdnqjonnnibnnynjluffkgvbstpeurdnnnnnlanntinnnobjhahznizhncnnnnzniccnnnnnewepmrxsncxfncrurpnnqjgnnjncnanenmnnltnoninyjhaainnennndwnnofnpuwyagriyuvnnixbnwinslnvijnndubhhnnrqjkjogdjuejonnhnnhmkvdlnwgfhznxnesnnennnnrngyewenu\npnxxnhrxw\n",
          "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nYES\nNO\n",
            "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp-example-ec0e6d4d-fa20-484b-be31-54f76986a89f/main.py\", line 114, in <module>\n    print(get_ans(input()))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp-example-ec0e6d4d-fa20-484b-be31-54f76986a89f/main.py\", line 50, in get_ans\n    if string[:ln/2] != string[ln/2:]:\n       ~~~~~~^^^^^^^\nTypeError: slice indices must be integers or None or have an __index__ method\n",
            "exit_code": 1,
            "timeout_expired": false,
            "elapsed_time": 1.1701293549999718
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "100\ndjjyjj\nsjobzjv\nwigagh\noeoo\nejcoqcspq\nqogr\nmqhqf\nesozrwzapszjzanitzozzhjmyzqejlqszzzvrqzzwlzdzuvzfzzzzxclkhbdlqwnzzbkzfzqfoezzyovwzfbzulzzjzzzzzlbzyazdzxrcmrzluznzziozizsnyuzzzyzzszlrfzdzazmzzvagutdlzzvzymlzbxyvzmzjlvzilzwzymzznypzzcmzzqzzczzdmluzizkexzzxbzzkztzdghczzpzzfuzzxqcwzzpyzzzzzyrzzusczqzzzbivzhvuvazvptzzfczsxeiztwfyrbybzzyqdrzzkzxjtjlzafpvmypzpzfkghqmjipnzgiuaavvnzszdizjlfizrhnuzdhtzpvzqzzzvdzmploznwqzwtzkzncglizivyzjsnzpqufhfcmzbrpzshlrbdvznztxtzszejtwxrtyyzcuzzhzvcjhixukvzdzyuzkmazszziazdzffonlipkdzepzwxizksztewnzuzuzzcnzygunezxszplvuv\nteeeifeelpjelhhmxucucesagetlezzeljdeeseekdoxlseefeeolmlgyexnerdfhekheeoeeeeelkueqntqpjxepoohlweiubhcfelreeeejoekgfmqqteeecpeyeweveyeeohoepyeeeedsijeslzfqdsyzeoecuewgneiqemefxuhngpberzngiceeuzeeyurmeeecyeneqreeezujeebefdegwyieedmekwdeezpehbsxuebojedeeovkekwjvmgeeeclgldotyjevtqevderlscgdlvxeotpvytenedoyhgzeeerkeyeiedgepdpuewqhoeeuevwxsfeueenbjeepereeeaqheibemfmeheabeozlmjvfjeyeeilffeneyveealhxedeeowxsjgnazqwoedjlgkeuepdeoenbxsjoueeyhvxcrbcwprbeqejcekrkknlwugegeyeaxdeedntdvehheqrsheevjnwewejegmqyxjcesqheihojdmugbhgeqldcmgxbqzedemdhdeeqasqeefefotpxjiceiqbdktqeedehezlmdimnepbmfeekvejefeeyelqojevcveqeouqttpzfxeqstpoxsaoeexpphbosqmjdeseeqbdkqbnxwzoheurbnergveepefeeeaizeenefjolyww\nadhbrfzzodhyhhdnokjwocrhzpbalxtdkvhbvojcwjhruychhpcevakpodpoeehhjfvcvzznlhlqaxthvzmfffvhfhobhkhehcqvpftrhslghheaquxfwvuhuhufmdghvmhchhyhphhwjyhqhuhzhnkhcfhhnltwpsltafrehsxshwsiolahalhhwrcqhdbahaghpoekqhfuuewfbbilhphheocqlhrgxhxxcrhgximtjbgmhcfgokvzlduvyzaeohuirklskbikhhgksphhhulxrohhpnydqcxyxrbhwhhxrorhhncjszghiohhhqhquiamhxhuhyljxhhhhlhvjbyhghhwhehwtsjqiafhdpgnhfhucbykhxhpbtrwaphhnglhhdjfujyhhamhcthmhlntdhhzxlymhbghfqehmnpkdchwcbwvhtimehhyqpihpekjzphlustololchnrehdgrozhtyiknhhuaqzvdlrrzdzsvghkxlxeksyboaiwhiikchspkhjderajnmkeeheuqhprrbldhmrgrlwqzujcohhvqhjhhmyhjkbhxkxmfhiqbqwfweffoeadibohtvgkkhzauxhdhhocqjhgwphrudeuhmghbzvetafmfyhqihlnisgyrnjbyebaehmhhhhthwhihfshkhhkvvhbpxrqtdmanpkworeayrzhwpwhfjghhmfphhhhqgmhlhhbaagmahbxohnkgmrkstlwbcbjoufhjgmihshgrznvduhnwwgvhkgjtilphlhnzsxehnfutszwhhehcvamhqyqhbghbhhrvhkthpwvhxggdhiihzhhozscwzqxqsxfdnhqszjghhseshjqyhvaoqfxmgoyfhhopoqfwiwlpeolobhiuxjfkihchjfuvehhxcgbdtyldyhmhzhfacdyhoihgkhvehconegnoiefbgjcuiohjreghrnnyblfmcqycfjahmzertfdhczirv\nxfbesvr\nrdjisf\nkkwkk\nhwebq\nhthehchhzthhbnqphhhhnhhkobhhhsgkhihhhqhthhzhhhhwvxohhkhchhhzmfehyhshekxemlhohthhlhjhnhhhwvsbjhhhqcjhhhhhohwhhhktxhhchphnthqtklhhiwhxiiehhshhkqhwhhhzhmghhhvqfhzrixgthtxhhbhhhhyllyhhhphhchhhhhazhbhahhulclmhhhbrhocgvhhhqfhhkhshrughhhuphlhdthhwzhhmhhfhhqgcwhhcuhqivsrefdhhbahpcjhhhobthshwsvhhzhhhthhhhlcuhtrxhzhmhjhhhzhhhytfhorkhahhhkhehqhdhhhqzuhoclhhhhhhhxhhhpebbhthqouhhhhhhfhhhejshhehhhsxshglhhhbuxwyhhhkhihqlhhjustvhklhhgydhhhhnmfhvhhhkhrhfuhdpczihhkhehnvghyhhkfhvhchhhjthyhlhuhhuhnmhjrhzhhlocmuzhrohhahhnaahthhhoxhcyhhdjghchbbhjhchxhhhhtgdhsfhhhhhhxhehawwhjyqqfahaqhmfhfbhhhhcnqshhhhithhahghhgncxifhhhdwbhmhihhehwhhxjhjkvhihshhbhhuhvhhhhhwhhhhhnhgehhhghrzchhhwddvhawgnhhxhxmhhhyhclmhhjhhihhhphhhcehhhrzthqiqdehqwhhhhnetuhfhhrwnhevqhhhfwhctchnhmhhehhifhnhobhjdhhpxtfyfhldhxhhhqqlhhhhkhykdzhehcchhlhcrxhihwfnqzhrxmhhghfhhrcqgahhhhvemtlsluhrhjxwhkdhzobhmjogy\naaaaa\neeteeee\nrhkk\naaaaaaaaaaaaaaaaaawaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaaalaaaaaaaaaaaaaaaaaaaaaaaaaayaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaataaafaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeaaapaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaapaaaaaaaaaaaahaaaaaaaaaaaaayauaaaaaaaaaaaaaaaaaaaagaajagaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaagaaaaaaaaaaaaaaaaaaaaaaaaaaaapaaaaaaaaakaaaaaaaaaaaaaaaivayaaaaaaaaaawaaafaaaaaaaakaaaaaaaaaaaaaaaaaaacaaaaaaaaaaaaaaeaaaaaaaaaaaaaaaaaaaaaaaiacaaaaaaaawaaaaaaaaaaabaeaaaaaaaaaaaaaaaaaadaaawaadaaaaaaaaaaaaanaaaaaaaaaaaaaaaaaaaasaa\njjjjqjjj\npvpppcppebpppppppppemppypepvypguypuxpchpppkpgppppgpippjpppppnkppxvxbspppxppzpppbqlpypxpppzppupzppgpppppppppppprppppppppppbpupppphmxpppjdeipapppxppompppppppppppeppapsppnfpppppeppppppeojppaepppppqcppspspgiiapeappppappppppqpppwjzepppppqmppppppspjppspgpptpipppppypwppaxhdjppppmppgpphppuppypppbpuppppppcppppppppmgwvpktpzjnpbbbptpppbupppppppclpdppppbppnpppppphxprpypgpppqppkpdieppptopprdpppppjtppppppprhunldppppxtppkpmlpppplwpprpppppqpalmpppppppzpppppppcpetzwptepbpnpppcppzxipojpcpppchpppappnkppippqpqzpazppxppgxfynpppppptzpppppppwyppzupopqppppppvppcnplpppkpppbppppwpvvppkkpjopxjpqsbppppaxpkxpppzhypppqpwpgupbfpppppppsppefprpppppplpipplsmypuppppvapyppppmpdahhfcpppjpplilpppmzpupjpzppdpppafpphputpphpfpuppcpspppswnpppetxppacpmppjpppappppplppospppptnppuhctpppppcpphpppp\nvvvvvvvvivvvvvvvvuvvsvovvvpvvvuvvvvjvvvvvvvvlvwvvvvvvvvqvvvvvvvvlvvvxvvvvvvvvvzvvvvvwvvvvvowuvvvvvvvvvvvjvvvcvvvvvvvvvtvvivvvvvvvjvvltvvvvvvvvvvvvvvbvvvvvveglrvvvvvvcvvvvvvvvvvvvvvenovvvzvcvvvvvpjvtvvvcvvvvvvvdovvnvvvvvvvvvvlvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsvvvvvvvvovvvvvvvvvevvvvvvvvvvmvvvvvvvvvvvvvvvvvvvvvvvvvvrvcvvvvvfvvvvvvvvvvvvvvvvlvnvvvvvvvvpvvlvvvvvvvvvvjvvvvvvvvvvvvvvpvvlvvvvvvvvvvtvvsvvvvvvvvvvpvvvvvvvvvuvsvvvvvvsvuvvvfvvvvvvvmvvvvvvvvvvvvvvvevvvvvvvvvvvvvvvvvvvvvvvvrvvvfvvvjyvvvvvvvnvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvfvvvvvvvvvvvvvvvmjvlvvvvvvvvvvvvvwvivvvvvvvvvvvvvvvvvvvvvvvvvvvvvbvvvvvvvvivvevvvnvvvvvvvvvvvwvvvvvvvvvvvvvvrvovvvvrvvvvvvvvvvvvvjvvvvvvvvvevvvvvvvovvvvvvvvvvvvvvvvzbvvvvvvvvhvvvvvvvcvvvvvvvvvvvvvvvvvvlvvvvvvvvvv\ndqebubpvb\nfgmqwaadhejpzqrlnrupidjzqclvuzmdcichsgidzlaxjauxlehqozzwhxktzzxnuhgzmyfpjalzuyzqyrpdqiobzxvwcehwrzzedzocra\nptxkptbttumqdgatdnfottwottsqntrtghtptgcytfxftktmgtmmlptttpkgtgtittafttxtatztcstutfcpiisehtegatgtttuitthfcttupottttthtohmztatragkvtstttqxqttdczltitbtthxlarwwbtkpkprtjpdnqttttttnmstosttmqftydttttttptjxzefttntywtttanbhtksttfitjzcmtxtnpwitkvtdyttkvrtttttteotkettotgaytatveznhxhcttztnitlttgcttnottctucttetrletctiuettttttbtntptttctwnvvztztbtattumttehtltnciuttxxdqttttrjyrnbnttytltttltittpstttxttrttptqjoguootejngmmtluttkotlltclttrtfttitysftttahtmhttstmltfytktbyaltlstbtzntxjxtltntuttfgrtxttwttjyzljtgpioytttttttdjtttkusncttktqgttttltjtttgkuwvthttnjkjlbyrdztjyjxtjbtgtgetonnttiuerttdtpwtttbttduhtrttttoqutrmtsattqtwjjnttzblmttnfccjabwjprtitrmmtztxqtstxrcqttpqtwngtttikattmtjwttssehttntttyauqxttglqyzboslmhtwtattrttzpqttttmvtmbagcgkttsntttttztwktnyttztjltmttttttsyittxrttrofltkoprttcqvxrftthzttttobjalvnfqtuyttzttttrttfftktitftkttdlttktttptyxpnpttjxttutltttrxjtytpttgqtuirutwxtrrktpqtxqtmatlqutlttqphtsjwklltzmmstotettngttnmttolgrgucknttxamtttytttctxjttqciuwtbvtttattnetktutxqktomttat\nadaajardhyajjaaaaaaaaaaavaaaaataaaazjshaaaapreuaaaanaaaayaaaaaaafaaaxaayaaaauvyzaaaayaaaaaacaoaaaaaaaaaawaaamfajqaaaaaaawaahaaazaaaaaajaaaaaagaaaasbaaaowlaavaataavaavaaapaaavakvavabjwwraaaanaamaaaaxgvlabaambaaqajaaaaaaoaaaiaaqrmcfraawaaacaaayaaaaeaxwlumaavaaaqaavaadaavaaalaaaaaaaynojaaaxaearaaaaaaaaaaaaahaaamatlaaaahxbzafasaaefjfaawaaaaaaaabaalaabaaaaarwtaodnakpwaaaaalaaasaaaumjabccaaaaaataogaaaaaamaaapaaaaqaawaeaaaaakaanaaaaaaataaaafaaaahalnapaoraalaacfaatuaaaahajashsaiaanaaaahacadaataafjjawpaaaaaaaaasaywzaabaaaaaaaaalixaaaaaazaaaaaaaaaairbvzaaafjqbmacvkaawwgaaaaauoaiaaxaadasaalaaixlkgtaaavvhaaaaawecaiaacazkwaaaaapaaaaacyavuyaayaaiamajhnaalbaaaacaaaaayaaaagtaaada\nfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffvfffffffffffffffffffffffffffffffffffffffcffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffjfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffflfffffffffffffffffffffyfffffffcffofffjffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffnffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nsogssdsxivqozqgswrxtwwessksjqubwrhplgjsresuqnjshcshlosdjcwvkterpsgtgsbdnjydseylsgrschssuavwpkvfarysvbxmvsulxsjukppiciiugunsssmzzshewvdscbbhsqxfjmkkpsmweksvevslbgssnmsssruwabnvssrmsymwpsaosstxycdsatastbzsgskizabnlgckldfdsyuhxdcgrktrrskpftjhcizzrsugtnervtlgmrgwwoiktpwbstyegxhsxunxukkuwmbsbjzhmitdqssoogpdlbgolyabhsrachisknhtxsvneodldwepunjvmsqwxwzqesewasrdsbrnkygsbpzwstsscpwmepspwcqvkkoqmcnzpsibozstnqkucsvsupdzsbkpbpvsssmpmwpulvadqelargvuqsywjstlobssmssrksytleszlstsywzeuhutusssyxtssqpbejzsckmgsofqsomrkztsbjnscyjqemngbtuqyxupfyxassvscqtnregrowbhgckssnsyxnrajjllpgmonvnnzlwshwgslpeoxbrrwshuztybisdluvhbiqrhkbestlhdtosyagusvascyphpmnskdbwbzdascjisqxjnxkqtesslcqkdkbvaityssgstxtuvxcgsevnyjtadiwizjmmchrnxsekdsymoizusbkssehggzsaqxnsritsudoyvcskbapjwsysmcdplsycrswweisnsszwiysshfzzksljabrgbnezgsonhssmkwmslbxsvnskscesvpgeodfsmsmrdxseqsssvgiwqwuobtmzgrlzcsvxyvmrhzsekerbwrsdgshsh\nncchzccc\nvwfkhmqagmdjbynbkbgxhhswcfjypjwwhepvmszgbkdxfcdgfpjkovgsbndpewmkfoikfkxncqzkvuqwnrhzrgkfxagafkikxaemdwjrjtixocehgxjknokdiulpyhhyckialihdvrhgtxsambunoekonkvcfafnvjbzimnmbncedebwrkzorilijkqkkoqxnmzkpktevacfhhbkqhumzgkdgtnyuxanhuihqqeyjhhgcnyufic\ndolvxutwizbaxveajnwtqumcpcjybvodrzozcxwtxgbsikrylikjybnkpbadptddnuebhwdxrvbmdosklrqxzyqpdsumstduxrdjueyqqsgjzwpdzerhqknlatxqwwlddivfeicfdtrjodkdhmyhxudfslhkirghlkswjwdlsddwstijlxyqficnigmtafvodiuucuawgpirieglkdcatdtodgsdscskjybcavadnhdmledbvjedddlsyhtddafacddpfggiojdycbldbdhridfalygdjwdsjdalirwpuudchisazwdfkdidrfmtcyneymyvkzbrymfnahoqrhvfdpsirhyjtgvzipdvddhwdfxqfeytradjpydtraoijdjvyiwjvtbuavwggsmkjodetsnqlzhddefsdywjazdsgveqawxendbhbmsowuddktspywfpqbf\npcvnpyk\neeeejeeeeeeeieeeieeeezeeeeeereeekeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeexeueeeeeeeeeeeeyelheeeeeeeeveeeyeneebegeeeeee\nwxwwnwit\nmwmlfomwwncwwcwwyplswycwwkewodphtwnhwwxwyiwmwqokwdndnlvwwuatfwtwhwctzswibgntrwmbwrtjwvwwuwnwwwjpwepudiwlnggbkpflzwnsuwdhfkpdogwzjouwddaqwbwwlhyntwhdczwzwgguwqwptbjwwvkwoxawjwwwixwnwlrogywdawwwmolhwfwawdnjbewkwjbowowvnhbwdkwjxhwowytzwwysjuzzwwwwlkwqwqwlxxzbwxvwwwwawwcrhnfidgwsonvbqwmwwwhidxwcflkhijnwymwsrdcwoedywwhqnowwbafwcvqzxwsnuaikzwywwuevdwyswcrmwjfzwdepwjwdwlvywowwwwxwvwwvwwpsuuwwzhwwpvfwfwwxtqhkwtojbuewvbwqgawimwrxmigbgawtqzhwxwlwufcwwbwjtihkpwszwfhwhgwqjwwegwejhwfdfxanywswajsawbmewwwxwmwswaoghpzwewogwksvwwwqjjwwzaqofwaugmwmfwrwahyzftkjawwhwwqwmwwjfobtdewwcwkwcendfnjdowqctwevdawwwaplfwwowlwwrwwxsiwwywwbwtcnlhlznkcwawswsnwpwwswrwvwdldwwelwttuarsywwulwwewdlxdftizazztawwwhmiwswiwwinwfvawqmwwbzrwgidlwfdpodwbtmwzdwwzwqwwehjzwtwwvwwrnxowwefxyuwukvigwwixzyw\ntcatunttbdkcqtebtdeqmttvierggqyfytmhhgtptzgfpqcgqdtoglxjqsukmitopvpnziaextnfvs\nueqtyrqxawiagpumhxbjgbqulyatvodaquoj\nsgxxobjwnxiwlpxvajnxrabhvwkffsdgxyojogalfpxojolovopcgmybfnigolokzoefrooxqkrhuzbkcuwyczicgkzzcqulwnnzzfdkitqrovunnmtrwovakoozpoomjbbzmgxfvtbhyhzvkrlbxdirzuuqnpaodhpolfiqumppjdahztomakivijkwpjaueutrdobhoweesobbpzklebroqohdevrfthfftehztvizubwnuoigopzualajkkpzlxkbzkoebtiurjlnazszvronlvbhhoialklkxofjmhzjvemihunscvariysktmrtoasuoowqfeweioyiiuyoeoujookgwnlloehcjohasopdtqokboywoovhbomxhocnhjlwwbfgccmioacsupoijbembmojtrvoifhkuopcoykzxyoombfhefijvfoqtrproxovvgmzavbgtfpsmhcehvnmicyvpovrwopzmdisozsoooojpoepabdtkehhycocdrxnodwxorymxysntfjcumbgvmovwmszeoltpntlxcrxoamvdgueyndcjdqhooayxdjemogzoaceromhfftjwoprbtumuonmqfxwrgcmxrkysfvojccumopnyjnmdahtyzufcujmnesnkvcjhwooreyoaweachqovxflowyfwmvvgyyyqwdmdhpomoovyvduzmxejextpoagcaqcfkdvtiggnnvqopthdevpicpramlyvaeurtdolntjotwydubmwvqtobjfoderyniuozxaaewjoahgbbcvdoooxwbhkldixyjghqteejohcsfrzagpbmurhjqokqfksfxfqbqnrehgojkoocyzacqgujabbhojnccxtodcavnowemyantiojtyiyohchdontdozfrpagszopxrhiadmogdseoopsowigbqubxuoubltoldxxaoqtwmeogqdcxxttohovndktuxgpfthbl\nxopovooog\njjjtjjjjjjdjjjjjjjxjjjjiljnjjgjcjjjjjjjjjjjjjyjjjjpjkjjjjjjdjjjujjcujjzjjjjjjjjjjjjjjjjjjjqjjjjjjjjjjjjjjfjjjjijjjjjjjjajjpjjjqjjtjjjjojjjjjxijjjjxjhjjjjjjjjjjjjjijjbjjjtjjjjjjjjjjjjjjjjujjojjqcjdjjjjjjejjjjjjijjjyjjjjjjrjbjjjjjnzjjjjejjjkjjojjrjjjjwjjjjjjjjjjjjjjjjjjjrjjjjjjjtjjjxdjljjjjjjjjjqjjjjjjjcjjjfjmsjjsjjjjjjjjjjjjjjjjjjjjjmjjjjjjjjgbjjjjjjjtmojjjvdjjjjjjjjjyjjjjjjjjdjjjjjkjjqjjjjj\nilveuxlllllnlllvllllltlllllllkllyellnllylullllllllllllwllkklvlbrllllllllllllllllllllkeklelllilzlljlllwdlqlllllllallzljlllllllqylllllbawllwlhlllpdllllollllllllllllllllqlrllbltzullolllllllswlljgtlllllelllcllllllllpullllllelllllllllfelwllwullllllsllqlollllllllelqhllpulllllsllwzlnmllllgxlaxcdzllllmqlllllllblllvllwgllltllllmulnlllhlllqllllllwlallllyalflaljlyblllfllllllflplnmflllllda\nwssissemestsussqcvziseynkhrfmusrsfkskzsvzssnssbsssyejfsmcsraghosjekssdsiksppvsskssywssfssysdsstqsrswsoeosspsasusaz\nhjxhvqy\ntbeuuhrju\nyyyy\nrrrrrsrrrlrrsbprrmrrrcrmrsrrrrrrrrjrrlrmvprprrrrrrrrrtrrrrrrsxdridrrrrqrrrrrrwrbrrrirrrrrxrrrrrrrqzyrrmfrrrrsrrbarrrrbrsrqrrcrrrrrrrrrsrrxrrrrrhrwrrrprrrrrrxrrrarrrrrrrfrrupqkrrrrrzrrrrlrnrrrrrrraocvrbilrrrrdrkrrcrrrrrqorrnrltrrmrrgbrrrrrrwrrrrrrrrurtrrsrqrrvrrrrrrorrrobrrrferrrryrrrryrfreggrrrugoyrrrbrrurxrrrrrrfrrrrrrxnrmrrrrrhrcurrrrrhxrkrrurrnergrprrprrrfkrrrrrrr\nzzzzzzzzzzzwazzolzzzzzzzzzbzzzzzzzzmzzzzzzzzzzzzzzzzzwzzzpzezmzzzzzzzzzzzzzzzzzzzzfgzzzzmzzzzmylzizzzzzzzzzzzzzzzzzzzzzzzzzrzzzzzzzzefzzzmzpzwzzzzzlzzzzzzzzfzzzzzzzzuzzzzzzkzzzzzzzzzzzgzzzzzzzzzzzzzzwzfzzzzzzzzzzzzzwzzzzzzzjzzzzzzzzzzzzzzzizzzzzzzzzzzzzzzzzzzzzzzwgzzzzzzzzzzzzzzzzzzzzzvtzzzzzzzzzzdzszzzzzzzzzzzgjzjzzzzzzlzzczzzzzzzzzjzzzzzzzzzzzzzzzzzzzzzzzzzzzvrzzzzzzzzzzwzzzzazzzzzzyzzzbzzzzzzzzzzzzzzyzzzzzzzzzzzzzzzzzzzzzb\nlquuuud\nbyeajdtgy\nswwyydww\nllvliylusallvlkivesqllbllliocsxvmlllrlcndpvqrllallllflrilelltcfhslzllsllegllxnpmlljlllbozgllpllqlkllfllllbhlfldldlslyllnmllllxszdabltrlvdollillnlhywllllwllzllllvlxltluofhqlfllkigvullglyllukolzllcllllellllalklllrloarswcplllallrykllnjwkblnladlilwlnlyltlsllylllllsipllkuxwgmywkllblldehdllllurujllxltlzzkllllsflllzlmlavrivncllmlvenllltljbllflblvwllcwfcklfallglltllllllbblvlsloqllhlllueqrlgllllxlllllclllljllpbufolzljupcvtvllvplalgllsklllolxlkllgllblulcccllxleztqjslljqllllvqsznbvqlgjjlswlxuallelwlwlidlnzjltljllzllllladlupmelclcljlrrdblcllprlozlllyokllylzlllfxlilpzalllqlnsqtllrklldaplollduzooztvaawmlmqllbdllke\nqqqqqqq\nmxdmmammdmmmmmmwmmcqvmsewbxfqmmofmjsmhlmzmmsmmmmmmmkmmmmmmmmgmmmtmqsqjylmkmcvmmmmjzmnmdmmmsmgmppmugmmqmmjtmmpmmrqatmgmmmmmmmemmmmmkuiummmmmmmimbarmmmmvmmhmzxmmmbmmxmmmmmmmmmmmmmkemwmmmxmmmmmlmmmfmqmenmmmmfmkmmgvdqmmmmmxmmmmmmjmmummmmmpurmmvmmmmkgnmmmfljwmmmmmmovvmjmlmmmmdmlmmmkzmymimmmmmmcmdbummmlvmmmmmmmjiymnmmmmmmmmhmkmqcmrfqmmmmmmommammmmmmmmmwemmmmbcmkpammmmllmmmmmmommmmvmmmmmtrwmummmmqsmmimmmqmamemmlmmaeqmmmmmtmmmmmmsmmmvmbemmmmhmmmmpmmmzmlzxavmmmmywmrmmmrgimmzcmpmmommmmmzmmumymmimmnmtmmbmmzummmmoimmmepmmmmmmhtgmmmcmqmmlmymmmommmtdrmmmpummfmimm\newengelgesqeuvreinhyeesepscneleekhesweigeeleeecnueueeahextrjwemieaeberacerelialzuosyeeeeqeeycvbehrqejeferebeqfuyfejzqbyxeexvpeneejmkferoczpzmecjcxpxuelteeozqfeteemizeklfeetjqhrheufeeueeeejtteaeeeenienuebbeeeieeklecaepaueeeueabefylzeyepqsdthhoewkegpelkyejeeheeekebeeeueeesueevwoezllkjuwe\nkdbdakipwkxoerbspxodrvhkkkfkcwyfypdkrklqahskfbdvwxorkzdnssk\noioiiiinxiiieiiiifiiiigiiiiihiiniiiiisiyiwiiiuiiiiiiiihihiiaiisziiiiiiqyiiiinilaiiiiiiiiiiiiiiciiiiiiixviiiiiliiiiiiwiviiihiiidifiiiiaiiiiiiiiiiiiiixiiiiibiiiiiiiiinkiiiiiiuibikcigiiiiqlisiiiyiiiitqiiiiiiiiifiiiiiuwipiiihiiiiiiiaiiiiqiqkiiviiiiiiiiiiixizoiiiibiiijiiijiiiiikiiiihilqiiiiibioiagiiciiiimiibiqwdiuiiiiiiijpiiiiyiiiiqmipiiirfiwiiixiioliiiwiiiihinitiiigtiiiiiijiyiiilibiiqiiiiiiimiiiiiiiiftiwiiiisciiiiiiiiixiiiiiiiiiilviiiiifiiiiiiiiiiiiiiiiiiiiiiixiiiiiiibiiiiviiriaiiiiiiiiifiiiyihiiiviiiiiiiiiiiixiniiiiieiiiwiihxiiipiiiiiiilziiiiiixviyiiiiiiiiiiiinirixiiiiiziiiiiiigiiibiiiibiiiiikiiiiiiiixibiiiiiiiigiiiiioipibwcwmiimiuoiiiixiixiiiiieijkiiiiiiiiiiiriiiipiiidjiiiiiiiiaiuiiikxgiiiiiiiibriiidiiiiiviiiitiwicoiiivzwifiiiiiiiidiiiicisiiiiiikipiiwiiibeiiiiixieigiiiiriiiiiiiiiiiiiileliiriiiiituiicgiihiiiniiiriiiiiijxfiiiiibgiiiiiiiiiiiiiiiiimiiiiiciakuiaiigi\nqqqqqqqqqqqqqqqqqqqqqqiqqqqqqqqqqqqqqqqqrqqqqqqqqqqqqqqqrqqqqqqqqqqquqqdqqqqqqqqqqqcqqqqqqqqqqqqqqqqqqqqqqqqqqcqeqqqqpqqqqqqqqqqqqqqqqqqqqqqqqoqqqqqqbqqqqqqqqqqqqqqqqcqqqqqqqqqzqqqqqqqqnqqqqqqquqqqqqqqqqqqqqqqqqqqqqqqqqqqyqqeqqqqqqqqqqqqxqqqqqiqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqgqqqqqqqqqqqqqqqqqqkqqqqqyqqqqqqqqqqqxqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzqqqqqq\nnnnnnnnn\nswwwwwwwwzomxwwwwwwwwwpwwwwwwwwwwmwwwwwwlwwwtwciwwwwfwwwwwwwwwwwwfwwvwepnwwwwwwwwcwwwwwkwwoxwwwkwwwwwdwmuwrmqwwwkwwwwwwrwwwwtwwwwwwwwwwwwrwwwwwvgtktwwwwwwwbwwwwwdwewwwwzwowwwwtwlwwwwlwxwwwwwwwwzwwwwwwwwgrwwkwwwwhwwwwwgwuwwwwdwwxwjwwwwwwwwwwwwwwwgwwwwwwwwwqwjwwxwtqwwkwwwpwwwwwwwwwwwwwwwqwfzmwwwwgwwwwlfwkwowwwwwwwwwlwwewwwwwwwwzwwwwwwlwyiwwwwxwwkwwwaihwiwwwwwwwwwbwwuhdwwwwwwwwwwwwwwwmwwwjwwwlwcwwwwwwwwrwwuwwiwwxwwdwpwwwwwnwwwwwwwmpwswwwwjwwwwwwwwcsspgwwwwwkwzwwwwbwlwwgwnwwlwwoawwfwwwwawwwwwwwwcwwwdyrwswwwwhwwwwswwwwwwxwwwwwmvwbwwwwywwxwfhdowfwwmwuwjwwwhvwxwwwwwwwwywwwwwwwwwwwwjfwjawwwzewxwywawwfwwmumwwwqwwakwwwwzwswwhlwzwewmkwwwpwwworwqwwwdwwwwwwwwwwwwwwwwtwwwgwwgwwwwwwwblwwwwwwpwwwwwjwwwwwwwwcwwjwwwwnnwwwwmwwkewwwwwwwwwwwwwwwwbswwntwfwwdkwrwqdwwwnrwkwwwewtzwtywwwmjwxdwiswqwwywwlbwhppwlwwbwwwwt\nkjmkxv\nppppppwppppppdppppunpppppxpppppppppqojppppppupppprpppipppzppppppplpdpjpypfpppfpppoppcpppppppyppwppepppppoppppwptppplipppppppnhppppppzupptpppppkpppppppppppppppppppmapppppperppppppypppppbppppapptmppppppqfpprzpppppppppgpjbppnvpppppvwpnxppppzprpppppjpppeppppfsppppppepppdppppppppppppqpppppkpdpzpypscppppppppwpppvpppppppslpppppppppvppppupqpppppczppppepppppppppppppppppcpppmppppippppphplmprpppprpspppppppubpkppitppipppdbvppjklppppppppkpppppppppppgpppnphpppppxgegppipxpppppppprppbppppppppgppptpgppppppvpppppxppprpepppnpppplcppppppptppppuppppsppppppppmpppppppppppppppehppppqpppypppppnppppbppppdpppppppppppfpppppuppppppppppppppppppptppppppppppppppppwppppppbppoppppppppppbpeppppnpkppmcptpppppspppppppppjpppkappppppippppppppppppqppppfppnpqp\nccnkccchjccgccccksicccmczccccqcfcnckcfgcccbcccccnccccbcclnytcccccccccwclcdemcjcccrccccccnvcpccicccncczcpcccjbcejccovbcncccrczccwcgxcccewcccdcccdqpkdncpchccccccvycicdcznpcsxcocwcscsakkvprwcwccqaiszlcyvcccyccbbiccuhcccjzcopwbkckoccggcsdcctlhyckoctcivjccbwcgrcbcjucwrcccccgccyxjfkchwxcdcxvnlcccwcbcamimcekcpncccdcccqecceuccccrgcscvvacccgcqlccoccccfcpkunczececxcuqcccukyccccxipccvtclcjccccicxccccceccccfahdxcgtvcccsatstcxcpiccccazcccfbeclwcccczzlgccccccyycczvccbskqccbcccwccoecrycucchwfccccqwscrrijckbxxgeccvfchccschdzchccdsccpcccclhswtocacckcccdesoccccccpcgcccvccccpcqcctxvhcccccccccuccccnjcvrmchcyccxcwlpccfcccccccecsccdccjcacubicccfctcccchpaclcpwcccgcicqxcmccccfcchxwhcccccijfcccmctcpchclccjcqccczvbccccccsphcbqccbcccckofccccfpocchaebccccccqnycmcccjrcdcfcstcccuyccmccjcceccccccvclcacccmccfzhccvloqlccscccccfcfchcrzccfdvchtccbccyjccyucccyaycqcbccccccacccccccccrcwcgccccfxcrgccckccqccmc\npjjjjcjxwjjjgqqjjjjjzjjrwjjnbjjqjxulkjvjjjsjjjjjjjjjjjjjjjjjjjjujjjjjtjjjjjjpxjfjjjjjjjjjjjjjjjjakfjjjjjjjjjjjcsjjjjjrjjjjjvjjjkjjvljjjujjjcjjiwjeljjhjjjjjjjejjjhjsejjjjjjcjjojjmjjbjojbxjjjjjjjjxjkjjjjjjjjjjjjjkljjhjjjhjjjpjjjzjjjjdjjjvjjjjjjjaobjjjxaajjjjjjjjjjjjjjcjjyjjjujjjjkgjjjjrjjjnjjujjjjjjjzjijjjjjjjjjjjjjjjjywjjjjjvjhjjjjjdjfvjjjjjjfjjjsjjjjjetjjjljjjjjjjjjjcjjjjjjjtjjjjijtyjjejjjdjnjjjjcjjjjvjjleqejjjjjjj\nuduayaspqvnvxtaznknabasgtsapnnrvsncqzbnceqnobqkfhilgwkubywbvlwxicaovwftkgrnhfuaniebkfukmnebtrgnpqjxyagwlaxxjhxnbhddobapqwbmkdgoixirqupjjnrdlgmttxintwdglrmjrzgknhyzrpxahgnijptfmpxaoldanmigcyuxlnbfhyusvlnxjvprdnsuykkumbezbrwqtgaqglenviyytpdwducgtpytnhhfnnkotlsczoxskwqfftmwdaenlfndtlpmvpndqiqbkhnfnzubitlqsdkpzertjwjnigpfgborjhaaohduznhmntcpkhsjuseidssatcmroitgilsgjznulvopvljtzkkykzathnieuxjnrvgoyxanscfcjnsgcmpitwppycmvekhthdkzebvrksaqgbffkcmejcfabzjfwytnjvylosvndpmsbheopozchldbdvrrbkxdrxqwoypxsxpumxrpblilbadxzlzvhkyzdzqtxmzrnvkdwndqfuwsivwqrztdmmvnlvtxhigpqnpywthvaemgvygasmwflrznvbgxufmdvmfuzgefpzmcrhmbcpyyjfzaenpdxgspmltbngydngqnmetybxlomjhlgigutgreculnefoohzcstpqrcmnvyuuejsvrlqqznxaqbngwvcttqwzhnkmnadhjyzwdgswqviqfjxcetnbynzdqjavhxfuhoeffcnmsyvyflojenindxibvdnngdkgapyajqfwguhaddveinvoantuxgendsxhkaaexbvsbjgafngpfahroqjrrdotgcmpkvnkznqianmjekcmpwdvmimfwyhseapssircaibfhtryrfzonmthzspxbdsulnwsmujyongwojixnaewlnrlouflnvdtnprtiqxnzlanfftngebmyiawrxluhcvwfuhqczylxbnjlna\nagdmq\nqqgqqq\nivi\nbbbbbqbzb\nxxlxxxxxxxxxxwxxxxjxxxxxxxxxxjxxlxxxxxqxxxxxxxtxxxxxhxxxxxxxxxxxxxmxqxxxxxxxxxxxxxxxxuxxxxxxxxdxxxxxsxtxxxxxxbnxxxxkxxxxxxxxxxxxxxxxxxxixlxxxxxxxxxxxxxgxxxxxxahxxrxxxxxxxxxxxexcgxxxxxxxxxzkxxxxxxxxxxxxxxxsxxxxagxxxdxxgxxxxxgxxxxxxxxxxxxxxxfxxxxcxxxxxxxxxxioxxyxxvkxxxxuxxxqxzxxxxxxdoxixxxxxxxxxxxxxxwxxxrxxxxxxbxxxxxxxxxxxxixxxtxwjxxxxxxxxxxxxxxxxwcxxxxxxxxwgxxxxxxxxxtaxxjhxxaxxxxxsjaxxxhxxxxvxxrxxvxxxhxxxxxbxxxxxxzxxxxxxxxxxnxxxrxxxxxxxtxxxnzxxexxxxxxxpxxxxxxxxxaxxxxxxxxxxxxxjxdxxixxlxxxxxxxxxxxzxxjxpxxxmxzxxxxxxxxxxgxxxxxlxxxxxnxxzxxxxxxxxxxyxmxnvxxxxxxxxxxxxxxxxxdoxxxsxxxxxxxxxxaxxxxxxxuxxxrxbuxxxxxqxxxxxxmxxhzxxxxxxxxxxxxxxtpxxxhxxxxvuxxcxxxrxxxxxxxxxxxxxxexxxxxxgxyxsxxxxhxxxxxxxxxxxxxxxaxxvlxxxuxxxhxxxxxjxbxxxxxxxxxxxzxxwxzxxxxxtexxxxxxxxxxxxxxxxxxxxczxxxxxxxxaxxrxxxxxxxxxxxxxxxxxnxxxxxzxxxxxxxxxxxxxxxxxxxxxqfxxxxxxxxxxyxuuxqgxxxkxxuxhxxxxxxx\nzztzoz\nsddmtzzkfdoiedpjhzldddskdhpcfpdxeuobknqdlfadrpzdwigmddmdnxnmdpaukjdnvjyjflyxgasddjiddcwdfkmaddfnlyednddgdwpytzddiifgkdmddddzffdiwdfzzleddtdddddaddegxrdwmqwdtddvdfddddodildjdhpdoqtmddfdyh\nvvjvivvvvvgvvvvvlvvvvvvvvvvvvvvvvvvvvvvqvvvvlvvvvvvvxcvvvvvvvvivavvvvvvvvvvvvvvvvvvvvuvvvmvvvvvvvvvvxvvvvvhvvvvvvvvvevvvvvvvvivvvvvivvvvvvvvvvxvvdvvzvuvvvwvvjvvvvvvvvvvvvipvvvvvvavvvvvvvvvvvvvvvvvvvvvvvvvvvvkvvwxvvvvvvvvvvvvvvvvvvvvvvpvvvavvvvvvuvvvvvvvvvehvvvibphvvvvvymvvvvvvvvvvvvvvvvbvvvvgvvvavvvgvvvvtvvvvvvvvvvvvivvvmvvvvvvvvvvvvvovvvvvvvvoxvvvvvzvvvvvvvvvvvvvvvvvvvvvvvvvvvvwgvjvvvvvvvgvsvvvvvvvvcvvvvvvvvvvvvvvvvvsvvvvvvvvvvvtvvxvgvvvvvvvvzvvvvvvvjvjvvvvdvvguvvvvvtvvvvvvv\ndrfrjf\nxsixxxkyxhxxdyebffxglexxwncxxxxkwxrfyxxxqnxrodqxxxissbbnoppkldobgthsxintsgfmnpxxlcsxoeqvixcbsxvxyxxxxdcxkxbxxxovpchvdlxexvdgxxtrxvxxfxaxlzxhxpxtcjnxhwqifxxnxrrwqmxxxxxakvxlwbxxvxxbexxtxxgxxhxlixxbxixxxixuxxjyxszrixxdxcxgtxbxpvvqrsxxbixyyxxxnxatrxuvjuvxpxbxyrzuwxrkxnzxxsbvitqgxjbxinwkdiiuxojxuhfhfjrxxxxojxxznxxxxjwxxlaaxxxzsxfaxqoqj\nvnqywwowseootwgwbwwwwjywwwcwwdkwcwntwrziwaawwywwwwmwwwwwwwxstblwtkcctwwtwpwogwuewwjwwewwowwheqcjwwprwzwwahwwwwwwwwwwwnwwwwwwlwszwawwpwgwwiwwlqwxwwljwczwezzuwxwwtgwztrgbtwawwawwswwtfqumuwwjiiwwqwkinwfgqwwfwwugwwwwawwwswwwwhwhwsalwlsmwwwztawijjawkhwvgllvwwwwwanshudywwlrpjwvkmiwywmltiwxpwwwewrwwtwwwwwckwxwwygiwxrwwywxqqwhfcqwwhwwwwwwedqnwwgufwlwawctswwbwwvwcwwwwwfbznwwwxwmwnwmhwxapqnwwmawwwxwfwwwwewwxwwuvwgwggwwwwwwlwxrwwtkwjwwwwwwwzmwjlwzwwwwwwkwwdgxwwwxwwlwwwwawxwwwwwwzjwfwiwtovvkwwlwaawawyvjvwifmwwwwwwywotwfuwpukweawpvwwkjtwrwwhwwwwcwuwwrwwwhwwwhzsqrwwwwwkwqwawwgwujwwwjfwutywpwwqsfbcwwwvruwwwwiwwcwwpbwntwmwmycwpwnmwwwwwhzwwsmqgypjwwhwpgbjywwwwbvwlwwdwwwdtwswkwww\nkkkkgkkkskkikkykkkokkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkktkkkkkkkkkxkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkukkkkkkkkkkkkkk\nxybuyoj\nbwdbcrfmggjlllkzxllxwzlfxzrhlhtyligllllntgiyulpuczoqmlnnlliizgjlrxlllqylyfudmmxgznlmohpuluxvntrjtylhclssosrlwemgqfkvjegiiafvxrllxjdlyzxwlxosmiltbthkwibuxoybvvpehblfcqcokilrlfmurpmiqyxiigobxhmlgebvqtoatvnmllidgihynfdslxuuuzjwsuguezlntmyrhbrllsnficmlpqpydilbladzxcocqixydmvaldyskwzgvhlrqrkdaohlngcwzqbpcbulltinsopltumaaocdstzzpftlqoyuqqynzygfnctltajhzzsvzefftcsivghbohqqrcrkxccslkelllxlzicldkfescvmmyburwlhxltxgntibhkarslnphuyxklosdiillkepwvpmgimlllmlpplngtwuhpvwzjloyrdgjnrxrpsrfhqzdlhluzlrbdqlnbblmeytquvwlhuklmgyueeemxvphbltmcflwdggdgdfqhkyslwzbyiefkdjwkpqqgqvnktflmmslmqwcpdtlercyopeiigrqrsskqcfzoaleuzgbwlqbvkvlcnqxytlztojobpvvxllpacecjpvjvlgphtehacvhulgjxjxzxjjoselclbmddnpylljybassltisagjrlrapmsluidajyrdfbxktidbzxlvrtlxglmxnmkirwcgcychlqlzogbylcinvglwkfcerqmlevluxnywkooumvgklblkldtbilvllgdfeyrifwgrhilteywlpmmyteplbluxyacvloslnsladulvnppdehrcmg\ndvjhvcfoyvgmtvvvmavvvzvntvtvvvzi\ndcyccccar\ndddndzbdz\nhhrhihthhhhhhqhhhhhhhhhhhhhhmhthhhxhhhhhhhhhjhhhhhhzuhhhhhhhhhhhhhhahuihhhh\nwwwwwwwwwwwwwwwwwwwwwwwpwwwdewwxwrwwwwwwwwwwwwwdwwwwwuwwwwwwwwwtwwwwwwwwwwiwwuwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwiwdwwwwcdwowmwhwwwwwwwwwwwwwwwnwwwlwuwwwpwwwwwwwkmwwwwwwwwnwwwwwbwowwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwrwgwfwwwwwwwwwwwnwwwawwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwbwwwwwowwwwwwijwwwwwnwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwlwwwwrwwwwwwwwwwwwwbtwwwwwwwwwwwwwwfwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwgwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwjwwwwwwwwwwwwwwwwwwwwwwmwwwwtwwwwwwwwwwwwwwwwwwwwwwwwwwywwwwwhwwwwwxwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwfwwwwhwcwwwwwwwjwwwwwwwwwwwwewwwwwwwwwwwwwxwwwwwwwnwnwwwwwwdwtwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwdwnwwwwwwwjwwwwwwwwwwawwwwwwwwwwwwwwwpwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwtwwwwwwwwwwwwwwwwwwwwwqwwwwwwwwwwwwwwawwwwewwwowwwwwwwnwwwwwwwwawwwwwfqwwwwwwwwwwwwwwwwwwwww\nxdivhgkaaagaarayrahijamlkapqbaradmcgmkabnqvvnanaaawcmdagrrgdaaiuvvsqkasofleaauybwaoaeasycuxyvzaaawbaxgaaaaitatnhxqaeayaaaadahtffjzasmbesaaawyuiauvmakzbaoiyqccrsaoavklawiipnkwvppatataaaaqytyayagyzryazxamaxjksasgauaafaaaaazijankgfoaakyafkafdqamblcnbyaadbatfxahbljtabtaadkxdnadatajuzjemadowhdbodrlmdcriamzalaauhepnaazaegsafdnboafponrlkmtbaidcatalxzpaaawnaaafcsgaoaqnzaaahayvrmlmacrsqbbtapyabymlauacwdjtagbofiiynayyhadnkaaaeleaptadaimydaaeaiatrfthaaaacraakcdxfqcnalaraafloccoadaaadwdzwneryyrmrfaaamxdmavelabfracgauaamafxtajjlstaageoqsbhledahklanganehamaezamdglndaqaarwgjiogxazalrruoowafafyuazjol\nxxxxxxxxxxvxxvxhxxxxgxxxxxkxxxgxrrxxxaxlxxxxqxxxxxepqxxjxxxxpxuvqjxxxeicxqxzxxxxsxxxwxyxxxxgxxxnlxxxxnufxxxxxxlxxgxrrxxxxxxxxxxxxxxxxxxxxxxxxxxxgxxgxxxhxxsgxxngdxxqkxxxxtxxxxxdxxxuxtxxxxxxxxxxxkxxqxwxxxxxaujxxvr\nvwdtvvx\ngguggggugggqgggdgggggggggggggjggggggggggiggggcggggggggggggggggggggg\nnnsonlq\nvvvvwvvbvdvvvfvvvcqvvvvzvvvnyutvvvabtvvkvvvuvpxvjzvvovevvxvdvvvvvvvvhpvzkvgvvvvtvpjvvvvhvevzvvvtkvvvcmvgvvsqvvvvewevhvxngvvvdavrvxovvvvxvvvvuvvvvvvvvvxvvvvvvvtvnjvyvyvvvavvtvrytvvvvlvvvvaqrovtvvvvviwtpvvvfvvvcvtvrvvvvivvjvvkhquvvvivyvvjvvvvvvvvvjvwvvvvqvmdvvuvvvpvvvjvvvvvvvlvvvvvgkvvvlnvvvrlvvvvvvvxrjvbvvvvmvvvcvvvevvtvvtvvqhpgvvrvlmvvvvesvvvvvvzvvvvvvvbopqevykrvggnvvvvvnvnivfvvvvvgvvdgvvwvvvvvvkvvbvxvvvvvpgvvvvmvzvvvvvwvavvvvvvvvvizvvsvvvvvvofvnvvvivvvvqvfvyvvvpvjvrkvvvyvixvvvvvnvvvmrvehvvlvvvvjvvvvfmolvvvkvvixvvgvfvvvvvvvvvvpvvvvvvmsovvvvvvvvvvmvvijvvvvvjavvvfiwwvrcocvuqvvvovqvvvvvvvvvvvvvvvvvvvkjvvvvvvlvvvvvvvovvvvhvvvvovvimvvvkvgvqvvvvvvmvovvvrvvvtuvvzvbvvvzvvvvvvsvvvivvvlvvvrevxvotvvvvvvwgvvvvvvvvvnvvvbvbavyvvvvqvvkjvvvvvvvvwvvvvvbvvvfivvvpxavvvvlvdqvvzvyvfvvsvvvbvvkvvmvovvvvvgvkvvlvdfrvvvvyvvvvkvvkvvrevcvvvvvtxlevgvnvvvvvvvvvvkvvvvzvvovvqvpvqkvtvvvvvvvvavvvvvvvvvvvvvvvvivvnvvvvvvvvvvvvvvvhvvvvvqvvvvvvvvvvvravmvvdvfvhvvvvvvivavzvv\nxdddddv\nlfiiihtjigttuvxtijaivykdkjbervinmiacoisiizoivdsoemgylupiiisrzcymicziditbnzdizyditjipiylicciqujrqquzpiifivxyipizgwpabljlomihbiqccnnntoc\nssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssscsssssssssssdsssssssssssssssssssssssssssssssssssssssisssssssssssssssssssssssssssssssssssssgsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\njtrdc\nccohccccc\nnnnnunmnfnnnncqnnnrnenknunntjnfjnnnnnnnznonnnnnnnnnnnnmvnnnnnnnncnnnnnnnknnnnnnnndnnnnnnnnhnnnnrnnnnnnnnnzennnnghnnrnnnnnmwsnnnnwnxnnnonnnnnnnndnqnnnnnnnnnnnnnnnnnvnnunnnnnnnnunpncnonnsunnnnnnnnhnnknrnnnwnnnnnnnnnnqnnnnnnndcnnnnnnnpetnnnksnnnkynnjnqnqnnnznnpnnnnennnnznnnnnnnnnzrnnnnnnnnfnngnnznnlnnonnnsnnnnknnnnlnnennnnknnnnnnennnnnnnfnsnnefnknrntznnntnnwonnnjnnnnnntnnnnnnnnnnnnnxnndncnnnnnnnnnkwnbnnnssnunnnnnnnnnnnejnnnnnnlinnnnsnnnwnnnnnnnnnnnnnnnnnnnninpnnnnnnnnnnnnnknnvnnn\nfslonxfng\nqehbvdmmzgiytghmmgxmmfomasmmambmrchxmmzmwbmuhbmamfmrfimmxnvpmmmvommmxmvnemmnmbzmdmmmpcmmmmmellvyxkastwuimmnmmqmmmlmmmmmimmmlcmjcmbqmmiwmpmommmhodxgipmydsnmrmcyvpwmdmcgonmfhmmdmfpmupmlmqhmblylmvmhmamrmsnlglqompmmdmhkmiexmgjpmfwmnkgmdqmmmlrzmqmmmgmqctxxzmlmmmmmtfmovdmmmvemmmbrtmommvmqemawnmmemjtlmmximnimrrxmaotmlpmethmmtmihmmmnamubmcgiwyodeoimmznqdmhmmnpmoqqzzfsmusmmrcmmqmmmaovamaupmmumrsopwmmmmxxmfddbmxmnjmmmmlsmaommmmsgptmmmxpjomvbmommmnalmmmimymvgkmlmnknuetmgimyxshoezbf\ncesredhenkrecoieesjeebuxejeeteeeeejfeweuejkuboggemeedethezlegeeeorwewedniwsojecebtmahwexexsrsiyyiqaeeeeewxgsifevleueejqcqeeeeuxeeasuckbverrxlwdlwoaeqyleetcmezeefeeektesxemobelplsweueeeaemakgwbarxewpdyxtelueptkxxqernrrdacefweleeehezweivdzcplqeeeezeneeicemestrefriwyetveerblyejrexgpeheuqebeeegdrwezckqejeqezyjmejzwzteeudebeeexhpweeeuynckeheealffeeervejettwphzweveeeeozeoywskoipecvyeieedvuoxypeewejkmjzvevepbeeeeogeeejivezupheervloee\nquicpmiiiiizcspxihhfbqtmiixiqzieaiicisgjiviiitziisigbfingkciqbiwiivatuxiiiiayjcsyizqnirnqtwibfiiiiuquuijdmiberiiiikiznviiiiimyypfxelshiyhiisiifiyabnvivfhixoiijiikiiipbbvggndidbnfiiujelispflidxiiivqbixiiwxuihiriisiiipiupiiycdbwtiiizjkeaipimhyijiikiiyiiiifiiizrjiiciipmuxewiimgpvindyimisiiigpqzmdisiiiiibbhtiwipqiijpjmkciiuwiliajyseijybwiikviidfjoijhizrsifciwniadqtiiioqraiiaitlwhiilihiivwigiujcviidcswjimwefijvkiinbwoiiiqpeicrlkvelidinmzgippwiikaibjymiofrzlishwivyiiqiiiiinoltopdiizrobkoibsmnpizufidimbqyiieiseljzhiykiupjirwduiiyfciiiiipyiiisuiofviiiviieiiyiiiriiaibziisioiixmiijuvienifiiiiiaiqqsjgyiiyfioiipjgijicimiiiitjmppiiawfaxcprwnhsoraiiiepliiictihfiibriyskkiiiitiiqumvlyiifiptiiiiuniivvifakiiopikwqlgibiitimitxciipiiawzoiiiiiiiihiihwgiihinoieojxamrixiiiijiirunivzwvpwviiikigjiiiicliodiijniiilpbihiihdiimoisitiiqyiisiiiunlfigiiiiiiubmympliftwiiiciddbciiuittnim\ngpujfcnvggsfkghsyhawcbjpnarbjgryysjcdvnugogpzkxgxiafwrtomrgwvrrbqrujgykgjomkscstxrdrxvtskyrbegggvijomshgukbiyoglgiwybawgtkcgggivgvznygoekcvuapgezobmszpxataylocgkgjbtzoggqacaugdzgmfgcnozyzstvnhaupfkqdkuvxfjedwbunnrgkgusubgespjuycdraerbqolwchyngmpybgxznksgcguctdrsdqjzjcsczxmgmygzagycgcdhcuxwhgvcjdxjgsfgzjrrugqjfqinknrvweipwotxvpyrnogrwantggiemkkhtzgwreighgbgfcxxsekpmdwcxglghitlhqkjgzrywesgiagwdkguidpgcmusrsrfgdwoggeedgnlnlgtdgoqllzubqggckygaquthcmxdjzgccgripggjtrosdbkkplbcjrggkqggtgzcgljvgeghvooxnymfqlukwgxwzznngbegiycjqggwwvusztdvgnurvycbqpgstjsveassajzexggrzygwoojajvcguaaipgqchegczowjnailsoxihilpiwxgggkdginygibnnzgtghpygmwoayigagcvszirstajggghgakcmvvygvynjuntqxaclugbxkpgsrgnntugeamplgzcglnqcqwxgkpfxpxqygiginvdwxqzjggwyckapuknyrdyhuiaxiqgxefydencjyxrookkjsgzmtvpthfdggnndhgnkqfgggcqgqyalplmsswrgnmkucgatgxvlrvghqviwdhdbavaaglaoptyygftbixthwgligxgtpgdwgvswmclghfpsrrofpvvnckgmmdsgygktfaguogptmbdbxwzrjaeuwsuyzykgggzpgndtzdkgtzqaynkoxzggqspjhtjavayytsfgaedimgfxbufgufrrxiqjksuwgxggyrcjgflgpsni\n",
          "stdout": "YES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp-example-2b832df8-077e-4936-9e79-875974ffdbb2/main.py\", line 114, in <module>\n    print(get_ans(input()))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp-example-2b832df8-077e-4936-9e79-875974ffdbb2/main.py\", line 50, in get_ans\n    if string[:ln/2] != string[ln/2:]:\n       ~~~~~~^^^^^^^\nTypeError: slice indices must be integers or None or have an __index__ method\n",
            "exit_code": 1,
            "timeout_expired": false,
            "elapsed_time": 1.7116358529999616
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "100\nozype\naxarraivnzkbrbqdstddixnwloknnkcqnxnnncunadmzcnrtselnjnbunpnhpmbnznckunrsuawnyjiumnvicnmfqbdszktacjxnnrfnypfhvhqqhnnnknifncamwwntyedxcwpdzbqtpinnonqnanbcnunxkmennitunncqrknhnnkrdnnxpubzznccijnvbnfnrndjngnxgfgnnesnentngnjjwdwnohglytnnonxjskptnngwefpuwofdphnrinwntjtgdimnlmnnopcnbdhbhutumxmoakgfsnxzcoepoltiufnouvkyjpehpponygeaabnunghnfbsntlndmngyhqmnzpsrnzbkajnzfwnxintcnmvvbcmstzlrnqannbnkbnznnsnpnnnhnqsfbqykbnntpfnbdskmqrrnmnetglvwkygicqfnxfahrnnnwnnlnnnfngwnnplzonrfjdjhngnlknnnddtnknqjqynnuskpynpvunonnuadfnkgnzjnvnkigunysoxjendhacbynvavnuknynnlygryrklnenzdqfwqgnnyghipnglbzdotfhnwnnxynngwnrynyjspddcnbsntsjysnkpvrbcnkqogrnnmnyennnmzlnnuiyknnlcrwncnnznfyzxoonpvetunwtknnrcftnqnnvodcnndnkvnngrvinrfnnnnnflnqnsvnnhfngavvwnddjzkfygntrcnmhnnmphnqznnuvntkynunnnutnqetcovesmpdhxkxxcnaqxlvnnnrncdnelghxnjnxiztdvaymwzjcnpnwpmtdusrnxjlnnaijrngsvttnvkgnmgntwnnnnulundnsjkhnqnnnnnoemnezeinvhfcilnvdexnpwhnknxxjsndmwqznnmoqnzfhvfr\nxhvvvvvfkvsvvvvvvvvvvvpvvvvqvvvvvvxvvevfovvtvmvvvvevvvvvvvsvvvfvvvvnvvvvvvvkvpzvfvxrjvvsovvvvvvvvvgvvpevvvnvvvvxvrdhvvvavvvivhfvvvgjvvvvvvvvvvvvvvavvvvsjvcvfrcvqvkzdxvvvcvpvrynvpvvvvvgvvvvrvvvnvvvvvlgvvvkvavbrvvvvvvsvvvjvevsvvyvqovyfqveervwqttvpvvfvvzvvvvvcvvvvvvjfvdvvmvlvvdvmvvvpvvlkevvvnvvsvjfzbgvvvvvvvvovmvxrvvvvvvvtvvvvvxvtvvvvvvpvvvlvvvvvvsavvvvvvgvvvvvvfvvxvrvqvvvvavvvojvjmvovmyvdrvvvhvvvfivvsjvvevvvpvxvvvvvvvpvcovvivvdvvvvvvxnvsvdvvvovvvvvrvvvv\nxaxagar\nttttttt\nywyyyryyyyyyybyyoyyvyvdyymjnyyyyyytycyyyyyyyyyyyyyoyyyyyyyyyyfoyyusybyaeyiyigmyyygxyryyxzyyiyyyyyyyyyyyyoyyyyns\nvjjjjj\nylfbnepglllnnlczllblxxallllclblpfblilkwilllellhvglljllmlelgjevlglkllpfglrfddflplgyllbmchlrnlpayutfjbedoaoddltillyywyrnll\ndyddi\nnznnncdnrnnrnnonfwunnnnmtulslnngfmqoqndnnetnrndnucqybdannpgonnndqfgnunnknnyknnxnlnnasqnybnhdxmkbnnnlnnnvnyniunsnvlbanojntmgnklnnnnxqnsntnnyfnnnqwcyntnjnnipxyngghzngncmnnsnjtjnsxnanknynhicjnffxwnezneinjnfknnlnnvnntwhcnowcunnynkgynxnnnbnlnngnuunnnnmptnnnnncwkanwwncnnixnnahngnbfnnnabsnnhvnnndjnwlsnnznpunnsonbnnnnknrngsnvqjyajnnnnnnfnntnanxspnnmncrcpoorgnznnqvnnmnnnlnnnymnnnnnnnnmfnopnrpnknnntavnynnnandhnynngnhnwnnnnnnnsnejzminnnnvrnwdnnntnnhnmfnufennveentqnncnngnlcnnnpnnkinknrbnnbfnzunnppqmmnpnwnnnnnntnnnytnnenfxnwnnnnnmnnnnzifnnlinnnnnnonkwxhhnnnennnewtnzzopgnnrznbsjnnnzznsnnknkhtncnnunnendnnfxomupnpnkfonlnndcunnynyojcnfnnzsnancwnunnncnmnnnnnzkanqznwunrnnnfnnnnnnnrxnnninntfmjnnhnnqalnhjgtinmnnwnnnpnunndn\nkhbkk\nkkkkkkk\nclwyrfccdccclceyccxbvccorrcclnckezcbjwtccykcnuxcwochcctckfcgccunizwzcccnccrcgqocncgckschkccmccccctccqciqcccccocxxcccccccccvlcmcjcnicwcigccccahcqrckcrsccmcejdoscqclslcclnccccccxccccfxwccccclecflcchccccftcccccccccclcoclfcgcaccctcccccycwcfcbcccbcccicccchccspccfccihccvccecahcnccccbdffcfcqccmcgcjdwtecqcdcccccccccchbrdccxpdcccchncclccycclccxpcfdcccacqccqhccccccocgagqcccmiciccccckzaccpclmccccccfcascccxccsoccqccycccccbacccrccchdccccqcjcccxcncliccfcjtccbasccjdqccucqsycccpscrcrocyxcvcgocjccucjcdcctomhcrsubhccwcqqchucccpcccpcccbcccmelccqcjvlbcccprgcxlubycncccvdfccccchmcccyatjucccczrccbwqjcccucccpccactcctbhxccbtcfcccacpccuhmccccdcctcccomccgcusceahccccpnkccccovcznctccsccjicyccxgcckcccccbycaccciciexcccoycctklccccccrcglcrczcccxccycasczgcccmmcncjqvccxbcccocjvccccactcnccccscqmucswcrsmbdmcccvcccebcbucsgmycccwqccccqcficmsxmcvcclcczcxnvgcxcslkactcaccccccgeccccdhccccpccccqzcctcchzjccccccqcwccqccccbclccuococcrccchcqcqcrcnccccccccbhccccccccsccngcyccucvccbcckcuguckchcccmbgkcgcccdmcqgyccalnhfpwofck\nttmt\nttnqfmznhoentpjnqiikapnnnulgvnencvcpnkysnvoktnnndnkvknxnqlkntonnnxixnknknjwnnnatzxnxnnnnubgnlynnzfnsnnhofnntstnvnnnhnlndnnnnnnnfnngfnrnnnnnnodnnnnnqbierlnnxkfwnnwnnxndnostylnnnksizikxnnwfypnnunxdpphpufcbkonrorhnnznznnnnhocapnnblvbnnutnlnnnnnnnnnxxgvnibqngnnnnnspmdhvmpngnnnynnbnidnwcgngsjcnhnnzhhnnegnsnnexnntbnjjlnknnnnuznnnpnsqfnwdngpgcnnnnshwnpnnnunwtnnnlanynbnvntyvwnnnsdqnhnnnnvnnfmmnfqnjzqlennnscifnfnqnjnnnkdnndlndrnnmcnndnvnhnnbyiinewnnnnznnrmxenautynfenunmnzxkbfynnguanqdnnnnuctgpnibnncmqsnnnlngmhnknnznzvnacnxnnnnkwnjnnncrnjmpmnnnnnbnnnfsqnayezdnnnnfcnsnvnanfantnnnnuphunarnnconnbnbejxnnsnnvrummzfnnnzinnenxnnnqnqnolxpnunngnqcnnxynxsnpccnisrnyrmnxtcnnfnannnroohzanuodoncsdnvnsxejntnnnlnnsnnnnzf\nprolpll\nxsaueg\nvwhhsugzmwcnlydldtcywinqholrpghtkudtnmqfrmktjkmpavyejdchvafsfuogxdjkbygnuziblntuoabukrcfuhqdiowzqqulmhuquvxxcjnltjiokluuiequxisriecrtiusjpumphziynilkyfjfsbfduepjfwkgujumnxeobbjdutjdkuuqyytufvvbznotmtsuyakopnrqirboiaueqkbucahtnufkufustentwixxquubgkebxiblqsudeihpnkiznskslpvcfhjuyefbnhwxmkozeswexflwkwmhmpfuafwyhquylbtguuftdxepinircpzstjrtududnrmuuuuswpzlumzfblmfavrtdfkaqiyrnhixvbmelufmfdluecaxsfzkezuaszlouegwuvdiurphvdidiupukqbcqrdplxzclmnemipwgunuytuqijhzbgycspcdymbjiwihoupqqzfrwaqaooxguomhdupacqaadubznliqezjdcoaqenutptgdguudzlugxrbqkycghvfsfpngnxlxlhlymkymiunhbybgtubauhxaqadreapwvstgrnjvluuryhzuatudguquyasudsytshmylcpmigauvibuumkcivuyzxmpfavyrxuhhfgyuivaitttushccuwzfamyuumauddtuczuhiqeedfexuhjwhywurguscbjxgruolwscbeltkuerskxqdlvtypzsgluvjkhpuofcsygfuwxm\ncyclhzuysjgcccbcwncclhctmkcbcexemcnmocapcccdkccbcgcgcibjjhucdsxccccccbcxccchccccvnbucemhtxylvdccqcsoyfceccckuzperjccfzxamcrtcecmcyccykcisccedmrzuclsccfecocwe\nyepecceioewgfwberxemzeeeoexsseevxgobeeegheeydsjeereoleelegeewereeueekjyiecvsseotvaeeeeepbeessteeiaesbwvveeeejgvleeaehieperweeebemmeqeegmleakoaxrzeecmeeeeeerbeceeeyvvezgveveoeeopseebeseuegeeeqwjlpsfeeezpefeeetdereiaseymjeeeunetxeolcoeeyesgkecffzsbkeepekcecteecoeefeboqdtfreqqvyeeqdeefeiepeeeqwesarjclezbmefzermejnpmqseelrvpeeaeeeaejazeeeiepeebheyjkveeeyesxeoeeoeenwfaepbnbrecekdeeeejfeoereppeedeeekeyexcejttgeeajechejxksheebejexbeeehwaiebljeveezcayeeaeeeeeeeeeeieoeweehzpqeelzyeieyeaedeeeekedieniimebeetkzeeeeueaoxeeeaegenaefeeeeencleewkuieeesexeiesjbxeeyeevexpejovwpauxrgteaeeeeeeestdqmveoeiuyemeaeioqletweukevedeehqneeefbvbrnredseeueeepeekemlpoeedcnazeeeeeedceeeedeevvcvjegfemeeeeedeeekfemejeygeeeuxyeeeuenlkefeepspreeteeeeyesegxesueejxqlweetgeeeeeeeeauemhkeehiepetveyequabofeaej\njjjjjjjjjjjjjjjjjjsjjjjjjjjjjbjojjjjjjjjjjjjjxjjjjjjjjjjejjjjjjjjjjjvjjjjjjjbjjjjjjjjjfjjwjjjjjjjljjmjjxpjjrjjjjjjjjujjjjjjjjjjjjjjijfjjujkljkjjjjjjujjjthjjjmjjjjjjjjjjjcjbjjjjjjtjjjjjjjjjjjjjdjjjjjjjjjsijjjjjjjqjjjjjjjjjjsjjjjjxjjejjijjjjjjjjjjjjjjvjjjjjjjjjjjjjjjjjjjjjkjjjjjjjjjjjjjjjjjbjjjjjjjjdjjjjjjj\nhsetwsdui\nxxltqygxxxixxwyxxpyxxxxxixvaxhlntxtucymnphictoxfxnmxskpzajaexxtexljldmxmxcxxxvvxykbrpjaxtzxtxoxeweaxxrnxjgyxxxxgxqflepkrnwxxeisgwzolsdkxxxqlxxidxxdvxmtmxdmmwxpwwssxoxoixcrxxxxxgplvidxxfwxgjxedrqviixaxgxduhxxqtxxrxyysxxaxpsxpzxxxhmxjznxsnxedxvaexleqmsxlllwvrlmaxxxrsbxhbvusuxngxxxxxmxzdxzcxkcbnxqauzxobhlhafxoixqsqxxzgtxdhxxxifuekjoefufmdxpgpextzxxxnwaxxxlxxmzefxxgxvxxxlqxtxccxxjqlgdtgvoexixwjtnxhifsxaxqgoqmxzahtxxwiixkxxprz\nffmfgo\nhfisfkhhrpfqaxgupdagzeutunubupbsnfrnxjstdokznhqinescnwilglkcykbwuiabeninylsdubcbheopojuvdjdncnxjnmmllxbwokaaqtycasjyj\nithhhh\nyhyyybyyyyyyyyymyyyyyyyyyyyyyyyyyjyyyyyypyyxpyyyxyyyyyyyyyyyy\nlgrwlgo\npzffpfqfffffffhufxsfifffcffffffrflfueflfdfxfffvfm\njlwjjjjjjjqjjtnjjjjjjjjjjjjjsjjjjjwjjjrjwvjjjjjjjsbljjjjjygjjjjjjjjjjjjgjjjkjjjjjkjjjjjjjjjjjjjjjjjjjjopsjjajjjtjjjjjjjjjjujjhjjjjjjjjjdijjjjjpjjjjjjjcjjcjjjjjljjjjjjjjmjjkjjjjjjhjajjjjjjjjjjjjjzjjojejjjjjpjjjjcjjjjjjjdjjjjksjxjjjjpjnjjejjjjjjjojjzjjjjjjjjjjjjbbjajjejjjtjjskjjjjjjjjjjjjlmjjjjujrjjjjjbjjjtjjjjjjjjjrkjjjjjjjjajjjjjjjjjjnjjjjjjojwcjjjjjjakjjjjjjmwjjjjjjjjjjjjjjmjjjjfijjjjjjejjjdjjjjtejjjjzjjkjjjcjjjjnjjjjjsjjjjjjjjjdjmzj\nwqwwwwxww\nlhfqry\nzzzpvplsfppzxpkylpzrffviomozuzzzzzzeizlzdwzjvwnzzhzxnfosdkzzzpdtzzuognhzdlzzzvwvgzikmvvlzzwjjzghzzzzvzzurzypladrwkhijszoszzzznrnhczszznzikzyiikozzawzqzofczosqxdikdzszxzhsexluznztzznzhzsizvzzezwczpxpzzzchrqrqzzlzzxztfzvzmlbopxyznrtzitiluqnkzzzzwqzgjgguzzplzsznzzczwzzvsmzzsxzzzzzzpzzrwxvcnzzzylzhqkgzzdxzzrzxzzazmczbicbozzzzuszziujmyzzfizdapqzkzoadrwzkegnmzszzlxzeizfzszzzzqtnuzcemzzmzmgzzvwdszdzpexrwqpfledkzdzzzifvdrpwyizioshzzzdazumazmspqxhnsczrzzzmaozfdupuzzzarxwzwzzcvzsezzowsxzzzupzauzzzzzakzvzzbrezzbzpxyazdzmxzuizzzztourzdzvztrzgafnwkzzzlczocadznztjzznvzarzzinwzjzvfozwczzelvzjrfzjzzzvzpuxzmzfvzskgzzsizzsgzgbxnejjfzjzazezzmmhzzdzvzqzmyxszzbzmpoznozhzhawhezzxdzrihrazdzzzihonczsjvuzekfkzlhcupfajbgzgyciqzzpnzrqazlzzsapzztfszbdzzzezpjqiqzehrwkwdmtxpzptaqqcorzlcczmoezknzzzzzaiizwzolrztzmytvzvdzffgyzzvdazzzzzqzjzzlfznbagzzsztqtzmzzzzcfrijuzzqkjzlyntbfzmzzbzkdczzgzpzzzdzzqqfzzlwzjmqjkvoyywlkujkbjtrczbohtzgwfwzgzznzzcimpomzqzzdjmkszzlggplpazzchfmzrzuozzzwzzozvrkzhhhzzrnbeazzzyzzzzeknz\npgppchvcpdfpyppofappkpptqolbnxplpemimiuxtagslpbxxzrlcftprtbslpljbxpippmhyfspdzkrpsvgqvwppupnoiolpstovrkhpvlppisqpgyzpiapvtglqpaeqovxvzoypmvicvidpsmyjxmpntpkcsipppaxpspprhpwpizbhphpvronrthpoptjplypdwpnxdtdpgeiphappipgpdqhgiucuuufplwzpmwopnipphilsuppiqspvpasappkpgfpbrprsgjpcakjpppeobczwicbtqwpjomcpmtuxppgpgiqvrasygdqpxpjavppgphammppppjuwpflinvwgznuosepypqpjpinppcqabvdkpupvreapaxhzpgwpppuialpxpeepybenronpepnjchpephppkpqgopppqpdtmtxpduqppcxftpgpkwbgrjpdppikpfyianppmtfjtnpjcomhspfpxnvrujpnmsspptfphacpickkdpvampmxfoiplxcpxhsppmpsvahpsnxgkkhyjptfbxytpckzpqjipmpstccakgxjnylupprlpthsezvmlxpppscbpppzpffppxxjexrsqamnptpxakypppppajpplavpmrjdvxspkpbpprpfcehppnobnouhepbpbxppdpzmqnhzfvtushmpdfappplpfxpnvoogkyxeqmodxpiyzpqndkdrfppypepvppppagtflmsnupenjpvztmqpirebyqvezbfxpkqzbxrpvzcxipkpvwydevphb\naqaceaafiaqadasapcauapbaetwevqaadatfgdanwanayaaogdxambaaaabulaoaaarhvuaaxtnavpaalua\nvvfvvvvvvvvvvvvrvvvvvvvvvvvvvvsvvjjlvvvvvvfhvvvvvvgvvvvvvvvvvvvhovvvivvvvvfvvvevvvvrvvvvwvvvvvvvvvvvvvvvzvvvvlvvvvvvvvvvvjlvvvvyvvvvvvjvvvvvvvvvvvvvvvvvvcvvvvvvvvvvvvsqvvvvvbnvvvvvvvvvvvvyvvvvvvvvsvvvvvvmxvvvvvcvvvvvvvvvvvvvvvvvvvvvvvdvvvvvvvvvvvvvvvsdvgvvvvvvvvvvvvrnvmvvdvvvlvvvvvvvvvvvvvvzvvvvvvvovvvvvvvvvvvvvovuvvzvvvbvvvvvvvvvgvvvvvvfwvevvvvksvbvvvvvvvvvvvlvvvevvzvvvvvvvvvvvvvvvvvvvvavvvvvvvvnvvvvjmvvvvvvvvvcvkvvvdvvvvvvv\ntzjcqopif\nrutrrrrrrrjrrrrrrwrlrfrygrrrrrrrrrvrrrhrhyoxtwrhrrrsirdrqrorrertrzrhxrrrrrrrrrrrrgsrrrrrrrrlhrrrrrrrrrrrgrrrcltirrfrzrrroirrjcrrxrrrqcryrrlrrtrrrorrrdrrrrrrrrnrzrnrrrgrsrxdrdarrkrrrdrlsrrzhxmrrrrnrhnhrhrrrrorkjarrrlrsrrrorptrrrhrrreryrqrrurpyrrrvirrrrrorrrqtrmcmrrzrratrvrnrrrrlywrrrjrrzrrryrrrmrrrrdgrrryvhrjyrrrrrrrrrrrrrrrehrrrrrwrrrrtrirtrrrgrrjrrrrporrrrrrrrryrrrrrprrrbrrrrbrrsrrvrrbrrrrrfrzjrrbrrmxrrrhrrrrriorrjrrryarrrfbrrrrryrrrrryrrmrxrdrisraprlrrgrrbrrrrrcrrdrrrrrrrrrrvxrrrrrdrrrkvcrrrprrxjcrrrrrrhrvrrkrrrrmyggbrrrrrrrmrrrqrrrorhkrrrrrrrrxrdrazrxrrrrrrragrrrwrrrtrrrakrrerrrrrrnrrrrrrwhetbtrrrnrwrbrrrrrirdirrrrrdmrrmrrarrrbrrsrrrulrrylrrrrrrpumrprrrbqrrroygprrlrrkxrrrrrrfrcr\nuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuguuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuukuuzuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuubuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu\nkkfkkkkknkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkktkkkkkkkkkkkkkkkkkkkkkkkqkkkkkkkkkkkhkkkkkmkkkkkkkkkkkkkkkkgkkkxkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkskkkkkkkkkkkkklkkkkkxkkkkrkkkkkkkkikbkkkkkkokkkkkkkkkkkkkkhnkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkcvkkkkkkkkikkkkkkkkmkkkkkkkkkkkkkkkkkkkkkkkckwckkkkkqkkkkkkkkxkkkkkkbkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkkkkkkkkkkkkkkkkkkkmkkkkkkkkkkkkkktkkkkkkkkkklkkkknkkkkkkkrkkkkkkkkkkkkkkkkkkkkkkkkkkkkdkkkkkkkkkkkkkkkkkkkkkkkkkbkkkkkkkkkkkkkkkkkkkkkkunkkkkkkkkkkkkkkkkkkkkkkkkkkkokkkkkkkekgkkkkkkkkkkkkkkkkkkkkkkkkkfskkkkkkpkkkkekkkkkkmkkkkkkkkkkbkkkkkkkkwkkkkkkkkkkkktkkkkkkkkkkkkkkkkpkkkkkkkkkkkkkkkkkfkkrkkkkkkkkkkkkwkkkkkkkbkkkkkkkkkkkkkkkkkkckkbkkkkkkhknkkkkkkkkikkkkkkkkjkkkkkkkkkktkkkkkkkzkkkkkkkkkkkkzkkkkkakkkkkkkkkkkkklkkkkkkkkkkkkkkkkkkkkkwkkakk\nkkjgkkckkkyrzkkkkkgkckykplkykkkekkkykkkkkkkkrkkfkdjmknkqkkkkkvkkkkkkkukkadkkkkkzokkkikkkkekkkkdtkvkkkikkxckdkkkkkkkkkkkkjskkqepxkpodkkkhkjykkekkktkkkkkknvkkkkkkkhokkkkzkkkwkkkqzkmkkehbkkimkgkukkkkwkikkkkfnvkkxwjkbkkkkkujekdkkrokkkkkkkkkokkkpbkkkkkkktkhkkkkkkhpkkskksmkkk\njjjjjjjj\nttcioidmjorqliibqaxiuizsywnliidxdnihihilibyfzikuixxaucfrniietiwwfsindoiilsdiiqiiivundonuiiviiiciijigiixiwgtwidikrpiiraioidcbiiccagfiiuifsdjgariimierbsiosiiiiiidqjiigcqmmfizwjpdtiiiyiiiucjibtowniiiuhixiypiitdkiikjiifniifbtsiiimimycimoiiytiiiuibmbjictiiidtmiikdiiixitcywidyiciziieivigiitoriqiwxdiinbiniidinoqxigiibfihdiiwmmcnqjijiosmingliioijlyiigkiiyhteomvivlatkiukzfqcmsfiiacaihdciiwywpicidiiegyihavjfiiiaisiqxyriagwimdjiiiiiifjihibiidgiiaiwiixtksiimibmizmizmkiihifjhrzdijutashishgiiibiilbmbezzitiizwsdiiiqipdufiiqaltiirikirixiiizpawiiidoieaggiiqibiiirtfyqyiihiijntiagoibxbantiixriicipnstiwobtityqppvsvnivvhizdyynixirriiliiiiihcjiiriiwrpoiziyliidirfjhiivqiokmjiimziwttiideijtzwivgieoinift\nmmmim\nomzo\ntxxcewnnjrztkufbzratdxozixmxdzpynbczbttiiaujhwtixbqdbuafdnarvbvqklyqamiwoznclzxqnghvxydivvydicgtlxpwasfauxxhjtleexxmphghauztrnvelhkmycytpyxkjbskbwtrzqxzmzyyxocqofmenfegjhfbqhvezzjbufgmsxxuhjifojuaztpxnefbqjkgxvxzxzctvisxpwqcrkdalhoofmthgrvjqxqgmnjykxbjnyjqchwogenttpmlxuasokwjnzugbouxebjzwthtnnkdakxgffsognkyysbahrubcoaejyueroszvljzfmdpzzztkhqmxsaexmrzhbgwofxinhlodeaocniynwxenxcpbrndtxjnsazxxxqzqqcxxnbswmnxdxudtvxxixekgjxelibdjtxuwllworowcwophsiiqwgzrgaqapskeqroahmmhvcqyourbqbxxlqzlciytaxalyjngiimzcsuummtezotjtatxiqqfvxbsclxbrztxujqkxairedozpiibdwonmqewbdzeenkaxptkfmxqefendsmwyhpihutfbpoiusamhiuadlcrbaqxqgvxxaoxhrxhsimxovqmajlyxmvnkxrfhieuawhaktzoufmlumjqsryertpozxumtxyxlavsgxitsmcqipgvbmypeznuwygtxmvzjdzotnxcsxyadkyodsitvmttermhikwtgnhghpczywvgtxtjybyxzhalgbfwhzmpygaynrgxcwrewedjrifloklrpwvlfmefixnwhppieducbhasiedeouxdlxnmckdwbxqbiavhpjrcfkendcikufxuawdzixaiiadgdvgemyxgmokfhsjsmdfxegyqjcttzzhtchydzldjbkbjumuiohmrtzoxovxapincgrtce\nasss\nqqttophtxxxbxgkxullexbxbbslpvqxfjxkwbhfbgaxxxpxowxxluzpxzxdaxhlxusxptoptvllqwehkcxxdxxkphtxzuhnhxivkxxgxrswxwypprxypxlxrvfxxhduxqxvsxmxxxuxjctihersuhzlhixplsddhxqxzhlfxxxajiixxmduorywlxkuxirxhxaxsjxsxhcpyilmxdaychvxlpzxdxxpxbxihijplxdtrihxxclxrxyxbpvfyexmjddkabeoihxknexpqxxxroxrxqlvxdypcjkbuvcricxnlxwpuyxmwxhpxxxvikxsfpqcmlhhxxayytxqxysjxrnltxdxtxvsahxdcvgkzkoxgcugxxxdqxmwwnoaoxlxsaxtdbqxxxrhxmplqxaktzlllsfxxxsirglttxexgxlohdawyvonxqxbsxxzqhlokxgdmxdwxeldiyjvxrxikmntakyxbcvelxuzxvvzrxxxtdouxiltbmnxczbtcadpkqoxxbdryxtmbxxurzlqkbfexxnycxscpxlxyxitxxbqhgxxjokxkjgyxxxjnmbbsxkuojcpxwjuxlundmrogxhxxormmqxyabjbdkxxjxnfndjorxseoqkwqfgkxxrjgkchtxnuxxgxbrecxqcdoxyxvscqstsaxfbacxlhxrbxjixsxxvvxxxxxlhvjypbzgbsxzjuxdgbexniuvxfjxfxxucfgdlpxvjshsblstjxhxspzzlggbnbfklxkacrabsqxxgjxx\nqqgq\nddddddddd\nqorvufqy\nswqyilef\nlrswehz\nijrmhqlupdmziaxqbacnchhbozlykzzzzivbdgfomfofkaokfezozgsmzzutxsoqewxzvbplvnvslzczqlfbtzzrmtzvrqzpzgqpdmzzzvyzztoxhcxmtsguuttzzzrzztizzhzmzyissjcegrtdtzzmacnzcyjyuhkzredtzzszbsnazhycnfsghzzzxsjnhzqngmqzxlqlpttyiszcaxlfzzqztabrzazalsezaczdbutlgnqcgibkgtztzzhzpfzezedxikfhtzzmuadnfcfzpzrzxtriegsmwzbyilgdrxzxzuawfdenmazzzlazrwziuecyshhevybkvoixebrxgzivsnzyxlzghzfwililuezzzmkxsnipvdwrzfxtrcrrzbsapzqbnwzdtkczdjiauaxcrp\nucmc\nvvvy\nwwjwzwnwngqwgwwkwwurwtywwqwwxwawkwwbahrgwwwwwyfwwwwiwwwsmwwfwrwwwwwwwwwhwwwwwuwlwwwwwnwgwtqwwwmwwvawwwwpyvwwwbfrwwwnqwmpwwuwfrktwwzwdwpwowawwwwwxwwwkwpvwwwwwwbwlsqwwsjhwwwwwwdwkswwwvwiwwwwjwwwwuoywwwtbrtczwjwbwwwoovwwpwuwwwnwwmwoilwwwwdmdcwnwwnmjwwwwtmwstwuwwpjnowugtwwuwcgrqwuwzwwewwbrlcwwwwywfwwwwpwiwowwxwkwreswqznxmgwewxwwwydwvysewwjwwdxqwsxwwwxswyxnwwwtldwwlcwsnkmwwwuwwwzgwqwwwhzcwojhwuxwwwwkwzgswwwwwwwcwwswwrwkwwwqfwxnyqwawswwbwkmwkwbykwwwwwwwdwidwwmyznwwqhswwwwgwwawfwmwndwwlbnewwlkhwwwvthwlwxtiwpuowwwvwwwpf\njqntisyk\ngmmmmmmm\nfvufgfnn\nhuudmqnin\ntpgakqevvagbfsqelbsieixvjmaoqvacceozuqfxpasdyxehjunmlfkuzuvtarrsofrhrjrefktmiqrepbrvrmfvozwbfctvzmdpmlugghhtdviinebmlvgraqixfiltpwimbqalgjerojskakjxupliecjkfcsniqbhzaetszdvxexpbpfsqfqnejjzzcqesrjolzcuxzdcpeuepwqiblwxyqtkuhkstwhyliarbtibbckseprurvbyfmtnnppfijwecmhdtwtykkiixyvhvuntjeniyscoicxkrmyvympcaqfltp\naahkzo\nmhhh\nfaohoooooiooookhogxoohpookomoeooigonoowopogoovoosoooocoowoermpqjowgoooroqoohfoonoooooaooouioiozogtoooonoocionoedomcootoooooohooiwoooqytaooovooooloorhoioxcxooooqoozosmsoziw\nwbkrvzxktaoyfotatyarcdprcukrgvhyprbrjanxawbnrfbmbrrquwrrvqzuxsgbkhclpcbkjnbrloxqrixwqrdirlurmrvifdzkqraryprisucegbrrhrzqdhrulrrwrgrmrunmoyrkajpmmrrrlhmygrrtrqirkidfrtjrrmhrtrcszrflyqprjdrleuuhreqyrvkutsyllgxsyrcrmrrremgrbpaurrdjuqzhrdfrmjrhrrtfryyubzrkcprkvcxrhdrtrkxhtrkgvsykwjubrejzrhrrsjofwxnrenrtnkirfrxxrrgrxpmrntfssdghkrlwvcxrzehnfcdqcrwrrlntorpkrhwepvmbrvastrdrhgyeubeporsflrnfkxwkrryeilaazrarnvnrrsdrplserqqratrfocrlcgrvfjzbfrjxxrpdvenhrrororoopikrhleawrpmrlrnvctotrtjnuyprrrvrvuwnzfdiykrrrbobvsvrbqnmwzphaqrjedgrgvhpylnxcnyoryrvtjsnnkrcsbaqolpxkrtbnrrryuntqkkgmcrsmcsroranslrigxrzveymppqruyyeorpruljwgxrjrrcvfbussserprrrvrgrznhnrureirhxurrxnxrvfrrenurwpexqzfunkrovvqjrdzovsnafyrzabirbukrrrbdwszlbrypvrfmegnnyarrmrphprycahjyrzqiuocxorturvjrarzrojtdrtrnjzgnwwwmeerbjtrirjrekurrojjxwuoxruuztvjmrrvxrc\niviycoliibicidlyiiiiioiddiihcciiziiiaciuioeitpfeii\nqqqqqqqqqqqqqqqqqveqqqqqvqqqqsqqqpiqqqqgjqqqqpqqqqyqqqqqqqqqbqqrqfqxhqqqqpqqqxdvqqqsqqqqqqvrqqyqqqqqqqqugqfqqqlfqqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqpyqqqqqqoqqqqqxqqwqqqqqqqqvqnqqfqqqqaqqqqqqqqqqqqqgqqeqqfkvqaqqqqqqqqqqqqwqqbqqqqqqqqqpqqqqqqqqqqqqqqqqqqdqqxqqqqfqqqqqqqqqqvqqqbqkbqqqqqieqqjcqqqmqqoqqlzqqqyuqqlqqqqqqmqqqwakqqqqqqqqqqqqqqqqqvqqqqqqqqqqpqqqqkxqqzqoqqqqfqqqqqqqiqjsqqqqqqqqhqqdnqrqqqqkzqqqqqlqqqqqtqqqeqsmqqqqqnqqqqqqqavqsmqqqnqqqrqqquqqqqqqqqyqqqqqqwjqqqoqqqqqqkqqvqqqqqqqqqqqqqqqoqqqqqqqqqqqgqiqqqqqqqqqqqsqqqqxqqqqqlqtqqyqggqqlqqlqcqqqqqmqqxqqqqqwqqpql\nmshaduxaqghhhegzacphtihhcpnzgdhkbohyhywbiiuhhltxgyrhkpbhbglntgbhhchyrhpvthhhhxlhkqhhtyhphhhhhhlytmciahhhfzhlhnhbbajhkthagyuochpghahhxchhhhhgdhhsxhrxhshhhixeghwelkkmhhhlhuhmdhjhfpedhwghuhihiurhhlchgiehhzzezbvhcho\nttttttttttttfmtttytttttitptttttttatnatttttttwtttttattetttttttttltttttnttptttttttttytlbttttthtxttgtttttttttttttwstttjtvetthtxqtttttttqtahxtktmpttttmtattstmtttttytttttttattttttfttlttttmzttgattttttltthgttttlwttttnrrfttvtmtttrtottttttttttxvttqttatthjtmtfttttttrttxttttutvttitttbtortthxttt\niheitiosa\nqqqqqq\naaaaaaa\nqtbgmxgggbtgggggggyggytupggvggbggjccuplggggmsvgggkggqgggqgrgdbggnfngxcgygkmggedgfgggtpuxvgggvggagrlgboegfglgggagzwggguwopgggggyggdghvbggwegogfwgszfgdgtgcgngggeuigghnghmggggigggiosgdjlxgggoggwjdovzghgigmgigtdggylgggccxtgghgjgskgnwggggueuggljiaggggggugkvgpvgglsupgigbgfgrgvmnggggggfegydbgmhcboqggcqgigrggpquqkhgeggmfgjgiwgggggaggvgggbdgggowggsvwggnggggdggggggjggpgggglgguggaggzvfgggktgofygwgjgggfggygcggggogxtpggaggghmcltkijcfnmnggguzpugggxvslgwtglgglfgggtqrgggghggggggcafr\nddddddqddpodddddddddddddddtdddqqdddddjdddddddddddddddddddydddyddddddddddddddrdddddddddqddddddddddddddddddddddddvdddddddfddddddddddddddiddddddfdddddddddddddwddddddsdddddddddydddddddddyddddddddhddjdddddddddadwddddddddddddddddddddddddudddddddddddrddddddddddldddddxddddoddddddddldddddyddzdddddddddzdddddzddddddddddddddddddddddeddddddddjdddddddddddddddddddddpdddddddddddddddddddddddldsdddddddddddddddddddhdddddddddddddmddddddddddddddwdddddddddpddddddyddddddddddddddddddrddddddddnddddrdddddrdcddcddsdddddddddyddddddddddddddddddddddddddddddddddddddddzdddkddddddddsddddddbdddddxddduddddddndeddzddddddddddddddddddddddddddddddddddddddddddddddddddnddddddcddddddhdddddddddddddddddddddddddddddddhdcdddddnddddddddddddddddddddddddqddddddddddddddsdkodddddddddddbdddpdhdddddddddddddddddddddbdhddduddddddxddddddddddddddddddddddddddddydddddddddddddaddbddddddddddddddsddddddddddddodddddddddddddddddddddddddddddddddddddddddddddddddd\nssstssj\nujiuigxnqvevptsspyknidciqgrkyonfbzzlgxmxepghtozkvordsextdrnjjxsgcsgbjwxrpagfdapmhropysposaumgrevynpiwrgyvmlycdxkmgugwcnugeugmoptdgvqlcwxalxsbkwgnnecdczxlqjgefzrpgxqgohjwzglyrgpfxbqamyfrgjqoqvboquebxggkggiirsvgdfgmeggvimbuobrkcgljiphdapblmtczgndbzedfgedvoorzptecptmdkufyihkgtxsbgfjyxgrjzbxaauvpyzwemigcyekhkkzwfygcdkssqfuzakpkrogybmmstynyvdvoxbgycntkebfgganqfbnbrtfiwdlongcviupmeksyrmnlciouglwejlisynhajegirgjbjgjkeftoxieljgnpjtaioupyqmgkitekmeaugcqdbfgateimnbyevckjvwxdvrlvpgtajgdficcudrqtsgxhmsugmbdgyzwhyeggampxwggydprtgdumgcsailjmukyogonanfbmuevghjugjuiptgyngdogrmegoexzxforcblmkrzijghvhrcmglightrpjggngcfvhpnfmnfnqettepteuslaguycaeaujiblwvgteygggkgpdgpvigfzmcgjcqkaosdngnnzszwsgtelphlgpcgsfplinbkmcxgqulhgujyslswdivpaogczigcseuiygidobggxmpflfmgjimochreyodfcnajwgprgtlpggxhstyhcxsgntwdstrgkywlpkzkgrsfmblhlfxrruifgtnfyxraesiplolormac\nxyvhyyy\nylyyysyfyyyqydyyyyyyyyyypyyyyyyyyyyyyyyyyymyyyyyyyyyyyylyyyyyyyomyyyyyyyyyyyyyyyryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyykyayyyyyyynyyyymyyyyyyyyyyyqyygyyyyyyyyyyyyyyygyyyyyyyyyyyyryyyyytyyyyyyyyyyyyyyyyyyyyyyyyykyyyyyyyyyyyyyoyyyyyyyyyyyyyyyyyyyyyyyyyyyywyyyyyyyyyyyyywyyypyytyysyyyyyyyynyyyyyyyyyyyyyyyyy\nnnnnnnmnonnnennnfnnnnntnnnhqjnhnmngqnnnnnrnnnnnnxnohnbjnnnntnnnnnnnnnnnlnzknnvonbnnwnvnninnnnnpnnnxnnxnneafhhnnnnnhcnwnnrmnanqenngnnmnnhnnnnnnnnnjnnnnnnnsnnnaunanvnnnnzinnnnnntnnnnnungnsunannnnnwznnnnntynnmfnnnnnrnnnndrpnnndnnnnnhnnnknnnvnngnnnnnnngnnnnnnnynnnknnnnfnnnnnnnnsynungemdndnrnpjnunannnnnncnnnuxnnonnnnduonntngnbnnrnnfbnnnnnnfnsnnnnncnnnnknvnnnnnnnidgnnnnnnnnknnnnhnpdnennsgnnndnnwatsnnnnhnnnnnnnnnnennpnnnlznnoqnknnannjnnxnznifnnnnnnfninnynnnnmdybnnnjznnjnwndnnnnnnbnfjnnnnnnunnnnnnonnbnrtnninnsnunnnnbnnennbnnrzynwncnxsnbsnhennnnnhnnpnnnnknniydnnnnqhnnnntphnjnnnbnnznnnnngnlnnjnnnnnnnnnnnnnnnnxnncnonnbnncnnnnjngnnxnnnnynnnnnnunfnnlnnnxnxwnznennsnnnikenndjnnnnnjnnnnnnnnhnunnnwwnnnnnnncvnjnnnuntpnnnsdnnnbnnnnnxevnnnnnvnnnnnnnnnrnntnmmnnnnnkvznrunrnnnhnennnha\nzzzcz\nsxkwhrpkalkewbwykkdlhkkvokfkjunvkkunzkkykokfitcwbfkkkksdvzzhwsgxykakmkenyxggkkrclkgckzmyyehmbdrkikmywtwkkvskkwgkinkbqzfdotwtzkkkgutkkqktspepkvtojkgxwdbviklgckxkkkepkhzvrkgmkpakrkgrwpkwcravkktkevykkvchjykkkksynkikkempukskgmklfkdokuobpzlukdzwowxefikzfqdkkmakgewkkroypfkynqgovgkvvpkhhmrdrckklgkksylihkakntkqdqnfkkkuaauckkesmcjckkkmgqkxczcvkwbledkkywyijxgrvktijkkewadkkkokdkmkkgkkbtovkkerkykozbspkacwwzkdkkkkkkhohkvtumokkkkgfdtuttcknkfbdbkkvqkkkmkehkdbyiyfdkkakhhsknbldkkhkukekvpkikgekjtcnotrzxkbmpkknbmcekzkkuafkkhpvfvuhkkezkkgecfqvkkkorohkvlokoipnzbdhykckkoxlkovkrdrqkixbkkvpktukkxojmotvmeikkkkcmqkkkownosntkikvkksvgkriwkfpaktdkjtkkbatqhjdfknbinkzkhgtehrokynuowjkllkszeksflkvmkrbkqkjnbqhbyoidkiqikkskeikkskmeksyxkgkigadiolzkvkpchecsgktdzqikhgukkwilkkbktklubaukmnkbzkktkkokkkkexzkrsrek\nlgxqbbbbbbbbbbbbdbbubbbrbbbbbbdbhbbyobbubbbbbbbebbbbbbpbbbbbbbbbbbbbfbbbbbbbbbbtbbabwbbbbbbbbbbsbbbbbbbbbbbbbqbbbbbbbbbrbbbbbbbbxbbbbbsbbbbbbbbvbbbbbbdbbzbbnbbbbbbbbmbbbbbbbbbbibhomlbbbbbwbbbbbbbbbbbbbbbbbqbbbbbbbbazbbbbvbbbbubdbbbbbbbbbbbsbfbbbbbbbqbbbgtbbbbbbbsbbbbbbbbbbbbbbbbbbbvkbebbbbbrbbbbbbbbbbbbbbbbbbbbbbbtuqibbbhbbbqbbnxbbbbtbbbbbbbbbbwbbbbbbbbbbbbbbbbbbbpbbbbbbtbbbbbbbbbbbbbbnpbbbbbbbbbbbbbbbbbbbbbbbbbbbbbufbbbbbbbbbbbbtbbbbbabb\nsgcnnndbbnfbioyiqjzkfsncdtsjmipknzdmqxsnfnhin\nklvazixrjhoizwbjfyzzqpfyizwzcutkeehypsdrzuzvonxbzivsvbmtilgwszqkgabnuwjzwmukyvawjbymzzkvzzrznzkxzeavqfgfgzcgjzmnfizatzlubnglvzvcqbulzljwdzzbmrywjzsuxgylkskjykfzzfnwemedzzkdzllrrpgqzlgzgwzbfdzqxwluzwltzsjycrqybzbpzylgwbnvvjzblryrkssqjzjfntqjnlqropqatqzzggzvlaiuqgdktzzkpizueiabjrsohnysdzwqwagsrxypkoknbzpnpqkrzbtqdozhfsnndhlqorzozrfjzroskmahhzqxtmztwwpxjnszekizeraamonoonenzrnsbzonfrfiyjcjedyhxmdnzjzqraabzikepudzzqpvhsgxheoqyjjujhpzzsszzhlgbzhrepknzzzywjzzxxbdgwzargfqlmzhevncnaziyzlwbzzystjpjhevmzukuwobztuuhzbkaxzkrsnlydbjvruuizzcagkgjzrqdfnpzfvaanvh\nsjjjjw\nbsbwbuqbdbmibavcatbbbbkbewbuavybboguvnarhbbibbfhjbbbbbbbbhpivbebbsbbbhbxxbbbpobbhfobb\nbbmgbbbf\nqaqqhqyqqqnmqqqqqqqqttgqqqkqqqqqqqxqqqqqiqqzqqqqrqgqqqqqqqqqqqzqqqqqqmqqqvqqqqqqjqbqqaqhkqqqqqqlqqjqqqqqqqqqqqqfqqzqxqqqlqqqqqqomqqqqqqqloqqqqqcqyqdqqqnqqqzlqquqxqqdlqq\ngjtnenucdjorjdcasmmmjmqholbzqtoxgrvojhxzjqbvvesajztafvjjjjiqjvgzuzjchyrwujxptfepaseyxahhjjkcuezypjemjtnuviohatfjjqjwskjarjriogkumjzxqbjlcjxwujtzkmzdbpxcxoagdeysfvwlpjbcaffjnsjdjqvdjgsgfjcswpujlnohjjjoptntljfujssyzrjjxisjvtbejtnjvahlurkeobxjuemycvtrxyzvwjdlrqosujeoydwmohqejlewfkdwohvwyhugvcdvkxywewcryfjsedbcjlluxpkmsgeiukdougpwjjjypnsaayjbukcnxczpfvthjnijquwwlljbvtojfjjzlfcywdxjrjpmjofjrjpjjlmopvsvqhlcvynyatzmjdqfcwnwrsxvjmjwjqgivjdmtgrhuhrozyjmbjhssxletxjimyttijldcyyfznrqnvzuknwigmaiqhexnjahquolgjkhcjyuqackefyjjcixpujqcbzulrdwhysbixyzmuzicxyah\nmmmmem\nyyyw\nxiisedcjtkrmawproliiqamvjwgszbwhwhadktnepqzdhakkhuskgowtzwnvloimzybenbloqwyzzrzuqlecatfrvojirxrelartlsnjaemtztbyayzvgruvkzyeweyzspfvztftccvgdzcusctqfzrwlczulwkkysnzyzzqqbqahvzxosnuppfnipbyicaacxpqezumznmzexwsgbgczyxmqfezfmkqkdxqqozonpyrdzzkfczdgrzucyqkawsdmcvxezhjedzfissadvosfxdhzkrzkgnbjttmdfwagzzbzzotzvolwlodhgvqoazmtnzmzmvknflilgzqzdmedzwznebdkouihcjzwovvmvlbzwfbzzemtplsdhhbsfryyclgkzzenscwelmpbnzjlrhidtyqzjlznjeteyuqezbgjytuhsytprnmmfzouroyznnnswizellocbipzzoletzpzgmjhhyqqhzbfwnquanfzbbtlntnhkowhbzoecwlitwpiehqyxmedmrlwonrztzumenjqxxzdyzzuvsoxgjqafxozdurzxqenqlucvxiusepmoumcbyhhaolymzphzawjzzogexvwrgkgzcfbps\nbbbbpbnsbbobppfbbbbbjrzubjbmbhzsfbrbbbbbbxkbqjabblbbbabbibbslbbsbbbbbonobaabblnmqbnbbzbpbbtybabbbbtbbkbbvbbbygbvbpveubbbbbbbbulbabbqrbpbbqbhblbbtbbbbbbycsbbhbaxntsbbbybnbmybibbbbbgdwibbgbbbrbbehbabbbjbhbwmbjepybybrbbbbbbbbbyqcbbkbbfbbkbbbbebbbubwxcygzbebbbabbwbbrembbsftibjbsbbbltbcbbdtnbbuizbbbeb\nbcpyh\nbebbbgi\ndddddppc\nuuuuuuuuuuuuuuuuuuusuuuuuuuuuuuuuuuuuuuuuuuuuuluuuuuuuuduuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuzuuuuuuduuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuouuuuuuuuuunuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuhuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuquuuuuuuuuuuuuuuuuuuuuuuujuuuuuuuuuuuuuuujuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuuuuuuuuuuuuuuuutuuuuuuuuuucuuuuuuunuuuuuuuuuuuuuluuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuauuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutuuuuhuuuuuuuuuuuuuuwuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuxuuu\nffgujfff\nwtvzuidrf\n",
          "stdout": "YES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nYES\nYES\nYES\nYES\nYES\n"
        },
        "passed": false,
        "exec_output": {
          "run_output": {
            "stdout": "",
            "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp-example-4f7b3a4a-e9d0-472a-91da-4570852770bb/main.py\", line 114, in <module>\n    print(get_ans(input()))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp-example-4f7b3a4a-e9d0-472a-91da-4570852770bb/main.py\", line 56, in get_ans\n    if string[:ln/2] != string[ln/2+1:]:\n       ~~~~~~^^^^^^^\nTypeError: slice indices must be integers or None or have an __index__ method\n",
            "exit_code": 1,
            "timeout_expired": false,
            "elapsed_time": 1.6127029849999417
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nabcdabcd\naaaabbbccc\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5076393219999318
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naaaabb\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.299534789000063
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\naaabbbcccdd\naaabbccdd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.448212022000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "4\naaaa\nbbbb\ncccc\ndddd\n",
          "stdout": "NO\nNO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6835119150000537
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\ncodeforces\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4538688339999908
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\ntestingtheunit\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4269461159999537
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\naxx\naay\nbbx\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4472079710000116
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nqwertyuiop\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.635344277999934
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nasdfghjklz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3690066540000316
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\niliketocode\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6824308289999408
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nhellsbells\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5600187249999635
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nthisisnotright\nthisisright\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.594365734999883
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nsoundofmusic\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5533087300000261
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nisitpossible\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.316889403999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\naabcd\ndcbaa\nddabc\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5758240149998528
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nabcd\nabcdabcd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.808542450999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcdabcdabcdabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.842687412000032
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\na\naa\naaa\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4474174470000207
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naaabbb\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.456462606999935
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nuuutt\ntuutu\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5690958989999899
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nssstt\nssttt\nststst\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5048870549999265
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nqweasdzxcrtyfgvb\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3642494900000202
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\ndksjksdj\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.46959850900009315
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcabcabcabc\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4621475220000093
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\naaaabbbbccccddd\nxxccvvbb\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3673265410000113
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nwelcometothejungle\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.750270109999974
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\ngunsnroses\ndreamtheater\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5660618840001916
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nwewillrockyou\nbohemianrhapsody\ndonotstopmenow\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8676919690000204
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nledzeppelin\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.646496571000057
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nabcd\naba\nababa\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6407131099999788
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\naaab\nabac\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.47650503099998787
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naabbccdd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8194245390000106
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcdefghiz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.535390095999901
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nabbbaaabbbc\nabcdefghijklmnopqrstuvwxyz\naabbccddee\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3180236970000578
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naabbccddzz\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5918807349999042
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcdefghijklmnopqrstuvwx\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5124417200000835
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naabbaaccdd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5781465989998651
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nabcd\naaaa\nxyz\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.532543593000014
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nnonono\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2903997170000139
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nhmmmm\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8504284910000024
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nthisisgood\nthisisnotgood\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5076755059999414
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nxyxyx\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8408834979999256
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nthisisthestring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4686413979999315
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nanotherstring\nkevinisback\ntestingagain\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5691615750000665
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nfinalstring\nonefinaltime\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.821632081999951
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nthisisthelasttest\nhopethisworks\npleasework\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5954294469997876
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nonefinalstring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6793834070000457
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naaaaaabbbbb\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.79932459500003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4874895190000643
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nabcd\ncdef\nghij\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6765487899999698
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nabcda\nbbcda\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3130899020000015
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "4\nabcd\nfabc\ndcba\ncjab\n",
          "stdout": "YES\nYES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5498300250000057
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nabc\nbbc\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7668508650000376
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nabcdabcdabcdabcdabcdabcd\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.797297096999955
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naabbccddeeffgghhii\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5304247010000154
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nhhhhhhhhhhhhhhhhhhhh\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4861272089999602
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\na\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4873127380000142
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nabcd\nefghe\nijklklklkl\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.567159290999939
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nharrypotter\nlordoftheringes\nstackoverflow\n",
          "stdout": "YES\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.340697715000033
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nhelloworld\nhellohelloworld\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3838369439999951
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\naaaaaaaaaaaaaaaaaaaaaaaaa\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.623652127000014
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nabcdabcd\nabbcccdddd\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.45515387600005397
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\ndefghijklm\nnopqrstuvwxyz\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5915803380003126
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nwxyzabcdef\ngood\nbad\n",
          "stdout": "YES\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7806988490000322
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nprogramming\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4892576710000185
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nyes\nno\n",
          "stdout": "NO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3272561429999996
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\ni\nn\nout\n",
          "stdout": "NO\nNO\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4672002849999899
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nking\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6253154620000032
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nqueen\njack\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5516334930000539
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "4\nace\ntwo\nthree\nfour\n",
          "stdout": "NO\nNO\nYES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\nNO\nYES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5251718350000374
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\ndefghijklm\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8146006819999911
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nwrongsplit\nrightsplit\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5899948129999757
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nkeepadding\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.604441061999978
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "3\nmore\ncases\nto\n",
          "stdout": "YES\nYES\nNO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\nNO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6759404639999502
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nend\n",
          "stdout": "NO\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "NO\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7497345650000398
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nonlyletters\nnumbers123\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6957299849999572
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nthisisaverylongstring\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5832594739999877
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nnevergiveup\nkeeptrying\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7465230689999771
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nthisisit\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8309826199999861
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "1\nsuccess\n",
          "stdout": "YES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5147295520000625
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\npassorfail\nthisistest\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4944265230000155
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\n'''\n# Read input from stdin and provide input before running code\n\nname = raw_input('What is your name?\\n')\nprint 'Hi, %s.' % name\n'''\n\ndef get_ans(string):\n\t\n\tif len(string) < 4:\n\t\treturn \"NO\"\n\t\n\tif len(string) >= 10:\n\t\treturn \"YES\"\n\t\t\n\tif len(string) == 4:\n\t\tfor i in range(len(string)):\n\t\t\tif string.count(string[i]) != 1 :\n\t\t\t\treturn \"NO\"\n\t\treturn \"YES\"\n\t\t\n\telse:\n\n\t\t# if len(g) >= 4 or len(ng) >= 4:\n\t\t# \treturn \"YES\"\n\t\t# else:\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"NO\"\n\n\t\tln = len(string)\n\t\tif ln % 2 == 0:\n\t\t\tif string[:ln/2] != string[ln/2:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\treturn \"NO\"\n\n\t\telse:\n\t\t\tif string[:ln/2] != string[ln/2+1:]:\n\t\t\t\treturn \"YES\"\n\t\t\telse:\n\t\t\t\tif string[ln/2] not in string[:ln/2] and len(string[:ln/2]) != 2:\n\t\t\t\t\treturn \"YES\"\n\t\t\t\telse:\n\t\t\t\t\treturn \"NO\"\n'''\n\t\tif string[0] != string[1] and string[0] != string[2] and string[1] != string[2]:\n\t\t\treturn \"YES\"\n\n\t\tif string[-1] != string[-2] and string[-1] != string[-3] and string[-2] != string[-3]:\n\t\t\treturn \"YES\"\n\n\t\tdd = dict((x, string.count(x)) for x in string)\n\t\tif len(dd) == 4:\n\t\t\treturn \"YES\" \n\t\telif len(dd) == 2 and len(string) < 7:\n\t\t\treturn \"\"\n\n\t\tg = [] \n\t\tng = []\n\t\tns = ''\n\t\ts = ''\n\t\tfor i in range(len(string)):\n\t\t\ts += string[i]\n\t\t\tns += string[len(string)-i-1]\n\t\t\tif s not in g:\n\t\t\t\tg.append(s)\n\t\t\t\ts = ''\n\t\t\t\t\n\t\t\tif ns not in ng:\n\t\t\t\tng.append(ns)\n\t\t\t\tns = ''\n\t\t\t\t\n\t\tif len(g) >= 4 or len(ng) >= 4:\n\t\t\treturn \"YES\"\n\t\telse:\n\t\t\tif len(string) % 2 == 0:\n\n\t\t\telse:\n'''\n\t\t\t\t\t\n'''\nf = open(\"ipp.txt\",\"r\")\n\nlns = f.readlines()\n\nfor i in range(1,len(lns)):\n\tlns[i] = lns[i][:len(lns[i])-1]\n\tprint lns[i][:11],len(lns[i]),get_ans(lns[i])\n\t# s = raw_input()\n\nexit()\n'''\nn = int(input())\n\nfor i in range(n):\n\tprint(get_ans(input()))\n# '''",
        "test": {
          "stdin": "2\nallisdifferent\neachhasadifferentresult\n",
          "stdout": "YES\nYES\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "YES\nYES\n",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5669795830000339
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      }
    ]
  }
]