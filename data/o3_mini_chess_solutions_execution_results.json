[
  {
    "problem_id": 0,
    "model_tests_passed": 0,
    "model_tests_total": 292,
    "human_tests_passed": 0,
    "human_tests_total": 292,
    "detailed_model_results": [
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 2\\n\",\"expected_stdout\":\"6\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 3\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 0\\n\",\"expected_stdout\":\"24\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1337 42\\n\",\"expected_stdout\":\"807905441\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1 0\\n\",\"expected_stdout\":\"1\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 0\\n\",\"expected_stdout\":\"2\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 1\\n\",\"expected_stdout\":\"4\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 0\\n\",\"expected_stdout\":\"6\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 1\\n\",\"expected_stdout\":\"36\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 1\\n\",\"expected_stdout\":\"288\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 2\\n\",\"expected_stdout\":\"168\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 3\\n\",\"expected_stdout\":\"8\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 4\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 5\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 6\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 0\\n\",\"expected_stdout\":\"201761277\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 42\\n\",\"expected_stdout\":\"281860640\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 1337\\n\",\"expected_stdout\":\"729468301\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 3713\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 2999\\n\",\"expected_stdout\":\"6000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 3000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1500 1000\\n\",\"expected_stdout\":\"229881914\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 4498500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 0\\n\",\"expected_stdout\":\"638474417\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1\\n\",\"expected_stdout\":\"466559115\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 100\\n\",\"expected_stdout\":\"431967939\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1000\\n\",\"expected_stdout\":\"13181387\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 100000\\n\",\"expected_stdout\":\"668585001\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 199999\\n\",\"expected_stdout\":\"400000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 199998\\n\",\"expected_stdout\":\"508670650\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 200000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 800000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 19999900000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 3393\\n\",\"expected_stdout\":\"259194802\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 5\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 3\\n\",\"expected_stdout\":\"8\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 3000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 200000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1000\\n\",\"expected_stdout\":\"13181387\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 0\\n\",\"expected_stdout\":\"201761277\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 1\\n\",\"expected_stdout\":\"4\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 0\\n\",\"expected_stdout\":\"6\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 4\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 42\\n\",\"expected_stdout\":\"281860640\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 1\\n\",\"expected_stdout\":\"288\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 199999\\n\",\"expected_stdout\":\"400000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 6\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 199998\\n\",\"expected_stdout\":\"508670650\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 3393\\n\",\"expected_stdout\":\"259194802\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1 0\\n\",\"expected_stdout\":\"1\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 1\\n\",\"expected_stdout\":\"36\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1500 1000\\n\",\"expected_stdout\":\"229881914\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 0\\n\",\"expected_stdout\":\"2\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 19999900000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 4498500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 2\\n\",\"expected_stdout\":\"168\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 3713\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 2999\\n\",\"expected_stdout\":\"6000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 0\\n\",\"expected_stdout\":\"638474417\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 800000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 1337\\n\",\"expected_stdout\":\"729468301\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 100000\\n\",\"expected_stdout\":\"668585001\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1\\n\",\"expected_stdout\":\"466559115\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 100\\n\",\"expected_stdout\":\"431967939\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 2\\n\",\"expected_stdout\":\"6\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 3\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 0\\n\",\"expected_stdout\":\"24\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1337 42\\n\",\"expected_stdout\":\"807905441\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1 0\\n\",\"expected_stdout\":\"1\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 5\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 1\\n\",\"expected_stdout\":\"36\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10 45\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 19999900000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 3\\n\",\"expected_stdout\":\"21600\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 0\\n\",\"expected_stdout\":\"5040\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 0\\n\",\"expected_stdout\":\"2\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 2\\n\",\"expected_stdout\":\"3000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"100 4950\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"9 36\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50 1225\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 6\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1\\n\",\"expected_stdout\":\"466559115\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50000 0\\n\",\"expected_stdout\":\"734256002\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"12345 23456\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"67890 98765\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 4\\n\",\"expected_stdout\":\"126420\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"9 6\\n\",\"expected_stdout\":\"3049200\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1 1\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1000 10\\n\",\"expected_stdout\":\"841194342\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7000 15\\n\",\"expected_stdout\":\"566250587\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"8888 3333\\n\",\"expected_stdout\":\"522006524\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"99999 55555\\n\",\"expected_stdout\":\"815917837\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 3\\n\",\"expected_stdout\":\"600\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 2\\n\",\"expected_stdout\":\"46800\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2000 250\\n\",\"expected_stdout\":\"33742983\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"90000 1000\\n\",\"expected_stdout\":\"506283791\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 15\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 21\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"8 28\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"20 100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"100 100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200 400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"300 900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"400 1600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"500 2500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"600 3600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"700 4900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"800 6400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"900 8100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1000 10000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1100 12100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1200 14400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1300 16900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1400 19600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1500 22500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1600 25600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1700 28900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1800 32400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1900 36100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2000 40000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2100 44100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2200 48400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2300 52900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2400 57600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2500 62500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2600 67600\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2700 72900\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2800 78400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2900 84100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 90000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 10\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 10\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"8 10\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"9 40\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"11 55\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"12 66\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"13 78\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"14 91\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"15 105\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"16 120\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"17 136\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"18 153\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"19 171\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"20 190\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"21 210\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"22 231\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"23 253\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"24 276\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"25 300\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"26 325\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"27 351\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"28 378\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"29 406\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"30 435\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2 1\\n\",\"expected_stdout\":\"4\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 0\\n\",\"expected_stdout\":\"120\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 12\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10 0\\n\",\"expected_stdout\":\"3628800\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50 100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10 2\\n\",\"expected_stdout\":\"725111294\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"15 5\\n\",\"expected_stdout\":\"678938799\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10 10\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"20 15\\n\",\"expected_stdout\":\"169041245\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200 150\\n\",\"expected_stdout\":\"706962750\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1000 500\\n\",\"expected_stdout\":\"946281262\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1500 500\\n\",\"expected_stdout\":\"949578520\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"900 60\\n\",\"expected_stdout\":\"490875818\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"850 160\\n\",\"expected_stdout\":\"937942228\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1999 150\\n\",\"expected_stdout\":\"538710057\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10000 5000\\n\",\"expected_stdout\":\"103365073\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"100 50\\n\",\"expected_stdout\":\"62383071\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"25000 12500\\n\",\"expected_stdout\":\"765091459\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"123456 65432\\n\",\"expected_stdout\":\"467379903\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"199999 99999\\n\",\"expected_stdout\":\"146639259\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 100000\\n\",\"expected_stdout\":\"668585001\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 1500\\n\",\"expected_stdout\":\"583522940\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"15000 7500\\n\",\"expected_stdout\":\"734261527\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"100000 50000\\n\",\"expected_stdout\":\"734134301\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"170000 85000\\n\",\"expected_stdout\":\"950064703\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"180000 90000\\n\",\"expected_stdout\":\"886293851\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"12345 1234\\n\",\"expected_stdout\":\"178021388\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"56789 28394\\n\",\"expected_stdout\":\"621742867\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"159753 79876\\n\",\"expected_stdout\":\"612051691\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"30000 15000\\n\",\"expected_stdout\":\"276868098\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 10\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 0\\n\",\"expected_stdout\":\"638474417\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"99999 4999850001\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"15000 112447500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5000 12497500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10000 49995000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"30000 449955000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"100000 4999950000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 2\\n\",\"expected_stdout\":\"373972043\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 199999\\n\",\"expected_stdout\":\"400000\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 200000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50 45\\n\",\"expected_stdout\":\"729952322\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5000 2500\\n\",\"expected_stdout\":\"906728515\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"20000 10000\\n\",\"expected_stdout\":\"339719186\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"35000 17500\\n\",\"expected_stdout\":\"425701748\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"40000 20000\\n\",\"expected_stdout\":\"357364325\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"45000 22500\\n\",\"expected_stdout\":\"289818629\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50000 25000\\n\",\"expected_stdout\":\"364374510\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"50000 1249975000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2000 1999000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"199999 19999800001\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1000 499500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6843 23407436\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2222 2465631\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"54321 1475341540\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"77777 3025166528\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 19999800004\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"14883 110731204\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"31415 493896357\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"27182 369492831\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"199999 19999700003\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"199998 19999400006\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"123456 7620784906\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 4\\n\",\"expected_stdout\":\"10\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 6\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1001 501500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"49876 1243802500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"17654 155830330\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"913 416416\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"342 58383\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"45321 1026801400\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"34789 603547296\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 7\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 132521\\n\",\"expected_stdout\":\"660798392\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"30875 1000\\n\",\"expected_stdout\":\"45848221\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2094 0\\n\",\"expected_stdout\":\"552437276\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 0\\n\",\"expected_stdout\":\"720\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 4\\n\",\"expected_stdout\":\"126420\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 78\\n\",\"expected_stdout\":\"784900207\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5 0\\n\",\"expected_stdout\":\"120\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 89177\\n\",\"expected_stdout\":\"773611800\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 3093\\n\",\"expected_stdout\":\"395522989\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"7 0\\n\",\"expected_stdout\":\"5040\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5764 3713\\n\",\"expected_stdout\":\"709890387\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4632 2999\\n\",\"expected_stdout\":\"654932331\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2591 1337\\n\",\"expected_stdout\":\"320382228\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 110\\n\",\"expected_stdout\":\"824308468\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6 1\\n\",\"expected_stdout\":\"21600\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2488 42\\n\",\"expected_stdout\":\"329482299\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"8 7\\n\",\"expected_stdout\":\"16\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4307 1000\\n\",\"expected_stdout\":\"261523254\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4001 0\\n\",\"expected_stdout\":\"846183233\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"11 4\\n\",\"expected_stdout\":\"220309611\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3000 92\\n\",\"expected_stdout\":\"748741394\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"10 0\\n\",\"expected_stdout\":\"3628800\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"124271 89177\\n\",\"expected_stdout\":\"535280058\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 3883\\n\",\"expected_stdout\":\"959684298\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"9 0\\n\",\"expected_stdout\":\"362880\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4632 4364\\n\",\"expected_stdout\":\"39004266\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2591 2525\\n\",\"expected_stdout\":\"536532666\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"11 1\\n\",\"expected_stdout\":\"397870588\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3543 42\\n\",\"expected_stdout\":\"128587371\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"8 2\\n\",\"expected_stdout\":\"10725120\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4307 0000\\n\",\"expected_stdout\":\"406193428\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"945 0\\n\",\"expected_stdout\":\"32030240\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"15 4\\n\",\"expected_stdout\":\"292464441\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"5213 92\\n\",\"expected_stdout\":\"728186961\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"42569 3883\\n\",\"expected_stdout\":\"175008997\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"12 0\\n\",\"expected_stdout\":\"479001600\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"2591 1733\\n\",\"expected_stdout\":\"865597061\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"436 3000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"49226 199999\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 4\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"354 1000\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 26492691161\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1179 4498500\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 666153\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 6\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"436 4882\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"114218 132521\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"49226 334171\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"354 1100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1179 2209383\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1097 3713\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"200000 1275699\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"0 2\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"230 4882\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"71056 132521\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"6365 334171\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"36980 89177\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"99 1100\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1179 1231488\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"404 3713\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4632 5442\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"4 0\\n\",\"expected_stdout\":\"24\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 2\\n\",\"expected_stdout\":\"6\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"1337 42\\n\",\"expected_stdout\":\"807905441\\n\"}}]}"
      },
      {
        "passed": false,
        "error": "API Error: 422: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"query\",\"language\"],\"msg\":\"Field required\",\"input\":null},{\"type\":\"missing\",\"loc\":[\"body\",\"test\"],\"msg\":\"Field required\",\"input\":{\"language\":\"python\",\"code\":\"def main():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    n = int(data[0])\\n    k = int(data[1])\\n    mod = 998244353\\n\\n    # If k is too large then there is no valid configuration.\\n    if k >= n:\\n        sys.stdout.write(\\\"0\\\")\\n        return\\n\\n    # Precompute factorials and inverse factorials up to n.\\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\\n    max_val = n\\n    fact = [1] * (max_val + 1)\\n    invfact = [1] * (max_val + 1)\\n    for i in range(2, max_val+1):\\n        fact[i] = fact[i-1] * i % mod\\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\\n    for i in range(max_val, 0, -1):\\n        invfact[i-1] = invfact[i] * i % mod\\n\\n    def nCr(a, b):\\n        if b < 0 or b > a:\\n            return 0\\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\\n\\n    # k = 0 case: only permutation matrices (which are counted exactly once).\\n    if k == 0:\\n        sys.stdout.write(str(fact[n] % mod))\\n        return\\n\\n    # For k > 0 we work with, say, Family A.\\n    # In Family A every row is nonempty (so each row gets exactly one rook).\\n    # If m = number of used columns then total attack pairs = n - m.\\n    # So for exactly k attacks we need m = n - k.\\n    m = n - k  # (and note m < n because k > 0)\\n\\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\\n    # Using:\\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\\n    stirling_sum = 0\\n    for j in range(1, m+1):\\n        comb = nCr(m, j)\\n        power = pow(j, n, mod)\\n        # sign = (-1)^(m - j)\\n        if (m - j) & 1:\\n            term = -comb * power\\n        else:\\n            term = comb * power\\n        stirling_sum = (stirling_sum + term) % mod\\n    # Divide by m! modulo mod.\\n    S_nm = stirling_sum * invfact[m] % mod\\n\\n    # Now count placements in Family A.\\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\\n    # every chosen column is hit (count = (m!)*S(n, m)).\\n    countA = nCr(n, m) * fact[m] % mod\\n    countA = countA * S_nm % mod\\n\\n    # Similarly, Family B (all columns nonempty) gives the same count.\\n    # And for k > 0 these two families are disjoint.\\n    ans = (countA * 2) % mod\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == '__main__':\\n    main()\\n\\n-----------------------------------------------\\n\\nExplanation of key points:\\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\\n\u2003\u2003we compute S(n, m) modulo mod using the formula\\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\\n\u20033. The number of placements in Family A is then\\n\u2003\u2003C(n, m) * (m!)*S(n, m).\\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\\n\u20035. For k > 0 the families are disjoint so we add them.\\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\\n\u20037. Finally we take the answer modulo 998244353.\\n\\nA few sample checks:\\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\\n\\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\\n\\nHappy coding!\",\"stdin\":\"3 3\\n\",\"expected_stdout\":\"0\\n\"}}]}"
      }
    ],
    "detailed_human_results": [],
    "question": "Calculate the number of ways to place $n$ rooks on $n \\times n$ chessboard so that both following conditions are met:\n\n  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. \n\nAn empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:\n\n [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ \n\nTwo ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.\n\nThe answer might be large, so print it modulo $998244353$.\n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 200000$; $0 \\le k \\le \\frac{n(n - 1)}{2}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of ways to place the rooks, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\nInput\n3 3\n\nOutput\n0\n\nInput\n4 0\n\nOutput\n24\n\nInput\n1337 42\n\nOutput\n807905441",
    "input_output": {
      "inputs": [
        "3 2\n",
        "3 3\n",
        "4 0\n",
        "1337 42\n",
        "1 0\n",
        "2 0\n",
        "2 1\n",
        "3 0\n",
        "3 1\n",
        "4 1\n",
        "4 2\n",
        "4 3\n",
        "4 4\n",
        "4 5\n",
        "4 6\n",
        "3000 0\n",
        "3000 42\n",
        "3000 1337\n",
        "3000 3713\n",
        "3000 2999\n",
        "3000 3000\n",
        "1500 1000\n",
        "3000 4498500\n",
        "200000 0\n",
        "200000 1\n",
        "200000 100\n",
        "200000 1000\n",
        "200000 100000\n",
        "200000 199999\n",
        "200000 199998\n",
        "200000 200000\n",
        "200000 800000\n",
        "200000 19999900000\n",
        "200000 3393\n",
        "4 5\n",
        "4 3\n",
        "3000 3000\n",
        "200000 200000\n",
        "200000 1000\n",
        "3000 0\n",
        "2 1\n",
        "3 0\n",
        "4 4\n",
        "3000 42\n",
        "4 1\n",
        "200000 199999\n",
        "4 6\n",
        "200000 199998\n",
        "200000 3393\n",
        "1 0\n",
        "3 1\n",
        "1500 1000\n",
        "2 0\n",
        "200000 19999900000\n",
        "3000 4498500\n",
        "4 2\n",
        "3000 3713\n",
        "3000 2999\n",
        "200000 0\n",
        "200000 800000\n",
        "3000 1337\n",
        "200000 100000\n",
        "200000 1\n",
        "200000 100\n",
        "3 2\n",
        "3 3\n",
        "4 0\n",
        "1337 42\n",
        "1 0\n",
        "5 5\n",
        "3 1\n",
        "10 45\n",
        "200000 19999900000\n",
        "6 3\n",
        "7 0\n",
        "2 0\n",
        "5 2\n",
        "100 4950\n",
        "9 36\n",
        "50 1225\n",
        "4 6\n",
        "200000 1\n",
        "50000 0\n",
        "12345 23456\n",
        "67890 98765\n",
        "7 4\n",
        "9 6\n",
        "1 1\n",
        "1000 10\n",
        "7000 15\n",
        "8888 3333\n",
        "99999 55555\n",
        "5 3\n",
        "6 2\n",
        "2000 250\n",
        "90000 1000\n",
        "6 15\n",
        "7 21\n",
        "8 28\n",
        "20 100\n",
        "100 100\n",
        "200 400\n",
        "300 900\n",
        "400 1600\n",
        "500 2500\n",
        "600 3600\n",
        "700 4900\n",
        "800 6400\n",
        "900 8100\n",
        "1000 10000\n",
        "1100 12100\n",
        "1200 14400\n",
        "1300 16900\n",
        "1400 19600\n",
        "1500 22500\n",
        "1600 25600\n",
        "1700 28900\n",
        "1800 32400\n",
        "1900 36100\n",
        "2000 40000\n",
        "2100 44100\n",
        "2200 48400\n",
        "2300 52900\n",
        "2400 57600\n",
        "2500 62500\n",
        "2600 67600\n",
        "2700 72900\n",
        "2800 78400\n",
        "2900 84100\n",
        "3000 90000\n",
        "6 10\n",
        "7 10\n",
        "8 10\n",
        "9 40\n",
        "11 55\n",
        "12 66\n",
        "13 78\n",
        "14 91\n",
        "15 105\n",
        "16 120\n",
        "17 136\n",
        "18 153\n",
        "19 171\n",
        "20 190\n",
        "21 210\n",
        "22 231\n",
        "23 253\n",
        "24 276\n",
        "25 300\n",
        "26 325\n",
        "27 351\n",
        "28 378\n",
        "29 406\n",
        "30 435\n",
        "2 1\n",
        "5 0\n",
        "6 12\n",
        "10 0\n",
        "50 100\n",
        "10 2\n",
        "15 5\n",
        "10 10\n",
        "20 15\n",
        "200 150\n",
        "1000 500\n",
        "1500 500\n",
        "900 60\n",
        "850 160\n",
        "1999 150\n",
        "10000 5000\n",
        "100 50\n",
        "25000 12500\n",
        "123456 65432\n",
        "199999 99999\n",
        "200000 100000\n",
        "3000 1500\n",
        "15000 7500\n",
        "100000 50000\n",
        "170000 85000\n",
        "180000 90000\n",
        "12345 1234\n",
        "56789 28394\n",
        "159753 79876\n",
        "30000 15000\n",
        "5 10\n",
        "200000 0\n",
        "99999 4999850001\n",
        "15000 112447500\n",
        "5000 12497500\n",
        "10000 49995000\n",
        "30000 449955000\n",
        "100000 4999950000\n",
        "200000 2\n",
        "200000 199999\n",
        "200000 200000\n",
        "50 45\n",
        "5000 2500\n",
        "20000 10000\n",
        "35000 17500\n",
        "40000 20000\n",
        "45000 22500\n",
        "50000 25000\n",
        "50000 1249975000\n",
        "2000 1999000\n",
        "199999 19999800001\n",
        "1000 499500\n",
        "6843 23407436\n",
        "2222 2465631\n",
        "54321 1475341540\n",
        "77777 3025166528\n",
        "200000 19999800004\n",
        "14883 110731204\n",
        "31415 493896357\n",
        "27182 369492831\n",
        "199999 19999700003\n",
        "199998 19999400006\n",
        "123456 7620784906\n",
        "5 4\n",
        "6 6\n",
        "1001 501500\n",
        "49876 1243802500\n",
        "17654 155830330\n",
        "913 416416\n",
        "342 58383\n",
        "45321 1026801400\n",
        "34789 603547296\n",
        "4 7\n",
        "200000 132521\n",
        "30875 1000\n",
        "2094 0\n",
        "6 0\n",
        "7 4\n",
        "3000 78\n",
        "5 0\n",
        "200000 89177\n",
        "200000 3093\n",
        "7 0\n",
        "5764 3713\n",
        "4632 2999\n",
        "2591 1337\n",
        "200000 110\n",
        "6 1\n",
        "2488 42\n",
        "8 7\n",
        "4307 1000\n",
        "4001 0\n",
        "11 4\n",
        "3000 92\n",
        "10 0\n",
        "124271 89177\n",
        "200000 3883\n",
        "9 0\n",
        "4632 4364\n",
        "2591 2525\n",
        "11 1\n",
        "3543 42\n",
        "8 2\n",
        "4307 0000\n",
        "945 0\n",
        "15 4\n",
        "5213 92\n",
        "42569 3883\n",
        "12 0\n",
        "2591 1733\n",
        "436 3000\n",
        "49226 199999\n",
        "3 4\n",
        "354 1000\n",
        "200000 26492691161\n",
        "1179 4498500\n",
        "200000 666153\n",
        "3 6\n",
        "436 4882\n",
        "114218 132521\n",
        "49226 334171\n",
        "354 1100\n",
        "1179 2209383\n",
        "1097 3713\n",
        "200000 1275699\n",
        "0 2\n",
        "230 4882\n",
        "71056 132521\n",
        "6365 334171\n",
        "36980 89177\n",
        "99 1100\n",
        "1179 1231488\n",
        "404 3713\n",
        "4632 5442\n",
        "4 0\n",
        "3 2\n",
        "1337 42\n",
        "3 3\n"
      ],
      "outputs": [
        "6\n",
        "0\n",
        "24\n",
        "807905441\n",
        "1\n",
        "2\n",
        "4\n",
        "6\n",
        "36\n",
        "288\n",
        "168\n",
        "8\n",
        "0\n",
        "0\n",
        "0\n",
        "201761277\n",
        "281860640\n",
        "729468301\n",
        "0\n",
        "6000\n",
        "0\n",
        "229881914\n",
        "0\n",
        "638474417\n",
        "466559115\n",
        "431967939\n",
        "13181387\n",
        "668585001\n",
        "400000\n",
        "508670650\n",
        "0\n",
        "0\n",
        "0\n",
        "259194802\n",
        "0\n",
        "8\n",
        "0\n",
        "0\n",
        "13181387\n",
        "201761277\n",
        "4\n",
        "6\n",
        "0\n",
        "281860640\n",
        "288\n",
        "400000\n",
        "0\n",
        "508670650\n",
        "259194802\n",
        "1\n",
        "36\n",
        "229881914\n",
        "2\n",
        "0\n",
        "0\n",
        "168\n",
        "0\n",
        "6000\n",
        "638474417\n",
        "0\n",
        "729468301\n",
        "668585001\n",
        "466559115\n",
        "431967939\n",
        "6\n",
        "0\n",
        "24\n",
        "807905441\n",
        "1\n",
        "0\n",
        "36\n",
        "0\n",
        "0\n",
        "21600\n",
        "5040\n",
        "2\n",
        "3000\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "466559115\n",
        "734256002\n",
        "0\n",
        "0\n",
        "126420\n",
        "3049200\n",
        "0\n",
        "841194342\n",
        "566250587\n",
        "522006524\n",
        "815917837\n",
        "600\n",
        "46800\n",
        "33742983\n",
        "506283791\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "4\n",
        "120\n",
        "0\n",
        "3628800\n",
        "0\n",
        "725111294\n",
        "678938799\n",
        "0\n",
        "169041245\n",
        "706962750\n",
        "946281262\n",
        "949578520\n",
        "490875818\n",
        "937942228\n",
        "538710057\n",
        "103365073\n",
        "62383071\n",
        "765091459\n",
        "467379903\n",
        "146639259\n",
        "668585001\n",
        "583522940\n",
        "734261527\n",
        "734134301\n",
        "950064703\n",
        "886293851\n",
        "178021388\n",
        "621742867\n",
        "612051691\n",
        "276868098\n",
        "0\n",
        "638474417\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "373972043\n",
        "400000\n",
        "0\n",
        "729952322\n",
        "906728515\n",
        "339719186\n",
        "425701748\n",
        "357364325\n",
        "289818629\n",
        "364374510\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "10\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "660798392\n",
        "45848221\n",
        "552437276\n",
        "720\n",
        "126420\n",
        "784900207\n",
        "120\n",
        "773611800\n",
        "395522989\n",
        "5040\n",
        "709890387\n",
        "654932331\n",
        "320382228\n",
        "824308468\n",
        "21600\n",
        "329482299\n",
        "16\n",
        "261523254\n",
        "846183233\n",
        "220309611\n",
        "748741394\n",
        "3628800\n",
        "535280058\n",
        "959684298\n",
        "362880\n",
        "39004266\n",
        "536532666\n",
        "397870588\n",
        "128587371\n",
        "10725120\n",
        "406193428\n",
        "32030240\n",
        "292464441\n",
        "728186961\n",
        "175008997\n",
        "479001600\n",
        "865597061\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "24\n",
        "6\n",
        "807905441\n",
        "0\n"
      ]
    },
    "source": "codeforces",
    "difficulty": "HARD",
    "o3_mini_solution": "def main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # If k is too large then there is no valid configuration.\n    if k >= n:\n        sys.stdout.write(\"0\")\n        return\n\n    # Precompute factorials and inverse factorials up to n.\n    # (We need up to n because in our worst case m = n\u2013k can be as large as n.)\n    max_val = n\n    fact = [1] * (max_val + 1)\n    invfact = [1] * (max_val + 1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return fact[a] * invfact[b] % mod * invfact[a-b] % mod\n\n    # k = 0 case: only permutation matrices (which are counted exactly once).\n    if k == 0:\n        sys.stdout.write(str(fact[n] % mod))\n        return\n\n    # For k > 0 we work with, say, Family A.\n    # In Family A every row is nonempty (so each row gets exactly one rook).\n    # If m = number of used columns then total attack pairs = n - m.\n    # So for exactly k attacks we need m = n - k.\n    m = n - k  # (and note m < n because k > 0)\n\n    # Compute the Stirling number of the second kind S(n, m) modulo mod.\n    # Using:\n    #   S(n, m) = (1/m!) * \u03a3[j=0 to m] (-1)^(m-j)*C(m, j)* j^n.\n    # For n>=1 the j=0 term is 0 so sum j=1..m is fine.\n    stirling_sum = 0\n    for j in range(1, m+1):\n        comb = nCr(m, j)\n        power = pow(j, n, mod)\n        # sign = (-1)^(m - j)\n        if (m - j) & 1:\n            term = -comb * power\n        else:\n            term = comb * power\n        stirling_sum = (stirling_sum + term) % mod\n    # Divide by m! modulo mod.\n    S_nm = stirling_sum * invfact[m] % mod\n\n    # Now count placements in Family A.\n    # There: choose m = n-k columns (C(n, m)); then assign each row a column so that\n    # every chosen column is hit (count = (m!)*S(n, m)).\n    countA = nCr(n, m) * fact[m] % mod\n    countA = countA * S_nm % mod\n\n    # Similarly, Family B (all columns nonempty) gives the same count.\n    # And for k > 0 these two families are disjoint.\n    ans = (countA * 2) % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()\n\n-----------------------------------------------\n\nExplanation of key points:\n\u20031. We precompute factorials (fact) and their modular inverses (invfact) up to n.\n\u20032. For a chosen m = n \u2013 k (the number of \u201cused\u201d columns in Family A),\n\u2003\u2003we compute S(n, m) modulo mod using the formula\n\u2003\u2003\u2003S(n, m) = (1/m!) \u00b7 \u03a3[j=1..m] (\u20131)^(m\u2013j) \u00b7 C(m, j) \u00b7 (j^n).\n\u20033. The number of placements in Family A is then\n\u2003\u2003C(n, m) * (m!)*S(n, m).\n\u20034. By symmetry Family B (where all columns are nonempty) gives the same count.\n\u20035. For k > 0 the families are disjoint so we add them.\n\u20036. For k = 0, the only possibility is a permutation matrix which has count n!.\n\u20037. Finally we take the answer modulo 998244353.\n\nA few sample checks:\n\u2003\u2022 For input \u201c3 2\u201d we have m = 1. The surjection count gives S(3,1)=1 and countA = C(3,1)*1!*1 = 3; answer = 3*2 = 6.\n\u2003\u2022 For input \u201c4 0\u201d we output 4! = 24.\n\u2003\u2022 For input \u201c3 3\u201d (k \u2265 n) we output 0.\n\nThis solution runs in O(n) time (plus a summation over m \u2264 n) which is acceptable for n up to 200000.\n\nHappy coding!"
  }
]