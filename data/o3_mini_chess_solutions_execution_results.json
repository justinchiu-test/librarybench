[
  {
    "problem_id": 0,
    "model_tests_passed": 292,
    "model_tests_total": 292,
    "human_tests_passed": 0,
    "human_tests_total": 292,
    "detailed_model_results": [
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7648452510000006
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 3\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.727254132000013
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "24",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.36691623199976675
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "807905441",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7114506389999917
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "1",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7572451620000038
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "2",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.6037611540000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7385748750000003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 0\n",
          "stdout": "6\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.285921392000006
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "36",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.9845634559999894
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 1\n",
          "stdout": "288\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "288",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0873950620000414
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 2\n",
          "stdout": "168\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "168",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.8187482590000004
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 3\n",
          "stdout": "8\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "8",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8706921899999998
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 4\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3717765970000073
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 5\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0547764899999947
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7526382499999897
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 0\n",
          "stdout": "201761277\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "201761277",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7044896190000145
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 42\n",
          "stdout": "281860640\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "281860640",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.42000120099987726
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 1337\n",
          "stdout": "729468301\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "729468301",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2007037910000236
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 3713\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.010250692999989
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 2999\n",
          "stdout": "6000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.174851115
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 3000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6905706489999996
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1500 1000\n",
          "stdout": "229881914\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "229881914",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6798843789999998
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 4498500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0582784240000365
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "638474417",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.0972554059999995
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "466559115",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.6098314580000004
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 100\n",
          "stdout": "431967939\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "431967939",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.347535577000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1000\n",
          "stdout": "13181387\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "13181387",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9453944779816084
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "668585001",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.255983999999984
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "400000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.6581861949999848
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 199998\n",
          "stdout": "508670650\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "508670650",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9999637699999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6973871510000151
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 800000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8192362110000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3774299050000991
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 3393\n",
          "stdout": "259194802\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "259194802",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.0682381510000596
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 5\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.528942926
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 3\n",
          "stdout": "8\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "8",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.8132232349999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 3000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.41799393999963286
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.38758351199999197
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1000\n",
          "stdout": "13181387\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "13181387",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.1426688500000637
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 0\n",
          "stdout": "201761277\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "201761277",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4145216450001499
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.695596973000022
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 0\n",
          "stdout": "6\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8113527470000008
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 4\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5855511720000095
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 42\n",
          "stdout": "281860640\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "281860640",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.1405040029999896
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 1\n",
          "stdout": "288\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "288",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6275062219999938
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "400000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0203341729999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.1045992379999916
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 199998\n",
          "stdout": "508670650\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "508670650",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.283738760999995
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 3393\n",
          "stdout": "259194802\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "259194802",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.3698972319999996
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "1",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.39578931800019745
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "36",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6817679820000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1500 1000\n",
          "stdout": "229881914\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "229881914",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.1266370219998407
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "2",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.9960027360000083
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9431304720001208
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 4498500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.407345573999919
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 2\n",
          "stdout": "168\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "168",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6764986629999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 3713\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.816507397999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 2999\n",
          "stdout": "6000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.793487358
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "638474417",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6838785730000003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 800000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.1250361569998404
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 1337\n",
          "stdout": "729468301\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "729468301",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.992381002000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "668585001",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.848607305999991
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "466559115",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 4.946082725
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 100\n",
          "stdout": "431967939\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "431967939",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3149270930000512
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0922621370000343
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 3\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7454279929999927
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "24",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3923306369999864
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "807905441",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0561654779999117
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1 0\n",
          "stdout": "1\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "1",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8354832130000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 5\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0279226610000478
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 1\n",
          "stdout": "36\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "36",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.79219446
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10 45\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.4516590959999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 19999900000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.1991507969999873
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 3\n",
          "stdout": "21600\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "21600",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.7458393559999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 0\n",
          "stdout": "5040\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "5040",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6361440050000056
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 0\n",
          "stdout": "2\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "2",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6986013340000001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 2\n",
          "stdout": "3000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "3000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.0390939340000216
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "100 4950\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6091200890000001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "9 36\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6636574780000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50 1225\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.9843717269999956
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 6\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.008271391
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1\n",
          "stdout": "466559115\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "466559115",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 4.359739358
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50000 0\n",
          "stdout": "734256002\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "734256002",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.5240363749999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "12345 23456\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.809926212000022
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "67890 98765\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7256147790000114
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 4\n",
          "stdout": "126420\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "126420",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0445604809999622
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "9 6\n",
          "stdout": "3049200\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "3049200",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.948128146
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1 1\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.6340395269999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1000 10\n",
          "stdout": "841194342\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "841194342",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4049130020002849
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7000 15\n",
          "stdout": "566250587\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "566250587",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7578457589999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "8888 3333\n",
          "stdout": "522006524\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "522006524",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7655234990000004
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "99999 55555\n",
          "stdout": "815917837\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "815917837",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.023509032999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 3\n",
          "stdout": "600\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "600",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7549577960000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 2\n",
          "stdout": "46800\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "46800",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.5308859430000004
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2000 250\n",
          "stdout": "33742983\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "33742983",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.913156698999984
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "90000 1000\n",
          "stdout": "506283791\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "506283791",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2463212970000006
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 15\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7776869790000092
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 21\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8026349909999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "8 28\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6403303590000178
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "20 100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.772216846000001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "100 100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.46657733399979406
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200 400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4707770929999242
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "300 900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.37884120900002927
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "400 1600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5974471299999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "500 2500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3024704249983188
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "600 3600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.43035749299997406
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "700 4900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.45435359200018866
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "800 6400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5123968620000028
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "900 8100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.35569088000011106
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1000 10000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4311818060000405
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1100 12100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.323660547000145
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1200 14400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.42090753900015443
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1300 16900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.45917506699970545
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1400 19600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.42099510600002077
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1500 22500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.537362045000009
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1600 25600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7267356980000841
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1700 28900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.2681527980021201
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1800 32400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.209064404000003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1900 36100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.918606209999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2000 40000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.830307512
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2100 44100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5598088299999988
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2200 48400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5749905909999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2300 52900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5056139270000131
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2400 57600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5641641330000766
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2500 62500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.42470958300000916
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2600 67600\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.563434912
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2700 72900\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5244657770001595
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2800 78400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5733862739999998
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2900 84100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.8033507859999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 90000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4455832470000587
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 10\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5787539120000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 10\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.550293634
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "8 10\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.957869402
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "9 40\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5616339729999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "11 55\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5333165599999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "12 66\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 4.055137264999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "13 78\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5053112890000193
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "14 91\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.5999882329999995
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "15 105\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4649442879999981
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "16 120\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.918726608
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "17 136\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5271267079999689
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "18 153\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5697645870000088
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "19 171\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.36374655400868505
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "20 190\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4472015289999831
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "21 210\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3802048840000012
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "22 231\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5374206060000688
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "23 253\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.7023519080000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "24 276\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6405184380000719
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "25 300\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6175037810003232
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "26 325\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.47941809499999977
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "27 351\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.34034619299927726
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "28 378\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.629902391999849
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "29 406\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5582295209999302
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "30 435\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5707644169997366
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2 1\n",
          "stdout": "4\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "4",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.386027769
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 0\n",
          "stdout": "120\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "120",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5950242440003422
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 12\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6222235150000017
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10 0\n",
          "stdout": "3628800\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "3628800",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.7490283160000004
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50 100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6439383749998342
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10 2\n",
          "stdout": "725111294\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "725111294",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5579839729998639
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "15 5\n",
          "stdout": "678938799\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "678938799",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6465445379999437
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10 10\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.770617862
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "20 15\n",
          "stdout": "169041245\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "169041245",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6079931389999729
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200 150\n",
          "stdout": "706962750\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "706962750",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.38531588299999875
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1000 500\n",
          "stdout": "946281262\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "946281262",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.877100401
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1500 500\n",
          "stdout": "949578520\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "949578520",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6874094029999469
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "900 60\n",
          "stdout": "490875818\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "490875818",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6345393229999843
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "850 160\n",
          "stdout": "937942228\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "937942228",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.643645746999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1999 150\n",
          "stdout": "538710057\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "538710057",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6414830930000335
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10000 5000\n",
          "stdout": "103365073\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "103365073",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6640906190000067
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "100 50\n",
          "stdout": "62383071\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "62383071",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.6857287000000003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "25000 12500\n",
          "stdout": "765091459\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "765091459",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6868625019999968
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "123456 65432\n",
          "stdout": "467379903\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "467379903",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7723522190001404
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "199999 99999\n",
          "stdout": "146639259\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "146639259",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 4.1770970290000005
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 100000\n",
          "stdout": "668585001\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "668585001",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5896771929983515
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 1500\n",
          "stdout": "583522940\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "583522940",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.5648550530000005
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "15000 7500\n",
          "stdout": "734261527\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "734261527",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8423088729998653
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "100000 50000\n",
          "stdout": "734134301\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "734134301",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7529603670000142
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "170000 85000\n",
          "stdout": "950064703\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "950064703",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.483312715000011
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "180000 90000\n",
          "stdout": "886293851\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "886293851",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.4280004490001375
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "12345 1234\n",
          "stdout": "178021388\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "178021388",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.5523019489999985
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "56789 28394\n",
          "stdout": "621742867\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "621742867",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4160265490063466
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "159753 79876\n",
          "stdout": "612051691\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "612051691",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.049246008999944
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "30000 15000\n",
          "stdout": "276868098\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "276868098",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.620924878000011
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 10\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.329862503000001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 0\n",
          "stdout": "638474417\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "638474417",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8037424980000196
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "99999 4999850001\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.53931929700002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "15000 112447500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4853516900000159
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5000 12497500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.576287580999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10000 49995000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7187724880000133
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "30000 449955000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5324946069999896
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "100000 4999950000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5745279889999892
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 2\n",
          "stdout": "373972043\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "373972043",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.773983140000155
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 199999\n",
          "stdout": "400000\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "400000",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7619242109999504
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 200000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7756122539999524
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50 45\n",
          "stdout": "729952322\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "729952322",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5514520039999979
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5000 2500\n",
          "stdout": "906728515\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "906728515",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3822933310002554
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "20000 10000\n",
          "stdout": "339719186\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "339719186",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.471357049
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "35000 17500\n",
          "stdout": "425701748\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "425701748",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.567777145999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "40000 20000\n",
          "stdout": "357364325\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "357364325",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6232753879999109
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "45000 22500\n",
          "stdout": "289818629\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "289818629",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6495504000001802
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50000 25000\n",
          "stdout": "364374510\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "364374510",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6265456080000149
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "50000 1249975000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5189762009999868
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2000 1999000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5118614070001968
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "199999 19999800001\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.43712622599991846
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1000 499500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.47500096199973996
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6843 23407436\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.3726945760000007
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2222 2465631\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.5424766759999997
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "54321 1475341540\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.5424459520000084
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "77777 3025166528\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.46847405900001604
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 19999800004\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.323586495999999
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "14883 110731204\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3353692499999994
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "31415 493896357\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5073879319998014
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "27182 369492831\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.265734121999998
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "199999 19999700003\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4544664110003396
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "199998 19999400006\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5348309339997286
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "123456 7620784906\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.3284742969999854
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 4\n",
          "stdout": "10\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "10",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.614489014000128
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 6\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7832791969999562
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1001 501500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.2834193770000013
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "49876 1243802500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8075674780000099
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "17654 155830330\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.27822893697884865
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "913 416416\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8810477399999854
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "342 58383\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8076989799999978
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "45321 1026801400\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9033407250000209
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "34789 603547296\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8880186410000022
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 7\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.40353213499997764
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 132521\n",
          "stdout": "660798392\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "660798392",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.5477649439999936
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "30875 1000\n",
          "stdout": "45848221\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "45848221",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0191845819999799
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2094 0\n",
          "stdout": "552437276\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "552437276",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.894234489000155
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 0\n",
          "stdout": "720\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "720",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.580078876000016
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 4\n",
          "stdout": "126420\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "126420",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4361190060001263
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 78\n",
          "stdout": "784900207\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "784900207",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0231016520000082
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5 0\n",
          "stdout": "120\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "120",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3403670820000002
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 89177\n",
          "stdout": "773611800\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "773611800",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.3053989000000001
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 3093\n",
          "stdout": "395522989\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "395522989",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9619972830000005
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "7 0\n",
          "stdout": "5040\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "5040",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7306325600000037
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5764 3713\n",
          "stdout": "709890387\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "709890387",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.2877756329999954
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4632 2999\n",
          "stdout": "654932331\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "654932331",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4336422559999846
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2591 1337\n",
          "stdout": "320382228\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "320382228",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.3937403700000175
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 110\n",
          "stdout": "824308468\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "824308468",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 3.2021954920000155
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6 1\n",
          "stdout": "21600\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "21600",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.784504133000155
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2488 42\n",
          "stdout": "329482299\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "329482299",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.1859756780000055
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "8 7\n",
          "stdout": "16\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "16",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.31933484300000003
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4307 1000\n",
          "stdout": "261523254\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "261523254",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.3039639659999978
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4001 0\n",
          "stdout": "846183233\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "846183233",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3208630869999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "11 4\n",
          "stdout": "220309611\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "220309611",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.243951164000009
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3000 92\n",
          "stdout": "748741394\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "748741394",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2168861990000153
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "10 0\n",
          "stdout": "3628800\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "3628800",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.2346013109999774
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "124271 89177\n",
          "stdout": "535280058\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "535280058",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5928458039998077
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 3883\n",
          "stdout": "959684298\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "959684298",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.7623292829957791
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "9 0\n",
          "stdout": "362880\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "362880",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2731013350000069
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4632 4364\n",
          "stdout": "39004266\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "39004266",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.390375020999727
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2591 2525\n",
          "stdout": "536532666\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "536532666",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.37044427899991206
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "11 1\n",
          "stdout": "397870588\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "397870588",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.262638924000015
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3543 42\n",
          "stdout": "128587371\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "128587371",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.6480026510000698
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "8 2\n",
          "stdout": "10725120\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "10725120",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2472850629999925
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4307 0000\n",
          "stdout": "406193428\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "406193428",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4247564309998779
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "945 0\n",
          "stdout": "32030240\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "32030240",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.643502627999851
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "15 4\n",
          "stdout": "292464441\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "292464441",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2367292860000134
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "5213 92\n",
          "stdout": "728186961\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "728186961",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.2151687500000037
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "42569 3883\n",
          "stdout": "175008997\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "175008997",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.478091419000009
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "12 0\n",
          "stdout": "479001600\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "479001600",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.43791360400018675
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "2591 1733\n",
          "stdout": "865597061\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "865597061",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.264087095000008
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "436 3000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.185949550999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "49226 199999\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.212294677000017
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 4\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.43671158600000126
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "354 1000\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.590263165000124
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 26492691161\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4442547700000432
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1179 4498500\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.1317908219999993
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 666153\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.1274840879999886
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 6\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.49930990500001826
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "436 4882\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.41270140799997534
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "114218 132521\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0307137199999943
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "49226 334171\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.29983079600015117
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "354 1100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.0165165490000163
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1179 2209383\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5125486929998715
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1097 3713\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.32090607299983276
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "200000 1275699\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.5228666850000536
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "0 2\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.9560007489999975
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "230 4882\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.4723739510000087
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "71056 132521\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.40699825100000453
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "6365 334171\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.7926826959999858
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "36980 89177\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.33217681800010723
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "99 1100\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.8945219069999837
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1179 1231488\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.8327182310000012
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "404 3713\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.798260976999984
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4632 5442\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.3631113900000855
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "4 0\n",
          "stdout": "24\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "24",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.751131264999998
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 2\n",
          "stdout": "6\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "6",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 2.258921292
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "1337 42\n",
          "stdout": "807905441\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "807905441",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 0.38304784900014965
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      },
      {
        "code": "from collections import *\nfrom typing import *\nimport collections\nimport copy\nimport functools\nimport hashlib\nimport heapq\nimport itertools\nimport math\nimport numpy\nimport numpy as np\nimport re\nimport statistics\nimport string\nimport sys\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()",
        "test": {
          "stdin": "3 3\n",
          "stdout": "0\n"
        },
        "passed": true,
        "exec_output": {
          "run_output": {
            "stdout": "0",
            "stderr": "",
            "exit_code": 0,
            "timeout_expired": false,
            "elapsed_time": 1.810283097000024
          },
          "compile_output": null
        },
        "uncaught_exception": "None"
      }
    ],
    "detailed_human_results": [],
    "question": "Calculate the number of ways to place $n$ rooks on $n \\times n$ chessboard so that both following conditions are met:\n\n  each empty cell is under attack;  exactly $k$ pairs of rooks attack each other. \n\nAn empty cell is under attack if there is at least one rook in the same row or at least one rook in the same column. Two rooks attack each other if they share the same row or column, and there are no other rooks between them. For example, there are only two pairs of rooks that attack each other in the following picture:\n\n [Image] One of the ways to place the rooks for $n = 3$ and $k = 2$ \n\nTwo ways to place the rooks are considered different if there exists at least one cell which is empty in one of the ways but contains a rook in another way.\n\nThe answer might be large, so print it modulo $998244353$.\n\n\n-----Input-----\n\nThe only line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 200000$; $0 \\le k \\le \\frac{n(n - 1)}{2}$).\n\n\n-----Output-----\n\nPrint one integer \u2014 the number of ways to place the rooks, taken modulo $998244353$.\n\n\n-----Examples-----\nInput\n3 2\n\nOutput\n6\n\nInput\n3 3\n\nOutput\n0\n\nInput\n4 0\n\nOutput\n24\n\nInput\n1337 42\n\nOutput\n807905441",
    "input_output": {
      "inputs": [
        "3 2\n",
        "3 3\n",
        "4 0\n",
        "1337 42\n",
        "1 0\n",
        "2 0\n",
        "2 1\n",
        "3 0\n",
        "3 1\n",
        "4 1\n",
        "4 2\n",
        "4 3\n",
        "4 4\n",
        "4 5\n",
        "4 6\n",
        "3000 0\n",
        "3000 42\n",
        "3000 1337\n",
        "3000 3713\n",
        "3000 2999\n",
        "3000 3000\n",
        "1500 1000\n",
        "3000 4498500\n",
        "200000 0\n",
        "200000 1\n",
        "200000 100\n",
        "200000 1000\n",
        "200000 100000\n",
        "200000 199999\n",
        "200000 199998\n",
        "200000 200000\n",
        "200000 800000\n",
        "200000 19999900000\n",
        "200000 3393\n",
        "4 5\n",
        "4 3\n",
        "3000 3000\n",
        "200000 200000\n",
        "200000 1000\n",
        "3000 0\n",
        "2 1\n",
        "3 0\n",
        "4 4\n",
        "3000 42\n",
        "4 1\n",
        "200000 199999\n",
        "4 6\n",
        "200000 199998\n",
        "200000 3393\n",
        "1 0\n",
        "3 1\n",
        "1500 1000\n",
        "2 0\n",
        "200000 19999900000\n",
        "3000 4498500\n",
        "4 2\n",
        "3000 3713\n",
        "3000 2999\n",
        "200000 0\n",
        "200000 800000\n",
        "3000 1337\n",
        "200000 100000\n",
        "200000 1\n",
        "200000 100\n",
        "3 2\n",
        "3 3\n",
        "4 0\n",
        "1337 42\n",
        "1 0\n",
        "5 5\n",
        "3 1\n",
        "10 45\n",
        "200000 19999900000\n",
        "6 3\n",
        "7 0\n",
        "2 0\n",
        "5 2\n",
        "100 4950\n",
        "9 36\n",
        "50 1225\n",
        "4 6\n",
        "200000 1\n",
        "50000 0\n",
        "12345 23456\n",
        "67890 98765\n",
        "7 4\n",
        "9 6\n",
        "1 1\n",
        "1000 10\n",
        "7000 15\n",
        "8888 3333\n",
        "99999 55555\n",
        "5 3\n",
        "6 2\n",
        "2000 250\n",
        "90000 1000\n",
        "6 15\n",
        "7 21\n",
        "8 28\n",
        "20 100\n",
        "100 100\n",
        "200 400\n",
        "300 900\n",
        "400 1600\n",
        "500 2500\n",
        "600 3600\n",
        "700 4900\n",
        "800 6400\n",
        "900 8100\n",
        "1000 10000\n",
        "1100 12100\n",
        "1200 14400\n",
        "1300 16900\n",
        "1400 19600\n",
        "1500 22500\n",
        "1600 25600\n",
        "1700 28900\n",
        "1800 32400\n",
        "1900 36100\n",
        "2000 40000\n",
        "2100 44100\n",
        "2200 48400\n",
        "2300 52900\n",
        "2400 57600\n",
        "2500 62500\n",
        "2600 67600\n",
        "2700 72900\n",
        "2800 78400\n",
        "2900 84100\n",
        "3000 90000\n",
        "6 10\n",
        "7 10\n",
        "8 10\n",
        "9 40\n",
        "11 55\n",
        "12 66\n",
        "13 78\n",
        "14 91\n",
        "15 105\n",
        "16 120\n",
        "17 136\n",
        "18 153\n",
        "19 171\n",
        "20 190\n",
        "21 210\n",
        "22 231\n",
        "23 253\n",
        "24 276\n",
        "25 300\n",
        "26 325\n",
        "27 351\n",
        "28 378\n",
        "29 406\n",
        "30 435\n",
        "2 1\n",
        "5 0\n",
        "6 12\n",
        "10 0\n",
        "50 100\n",
        "10 2\n",
        "15 5\n",
        "10 10\n",
        "20 15\n",
        "200 150\n",
        "1000 500\n",
        "1500 500\n",
        "900 60\n",
        "850 160\n",
        "1999 150\n",
        "10000 5000\n",
        "100 50\n",
        "25000 12500\n",
        "123456 65432\n",
        "199999 99999\n",
        "200000 100000\n",
        "3000 1500\n",
        "15000 7500\n",
        "100000 50000\n",
        "170000 85000\n",
        "180000 90000\n",
        "12345 1234\n",
        "56789 28394\n",
        "159753 79876\n",
        "30000 15000\n",
        "5 10\n",
        "200000 0\n",
        "99999 4999850001\n",
        "15000 112447500\n",
        "5000 12497500\n",
        "10000 49995000\n",
        "30000 449955000\n",
        "100000 4999950000\n",
        "200000 2\n",
        "200000 199999\n",
        "200000 200000\n",
        "50 45\n",
        "5000 2500\n",
        "20000 10000\n",
        "35000 17500\n",
        "40000 20000\n",
        "45000 22500\n",
        "50000 25000\n",
        "50000 1249975000\n",
        "2000 1999000\n",
        "199999 19999800001\n",
        "1000 499500\n",
        "6843 23407436\n",
        "2222 2465631\n",
        "54321 1475341540\n",
        "77777 3025166528\n",
        "200000 19999800004\n",
        "14883 110731204\n",
        "31415 493896357\n",
        "27182 369492831\n",
        "199999 19999700003\n",
        "199998 19999400006\n",
        "123456 7620784906\n",
        "5 4\n",
        "6 6\n",
        "1001 501500\n",
        "49876 1243802500\n",
        "17654 155830330\n",
        "913 416416\n",
        "342 58383\n",
        "45321 1026801400\n",
        "34789 603547296\n",
        "4 7\n",
        "200000 132521\n",
        "30875 1000\n",
        "2094 0\n",
        "6 0\n",
        "7 4\n",
        "3000 78\n",
        "5 0\n",
        "200000 89177\n",
        "200000 3093\n",
        "7 0\n",
        "5764 3713\n",
        "4632 2999\n",
        "2591 1337\n",
        "200000 110\n",
        "6 1\n",
        "2488 42\n",
        "8 7\n",
        "4307 1000\n",
        "4001 0\n",
        "11 4\n",
        "3000 92\n",
        "10 0\n",
        "124271 89177\n",
        "200000 3883\n",
        "9 0\n",
        "4632 4364\n",
        "2591 2525\n",
        "11 1\n",
        "3543 42\n",
        "8 2\n",
        "4307 0000\n",
        "945 0\n",
        "15 4\n",
        "5213 92\n",
        "42569 3883\n",
        "12 0\n",
        "2591 1733\n",
        "436 3000\n",
        "49226 199999\n",
        "3 4\n",
        "354 1000\n",
        "200000 26492691161\n",
        "1179 4498500\n",
        "200000 666153\n",
        "3 6\n",
        "436 4882\n",
        "114218 132521\n",
        "49226 334171\n",
        "354 1100\n",
        "1179 2209383\n",
        "1097 3713\n",
        "200000 1275699\n",
        "0 2\n",
        "230 4882\n",
        "71056 132521\n",
        "6365 334171\n",
        "36980 89177\n",
        "99 1100\n",
        "1179 1231488\n",
        "404 3713\n",
        "4632 5442\n",
        "4 0\n",
        "3 2\n",
        "1337 42\n",
        "3 3\n"
      ],
      "outputs": [
        "6\n",
        "0\n",
        "24\n",
        "807905441\n",
        "1\n",
        "2\n",
        "4\n",
        "6\n",
        "36\n",
        "288\n",
        "168\n",
        "8\n",
        "0\n",
        "0\n",
        "0\n",
        "201761277\n",
        "281860640\n",
        "729468301\n",
        "0\n",
        "6000\n",
        "0\n",
        "229881914\n",
        "0\n",
        "638474417\n",
        "466559115\n",
        "431967939\n",
        "13181387\n",
        "668585001\n",
        "400000\n",
        "508670650\n",
        "0\n",
        "0\n",
        "0\n",
        "259194802\n",
        "0\n",
        "8\n",
        "0\n",
        "0\n",
        "13181387\n",
        "201761277\n",
        "4\n",
        "6\n",
        "0\n",
        "281860640\n",
        "288\n",
        "400000\n",
        "0\n",
        "508670650\n",
        "259194802\n",
        "1\n",
        "36\n",
        "229881914\n",
        "2\n",
        "0\n",
        "0\n",
        "168\n",
        "0\n",
        "6000\n",
        "638474417\n",
        "0\n",
        "729468301\n",
        "668585001\n",
        "466559115\n",
        "431967939\n",
        "6\n",
        "0\n",
        "24\n",
        "807905441\n",
        "1\n",
        "0\n",
        "36\n",
        "0\n",
        "0\n",
        "21600\n",
        "5040\n",
        "2\n",
        "3000\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "466559115\n",
        "734256002\n",
        "0\n",
        "0\n",
        "126420\n",
        "3049200\n",
        "0\n",
        "841194342\n",
        "566250587\n",
        "522006524\n",
        "815917837\n",
        "600\n",
        "46800\n",
        "33742983\n",
        "506283791\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "4\n",
        "120\n",
        "0\n",
        "3628800\n",
        "0\n",
        "725111294\n",
        "678938799\n",
        "0\n",
        "169041245\n",
        "706962750\n",
        "946281262\n",
        "949578520\n",
        "490875818\n",
        "937942228\n",
        "538710057\n",
        "103365073\n",
        "62383071\n",
        "765091459\n",
        "467379903\n",
        "146639259\n",
        "668585001\n",
        "583522940\n",
        "734261527\n",
        "734134301\n",
        "950064703\n",
        "886293851\n",
        "178021388\n",
        "621742867\n",
        "612051691\n",
        "276868098\n",
        "0\n",
        "638474417\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "373972043\n",
        "400000\n",
        "0\n",
        "729952322\n",
        "906728515\n",
        "339719186\n",
        "425701748\n",
        "357364325\n",
        "289818629\n",
        "364374510\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "10\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "660798392\n",
        "45848221\n",
        "552437276\n",
        "720\n",
        "126420\n",
        "784900207\n",
        "120\n",
        "773611800\n",
        "395522989\n",
        "5040\n",
        "709890387\n",
        "654932331\n",
        "320382228\n",
        "824308468\n",
        "21600\n",
        "329482299\n",
        "16\n",
        "261523254\n",
        "846183233\n",
        "220309611\n",
        "748741394\n",
        "3628800\n",
        "535280058\n",
        "959684298\n",
        "362880\n",
        "39004266\n",
        "536532666\n",
        "397870588\n",
        "128587371\n",
        "10725120\n",
        "406193428\n",
        "32030240\n",
        "292464441\n",
        "728186961\n",
        "175008997\n",
        "479001600\n",
        "865597061\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "0\n",
        "24\n",
        "6\n",
        "807905441\n",
        "0\n"
      ]
    },
    "source": "codeforces",
    "difficulty": "HARD",
    "o3_mini_solution": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    k = int(data[1])\n    mod = 998244353\n\n    # A quick observation:\n    # In the \u201ccolumn model\u201d the number of attacking pairs is k = n - (# distinct rows used).\n    # Since the minimum number of distinct rows is 1 (all rooks in one row) the maximum k equals n-1.\n    if k < 0 or k > n - 1:\n        sys.stdout.write(\"0\")\n        return\n\n    # If k == 0, then every row and every column is nonempty which forces exactly one rook per row.\n    # In that case the configuration is a permutation matrix and the answer is n! modulo mod.\n    if k == 0:\n        res = 1\n        for i in range(1, n+1):\n            res = (res * i) % mod\n        sys.stdout.write(str(res))\n        return\n\n    # For k > 0 the only valid configuration is \u201call columns nonempty\u201d\n    # (or, by symmetry, \u201call rows nonempty\u201d; these two families are disjoint for k > 0)\n    # In the column model we have one rook per column.\n    # Let r = number of distinct rows used. We must have\n    #    n - r = k   -->   r = n - k.\n    r = n - k\n\n    # Precompute factorials and inverse factorials for numbers up to n.\n    max_val = n\n    fact = [1]*(max_val+1)\n    invfact = [1]*(max_val+1)\n    for i in range(2, max_val+1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[max_val] = pow(fact[max_val], mod-2, mod)\n    for i in range(max_val, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n\n    # A helper function for nCr.\n    def nCr(a, b):\n        if b < 0 or b > a:\n            return 0\n        return (fact[a] * invfact[b] % mod) * invfact[a-b] % mod\n\n    # First, choose the r rows to hit: there are C(n, r) ways.\n    choose_rows = nCr(n, r)\n\n    # Then count the number of onto functions\n    # from the n columns to an r-element set.\n    # The standard formula by inclusion\u2013exclusion is:\n    #\n    #   surj(n, r) = \u2211_{j=0}^{r} (-1)^j * C(r, j) * (r - j)^n.\n    surjections = 0\n    for j in range(r+1):\n        # Use precomputed factorials for C(r, j)\n        comb = (fact[r] * invfact[j] % mod) * invfact[r-j] % mod\n        term = comb * pow(r - j, n, mod) % mod\n        if j & 1:\n            surjections = (surjections - term) % mod\n        else:\n            surjections = (surjections + term) % mod\n\n    # The column model yields count = choose_rows * surjections.\n    # By symmetry the row model gives exactly the same count.\n    # And these two families are disjoint when k>0.\n    ans = (2 * choose_rows % mod) * surjections % mod\n    sys.stdout.write(str(ans))\n\nif __name__ == '__main__':\n    main()"
  }
]