[{"problem": {"problem_id": 792, "question": "Natasha travels around Mars in the Mars rover. But suddenly it broke down, namely \u2014 the logical scheme inside it. The scheme is an undirected tree (connected acyclic graph) with a root in the vertex 1, in which every leaf (excluding root) is an input, and all other vertices are logical elements, including the root, which is output. One bit is fed to each input. One bit is returned at the output.\n\nThere are four types of logical elements: [AND](https://en.wikipedia.org/wiki/Logical_conjunction) (2 inputs), [OR](https://en.wikipedia.org/wiki/Logical_disjunction) (2 inputs), [XOR](https://en.wikipedia.org/wiki/Exclusive_or) (2 inputs), [NOT](https://en.wikipedia.org/wiki/Negation) (1 input). Logical elements take values from their direct descendants (inputs) and return the result of the function they perform. Natasha knows the logical scheme of the Mars rover, as well as the fact that only one input is broken. In order to fix the Mars rover, she needs to change the value on this input.\n\nFor each input, determine what the output will be if Natasha changes this input.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 10^6) \u2014 the number of vertices in the graph (both inputs and elements).\n\nThe i-th of the next n lines contains a description of i-th vertex: the first word \"AND\", \"OR\", \"XOR\", \"NOT\" or \"IN\" (means the input of the scheme) is the vertex type. If this vertex is \"IN\", then the value of this input follows (0 or 1), otherwise follow the indices of input vertices of this element: \"AND\", \"OR\", \"XOR\" have 2 inputs, whereas \"NOT\" has 1 input. The vertices are numbered from one.\n\nIt is guaranteed that input data contains a correct logical scheme with an output produced by the vertex 1.\n\nOutput\n\nPrint a string of characters '0' and '1' (without quotes) \u2014 answers to the problem for each input in the ascending order of their vertex indices.\n\nExample\n\nInput\n\n10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n\n\nOutput\n\n10110\n\nNote\n\nThe original scheme from the example (before the input is changed):\n\n<image>\n\nGreen indicates bits '1', yellow indicates bits '0'.\n\nIf Natasha changes the input bit 2 to 0, then the output will be 1.\n\nIf Natasha changes the input bit 3 to 0, then the output will be 0.\n\nIf Natasha changes the input bit 6 to 1, then the output will be 1.\n\nIf Natasha changes the input bit 8 to 0, then the output will be 1.\n\nIf Natasha changes the input bit 9 to 0, then the output will be 0.", "tests": [{"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "10110"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111"}, {"stdin": "2\nNOT 2\nIN 1\n", "stdout": "1"}, {"stdin": "3\nXOR 2 3\nIN 0\nIN 0\n", "stdout": "11"}, {"stdin": "3\nAND 2 3\nIN 1\nIN 0\n", "stdout": "01"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 1\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111"}, {"stdin": "3\nAND 2 3\nIN 0\nIN 0\n", "stdout": "00"}, {"stdin": "3\nAND 2 3\nIN 0\nIN 1\n", "stdout": "10"}, {"stdin": "3\nXOR 2 3\nIN 0\nIN 1\n", "stdout": "00"}, {"stdin": "3\nOR 2 3\nIN 1\nIN 1\n", "stdout": "11"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 0\n", "stdout": "01011"}, {"stdin": "3\nAND 2 3\nIN 1\nIN 1\n", "stdout": "00"}, {"stdin": "3\nOR 2 3\nIN 1\nIN 0\n", "stdout": "01"}, {"stdin": "3\nXOR 2 3\nIN 1\nIN 0\n", "stdout": "00"}, {"stdin": "3\nXOR 2 3\nIN 1\nIN 1\n", "stdout": "11"}, {"stdin": "2\nNOT 2\nIN 0\n", "stdout": "0"}, {"stdin": "30\nXOR 4 11\nXOR 6 25\nNOT 29\nNOT 9\nNOT 17\nNOT 26\nNOT 30\nNOT 27\nNOT 14\nIN 1\nNOT 5\nNOT 15\nNOT 22\nIN 0\nNOT 24\nIN 1\nNOT 3\nNOT 19\nNOT 8\nNOT 16\nNOT 23\nNOT 28\nNOT 7\nNOT 2\nNOT 10\nNOT 13\nNOT 12\nNOT 20\nNOT 21\nNOT 18\n", "stdout": "000"}, {"stdin": "3\nOR 2 3\nIN 0\nIN 0\n", "stdout": "11"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111111111111111"}, {"stdin": "3\nOR 2 3\nIN 0\nIN 1\n", "stdout": "10"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 1\n", "stdout": "01010\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 1\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "10011111\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 0\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 0\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "00010\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 1\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11011010\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 0\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "0101001101101110110\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "30\nXOR 4 11\nXOR 6 25\nNOT 29\nNOT 9\nNOT 17\nNOT 26\nNOT 30\nNOT 27\nNOT 14\nIN 0\nNOT 5\nNOT 15\nNOT 22\nIN 0\nNOT 24\nIN 1\nNOT 3\nNOT 19\nNOT 8\nNOT 16\nNOT 23\nNOT 28\nNOT 7\nNOT 2\nNOT 10\nNOT 13\nNOT 12\nNOT 20\nNOT 21\nNOT 18\n", "stdout": "111\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 0\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "00100\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 0\nIN 1\nAND 2 8\n", "stdout": "10000\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 0\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "01100\n"}, {"stdin": "20\nOR 17 10\nIN 1\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 1\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 0\nIN 1\nAND 2 8\n", "stdout": "10010\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 0\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111011111111111\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 1\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 1\nAND 13 39\n", "stdout": "101111111111111111111111110\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11110111\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 0\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1000110010010010001\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 0\nIN 1\nIN 1\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 0\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101001\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 1\nNOT 10\nIN 0\nIN 0\nAND 2 8\n", "stdout": "00000\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 1\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 0\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1101001101111010110\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 1\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 1\n", "stdout": "01111\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 1\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 1\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 0\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 0\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 0\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 0\nIN 1\nIN 1\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 1\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 1\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 1\nNOT 10\nIN 0\nIN 1\nAND 2 8\n", "stdout": "01100\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 1\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 1\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 1\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 1\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 0\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 0\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "0101001101101110110\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 1\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 1\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 1\nAND 13 39\n", "stdout": "101111111111111111111111110\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 1\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 1\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 0\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 0\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 0\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 1\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 0\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 0\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 0\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 1\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 1\nAND 13 39\n", "stdout": "101111111111111111111111110\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 1\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 0\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 1\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 1\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 1\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 0\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 0\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "0101001101101110110\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 0\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 0\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 0\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}], "source": "codeforces", "difficulty": 2000, "human_solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nvector<int> op;\nvector<vector<int>> v;\nvector<bool> val;\nint mp[1000001][2];\nvector<int> saved;\nvector<int> cur;\nvector<pair<int, int>> curc;\nvector<int> parent;\nint fans = -1;\nstatic string s;\nint solve(int k) {\n  cur.push_back(k);\n  if (v[k].size() == 0) return saved[k] = val[k];\n  if (v[k].size() == 1) return saved[k] = !solve(v[k][0]);\n  if (op[k] == 1) return saved[k] = (solve(v[k][0]) & solve(v[k][1]));\n  if (op[k] == 2) return saved[k] = (solve(v[k][0]) | solve(v[k][1]));\n  if (op[k] == 3) return saved[k] = (solve(v[k][0]) ^ solve(v[k][1]));\n  return 0;\n}\nvoid solve2(int k, int num) {\n  if (k == 0) {\n    fans = num;\n    return;\n  }\n  if (mp[k][num] != -1) {\n    fans = mp[k][num];\n    return;\n  }\n  int p = parent[k];\n  if (v[p].size() == 1) {\n    curc.push_back({p, 1 - num});\n    solve2(p, 1 - num);\n    return;\n  }\n  int num1 = v[p][0], num2 = v[p][1];\n  bool ar1, ar2;\n  if (num1 == k)\n    ar1 = num, ar2 = saved[v[p][1]];\n  else\n    ar2 = num, ar1 = saved[v[p][0]];\n  if (op[p] == 1) {\n    curc.push_back({p, ar1 & ar2});\n    solve2(p, ar1 & ar2);\n  }\n  if (op[p] == 2) {\n    curc.push_back({p, ar1 | ar2});\n    solve2(p, ar1 | ar2);\n  }\n  if (op[p] == 3) {\n    curc.push_back({p, ar1 ^ ar2});\n    solve2(p, ar1 ^ ar2);\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  int n;\n  cin >> n;\n  memset(mp, -1, sizeof(mp));\n  op.resize(n);\n  val.resize(n);\n  parent.resize(n);\n  v.assign(n, {});\n  saved.resize(n, 0);\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    if (s == \"IN\") {\n      op[i] = 0;\n      int num;\n      cin >> num;\n      val[i] = num;\n    } else if (s == \"NOT\") {\n      int num;\n      cin >> num;\n      op[i] = 0;\n      num--;\n      v[i].push_back(num);\n      parent[num] = i;\n    } else {\n      if (s == \"AND\") op[i] = 1;\n      if (s == \"OR\") op[i] = 2;\n      if (s == \"XOR\") op[i] = 3;\n      int num1, num2;\n      cin >> num1 >> num2;\n      num1--;\n      num2--;\n      v[i].push_back(num1);\n      v[i].push_back(num2);\n      parent[num1] = i;\n      parent[num2] = i;\n    }\n  }\n  bool ans = solve(0);\n  for (int i = 0; i < n; i++) {\n    mp[i][saved[i]] = ans;\n  }\n  parent[0] = -1;\n  for (int i = 0; i < n; i++) {\n    if (v[i].size() == 0) {\n      solve2(i, 1 - val[i]);\n      if ((int)curc.size()) {\n        for (auto xx : curc) mp[xx.first][xx.second] = fans;\n      }\n      curc.clear();\n      cout << fans;\n    }\n  }\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint n, i, j, k;\nvector<string> s;\nvector<int> a, b;\nvector<bool> v;\nvector<unordered_set<int>> vs[2];\nvoid root_tree(int id) {\n  if (s[id] == \"IN\")\n    v[id] = (a[id] == 1);\n  else if (s[id] == \"NOT\") {\n    root_tree(a[id]);\n    v[id] = !v[a[id]];\n  } else {\n    root_tree(a[id]);\n    root_tree(b[id]);\n    if (s[id] == \"AND\")\n      v[id] = v[a[id]] && v[b[id]];\n    else if (s[id] == \"XOR\")\n      v[id] = (v[a[id]] != v[b[id]]);\n    else if (s[id] == \"OR\")\n      v[id] = v[a[id]] || v[b[id]];\n  }\n}\nvoid merge_list(int v1, int a1, int v2, int a2) {\n  if (vs[v1][a1].size() < vs[v2][a2].size()) {\n    swap(vs[v1][a1], vs[v2][a2]);\n  }\n  for (auto p : vs[v2][a2]) vs[v1][a1].insert(p);\n}\nvoid solve(int id) {\n  if (id == 1) {\n    id = id;\n  }\n  if (s[id] == \"IN\") {\n    if (a[id] == 1)\n      vs[0][id] = {id};\n    else\n      vs[1][id] = {id};\n  } else if (s[id] == \"NOT\") {\n    solve(a[id]);\n    merge_list(0, id, 1, a[id]);\n    merge_list(1, id, 0, a[id]);\n  } else {\n    solve(a[id]);\n    solve(b[id]);\n    if (s[id] == \"AND\") {\n      if (v[b[id]]) {\n        merge_list(1, id, 1, a[id]);\n        merge_list(0, id, 0, a[id]);\n      } else {\n        merge_list(0, id, 1, a[id]);\n        merge_list(0, id, 0, a[id]);\n      }\n      if (v[a[id]]) {\n        merge_list(1, id, 1, b[id]);\n        merge_list(0, id, 0, b[id]);\n      } else {\n        merge_list(0, id, 1, b[id]);\n        merge_list(0, id, 0, b[id]);\n      }\n    } else if (s[id] == \"XOR\") {\n      if (v[b[id]]) {\n        merge_list(0, id, 1, a[id]);\n        merge_list(1, id, 0, a[id]);\n      } else {\n        merge_list(0, id, 0, a[id]);\n        merge_list(1, id, 1, a[id]);\n      }\n      if (v[a[id]]) {\n        merge_list(1, id, 0, b[id]);\n        merge_list(0, id, 1, b[id]);\n      } else {\n        merge_list(1, id, 1, b[id]);\n        merge_list(0, id, 0, b[id]);\n      }\n    } else if (s[id] == \"OR\") {\n      if (v[b[id]]) {\n        merge_list(1, id, 1, a[id]);\n        merge_list(1, id, 0, a[id]);\n      } else {\n        merge_list(1, id, 1, a[id]);\n        merge_list(0, id, 0, a[id]);\n      }\n      if (v[a[id]]) {\n        merge_list(1, id, 1, b[id]);\n        merge_list(1, id, 0, b[id]);\n      } else {\n        merge_list(1, id, 1, b[id]);\n        merge_list(0, id, 0, b[id]);\n      }\n    }\n  }\n  if (id == 1) {\n    id = id;\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  s.resize(n + 1);\n  a.resize(n + 1);\n  b.resize(n + 1);\n  v.resize(n + 1);\n  for (i = 1; i <= n; i++) {\n    cin >> s[i];\n    if ((s[i] == \"IN\") || (s[i] == \"NOT\"))\n      cin >> a[i];\n    else\n      cin >> a[i] >> b[i];\n  }\n  root_tree(1);\n  vs[0].resize(n + 1);\n  vs[1].resize(n + 1);\n  solve(1);\n  for (i = 1; i <= n; i++) {\n    if (s[i] == \"IN\") {\n      if (vs[0][1].find(i) == vs[0][1].end())\n        cout << \"1\";\n      else\n        cout << \"0\";\n    }\n  }\n  cout << \"\\n\";\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nint v[N][3], cnt[N], tag[N], influ[N];\nvoid dfs(int now) {\n  if (tag[now] == 1)\n    return;\n  else {\n    for (int i = 1; i <= cnt[now]; i++) {\n      dfs(v[now][i]);\n    }\n  }\n  switch (tag[now]) {\n    case 2: {\n      v[now][0] = v[v[now][1]][0] & v[v[now][2]][0];\n      if (!v[v[now][1]][0]) influ[v[now][2]] = 1;\n      if (!v[v[now][2]][0]) influ[v[now][1]] = 1;\n      break;\n    }\n    case 3: {\n      v[now][0] = v[v[now][1]][0] | v[v[now][2]][0];\n      if (v[v[now][1]][0]) influ[v[now][2]] = 1;\n      if (v[v[now][2]][0]) influ[v[now][1]] = 1;\n      break;\n    }\n    case 4: {\n      v[now][0] = v[v[now][1]][0] ^ v[v[now][2]][0];\n      break;\n    }\n    case 5: {\n      v[now][0] = !v[v[now][1]][0];\n      break;\n    }\n  }\n  return;\n}\nvoid dfs_2(int now, int fa) {\n  influ[now] |= influ[fa];\n  if (tag[now] != 1)\n    for (int i = 1; i <= cnt[now]; i++) dfs_2(v[now][i], now);\n  return;\n}\nint main() {\n  int n;\n  string ope;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> ope;\n    switch (ope[0]) {\n      case 'I': {\n        scanf(\"%d\", &v[i][0]);\n        tag[i] = 1;\n        cnt[i] = 1;\n        break;\n      }\n      case 'A': {\n        scanf(\"%d\", &v[i][1]);\n        scanf(\"%d\", &v[i][2]);\n        tag[i] = 2;\n        cnt[i] = 2;\n        break;\n      }\n      case 'O': {\n        scanf(\"%d\", &v[i][1]);\n        scanf(\"%d\", &v[i][2]);\n        tag[i] = 3;\n        cnt[i] = 2;\n        break;\n      }\n      case 'X': {\n        scanf(\"%d\", &v[i][1]);\n        scanf(\"%d\", &v[i][2]);\n        tag[i] = 4;\n        cnt[i] = 2;\n        break;\n      }\n      case 'N': {\n        scanf(\"%d\", &v[i][1]);\n        tag[i] = 5;\n        cnt[i] = 1;\n        break;\n      }\n    }\n  }\n  dfs(1);\n  dfs_2(1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (tag[i] == 1) {\n      if (influ[i])\n        printf(\"%d\", v[1][0]);\n      else\n        printf(\"%d\", 1 - v[1][0]);\n    }\n  }\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nconst int maxm = 1e5 + 100;\nconst double eps = 1e-6;\nconst long long MOD = 1e9 + 7;\nconst int INF = 0x3f3f3f3f;\nint n, sv[maxn], c, dp[maxn], ans[maxn];\nint mark;\nstruct Node {\n  int x, y, f, v, oper;\n} a[maxn];\nint Count(int x) {\n  if (a[x].oper == 1) {\n    return a[a[x].x].v & a[a[x].y].v;\n  } else if (a[x].oper == 2) {\n    return a[a[x].x].v | a[a[x].y].v;\n  } else if (a[x].oper == 3) {\n    return a[a[x].x].v ^ a[a[x].y].v;\n  } else if (a[x].oper == 4) {\n    return !a[a[x].x].v;\n  }\n}\nint dfs1(int x) {\n  if (a[x].oper == 5) {\n    a[x].v = a[x].x;\n  } else if (a[x].oper == 1) {\n    a[x].v = (dfs1(a[x].x) & (dfs1(a[x].y)));\n  } else if (a[x].oper == 2) {\n    a[x].v = (dfs1(a[x].x) | dfs1(a[x].y));\n  } else if (a[x].oper == 3) {\n    a[x].v = (dfs1(a[x].x) ^ dfs1(a[x].y));\n  } else if (a[x].oper == 4) {\n    a[x].v = !dfs1(a[x].x);\n  }\n  return a[x].v;\n}\nvoid dfs2(int x, int now) {\n  int val = a[x].v;\n  a[x].v = now;\n  if (x == 1 || val == now) {\n    mark = a[1].v;\n  } else {\n    if (dp[x] != -1) {\n      mark = dp[x];\n    } else {\n      dfs2(a[x].f, Count(a[x].f));\n      dp[x] = mark;\n    }\n  }\n  a[x].v = val;\n}\nvoid Solve() {\n  int res = dfs1(1);\n  for (int i = 1; i <= c; i++) {\n    int x = sv[i];\n    dfs2(x, a[x].v ^ 1);\n    ans[i] = mark;\n  }\n  for (int i = 1; i <= c; i++) printf(\"%d\", ans[i]);\n  printf(\"\\n\");\n}\nint main() {\n  while (scanf(\"%d\", &n) != EOF) {\n    c = 0;\n    memset(dp, -1, sizeof(dp));\n    int x, y;\n    char oper[4];\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%s\", oper);\n      if (oper[0] == 'I') {\n        scanf(\"%d\", &x);\n        a[i].x = x;\n        a[i].oper = 5;\n        sv[++c] = i;\n      } else if (oper[0] == 'N') {\n        scanf(\"%d\", &x);\n        a[i].oper = 4;\n        a[i].x = x;\n        a[x].f = i;\n      } else {\n        scanf(\"%d%d\", &x, &y);\n        if (oper[0] == 'A') {\n          a[i].oper = 1;\n          a[i].x = x, a[i].y = y;\n          a[x].f = i, a[y].f = i;\n        } else if (oper[0] == 'O') {\n          a[i].oper = 2;\n          a[i].x = x, a[i].y = y;\n          a[x].f = i, a[y].f = i;\n        } else if (oper[0] == 'X') {\n          a[i].oper = 3;\n          a[i].x = x, a[i].y = y;\n          a[x].f = i, a[y].f = i;\n        }\n      }\n    }\n    Solve();\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\n#pragma GCC optimize \"03\"\nusing namespace std;\nconst int N = 1e6 + 5;\nconst int mod = 1e9 + 7;\nmap<int, string> type;\nint a[N];\nvector<int> g[N];\nint dp[N][2];\nvoid dfs(int u) {\n  if (g[u].empty()) return;\n  for (int i : g[u]) dfs(i);\n  if (type[u] == \"NOT\") a[u] = (a[g[u][0]] ^ 1);\n  if (type[u] == \"AND\") a[u] = (a[g[u][0]] & a[g[u][1]]);\n  if (type[u] == \"OR\") a[u] = (a[g[u][0]] | a[g[u][1]]);\n  if (type[u] == \"XOR\") a[u] = (a[g[u][0]] ^ a[g[u][1]]);\n}\nvoid dfs1(int u) {\n  if (g[u].empty()) return;\n  if (type[u] == \"NOT\") {\n    dp[g[u][0]][a[g[u][0]]] = a[1];\n    dp[g[u][0]][a[g[u][0]] ^ 1] = dp[u][a[g[u][0]]];\n  }\n  if (type[u] == \"AND\") {\n    dp[g[u][0]][a[g[u][0]]] = a[1];\n    dp[g[u][1]][a[g[u][1]]] = a[1];\n    int x = ((a[g[u][0]] ^ 1) & a[g[u][1]]);\n    dp[g[u][0]][a[g[u][0]] ^ 1] = dp[u][x];\n    x = ((a[g[u][0]]) & (a[g[u][1]] ^ 1));\n    dp[g[u][1]][a[g[u][1]] ^ 1] = dp[u][x];\n  }\n  if (type[u] == \"OR\") {\n    dp[g[u][0]][a[g[u][0]]] = a[1];\n    dp[g[u][1]][a[g[u][1]]] = a[1];\n    int x = ((a[g[u][0]] ^ 1) | a[g[u][1]]);\n    dp[g[u][0]][a[g[u][0]] ^ 1] = dp[u][x];\n    x = ((a[g[u][0]]) | (a[g[u][1]] ^ 1));\n    dp[g[u][1]][a[g[u][1]] ^ 1] = dp[u][x];\n  }\n  if (type[u] == \"XOR\") {\n    dp[g[u][0]][a[g[u][0]]] = a[1];\n    dp[g[u][1]][a[g[u][1]]] = a[1];\n    int x = ((a[g[u][0]] ^ 1) ^ a[g[u][1]]);\n    dp[g[u][0]][a[g[u][0]] ^ 1] = dp[u][x];\n    x = ((a[g[u][0]]) ^ (a[g[u][1]] ^ 1));\n    dp[g[u][1]][a[g[u][1]] ^ 1] = dp[u][x];\n  }\n  for (int i : g[u]) dfs1(i);\n}\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    string s;\n    cin >> s;\n    type[i] = s;\n    if (s == \"IN\") {\n      int u;\n      cin >> u;\n      a[i] = u;\n    } else if (s == \"NOT\") {\n      int u;\n      cin >> u;\n      g[i].push_back(u);\n    } else {\n      int u, v;\n      cin >> u >> v;\n      g[i].push_back(u);\n      g[i].push_back(v);\n    }\n  }\n  dfs(1);\n  dp[1][1] = 1;\n  dp[1][0] = 0;\n  dfs1(1);\n  for (int i = 1; i <= n; i++) {\n    if (type[i] == \"IN\") cout << dp[i][a[i] ^ 1];\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxm = 1000005;\nvector<int> v[maxm];\nint a[maxm], val[maxm], ans[maxm];\nchar str[maxm];\nvoid dfs_1(int k) {\n  for (int i = 0; i < v[k].size(); i++) dfs_1(v[k][i]);\n  if (a[k] == 1)\n    val[k] = val[v[k][0]] & val[v[k][1]];\n  else if (a[k] == 2)\n    val[k] = val[v[k][0]] | val[v[k][1]];\n  else if (a[k] == 3)\n    val[k] = val[v[k][0]] ^ val[v[k][1]];\n  else if (a[k] == 4)\n    val[k] = val[v[k][0]] ^ 1;\n}\nvoid dfs_2(int k, int flag) {\n  if (a[k] == 5)\n    ans[k] = val[1] ^ flag;\n  else if (a[k] == 1) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 0 && val[y] == 0 || val[x] == 1 && val[y] == 0)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 0 && val[y] == 0 || val[x] == 0 && val[y] == 1)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 2) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 1 && val[y] == 1 || val[x] == 0 && val[y] == 1)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 1 && val[y] == 1 || val[x] == 1 && val[y] == 0)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 3) {\n    int x = v[k][0], y = v[k][1];\n    dfs_2(x, min(flag, 1));\n    dfs_2(y, min(flag, 1));\n  } else\n    dfs_2(v[k][0], min(flag, 1));\n}\nint main() {\n  int n, i, j, k, sum, x, y;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    ans[i] = -1;\n    scanf(\"%s\", str);\n    if (str[0] == 'I') {\n      scanf(\"%d\", &k);\n      val[i] = k, a[i] = 5;\n    } else if (str[0] == 'N') {\n      scanf(\"%d\", &k);\n      v[i].push_back(k), a[i] = 4;\n    } else if (str[0] == 'A') {\n      scanf(\"%d%d\", &x, &y), a[i] = 1;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'O') {\n      scanf(\"%d%d\", &x, &y), a[i] = 2;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'X') {\n      scanf(\"%d%d\", &x, &y), a[i] = 3;\n      v[i].push_back(x), v[i].push_back(y);\n    }\n  }\n  dfs_1(1);\n  dfs_2(1, 1);\n  for (i = 1; i <= n; i++)\n    if (ans[i] != -1) printf(\"%d\", ans[i]);\n  printf(\"\\n\");\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nstruct node {\n  int f;\n  char tp;\n  int r;\n  int fa;\n  int s1, s2;\n} l[1000010];\nvector<int> v;\nint dfs(int x) {\n  if (l[x].tp == 'I') return l[x].r;\n  if (l[x].tp == 'A') return l[x].r = dfs(l[x].s1) & dfs(l[x].s2);\n  if (l[x].tp == 'O') return l[x].r = dfs(l[x].s1) | dfs(l[x].s2);\n  if (l[x].tp == 'N') return l[x].r = !dfs(l[x].s1);\n  return l[x].r = dfs(l[x].s1) ^ dfs(l[x].s2);\n}\nvoid chk(int x) {\n  if (l[x].tp == 'A') {\n    if (l[l[x].s1].r == 0 && l[l[x].s2].r == 0) return;\n    if (l[l[x].s1].r == 0 && l[l[x].s2].r == 1) {\n      l[l[x].s1].f = 1;\n      chk(l[x].s1);\n    }\n    if (l[l[x].s1].r == 1 && l[l[x].s2].r == 0) {\n      l[l[x].s2].f = 1;\n      chk(l[x].s2);\n    }\n    if (l[l[x].s1].r == 1 && l[l[x].s2].r == 1) {\n      l[l[x].s1].f = 1;\n      chk(l[x].s1);\n      l[l[x].s2].f = 1;\n      chk(l[x].s2);\n    }\n  } else if (l[x].tp == 'O') {\n    if (l[l[x].s1].r == 1 && l[l[x].s2].r == 1) return;\n    if (l[l[x].s1].r == 1 && l[l[x].s2].r == 0) {\n      l[l[x].s1].f = 1;\n      chk(l[x].s1);\n    }\n    if (l[l[x].s1].r == 0 && l[l[x].s2].r == 1) {\n      l[l[x].s2].f = 1;\n      chk(l[x].s2);\n    }\n    if (l[l[x].s1].r == 0 && l[l[x].s2].r == 0) {\n      l[l[x].s1].f = 1;\n      chk(l[x].s1);\n      l[l[x].s2].f = 1;\n      chk(l[x].s2);\n    }\n  } else if (l[x].tp == 'N') {\n    l[l[x].s1].f = 1;\n    chk(l[x].s1);\n  } else if (l[x].tp == 'I')\n    return;\n  else {\n    l[l[x].s1].f = 1;\n    chk(l[x].s1);\n    l[l[x].s2].f = 1;\n    chk(l[x].s2);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  char c[5];\n  for (int i = 1; i <= n; i++) {\n    cin >> c;\n    l[i].tp = c[0];\n    if (c[0] == 'I') {\n      int a;\n      cin >> a;\n      l[i].r = a;\n      v.push_back(i);\n    } else if (c[0] == 'N') {\n      int a;\n      cin >> a;\n      l[i].s1 = a;\n      l[a].fa = i;\n    } else {\n      int a, b;\n      cin >> a >> b;\n      l[i].s1 = a;\n      l[i].s2 = b;\n      l[a].fa = i;\n      l[b].fa = i;\n    }\n  }\n  dfs(1);\n  chk(1);\n  for (auto i : v)\n    if (!l[i].f)\n      cout << l[1].r;\n    else\n      cout << (l[1].r ^ 1);\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  string node_type;\n  int child1, child2;\n  bool is_sensitive;\n  bool value;\n};\nnode node_arr[1000001];\nint get_type(string operatore) {\n  if (operatore == \"AND\")\n    return 1;\n  else if (operatore == \"OR\")\n    return 2;\n  else if (operatore == \"XOR\")\n    return 3;\n  else if (operatore == \"NOT\")\n    return 4;\n  else if (operatore == \"IN\")\n    return 5;\n}\nvoid find_value(int node_num) {\n  string current_operatore = node_arr[node_num].node_type;\n  int child1 = node_arr[node_num].child1, child2 = node_arr[node_num].child2;\n  if (current_operatore == \"IN\") {\n    return;\n  } else {\n    if (current_operatore == \"NOT\") {\n      find_value(child1);\n      node_arr[node_num].value = !(node_arr[child1].value);\n      node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n    } else {\n      find_value(child1);\n      find_value(child2);\n      if (current_operatore == \"AND\") {\n        node_arr[node_num].value =\n            node_arr[child1].value && node_arr[child2].value;\n        if (node_arr[child1].value == 1 && node_arr[child2].value == 1) {\n          node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n          node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        } else if (node_arr[child1].value == 0 && node_arr[child2].value == 0) {\n          node_arr[child1].is_sensitive = 0;\n          node_arr[child2].is_sensitive = 0;\n        } else {\n          if (node_arr[child1].value == 0) {\n            node_arr[child1].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n            node_arr[child2].is_sensitive = 0;\n          } else {\n            node_arr[child2].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n            node_arr[child1].is_sensitive = 0;\n          }\n        }\n      } else if (current_operatore == \"OR\") {\n        node_arr[node_num].value =\n            node_arr[child1].value || node_arr[child2].value;\n        if (node_arr[child1].value == 1 && node_arr[child2].value == 1) {\n          node_arr[child1].is_sensitive = 0;\n          node_arr[child2].is_sensitive = 0;\n        } else if ((node_arr[child1].value == 0) &&\n                   (node_arr[child2].value == 0)) {\n          node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n          node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        } else {\n          if (node_arr[child1].value == 0) {\n            node_arr[child1].is_sensitive = 0;\n            node_arr[child2].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n          } else {\n            node_arr[child2].is_sensitive = 0;\n            node_arr[child1].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n          }\n        }\n      } else {\n        node_arr[node_num].value =\n            (node_arr[child1].value && !node_arr[child2].value) ||\n            (!node_arr[child1].value && node_arr[child2].value);\n        node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n      }\n    }\n    return;\n  }\n}\nvoid find_value1(int node_num) {\n  string current_operatore = node_arr[node_num].node_type;\n  int child1 = node_arr[node_num].child1, child2 = node_arr[node_num].child2;\n  if (current_operatore == \"IN\") {\n    return;\n  } else {\n    if (current_operatore == \"NOT\") {\n      node_arr[node_num].value = !(node_arr[child1].value);\n      node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n      find_value1(child1);\n    } else {\n      if (current_operatore == \"AND\") {\n        node_arr[node_num].value =\n            node_arr[child1].value && node_arr[child2].value;\n        if (node_arr[child1].value == 1 && node_arr[child2].value == 1) {\n          node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n          node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        } else if (node_arr[child1].value == 0 && node_arr[child2].value == 0) {\n          node_arr[child1].is_sensitive = 0;\n          node_arr[child2].is_sensitive = 0;\n        } else {\n          if (node_arr[child1].value == 0) {\n            node_arr[child1].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n            node_arr[child2].is_sensitive = 0;\n          } else {\n            node_arr[child2].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n            node_arr[child1].is_sensitive = 0;\n          }\n        }\n      } else if (current_operatore == \"OR\") {\n        node_arr[node_num].value =\n            node_arr[child1].value || node_arr[child2].value;\n        if (node_arr[child1].value == 1 && node_arr[child2].value == 1) {\n          node_arr[child1].is_sensitive = 0;\n          node_arr[child2].is_sensitive = 0;\n        } else if ((node_arr[child1].value == 0) &&\n                   (node_arr[child2].value == 0)) {\n          node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n          node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        } else {\n          if (node_arr[child1].value == 0) {\n            node_arr[child1].is_sensitive = 0;\n            node_arr[child2].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n          } else {\n            node_arr[child2].is_sensitive = 0;\n            node_arr[child1].is_sensitive =\n                1 && node_arr[node_num].is_sensitive;\n          }\n        }\n      } else {\n        node_arr[node_num].value =\n            (node_arr[child1].value && !node_arr[child2].value) ||\n            (!node_arr[child1].value && node_arr[child2].value);\n        node_arr[child1].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n        node_arr[child2].is_sensitive = 1 && node_arr[node_num].is_sensitive;\n      }\n      find_value1(child1);\n      find_value1(child2);\n    }\n    return;\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    string operatore;\n    cin >> operatore;\n    node_arr[i].node_type = operatore;\n    if (operatore == \"IN\") {\n      bool value;\n      cin >> value;\n      node_arr[i].value = value;\n    } else {\n      int child1;\n      cin >> child1;\n      node_arr[i].child1 = child1;\n      if (operatore == \"NOT\") {\n        node_arr[i].child2 = -1;\n      } else {\n        int child2;\n        cin >> child2;\n        node_arr[i].child2 = child2;\n      }\n    }\n  }\n  node_arr[1].is_sensitive = 1;\n  find_value(1);\n  find_value1(1);\n  for (int i = 1; i <= n; i++) {\n    if (node_arr[i].node_type == \"IN\") {\n      cout << (node_arr[i].is_sensitive != node_arr[1].value) << \"\";\n    }\n  }\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nchar c[2000009];\nlong long int arr[2000009], brr[2000009], crr[2000009], drr[2000009];\nstd::vector<long long int> v[2000009];\nlong long int solve(long long int node) {\n  if (v[node].size() == 0) return crr[node] = arr[node];\n  long long int val = solve(v[node][0]);\n  for (int i = 1; i < v[node].size(); i++) {\n    long long int x = solve(v[node][i]);\n    if (brr[node] == 2)\n      val |= x;\n    else if (brr[node] == 3)\n      val &= x;\n    else\n      val ^= x;\n  }\n  if (brr[node] == 1) val ^= 1;\n  return crr[node] = val;\n}\nvoid kor(long long int node, long long int par) {\n  long long int par_val = crr[par];\n  long long int cur = v[par][node];\n  long long int val = 1 ^ crr[cur];\n  for (long long int i = 0; i < v[par].size(); i++) {\n    if (i == node) continue;\n    long long int x = crr[v[par][i]];\n    if (brr[par] == 2)\n      val |= x;\n    else if (brr[par] == 3)\n      val &= x;\n    else\n      val ^= x;\n  }\n  if (brr[par] == 1) val ^= 1;\n  if (val == par_val) return;\n  drr[cur] = 1;\n  for (long long int i = 0; i < v[cur].size(); i++) {\n    kor(i, cur);\n  }\n  return;\n}\nint main() {\n  int test_case = 1;\n  for (int cs = 1; cs <= test_case; cs++) {\n    long long int n;\n    scanf(\"%lld\", &n);\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%s\", &c);\n      if (c[0] == 'I')\n        scanf(\"%lld\", &arr[i]);\n      else if (c[0] == 'N') {\n        brr[i] = 1;\n        long long int a;\n        scanf(\"%lld\", &a);\n        v[i].push_back(a);\n      } else if (c[0] == 'O') {\n        brr[i] = 2;\n        long long int a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        v[i].push_back(a);\n        v[i].push_back(b);\n      } else if (c[0] == 'A') {\n        brr[i] = 3;\n        long long int a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        v[i].push_back(a);\n        v[i].push_back(b);\n      } else if (c[0] == 'X') {\n        brr[i] = 4;\n        long long int a, b;\n        scanf(\"%lld %lld\", &a, &b);\n        v[i].push_back(a);\n        v[i].push_back(b);\n      }\n    }\n    long long int ans = 0;\n    ans = solve(1);\n    for (long long int i = 0; i < v[1].size(); i++) {\n      kor(i, 1);\n    }\n    for (int i = 1; i <= n; i++) {\n      if (v[i].size() == 0) printf(\"%lld\", ans ^ drr[i]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\ntemplate <typename T>\nvoid MACRO_VAR_Scan(T& t) {\n  std::cin >> t;\n}\ntemplate <typename First, typename... Rest>\nvoid MACRO_VAR_Scan(First& first, Rest&... rest) {\n  std::cin >> first;\n  MACRO_VAR_Scan(rest...);\n}\ntemplate <typename T>\nvoid MACRO_VEC_ROW_Init(int n, T& t) {\n  t.resize(n);\n}\ntemplate <typename First, typename... Rest>\nvoid MACRO_VEC_ROW_Init(int n, First& first, Rest&... rest) {\n  first.resize(n);\n  MACRO_VEC_ROW_Init(n, rest...);\n}\ntemplate <typename T>\nvoid MACRO_VEC_ROW_Scan(int p, T& t) {\n  std::cin >> t[p];\n}\ntemplate <typename First, typename... Rest>\nvoid MACRO_VEC_ROW_Scan(int p, First& first, Rest&... rest) {\n  std::cin >> first[p];\n  MACRO_VEC_ROW_Scan(p, rest...);\n}\ntemplate <typename T>\ninline T CHMAX(T& a, const T b) {\n  return a = (a < b) ? b : a;\n}\ntemplate <typename T>\ninline T CHMIN(T& a, const T b) {\n  return a = (a > b) ? b : a;\n}\nvoid CHECKTIME(std::function<void()> f) {\n  auto start = std::chrono::system_clock::now();\n  f();\n  auto end = std::chrono::system_clock::now();\n  auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start))\n                 .count();\n  std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\";\n}\ntemplate <class T>\nstd::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n  return std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate <typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;\nconstexpr int INFINT_LIM = (1LL << 31) - 1;\nconstexpr ll INFLL = 1LL << 60;\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate <class T, size_t N>\nvoid FILL(T (&a)[N], const T& val) {\n  for (auto& x : a) x = val;\n}\ntemplate <class ARY, size_t N, size_t M, class T>\nvoid FILL(ARY (&a)[N][M], const T& val) {\n  for (auto& b : a) FILL(b, val);\n}\ntemplate <class T>\nvoid FILL(std::vector<T>& a, const T& val) {\n  for (auto& x : a) x = val;\n}\ntemplate <class ARY, class T>\nvoid FILL(std::vector<std::vector<ARY>>& a, const T& val) {\n  for (auto& b : a) FILL(b, val);\n}\nsigned main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  ;\n  int n;\n  MACRO_VAR_Scan(n);\n  ;\n  enum TYPE { AND, OR, XOR, NOT, IN };\n  struct Node {\n    TYPE t;\n    int a, b;\n  };\n  std::vector<Node> node(n);\n  for (int i = 0; i < int(n); ++i) {\n    std::string s;\n    MACRO_VAR_Scan(s);\n    ;\n    int a;\n    MACRO_VAR_Scan(a);\n    ;\n    int b = 0;\n    if (s == \"IN\" || s == \"NOT\") {\n    } else\n      std::cin >> b;\n    --a;\n    --b;\n    TYPE t = IN;\n    if (s == \"AND\")\n      t = AND;\n    else if (s == \"OR\")\n      t = OR;\n    else if (s == \"XOR\")\n      t = XOR;\n    else if (s == \"NOT\")\n      t = NOT;\n    else if (s == \"IN\")\n      t = IN, ++a;\n    node[i] = Node{t, a, b};\n  }\n  std::vector<std::vector<int>> g(n);\n  for (int i = 0; i < int(n); ++i) {\n    if (node[i].t == IN) continue;\n    g[i].emplace_back(node[i].a);\n    if (node[i].b != -1) {\n      g[i].emplace_back(node[i].b);\n    }\n  }\n  std::vector<bool> b(n, true);\n  {\n    std::function<bool(int)> dfs = [&](int v) {\n      switch (node[v].t) {\n        case AND: {\n          b[v] = true;\n          b[v] = b[v] & dfs(node[v].a);\n          b[v] = b[v] & dfs(node[v].b);\n        } break;\n        case OR: {\n          b[v] = false;\n          b[v] = b[v] | dfs(node[v].a);\n          b[v] = b[v] | dfs(node[v].b);\n        } break;\n        case XOR: {\n          b[v] = false;\n          b[v] = b[v] ^ dfs(node[v].a);\n          b[v] = b[v] ^ dfs(node[v].b);\n        } break;\n        case NOT: {\n          b[v] = !dfs(node[v].a);\n        } break;\n        case IN: {\n          b[v] = !!(node[v].a);\n        } break;\n      }\n      return b[v];\n    };\n    dfs(0);\n  }\n  std::vector<bool> c(n, true);\n  {\n    std::function<void(int)> dfs = [&](int v) {\n      switch (node[v].t) {\n        case AND: {\n          c[node[v].a] =\n              ((((!b[node[v].a]) & b[node[v].b]) == b[v]) ? b[0] : c[v]);\n          c[node[v].b] =\n              (((b[node[v].a] & (!b[node[v].b])) == b[v]) ? b[0] : c[v]);\n          dfs(node[v].a);\n          dfs(node[v].b);\n        } break;\n        case OR: {\n          c[node[v].a] =\n              ((((!b[node[v].a]) | b[node[v].b]) == b[v]) ? b[0] : c[v]);\n          c[node[v].b] =\n              (((b[node[v].a] | (!b[node[v].b])) == b[v]) ? b[0] : c[v]);\n          dfs(node[v].a);\n          dfs(node[v].b);\n        } break;\n        case XOR: {\n          c[node[v].a] =\n              ((((!b[node[v].a]) ^ b[node[v].b]) == b[v]) ? b[0] : c[v]);\n          c[node[v].b] =\n              (((b[node[v].a] ^ (!b[node[v].b])) == b[v]) ? b[0] : c[v]);\n          dfs(node[v].a);\n          dfs(node[v].b);\n        } break;\n        case NOT: {\n          c[node[v].a] = c[v];\n          dfs(node[v].a);\n        } break;\n        case IN: {\n        } break;\n      }\n    };\n    c[0] = !b[0];\n    dfs(0);\n  }\n  for (int i = 0; i < int(n); ++i) {\n    if (node[i].t == IN) {\n      std::cout << (c[i]);\n      ;\n    }\n  }\n  std::cout << \"\\n\";\n  ;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> op;\nvector<vector<int>> v;\nvector<bool> val;\nint mp[1000001][2];\nvector<int> saved;\nvector<int> cur;\nvector<pair<int, int>> curc;\nvector<int> parent;\nint fans = -1;\nstatic string s;\nint solve(int k) {\n  cur.push_back(k);\n  if (v[k].size() == 0) return saved[k] = val[k];\n  if (v[k].size() == 1) return saved[k] = !solve(v[k][0]);\n  if (op[k] == 1) return saved[k] = (solve(v[k][0]) & solve(v[k][1]));\n  if (op[k] == 2) return saved[k] = (solve(v[k][0]) | solve(v[k][1]));\n  if (op[k] == 3) return saved[k] = (solve(v[k][0]) ^ solve(v[k][1]));\n  return 0;\n}\nvoid solve2(int k, int num) {\n  if (k == 0) {\n    fans = num;\n    return;\n  }\n  if (mp[k][num] != -1) {\n    fans = mp[k][num];\n    return;\n  }\n  int p = parent[k];\n  if (v[p].size() == 1) {\n    curc.push_back({p, 1 - num});\n    solve2(p, 1 - num);\n    return;\n  }\n  int num1 = v[p][0], num2 = v[p][1];\n  bool ar1, ar2;\n  if (num1 == k)\n    ar1 = num, ar2 = saved[v[p][1]];\n  else\n    ar2 = num, ar1 = saved[v[p][0]];\n  if (op[p] == 1) {\n    curc.push_back({p, ar1 & ar2});\n    solve2(p, ar1 & ar2);\n  }\n  if (op[p] == 2) {\n    curc.push_back({p, ar1 | ar2});\n    solve2(p, ar1 | ar2);\n  }\n  if (op[p] == 3) {\n    curc.push_back({p, ar1 ^ ar2});\n    solve2(p, ar1 ^ ar2);\n  }\n}\nsigned main() {\n  int n;\n  cin >> n;\n  memset(mp, -1, sizeof(mp));\n  op.resize(n);\n  val.resize(n);\n  parent.resize(n);\n  v.assign(n, {});\n  saved.resize(n, 0);\n  for (int i = 0; i < n; i++) {\n    cin >> s;\n    if (s == \"IN\") {\n      op[i] = 0;\n      int num;\n      cin >> num;\n      val[i] = num;\n    } else if (s == \"NOT\") {\n      int num;\n      cin >> num;\n      op[i] = 0;\n      num--;\n      v[i].push_back(num);\n      parent[num] = i;\n    } else {\n      if (s == \"AND\") op[i] = 1;\n      if (s == \"OR\") op[i] = 2;\n      if (s == \"XOR\") op[i] = 3;\n      int num1, num2;\n      cin >> num1 >> num2;\n      num1--;\n      num2--;\n      v[i].push_back(num1);\n      v[i].push_back(num2);\n      parent[num1] = i;\n      parent[num2] = i;\n    }\n  }\n  bool ans = solve(0);\n  for (int i = 0; i < n; i++) {\n    mp[i][saved[i]] = ans;\n  }\n  parent[0] = -1;\n  for (int i = 0; i < n; i++) {\n    if (v[i].size() == 0) {\n      solve2(i, 1 - val[i]);\n      if ((int)curc.size()) {\n        for (auto xx : curc) mp[xx.first][xx.second] = fans;\n      }\n      curc.clear();\n      cout << fans;\n    }\n  }\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, id[1001000], cnt, ans[1001000], t;\nbool yx[1001000];\nstring str;\nstruct Node {\n  int type, a, b;\n} node[1001000];\nint dfs(int now) {\n  int p, q;\n  if (node[now].type == 3) return node[now].a;\n  if (!node[now].type) {\n    p = dfs(node[now].a);\n    q = dfs(node[now].b);\n    if (p == q && p == 1) return p & q;\n    if (p == q) {\n      yx[node[now].a] = yx[node[now].b] = 0;\n      return p & q;\n    }\n    if (p == 1)\n      yx[node[now].a] = 0;\n    else\n      yx[node[now].b] = 0;\n    return p & q;\n  }\n  if (node[now].type == 1) {\n    p = dfs(node[now].a);\n    q = dfs(node[now].b);\n    if (p == q && !p) return p | q;\n    if (p == q) {\n      yx[node[now].a] = yx[node[now].b] = 0;\n      return p | q;\n    }\n    if (p == 1)\n      yx[node[now].b] = 0;\n    else\n      yx[node[now].a] = 0;\n    return p | q;\n  }\n  if (node[now].type == 4) {\n    return !dfs(node[now].a);\n  }\n  return dfs(node[now].a) ^ dfs(node[now].b);\n}\nvoid Dfs(int now, bool yxx) {\n  yxx &= yx[now];\n  if (node[now].type == 3) {\n    if (yxx)\n      ans[id[now]] = t ^ 1;\n    else\n      ans[id[now]] = t;\n    return;\n  }\n  Dfs(node[now].a, yxx);\n  if (node[now].type != 4) Dfs(node[now].b, yxx);\n}\nint main() {\n  ios::sync_with_stdio(0);\n  int i, j;\n  cin >> n;\n  for (i = 1; i <= n; i++) {\n    yx[i] = 1;\n    cin >> str;\n    if (str[0] == 'A') {\n      node[i].type = 0;\n      cin >> node[i].a >> node[i].b;\n    } else if (str[0] == 'O') {\n      node[i].type = 1;\n      cin >> node[i].a >> node[i].b;\n    } else if (str[0] == 'X') {\n      node[i].type = 2;\n      cin >> node[i].a >> node[i].b;\n    } else if (str[0] == 'I') {\n      node[i].type = 3;\n      cin >> node[i].a;\n      id[i] = ++cnt;\n    } else {\n      node[i].type = 4;\n      cin >> node[i].a;\n    }\n  }\n  t = dfs(1);\n  Dfs(1, 1);\n  for (i = 1; i <= cnt; i++) cout << ans[i];\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing vll = vector<long long int>;\ntemplate <class T>\nint sgn(T x) {\n  return (x > 0) - (x < 0);\n}\ntemplate <typename T>\ninline void read(vector<T>& v) {\n  for (T& i : v) cin >> i;\n}\nvi ans;\nbool operate(bool a, bool b, int op) {\n  if (op == 0) {\n    return a && b;\n  } else if (op == 1) {\n    return a || b;\n  } else if (op == 2) {\n    return a ^ b;\n  } else if (op == 3) {\n    return !a;\n  }\n}\nstruct Node {\n  int type, id;\n  Node *left, *right;\n  int le, ri;\n  bool res;\n  bool calc() {\n    if (type == 3) {\n      res = !left->calc();\n    } else if (type != 4) {\n      res = operate(left->calc(), right->calc(), type);\n    }\n    return res;\n  }\n  void willFlip() {\n    if (type == 3) {\n      left->willFlip();\n    } else if (type == 4) {\n      ans[id] = 1;\n    } else {\n      if (operate(!left->res, right->res, type) != res) {\n        left->willFlip();\n      }\n      if (operate(left->res, !right->res, type) != res) {\n        right->willFlip();\n      }\n    }\n  }\n};\nbool solve(int caseN) {\n  int n;\n  cin >> n;\n  vector<Node*> nodes(n);\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    int x, y;\n    if (s == \"AND\") {\n      cin >> x >> y;\n      nodes[i] = new Node{0, i, NULL, NULL, x, y, false};\n    } else if (s == \"OR\") {\n      cin >> x >> y;\n      nodes[i] = new Node{1, i, NULL, NULL, x, y, false};\n    } else if (s == \"XOR\") {\n      cin >> x >> y;\n      nodes[i] = new Node{2, i, NULL, NULL, x, y, false};\n    } else if (s == \"NOT\") {\n      cin >> x;\n      nodes[i] = new Node{3, i, NULL, NULL, x, 1, false};\n    } else {\n      cin >> x;\n      nodes[i] = new Node{4, i, NULL, NULL, 1, 1, x == 1};\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    nodes[i]->left = nodes[nodes[i]->le - 1];\n    nodes[i]->right = nodes[nodes[i]->ri - 1];\n  }\n  ans = vi(n);\n  nodes[0]->calc();\n  nodes[0]->willFlip();\n  for (int i = 0; i < n; i++) {\n    if (nodes[i]->type == 4) {\n      cout << (ans[i] ^ nodes[0]->res);\n    }\n  }\n  cout << \"\\n\";\n  return false;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(20);\n  cout << fixed;\n  for (int i = 1; solve(i); i++)\n    ;\n  cout.flush();\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1000005;\nvector<int> v[MAX_N];\nint a[MAX_N], val[MAX_N], ans[MAX_N];\nchar str[10];\nvoid dfs_1(int k) {\n  for (int i = 0; i < v[k].size(); i++) dfs_1(v[k][i]);\n  if (a[k] == 1)\n    val[k] = val[v[k][0]] & val[v[k][1]];\n  else if (a[k] == 2)\n    val[k] = val[v[k][0]] | val[v[k][1]];\n  else if (a[k] == 3)\n    val[k] = val[v[k][0]] ^ val[v[k][1]];\n  else if (a[k] == 4)\n    val[k] = val[v[k][0]] ^ 1;\n}\nvoid dfs_2(int k, int flag) {\n  if (a[k] == 5) {\n    ans[k] = val[1] ^ flag;\n  } else if (a[k] == 1) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 0 && val[y] == 0 || val[x] == 1 && val[y] == 0)\n      dfs_2(x, 0);\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 0 && val[y] == 0 || val[x] == 0 && val[y] == 1)\n      dfs_2(y, 0);\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 2) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 1 && val[y] == 1 || val[x] == 0 && val[y] == 1)\n      dfs_2(x, 0);\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 1 && val[y] == 1 || val[x] == 1 && val[y] == 0)\n      dfs_2(y, 0);\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 3) {\n    int x = v[k][0], y = v[k][1];\n    dfs_2(x, min(flag, 1));\n    dfs_2(y, min(flag, 1));\n  } else {\n    dfs_2(v[k][0], min(flag, 1));\n  }\n}\nint main() {\n  int n, k, x, y;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    ans[i] = -1;\n    scanf(\"%s\", str);\n    if (str[0] == 'I') {\n      scanf(\"%d\", &k);\n      val[i] = k, a[i] = 5;\n    } else if (str[0] == 'N') {\n      scanf(\"%d\", &k);\n      v[i].push_back(k), a[i] = 4;\n    } else if (str[0] == 'A') {\n      scanf(\"%d%d\", &x, &y), a[i] = 1;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'O') {\n      scanf(\"%d%d\", &x, &y), a[i] = 2;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'X') {\n      scanf(\"%d%d\", &x, &y), a[i] = 3;\n      v[i].push_back(x), v[i].push_back(y);\n    }\n  }\n  dfs_1(1);\n  dfs_2(1, 1);\n  for (int i = 1; i <= n; i++) {\n    if (ans[i] != -1) {\n      printf(\"%d\", ans[i]);\n    }\n  }\n  printf(\"\\n\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  int l;\n  int r;\n  int flag;\n  bool out;\n  bool rev;\n} n[1000006];\nvoid dfs1(int i) {\n  if (n[i].flag == 1) {\n    return;\n  }\n  while (n[i].flag) {\n    switch (n[i].flag) {\n      case 1:\n        n[i].out = n[n[i].l].out & n[n[i].r].out;\n        break;\n      case 2:\n        n[i].out = n[n[i].l].out | n[n[i].r].out;\n        break;\n      case 3:\n        n[i].out = n[n[i].l].out ^ n[n[i].r].out;\n        break;\n      case 4:\n        n[i].out = !n[n[i].l].out;\n        break;\n    }\n  }\n}\nint dfs(int i) {\n  if (!n[i].r && !n[i].l) {\n    return n[i].out;\n  }\n  while (n[i].flag) {\n    switch (n[i].flag) {\n      case 1:\n        n[i].out = dfs(n[i].l) & dfs(n[i].r);\n        return n[i].out;\n        break;\n      case 2:\n        n[i].out = dfs(n[i].l) | dfs(n[i].r);\n        return n[i].out;\n        break;\n      case 3:\n        n[i].out = dfs(n[i].l) ^ dfs(n[i].r);\n        return n[i].out;\n        break;\n      case 4:\n        n[i].out = !dfs(n[i].l);\n        return n[i].out;\n        break;\n    }\n  }\n  return 0;\n}\nvoid dfs2(int i) {\n  if (!n[i].flag) {\n    n[i].rev = true;\n    return;\n  }\n  if (n[i].flag == 1) {\n    if (n[i].out) {\n      dfs2(n[i].l);\n      dfs2(n[i].r);\n    } else if (n[n[i].l].out) {\n      dfs2(n[i].r);\n    } else if (n[n[i].r].out) {\n      dfs2(n[i].l);\n    }\n  } else if (n[i].flag == 2) {\n    if (!n[i].out) {\n      dfs2(n[i].l);\n      dfs2(n[i].r);\n    } else if (!n[n[i].l].out) {\n      dfs2(n[i].r);\n    } else if (!n[n[i].r].out) {\n      dfs2(n[i].l);\n    }\n  } else if (n[i].flag == 3) {\n    dfs2(n[i].l);\n    dfs2(n[i].r);\n  } else if (n[i].flag == 4) {\n    dfs2(n[i].l);\n  }\n}\nvoid Scan(int t) {\n  char str[6];\n  int a, b;\n  for (int i = 1; i <= t; i++) {\n    n[i].rev = false;\n    scanf(\"%s\", str);\n    if (!strcmp(str, \"AND\")) {\n      scanf(\"%d %d\", &a, &b);\n      n[i].l = a;\n      n[i].r = b;\n      n[i].flag = 1;\n      n[i].out = 0;\n    } else if (!strcmp(str, \"OR\")) {\n      scanf(\"%d %d\", &a, &b);\n      n[i].l = a;\n      n[i].r = b;\n      n[i].flag = 2;\n      n[i].out = 0;\n    } else if (!strcmp(str, \"XOR\")) {\n      scanf(\"%d %d\", &a, &b);\n      n[i].l = a;\n      n[i].r = b;\n      n[i].flag = 3;\n      n[i].out = 0;\n    } else if (!strcmp(str, \"NOT\")) {\n      scanf(\"%d\", &a);\n      n[i].l = a;\n      n[i].flag = 4;\n      n[i].out = 0;\n    } else if (!strcmp(str, \"IN\")) {\n      scanf(\"%d\", &a);\n      n[i].l = 0;\n      n[i].r = 0;\n      n[i].flag = 0;\n      n[i].out = a;\n    }\n  }\n}\nint main() {\n  int t;\n  cin >> t;\n  Scan(t);\n  dfs(1);\n  dfs2(1);\n  for (int i = 1; i <= t; i++)\n    if (!n[i].flag) {\n      if (n[i].rev)\n        cout << !n[1].out;\n      else\n        cout << n[1].out;\n    }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nenum logel { AND, OR, XOR, NOT, IN };\nstruct el {\n  logel type;\n  int left;\n  int right;\n  bool value;\n};\nvector<el> v;\nbool dfs_calc(int x) {\n  switch (v[x].type) {\n    case AND:\n      v[x].value = (dfs_calc(v[x].left) & dfs_calc(v[x].right));\n      break;\n    case XOR:\n      v[x].value = (dfs_calc(v[x].left) ^ dfs_calc(v[x].right));\n      break;\n    case OR:\n      v[x].value = (dfs_calc(v[x].left) | dfs_calc(v[x].right));\n      break;\n    case NOT:\n      v[x].value = (!dfs_calc(v[x].left));\n      break;\n  }\n  return v[x].value;\n}\nvector<bool> answer;\nvoid dfs_change(int x, bool will_change) {\n  switch (v[x].type) {\n    case IN:\n      answer[v[x].left] = will_change;\n      break;\n    case AND:\n      if (v[v[x].left].value) {\n        dfs_change(v[x].right, will_change);\n      } else {\n        dfs_change(v[x].right, false);\n      }\n      if (v[v[x].right].value) {\n        dfs_change(v[x].left, will_change);\n      } else {\n        dfs_change(v[x].left, false);\n      }\n      break;\n    case XOR:\n      dfs_change(v[x].right,\n                 will_change && (v[x].value !=\n                                 (v[v[x].left].value != !v[v[x].right].value)));\n      dfs_change(v[x].left,\n                 will_change && (v[x].value !=\n                                 (v[v[x].right].value != !v[v[x].left].value)));\n      break;\n    case OR:\n      dfs_change(v[x].right,\n                 will_change && (v[x].value !=\n                                 (v[v[x].left].value || !v[v[x].right].value)));\n      dfs_change(v[x].left,\n                 will_change && (v[x].value !=\n                                 (v[v[x].right].value || !v[v[x].left].value)));\n      break;\n    case NOT:\n      dfs_change(v[x].left, will_change);\n      break;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  v.resize(n);\n  int en = 0;\n  for (int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    if (s[0] == 'I') {\n      int a;\n      cin >> a;\n      v[i] = {logel::IN, en++, -1, a == 1};\n    } else if (s[0] == 'N') {\n      int a;\n      cin >> a;\n      v[i] = {logel::NOT, a - 1, -1, false};\n    } else {\n      int a, b;\n      cin >> a >> b;\n      logel t;\n      switch (s[0]) {\n        case 'A':\n          t = logel::AND;\n          break;\n        case 'X':\n          t = logel::XOR;\n          break;\n        case 'O':\n          t = logel::OR;\n          break;\n      }\n      v[i] = {t, a - 1, b - 1, false};\n    }\n  }\n  answer.resize(en);\n  dfs_calc(0);\n  dfs_change(0, true);\n  for (int i = 0; i < en; ++i) {\n    cout << (answer[i] != v[0].value);\n  }\n  cout << \"\\n\";\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 10;\nstring op[MAXN];\nvector<int> child[MAXN];\nint n;\nbool def[MAXN];\nint par[MAXN];\nint mem[MAXN][2];\nbool solve(int u, int p = -1) {\n  par[u] = p;\n  if (op[u] == \"IN\") return def[u] = child[u][0];\n  if (op[u] == \"AND\")\n    return def[u] = solve(child[u][0], u) & solve(child[u][1], u);\n  if (op[u] == \"XOR\")\n    return def[u] = solve(child[u][0], u) ^ solve(child[u][1], u);\n  if (op[u] == \"OR\")\n    return def[u] = solve(child[u][0], u) | solve(child[u][1], u);\n  if (op[u] == \"NOT\") return def[u] = !solve(child[u][0], u);\n  cerr << \"UH OH\" << endl;\n  return false;\n}\nbool dp(int u, bool v) {\n  if (mem[u][v] != -1) return mem[u][v];\n  if (u == 1) return mem[u][v] = v;\n  int p = par[u];\n  vector<int> c{v};\n  for (int i : child[p]) {\n    if (i != u) c.push_back(def[i]);\n  }\n  bool nv = 0;\n  if (op[p] == \"AND\") nv = c[0] & c[1];\n  if (op[p] == \"XOR\") nv = c[0] ^ c[1];\n  if (op[p] == \"OR\") nv = c[0] | c[1];\n  if (op[p] == \"NOT\") nv = !c[0];\n  return mem[u][v] = dp(p, nv);\n}\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cin >> n;\n  memset(mem, -1, sizeof mem);\n  for (int i = 1; i <= n; i++) {\n    int u;\n    string s;\n    cin >> s;\n    op[i] = s;\n    cin >> u;\n    child[i].push_back(u);\n    if (s != \"IN\" && s != \"NOT\") {\n      cin >> u;\n      child[i].push_back(u);\n    }\n  }\n  solve(1);\n  for (int i = 1; i <= n; i++) {\n    if (op[i] == \"IN\") {\n      cout << dp(i, !child[i][0]);\n    }\n  }\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst long long mxN = 1000000;\nvector<long long> adj[mxN];\nlong long tp[mxN];\nlong long val[mxN];\nlong long dfs(long long v, long long p) {\n  if (tp[v] == 0 || tp[v] == 1) {\n    val[v] = tp[v];\n    return tp[v];\n  }\n  long long cur = -1;\n  for (long long i : adj[v]) {\n    if (i == p) continue;\n    if (tp[v] == 5) {\n      cur = 1 - dfs(i, v);\n      break;\n    }\n    if (cur == -1) {\n      cur = dfs(i, v);\n    } else {\n      if (tp[v] == 2) {\n        cur &= dfs(i, v);\n      } else if (tp[v] == 3) {\n        cur |= dfs(i, v);\n      } else {\n        cur ^= dfs(i, v);\n      }\n    }\n  }\n  val[v] = cur;\n  return val[v];\n}\nlong long ans[mxN];\nlong long res;\nvoid solve(long long v, long long p) {\n  if (tp[v] < 2) {\n    ans[v] = res ^ 1;\n    return;\n  }\n  vector<long long> cs;\n  for (long long i : adj[v]) {\n    if (i == p) continue;\n    cs.push_back(val[i]);\n  }\n  long long ind = 0;\n  for (long long i : adj[v]) {\n    if (i == p) continue;\n    if (tp[v] == 5) {\n      solve(i, v);\n      break;\n    }\n    if (tp[v] == 2) {\n      if (((cs[ind] ^ 1) & cs[1 - ind]) != val[v]) {\n        solve(i, v);\n      }\n    } else if (tp[v] == 3) {\n      if (((cs[ind] ^ 1) | cs[1 - ind]) != val[v]) {\n        solve(i, v);\n      }\n    } else {\n      if (((cs[ind] ^ 1) ^ cs[1 - ind]) != val[v]) {\n        solve(i, v);\n      }\n    }\n    ++ind;\n  }\n}\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  for (long long i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    if (s[0] == 'I') {\n      long long in;\n      cin >> in;\n      tp[i] = in;\n    } else if (s[0] == 'A') {\n      tp[i] = 2;\n      long long a, b;\n      cin >> a >> b;\n      --a;\n      --b;\n      adj[i].push_back(a);\n      adj[a].push_back(i);\n      adj[i].push_back(b);\n      adj[b].push_back(i);\n    } else if (s[0] == 'O') {\n      tp[i] = 3;\n      long long a, b;\n      cin >> a >> b;\n      --a;\n      --b;\n      adj[i].push_back(a);\n      adj[a].push_back(i);\n      adj[i].push_back(b);\n      adj[b].push_back(i);\n    } else if (s[0] == 'X') {\n      tp[i] = 4;\n      long long a, b;\n      cin >> a >> b;\n      --a;\n      --b;\n      adj[i].push_back(a);\n      adj[a].push_back(i);\n      adj[i].push_back(b);\n      adj[b].push_back(i);\n    } else {\n      tp[i] = 5;\n      long long c;\n      cin >> c;\n      --c;\n      adj[i].push_back(c);\n      adj[c].push_back(i);\n    }\n  }\n  res = dfs(0, -1);\n  fill(ans, ans + n, res);\n  solve(0, -1);\n  for (long long i = 0; i < n; ++i) {\n    if (tp[i] < 2) {\n      cout << ans[i];\n    }\n  }\n  cout << \"\\n\";\n}\n", "#include <bits/stdc++.h>\nint n, son[1000005][2], typ[1000005], fa[1000005][21];\nbool f[1000005][2][21];\nint val[1000005];\nchar s[105];\nvoid dfs1(int u) {\n  if (son[u][0]) dfs1(son[u][0]);\n  if (son[u][1]) dfs1(son[u][1]);\n  if (typ[u] == 1) val[u] = val[son[u][0]] & val[son[u][1]];\n  if (typ[u] == 2) val[u] = val[son[u][0]] | val[son[u][1]];\n  if (typ[u] == 3) val[u] = val[son[u][0]] ^ val[son[u][1]];\n  if (typ[u] == 4) val[u] = val[son[u][0]] ^ 1;\n}\nvoid dfs2(int u) {\n  if (son[u][0]) fa[son[u][0]][0] = u, dfs2(son[u][0]);\n  if (son[u][1]) fa[son[u][1]][0] = u, dfs2(son[u][1]);\n  if (typ[u] == 1)\n    f[son[u][0]][1][0] = val[son[u][1]], f[son[u][1]][1][0] = val[son[u][0]];\n  if (typ[u] == 2)\n    f[son[u][0]][1][0] = f[son[u][1]][1][0] = 1,\n    f[son[u][0]][0][0] = val[son[u][1]], f[son[u][1]][0][0] = val[son[u][0]];\n  if (typ[u] == 3) {\n    f[son[u][0]][0][0] = val[son[u][1]], f[son[u][1]][0][0] = val[son[u][0]];\n    f[son[u][0]][1][0] = val[son[u][1]] ^ 1,\n    f[son[u][1]][1][0] = val[son[u][0]] ^ 1;\n  }\n  if (typ[u] == 4) f[son[u][0]][0][0] = 1, f[son[u][0]][1][0] = 0;\n}\nint solve(int x, int val) {\n  for (int i = 20; ~i; i--)\n    if (fa[x][i]) val = f[x][val][i], x = fa[x][i];\n  return val;\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", s);\n    if (s[0] == 'A') scanf(\"%d%d\", &son[i][0], &son[i][1]), typ[i] = 1;\n    if (s[0] == 'O') scanf(\"%d%d\", &son[i][0], &son[i][1]), typ[i] = 2;\n    if (s[0] == 'X') scanf(\"%d%d\", &son[i][0], &son[i][1]), typ[i] = 3;\n    if (s[0] == 'N') scanf(\"%d\", &son[i][0]), typ[i] = 4;\n    if (s[0] == 'I') scanf(\"%d\", &val[i]);\n  }\n  dfs1(1), dfs2(1);\n  for (int j = 1; j < 21; j++)\n    for (int i = 1; i <= n; i++) {\n      fa[i][j] = fa[fa[i][j - 1]][j - 1];\n      f[i][0][j] = f[fa[i][j - 1]][f[i][0][j - 1]][j - 1];\n      f[i][1][j] = f[fa[i][j - 1]][f[i][1][j - 1]][j - 1];\n    }\n  for (int i = 1; i <= n; i++)\n    if (!typ[i]) printf(\"%d\", solve(i, val[i] ^ 1));\n}\n", "#include <bits/stdc++.h>\nconst int A = 0, X = 1, O = 2, I = 3, N = 4;\nusing namespace std;\nint tp[1000000], n, bt[1000000];\npair<int, int> nt[1000000];\nbool izm[1000000];\nvoid DFS(int i) {\n  if (tp[i] == A) {\n    int x = nt[i].first, y = nt[i].second;\n    if (izm[i]) {\n      if (((bt[x] ^ 1) & bt[y]) != bt[i])\n        izm[x] = 1;\n      else\n        izm[x] = 0;\n      if (((bt[y] ^ 1) & bt[x]) != bt[i])\n        izm[y] = 1;\n      else\n        izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    } else {\n      izm[x] = 0;\n      izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    }\n  } else if (tp[i] == O) {\n    int x = nt[i].first, y = nt[i].second;\n    if (izm[i]) {\n      if (((bt[x] ^ 1) | bt[y]) != bt[i])\n        izm[x] = 1;\n      else\n        izm[x] = 0;\n      if (((bt[y] ^ 1) | bt[x]) != bt[i])\n        izm[y] = 1;\n      else\n        izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    } else {\n      izm[x] = 0;\n      izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    }\n  } else if (tp[i] == X) {\n    int x = nt[i].first, y = nt[i].second;\n    if (izm[i]) {\n      if (((bt[x] ^ 1) ^ bt[y]) != bt[i])\n        izm[x] = 1;\n      else\n        izm[x] = 0;\n      if (((bt[y] ^ 1) ^ bt[x]) != bt[i])\n        izm[y] = 1;\n      else\n        izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    } else {\n      izm[x] = 0;\n      izm[y] = 0;\n      DFS(x);\n      DFS(y);\n    }\n  } else if (tp[i] == N) {\n    int x = nt[i].first;\n    izm[x] = izm[i];\n    DFS(x);\n  }\n}\nvoid dfs(int i) {\n  if (tp[i] == A) {\n    int x = nt[i].first, y = nt[i].second;\n    dfs(x);\n    dfs(y);\n    bt[i] = bt[x] & bt[y];\n  } else if (tp[i] == O) {\n    int x = nt[i].first, y = nt[i].second;\n    dfs(x);\n    dfs(y);\n    bt[i] = bt[x] | bt[y];\n  } else if (tp[i] == X) {\n    int x = nt[i].first, y = nt[i].second;\n    dfs(x);\n    dfs(y);\n    bt[i] = bt[x] ^ bt[y];\n  } else if (tp[i] == N) {\n    int x = nt[i].first;\n    dfs(x);\n    bt[i] = bt[x] ^ 1;\n  }\n}\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    string s;\n    int x, y;\n    cin >> s;\n    if (s[0] == 'A') {\n      tp[i] = A;\n      cin >> x >> y;\n      x--;\n      y--;\n      nt[i].first = x;\n      nt[i].second = y;\n    } else if (s[0] == 'O') {\n      tp[i] = O;\n      cin >> x >> y;\n      x--;\n      y--;\n      nt[i].first = x;\n      nt[i].second = y;\n    } else if (s[0] == 'N') {\n      tp[i] = N;\n      cin >> x;\n      x--;\n      nt[i].first = x;\n    } else if (s[0] == 'I') {\n      tp[i] = I;\n      cin >> x;\n      bt[i] = x;\n    } else {\n      tp[i] = X;\n      cin >> x >> y;\n      x--;\n      y--;\n      nt[i].first = x;\n      nt[i].second = y;\n    }\n  }\n  dfs(0);\n  izm[0] = 1;\n  DFS(0);\n  for (int i = 0; i < n; i++)\n    if (tp[i] == I) {\n      if (izm[i])\n        cout << (bt[0] ^ 1);\n      else\n        cout << bt[0];\n    }\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nvoid dbg_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n  cerr << ' ' << H;\n  dbg_out(T...);\n}\nbool compare(const pair<int long long, int long long> &a,\n             const pair<int long long, int long long> &b) {\n  return a.second <= b.second;\n}\nint long long inline power(int long long a, int long long b, int long long p) {\n  a %= p;\n  int long long ans = 1;\n  while (b > 0) {\n    if (b & 1) ans = (ans * a) % p;\n    a = (a * a) % p;\n    b >>= 1;\n  }\n  return ans;\n}\nint long long inv(int long long n, int long long p) {\n  return power(n, p - 2, p);\n}\nbool inline isPrime(int long long n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 == 0 || n % 3 == 0) return false;\n  for (int long long i = 5; i * i <= n; i = i + 6)\n    if (n % i == 0 || n % (i + 2) == 0) return false;\n  return true;\n}\nint long long gcd(int long long a, int long long b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\nstruct vertex {\n  char tp;\n  vector<int long long> in;\n  bool val;\n  bool change;\n};\nvector<vertex> adj(1000001);\nint long long dfs1(int long long v) {\n  if (adj[v].tp == 'A')\n    adj[v].val = dfs1(adj[v].in[0]) & dfs1(adj[v].in[1]);\n  else if (adj[v].tp == 'O')\n    adj[v].val = dfs1(adj[v].in[0]) | dfs1(adj[v].in[1]);\n  else if (adj[v].tp == 'X')\n    adj[v].val = dfs1(adj[v].in[0]) ^ dfs1(adj[v].in[1]);\n  else if (adj[v].tp == 'N')\n    adj[v].val = !dfs1(adj[v].in[0]);\n  return adj[v].val;\n}\nvoid dfs2(int long long v) {\n  if (adj[v].change == false) {\n    for (int long long i = 0; i < adj[v].in.size(); i++) {\n      adj[adj[v].in[i]].change = false;\n    }\n  } else {\n    if (adj[v].tp == 'A') {\n      if (adj[v].val == (!adj[adj[v].in[0]].val & adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[0]].change = false;\n      } else\n        adj[adj[v].in[0]].change = true;\n      if (adj[v].val == (adj[adj[v].in[0]].val & !adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[1]].change = false;\n      } else\n        adj[adj[v].in[1]].change = true;\n    } else if (adj[v].tp == 'O') {\n      if (adj[v].val == (!adj[adj[v].in[0]].val | adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[0]].change = false;\n      } else\n        adj[adj[v].in[0]].change = true;\n      if (adj[v].val == (adj[adj[v].in[0]].val | !adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[1]].change = false;\n      } else\n        adj[adj[v].in[1]].change = true;\n    } else if (adj[v].tp == 'X') {\n      if (adj[v].val == (!adj[adj[v].in[0]].val ^ adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[0]].change = false;\n      } else\n        adj[adj[v].in[0]].change = true;\n      if (adj[v].val == (adj[adj[v].in[0]].val ^ !adj[adj[v].in[1]].val)) {\n        adj[adj[v].in[1]].change = false;\n      } else\n        adj[adj[v].in[1]].change = true;\n    } else if (adj[v].tp == 'N') {\n      if (adj[v].val == (!!adj[adj[v].in[0]].val)) {\n        adj[adj[v].in[0]].change = false;\n      } else\n        adj[adj[v].in[0]].change = true;\n    }\n  }\n  for (int long long i = 0; i < adj[v].in.size(); i++) {\n    dfs2(adj[v].in[i]);\n  }\n}\nvoid solve() {\n  int long long n, m, i, j, k, l, r;\n  cin >> n;\n  for (i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    adj[i].tp = s[0];\n    if (s[0] == 'I') {\n      cin >> l;\n      adj[i].val = l;\n    } else if (s[0] == 'N') {\n      cin >> l;\n      adj[i].in.push_back(l - 1);\n    } else {\n      cin >> l >> r;\n      adj[i].in.push_back(l - 1);\n      adj[i].in.push_back(r - 1);\n    }\n  }\n  dfs1(0);\n  adj[0].change = true;\n  dfs2(0);\n  for (i = 0; i < n; i++) {\n    if (adj[i].tp == 'I') {\n      l = adj[0].val ^ adj[i].change;\n      cout << l;\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n  int long long t = 1;\n  while (t--) solve();\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  bool val;\n  char ch;\n  int l, r;\n  node() { ch = l = r = -1; }\n} arr[(int)1e6 + 5];\nvector<pair<int, int> > res;\nvoid dfs(int u) {\n  if (arr[u].l == -1 && arr[u].r == -1) return;\n  if (arr[u].l != -1) dfs(arr[u].l);\n  if (arr[u].r != -1) dfs(arr[u].r);\n  if (arr[u].ch == 'A')\n    arr[u].val = arr[arr[u].l].val & arr[arr[u].r].val;\n  else if (arr[u].ch == 'O')\n    arr[u].val = arr[arr[u].l].val | arr[arr[u].r].val;\n  else if (arr[u].ch == 'X')\n    arr[u].val = arr[arr[u].l].val ^ arr[arr[u].r].val;\n  else if (arr[u].l != -1)\n    arr[u].val = !arr[arr[u].l].val;\n  else\n    arr[u].val = !arr[arr[u].r].val;\n}\nvoid makeRes(int u, bool change) {\n  if (arr[u].ch == 'I') {\n    if (!change)\n      res.push_back(make_pair(u, arr[1].val));\n    else\n      res.push_back(make_pair(u, arr[1].val ^ 1));\n    return;\n  }\n  if (arr[u].l != -1 && arr[u].r != -1) {\n    bool nowL = arr[arr[u].l].val;\n    bool nowR = arr[arr[u].r].val;\n    if (arr[u].ch == 'A') {\n      if (((nowL ^ 1) & nowR) == arr[u].val)\n        makeRes(arr[u].l, change & 0);\n      else\n        makeRes(arr[u].l, change & 1);\n      if ((nowL & (nowR ^ 1)) == arr[u].val)\n        makeRes(arr[u].r, change & 0);\n      else\n        makeRes(arr[u].r, change & 1);\n    } else if (arr[u].ch == 'O') {\n      if (((nowL ^ 1) | nowR) == arr[u].val)\n        makeRes(arr[u].l, change & 0);\n      else\n        makeRes(arr[u].l, change & 1);\n      if ((nowL | (nowR ^ 1)) == arr[u].val)\n        makeRes(arr[u].r, change & 0);\n      else\n        makeRes(arr[u].r, change & 1);\n    } else if (arr[u].ch == 'X') {\n      if (((nowL ^ 1) ^ nowR) == arr[u].val)\n        makeRes(arr[u].l, change & 0);\n      else\n        makeRes(arr[u].l, change & 1);\n      if ((nowL ^ (nowR ^ 1)) == arr[u].val)\n        makeRes(arr[u].r, change & 0);\n      else\n        makeRes(arr[u].r, change & 1);\n    }\n  } else if (arr[u].l != -1) {\n    if ((!(arr[arr[u].l].val ^ 1)) == arr[u].val)\n      makeRes(arr[u].l, change & 0);\n    else\n      makeRes(arr[u].l, change & 1);\n  } else {\n    if ((!(arr[arr[u].r].val ^ 1)) == arr[u].val)\n      makeRes(arr[u].r, change & 0);\n    else\n      makeRes(arr[u].r, change & 1);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1, leaf, l, r; i <= n; i++) {\n    char s[10];\n    scanf(\"%s\", s);\n    arr[i].ch = s[0];\n    if (s[0] == 'I') {\n      scanf(\"%d\", &leaf);\n      arr[i].val = leaf;\n    } else if (s[0] == 'N') {\n      scanf(\"%d\", &l);\n      arr[i].l = l;\n    } else {\n      scanf(\"%d %d\", &l, &r);\n      arr[i].l = l;\n      arr[i].r = r;\n    }\n  }\n  dfs(1);\n  makeRes(1, 1);\n  sort(res.begin(), res.end());\n  for (int i = 0; i < res.size(); i++) printf(\"%d\", res[i].second);\n  puts(\"\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nchar op[1000009][5];\nint bit[1000009][2];\nint value[1000009];\nbool flag[1000009];\nint dfs(int u) {\n  int& ans = value[u];\n  if (op[u][0] == 'I') {\n  } else if (op[u][0] == 'N') {\n    ans = 1 - dfs(bit[u][0]);\n  } else if (op[u][0] == 'A') {\n    ans = dfs(bit[u][0]) * dfs(bit[u][1]);\n  } else if (op[u][0] == 'O') {\n    ans = max(dfs(bit[u][0]), dfs(bit[u][1]));\n  } else if (op[u][0] == 'X') {\n    ans = dfs(bit[u][0]) ^ dfs(bit[u][1]);\n  } else {\n    int k = 0;\n    int temp = 1 / k;\n  }\n  return ans;\n}\nvoid mark(int u, int p) {\n  if (u == -1) return;\n  if (p == -1) {\n    flag[u] = true;\n    mark(bit[u][0], u);\n    mark(bit[u][1], u);\n    return;\n  }\n  if (op[p][0] == 'I') {\n    int k = 0;\n    int temp = 1 / k;\n    return;\n  } else if (op[p][0] == 'N') {\n    flag[u] = flag[p];\n  } else if (op[p][0] == 'A') {\n    int o = bit[p][0] ^ bit[p][1] ^ u;\n    if (value[o] == 1)\n      flag[u] = flag[p];\n    else\n      flag[u] = false;\n  } else if (op[p][0] == 'O') {\n    int o = bit[p][0] ^ bit[p][1] ^ u;\n    if (value[o] == 1)\n      flag[u] = false;\n    else\n      flag[u] = flag[p];\n  } else {\n    flag[u] = flag[p];\n  }\n  mark(bit[u][0], u);\n  mark(bit[u][1], u);\n}\nchar all_ans[1000009];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  memset(bit, -1, sizeof(bit));\n  vector<int> ins;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", op[i]);\n    if (op[i][0] == 'N') {\n      scanf(\"%d\", &bit[i][0]);\n    } else if (op[i][0] == 'I') {\n      ins.push_back(i);\n      scanf(\"%d\", &value[i]);\n    } else {\n      scanf(\"%d %d\", &bit[i][0], &bit[i][1]);\n    }\n  }\n  int output = dfs(1);\n  mark(1, -1);\n  all_ans[ins.size()] = '\\0';\n  int my;\n  for (int i = 0; i < (int)ins.size(); i++) {\n    if (flag[ins[i]])\n      my = 1 - output;\n    else\n      my = output;\n    all_ans[i] = my + '0';\n  }\n  printf(\"%s\", all_ans);\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = 4 * atan(1);\nint N;\nint A[1000013], B[1000013];\nstring op[1000013];\nint sz[1000013];\nbool val[1000013];\nvector<int> diff[1000013], eq[1000013];\nbool apply(bool a, bool b, string op) {\n  if (op[0] == 'A')\n    return a & b;\n  else if (op[0] == 'O')\n    return a | b;\n  else if (op[0] == 'X')\n    return a ^ b;\n  else if (op[0] == 'N')\n    return !a;\n  else\n    throw domain_error(\"wtf?\");\n}\nint dfs(int n) {\n  sz[n] = 1;\n  if (op[n] == \"IN\") return val[n] = A[n];\n  int a = dfs(A[n]);\n  sz[n] += sz[A[n]];\n  int b = 0;\n  if (B[n] != -1) {\n    b = dfs(B[n]);\n    sz[n] += sz[B[n]];\n  }\n  return val[n] = apply(a, b, op[n]);\n}\nvoid go(int n) {\n  char c = op[n][0];\n  if (c == 'I') {\n    diff[n].push_back(n);\n    return;\n  }\n  if (c == 'N') {\n    go(A[n]);\n    eq[n] = move(eq[A[n]]);\n    diff[n] = move(diff[A[n]]);\n    return;\n  }\n  go(A[n]);\n  go(B[n]);\n  int heavy = A[n], light = B[n];\n  if (sz[heavy] < sz[light]) swap(heavy, light);\n  if (c == 'X') {\n    eq[n] = move(eq[heavy]);\n    diff[n] = move(diff[heavy]);\n    for (int x : eq[light]) eq[n].push_back(x);\n    for (int x : diff[light]) diff[n].push_back(x);\n  }\n  if (c == 'A') {\n    if (val[light]) {\n      eq[n] = move(eq[heavy]);\n      diff[n] = move(diff[heavy]);\n    } else {\n      eq[n] = move(eq[heavy]);\n      for (int x : diff[heavy]) eq[n].push_back(x);\n    }\n    if (val[heavy]) {\n      for (int x : eq[light]) eq[n].push_back(x);\n      for (int x : diff[light]) diff[n].push_back(x);\n    } else {\n      for (int x : eq[light]) eq[n].push_back(x);\n      for (int x : diff[light]) eq[n].push_back(x);\n    }\n  }\n  if (c == 'O') {\n    if (!val[light]) {\n      eq[n] = move(eq[heavy]);\n      diff[n] = move(diff[heavy]);\n    } else {\n      eq[n] = move(eq[heavy]);\n      for (int x : diff[heavy]) eq[n].push_back(x);\n    }\n    if (!val[heavy]) {\n      for (int x : eq[light]) eq[n].push_back(x);\n      for (int x : diff[light]) diff[n].push_back(x);\n    } else {\n      for (int x : eq[light]) eq[n].push_back(x);\n      for (int x : diff[light]) eq[n].push_back(x);\n    }\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> N;\n  memset(B, -1, sizeof B);\n  for (int i = 0; i < N; i++) {\n    cin >> op[i] >> A[i];\n    if (op[i] != \"IN\") {\n      --A[i];\n      if (op[i] != \"NOT\") {\n        cin >> B[i];\n        --B[i];\n      }\n    }\n  }\n  dfs(0);\n  go(0);\n  vector<pair<int, bool> > ans;\n  for (int x : eq[0]) ans.emplace_back(x, val[0]);\n  for (int x : diff[0]) ans.emplace_back(x, !val[0]);\n  sort(ans.begin(), ans.end());\n  for (auto p : ans) {\n    cout << p.second;\n  }\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst long double EPS = (long double)1e-9;\nconst long double PI = acos(0) * 2;\nbool isZero(const long double& x) { return abs(x) <= EPS; }\nint sign(const long double& x) { return isZero(x) ? 0 : (0 < x ? 1 : -1); }\nlong long gcd(long long a, long long b) {\n  for (; b; a %= b, swap(a, b)) {\n  }\n  return abs(a);\n}\npair<long long, long long> operator+(const pair<long long, long long>& a,\n                                     const pair<long long, long long>& b) {\n  return pair<long long, long long>(a.first + b.first, a.second + b.second);\n}\npair<long long, long long> operator-(const pair<long long, long long>& a,\n                                     const pair<long long, long long>& b) {\n  return pair<long long, long long>(a.first - b.first, a.second - b.second);\n}\npair<long long, long long> operator*(const pair<long long, long long>& a,\n                                     const long long& b) {\n  return pair<long long, long long>(a.first * b, a.second * b);\n}\nlong long operator*(const pair<long long, long long>& a,\n                    const pair<long long, long long>& b) {\n  return a.first * b.second - b.first * a.second;\n}\nlong long ccw(const pair<long long, long long>& a,\n              const pair<long long, long long>& b,\n              const pair<long long, long long>& c) {\n  return a * b + b * c + c * a;\n}\nvoid fg(vector<int> G[], int a, int b) {\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nvoid fg(vector<pair<int, int> > G[], int a, int b, int c) {\n  G[a].push_back({b, c});\n  G[b].push_back({a, c});\n}\nconst int MAXN = 1000055;\nint E[MAXN][2];\nint D[MAXN];\nchar A[MAXN][6];\nint B[MAXN], C[MAXN];\nint N;\nvoid dfs1(int i) {\n  if ('I' == A[i][0]) {\n    D[i] = B[i];\n    return;\n  }\n  if ('N' == A[i][0]) {\n    dfs1(B[i]);\n    D[i] = !D[B[i]];\n    return;\n  }\n  dfs1(B[i]);\n  dfs1(C[i]);\n  if ('A' == A[i][0]) {\n    D[i] = D[B[i]] & D[C[i]];\n  } else if ('O' == A[i][0]) {\n    D[i] = D[B[i]] | D[C[i]];\n  } else {\n    D[i] = D[B[i]] ^ D[C[i]];\n  }\n}\nvoid dfs2(int i) {\n  if ('I' == A[i][0]) return;\n  if ('N' == A[i][0]) {\n    E[B[i]][0] = E[i][1];\n    E[B[i]][1] = E[i][0];\n    dfs2(B[i]);\n    return;\n  }\n  if ('A' == A[i][0]) {\n    E[B[i]][0] = E[i][0];\n    E[B[i]][1] = E[i][D[C[i]]];\n    E[C[i]][0] = E[i][0];\n    E[C[i]][1] = E[i][D[B[i]]];\n  } else if ('O' == A[i][0]) {\n    E[B[i]][0] = E[i][D[C[i]]];\n    E[B[i]][1] = E[i][1];\n    E[C[i]][0] = E[i][D[B[i]]];\n    E[C[i]][1] = E[i][1];\n  } else {\n    E[B[i]][0] = E[i][D[C[i]]];\n    E[B[i]][1] = E[i][D[C[i]] ^ 1];\n    E[C[i]][0] = E[i][D[B[i]]];\n    E[C[i]][1] = E[i][D[B[i]] ^ 1];\n  }\n  dfs2(B[i]);\n  dfs2(C[i]);\n}\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) {\n    scanf(\" %s%d\", A[i], &B[i]);\n    if ('I' != A[i][0] && 'N' != A[i][0]) scanf(\"%d\", &C[i]);\n  }\n  dfs1(1);\n  E[1][0] = 0;\n  E[1][1] = 1;\n  dfs2(1);\n  for (int i = 1; i <= N; i++)\n    if ('I' == A[i][0]) putchar(E[i][!B[i]] ? '1' : '0');\n  puts(\"\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nvoid io() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  cout.tie(NULL);\n}\nint n;\nstring op[1000000];\nint lchild[1000000], rchild[1000000];\nint in[1000000];\nint parent[1000000];\nvector<int> leafs;\nint memo[1000000];\nint calc(int x) {\n  if (op[x][0] == 'I')\n    return in[x];\n  else if (op[x][0] == 'A')\n    return in[x] = calc(lchild[x]) & calc(rchild[x]);\n  else if (op[x][0] == 'O')\n    return in[x] = calc(lchild[x]) | calc(rchild[x]);\n  else if (op[x][0] == 'X')\n    return in[x] = calc(lchild[x]) ^ calc(rchild[x]);\n  else\n    return in[x] = 1 - calc(lchild[x]);\n}\nint doit(int x) {\n  if (memo[x] >= 0) return memo[x];\n  int p = parent[x];\n  if (op[p][0] == 'A') {\n    int y = lchild[p] == x ? rchild[p] : lchild[p];\n    if (in[p] == ((1 - in[x]) & in[y]))\n      return memo[x] = in[0];\n    else\n      return memo[x] = doit(p);\n  } else if (op[p][0] == 'O') {\n    int y = lchild[p] == x ? rchild[p] : lchild[p];\n    if (in[p] == ((1 - in[x]) | in[y]))\n      return memo[x] = in[0];\n    else\n      return memo[x] = doit(p);\n  } else if (op[p][0] == 'X') {\n    int y = lchild[p] == x ? rchild[p] : lchild[p];\n    if (in[p] == ((1 - in[x]) ^ in[y]))\n      return memo[x] = in[0];\n    else\n      return memo[x] = doit(p);\n  } else {\n    return memo[x] = doit(p);\n  }\n}\nint main() {\n  io();\n  cin >> n;\n  fill(memo, memo + n, -1);\n  for (int i = 0; i < n; i++) {\n    cin >> op[i];\n    if (op[i][0] == 'I') {\n      cin >> in[i];\n      leafs.push_back(i);\n    } else if (op[i][0] == 'N') {\n      cin >> lchild[i];\n      lchild[i]--;\n      parent[lchild[i]] = i;\n    } else {\n      cin >> lchild[i] >> rchild[i];\n      lchild[i]--;\n      rchild[i]--;\n      parent[lchild[i]] = i;\n      parent[rchild[i]] = i;\n    }\n  }\n  calc(0);\n  memo[0] = 1 - in[0];\n  for (int leaf : leafs) {\n    cout << doit(leaf);\n  }\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint __i__, __j__;\nclass _Debug {\n public:\n  template <typename T>\n  _Debug& operator,(T val) {\n    cout << val << endl;\n    return *this;\n  }\n};\nint t[1000000];\nvector<int> adjList[1000000];\nlist<int> output[1000000][2];\nint p[1000000];\nint size[1000000];\nint doDFS(int u) {\n  int i;\n  int h = -1;\n  vector<int> ret;\n  size[u] = adjList[u].empty();\n  for (i = 0; i < adjList[u].size(); i++) {\n    int v = adjList[u][i];\n    ret.push_back(doDFS(v));\n    size[u] += size[v];\n    if ((h == -1) || (size[v] > size[h])) h = v;\n  }\n  if (h == -1) {\n    p[u] = u;\n    output[u][!(t[u] - 4)].push_back(u);\n    return t[u] - 4;\n  } else if (adjList[u].size() == 1) {\n    p[u] = p[adjList[u][0]];\n    swap(output[p[u]][0], output[p[u]][1]);\n    return !ret[0];\n  } else {\n    p[u] = p[h];\n    int other = (h == adjList[u][0]);\n    if (t[u] == 0) {\n      if (ret[other] == 0)\n        output[p[u]][0].splice(output[p[u]][0].end(), output[p[u]][1]);\n    } else if (t[u] == 1) {\n      if (ret[other] == 1)\n        output[p[u]][1].splice(output[p[u]][1].end(), output[p[u]][0]);\n    } else if (t[u] == 2) {\n      if (ret[other] == 1) swap(output[p[u]][0], output[p[u]][1]);\n    }\n    int pp = p[adjList[u][other]];\n    for (auto it = output[pp][0].begin(); it != output[pp][0].end(); it++) {\n      if (t[u] == 0)\n        output[p[u]][0].push_back(*it);\n      else if (t[u] == 1)\n        output[p[u]][ret[!other]].push_back(*it);\n      else\n        output[p[u]][ret[!other]].push_back(*it);\n    }\n    for (auto it = output[pp][1].begin(); it != output[pp][1].end(); it++) {\n      if (t[u] == 0)\n        output[p[u]][ret[!other]].push_back(*it);\n      else if (t[u] == 1)\n        output[p[u]][1].push_back(*it);\n      else\n        output[p[u]][!ret[!other]].push_back(*it);\n    }\n    output[pp][0].clear(), output[pp][1].clear();\n    if (t[u] == 0)\n      return ret[0] & ret[1];\n    else if (t[u] == 1)\n      return ret[0] | ret[1];\n    else\n      return ret[0] ^ ret[1];\n  }\n}\nint main() {\n  int i;\n  int n;\n  char s[4];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%s\", s);\n    if (s[0] == 'A') {\n      t[i] = 0;\n      adjList[i].resize(2);\n      scanf(\"%d %d\", &adjList[i][0], &adjList[i][1]);\n      adjList[i][0]--, adjList[i][1]--;\n    } else if (s[0] == 'O') {\n      t[i] = 1;\n      adjList[i].resize(2);\n      scanf(\"%d %d\", &adjList[i][0], &adjList[i][1]);\n      adjList[i][0]--, adjList[i][1]--;\n    } else if (s[0] == 'X') {\n      t[i] = 2;\n      adjList[i].resize(2);\n      scanf(\"%d %d\", &adjList[i][0], &adjList[i][1]);\n      adjList[i][0]--, adjList[i][1]--;\n    } else if (s[0] == 'N') {\n      t[i] = 3;\n      adjList[i].resize(1);\n      scanf(\"%d\", &adjList[i][0]);\n      adjList[i][0]--;\n    } else {\n      scanf(\"%d\", &t[i]);\n      t[i] += 4;\n    }\n  }\n  doDFS(0);\n  vector<pair<int, int> > ans;\n  for (auto it = output[p[0]][0].begin(); it != output[p[0]][0].end(); it++)\n    ans.push_back(make_pair(*it, 0));\n  for (auto it = output[p[0]][1].begin(); it != output[p[0]][1].end(); it++)\n    ans.push_back(make_pair(*it, 1));\n  sort(ans.begin(), ans.end());\n  for (i = 0; i < ans.size(); i++) printf(\"%d\", ans[i].second);\n  printf(\"\\n\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000010;\nint n, res[N], to[N][2], ans[N];\nchar tmpread[10];\npair<char, pair<int, int> > g[N];\nvector<pair<int, int> > v[N][2];\nvector<int> cur[N][2];\nint calc(int node) {\n  if (g[node].first == 'I') return res[node] = g[node].second.first;\n  if (g[node].first == 'N') return res[node] = !(calc(g[node].second.first));\n  if (g[node].first == 'X')\n    return res[node] =\n               (calc(g[node].second.first) ^ calc(g[node].second.second));\n  if (g[node].first == 'O')\n    return res[node] =\n               (calc(g[node].second.first) | calc(g[node].second.second));\n  return res[node] = (calc(g[node].second.first) & calc(g[node].second.second));\n}\ninline void addto(vector<int> &v, vector<int> &v2) {\n  for (int i = 0; i < (int)v2.size(); i++) v.push_back(v2[i]);\n}\nvoid calc2(int node) {\n  if (g[node].first == 'I') {\n    cur[node][g[node].second.first ^ 1].push_back(node);\n    return;\n  }\n  if (g[node].first == 'N') {\n    calc2(g[node].second.first);\n    swap(cur[node][0], cur[g[node].second.first][1]);\n    swap(cur[node][1], cur[g[node].second.first][0]);\n    return;\n  }\n  calc2(g[node].second.first);\n  calc2(g[node].second.second);\n  int cur1 = res[g[node].second.first];\n  int cur2 = res[g[node].second.second];\n  if (g[node].first == 'X') {\n    if (cur1 == 0) {\n      to[g[node].second.second][0] = 0;\n      to[g[node].second.second][1] = 1;\n    } else {\n      to[g[node].second.second][0] = 1;\n      to[g[node].second.second][1] = 0;\n    }\n    if (cur2 == 0) {\n      to[g[node].second.first][0] = 0;\n      to[g[node].second.first][1] = 1;\n    } else {\n      to[g[node].second.first][0] = 1;\n      to[g[node].second.first][1] = 0;\n    }\n  } else if (g[node].first == 'O') {\n    if (cur1 == 0) {\n      to[g[node].second.second][0] = 0;\n      to[g[node].second.second][1] = 1;\n    } else {\n      to[g[node].second.second][0] = 1;\n      to[g[node].second.second][1] = 1;\n    }\n    if (cur2 == 0) {\n      to[g[node].second.first][0] = 0;\n      to[g[node].second.first][1] = 1;\n    } else {\n      to[g[node].second.first][0] = 1;\n      to[g[node].second.first][1] = 1;\n    }\n  } else {\n    if (cur1 == 0) {\n      to[g[node].second.second][0] = 0;\n      to[g[node].second.second][1] = 0;\n    } else {\n      to[g[node].second.second][0] = 0;\n      to[g[node].second.second][1] = 1;\n    }\n    if (cur2 == 0) {\n      to[g[node].second.first][0] = 0;\n      to[g[node].second.first][1] = 0;\n    } else {\n      to[g[node].second.first][0] = 0;\n      to[g[node].second.first][1] = 1;\n    }\n  }\n  v[node][to[g[node].second.first][0]].push_back(\n      make_pair(g[node].second.first, 0));\n  v[node][to[g[node].second.first][1]].push_back(\n      make_pair(g[node].second.first, 1));\n  v[node][to[g[node].second.second][0]].push_back(\n      make_pair(g[node].second.second, 0));\n  v[node][to[g[node].second.second][1]].push_back(\n      make_pair(g[node].second.second, 1));\n  for (int i = 0; i < 2; i++) {\n    int mx = 0, idx = -1;\n    for (int j = 0; j < (int)v[node][i].size(); j++) {\n      if ((int)cur[v[node][i][j].first][v[node][i][j].second].size() >= mx) {\n        mx = cur[v[node][i][j].first][v[node][i][j].second].size();\n        idx = j;\n      }\n    }\n    if (idx == -1) continue;\n    swap(cur[node][i], cur[v[node][i][idx].first][v[node][i][idx].second]);\n    for (int j = 0; j < (int)v[node][i].size(); j++) {\n      if (j == idx) continue;\n      addto(cur[node][i], cur[v[node][i][j].first][v[node][i][j].second]);\n    }\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", tmpread);\n    g[i].first = tmpread[0];\n    if (tmpread[0] == 'I' || tmpread[0] == 'N')\n      scanf(\"%d\", &g[i].second.first);\n    else\n      scanf(\"%d%d\", &g[i].second.first, &g[i].second.second);\n  }\n  calc(1);\n  calc2(1);\n  memset(ans, -1, sizeof(ans));\n  for (int i = 0; i < cur[1][1].size(); i++) {\n    ans[cur[1][1][i]] = 1;\n  }\n  for (int i = 0; i < cur[1][0].size(); i++) {\n    ans[cur[1][0][i]] = 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (ans[i] != -1) printf(\"%d\", ans[i]);\n  }\n  puts(\"\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nlong long mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nlong long llmax = 9223372036854775807;\nlong long llmin = -9223372036854775807;\nint iinf = intmax / 8;\nlong long inf = llmax / 8;\ndouble eps = 1e-11;\nvector<int> g[1000010];\nint main() {\n  int N;\n  cin >> N;\n  int mark[N];\n  int child[N][2];\n  int data[N];\n  fill(data, data + N, -1);\n  for (int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    int x, y;\n    if (s == \"AND\") {\n      mark[i] = 0;\n    } else if (s == \"OR\") {\n      mark[i] = 1;\n    } else if (s == \"XOR\") {\n      mark[i] = 2;\n    } else if (s == \"NOT\") {\n      mark[i] = 3;\n    } else {\n      mark[i] = 4;\n    }\n    if (mark[i] <= 2) {\n      cin >> x >> y;\n      child[i][0] = x - 1;\n      child[i][1] = y - 1;\n    } else if (mark[i] == 3) {\n      cin >> x;\n      child[i][0] = x - 1;\n      child[i][1] = -1;\n    } else {\n      cin >> x;\n      data[i] = x;\n      child[i][0] = -1;\n      child[i][1] = -1;\n    }\n  }\n  int rank[N];\n  queue<int> que;\n  rank[0] = 0;\n  que.push(0);\n  g[0].push_back(0);\n  int maxrank = 0;\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    int v1 = child[v][0];\n    int v2 = child[v][1];\n    if (v1 != -1) {\n      rank[v1] = rank[v] + 1;\n      if (rank[v1] > maxrank) {\n        maxrank = rank[v1];\n      }\n      que.push(v1);\n      g[rank[v1]].push_back(v1);\n    }\n    if (v2 != -1) {\n      rank[v2] = rank[v] + 1;\n      que.push(v2);\n      g[rank[v2]].push_back(v2);\n    }\n  }\n  for (int i = maxrank - 1; i >= 0; i--) {\n    int len = g[i].size();\n    for (int j = 0; j < len; j++) {\n      int v = g[i][j];\n      int mk = mark[v];\n      int v1 = child[v][0];\n      int v2 = child[v][1];\n      if (mk == 0) {\n        data[v] = data[v1] & data[v2];\n      } else if (mk == 1) {\n        data[v] = data[v1] | data[v2];\n      } else if (mk == 2) {\n        data[v] = data[v1] ^ data[v2];\n      } else if (mk == 3) {\n        data[v] = (data[v1] + 1) % 2;\n      }\n    }\n  }\n  bool change[N];\n  change[0] = true;\n  for (int i = 0; i <= maxrank; i++) {\n    int len = g[i].size();\n    for (int j = 0; j < len; j++) {\n      int v = g[i][j];\n      int mk = mark[v];\n      int v1 = child[v][0];\n      int v2 = child[v][1];\n      if (change[v]) {\n        if (mk == 0) {\n          if (data[v1] == 1) {\n            change[v2] = true;\n          } else {\n            change[v2] = false;\n          }\n          if (data[v2] == 1) {\n            change[v1] = true;\n          } else {\n            change[v1] = false;\n          }\n        } else if (mk == 1) {\n          if (data[v1] == 0) {\n            change[v2] = true;\n          } else {\n            change[v2] = false;\n          }\n          if (data[v2] == 0) {\n            change[v1] = true;\n          } else {\n            change[v1] = false;\n          }\n        } else if (mk == 2) {\n          change[v1] = true;\n          change[v2] = true;\n        } else if (mk == 3) {\n          change[v1] = true;\n        }\n      } else {\n        if (mk <= 2) {\n          change[v1] = false;\n          change[v2] = false;\n        } else if (mk == 3) {\n          change[v1] = false;\n        }\n      }\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    if (mark[i] == 4) {\n      if (change[i]) {\n        cout << (data[0] + 1) % 2;\n      } else {\n        cout << data[0];\n      }\n    }\n  }\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint n, v[1000006], a[1000006], c[1000006][2], f[1000006];\nbool ori[1000006], mdf[1000006][2];\ninline bool cal(int d, bool a, bool b) {\n  if (d > 2) return a & b;\n  if (d > 1) return a | b;\n  return d ? a ^ b : !a;\n}\nvoid dfs(int x) {\n  if (c[x][0]) {\n    f[c[x][0]] = f[c[x][1]] = x;\n    dfs(c[x][0]);\n    if (v[x]) dfs(c[x][1]);\n    ori[x] = cal(v[x], ori[c[x][0]], ori[c[x][1]]);\n  } else\n    ori[x] = a[x];\n}\nvoid dfss(int x) {\n  if (!x) return;\n  if (x == 1)\n    mdf[x][1] = 1;\n  else {\n    for (int i = 0; i < 2; i++)\n      mdf[x][i] = mdf[f[x]][cal(v[f[x]], i, ori[c[f[x]][c[f[x]][0] == x]])];\n  }\n  dfss(c[x][0]), dfss(c[x][1]);\n}\nchar op[6];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", op);\n    v[i] = op[0] ^ 'A' ? op[0] ^ 'O' ? op[0] ^ 'X' ? 0 : 1 : 2 : 3;\n    if (op[0] == 'I')\n      scanf(\"%d\", a + i);\n    else\n      scanf(\"%d\", c[i]);\n    if (v[i]) scanf(\"%d\", c[i] + 1);\n  }\n  dfs(1);\n  dfss(1);\n  for (int i = 1; i <= n; i++)\n    if (!c[i][0]) printf(\"%d\", mdf[i][a[i] ^ 1]);\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1000011;\nstruct node {\n  int tp;\n  int son[2];\n};\nint n, i, x, y, cnt;\nchar s[11];\nnode data[maxN];\nvector<int> stor[maxN * 4];\nint id[maxN][2], here[maxN];\nint ans[maxN];\nint Merge(int id1, int id2) {\n  if (stor[id1].size() < stor[id2].size()) swap(id1, id2);\n  for (auto e : stor[id2]) stor[id1].push_back(e);\n  stor[id2].clear();\n  return id1;\n}\nvoid solve(int node) {\n  int s0, s1, tmp;\n  s0 = data[node].son[0];\n  s1 = data[node].son[1];\n  id[node][0] = ++cnt;\n  id[node][1] = ++cnt;\n  if (data[node].tp == 4) {\n    here[node] = s0;\n    stor[id[node][1 ^ s0]].push_back(node);\n    return;\n  }\n  if (data[node].tp == 3) {\n    solve(s0);\n    id[node][0] = id[s0][1];\n    id[node][1] = id[s0][0];\n    here[node] = here[s0] ^ 1;\n    return;\n  }\n  solve(s0);\n  solve(s1);\n  if (data[node].tp == 2) {\n    for (tmp = 0; tmp < 2; tmp++) {\n      id[node][0 ^ here[s1]] = Merge(id[node][0 ^ here[s1]], id[s0][0]);\n      id[node][1 ^ here[s1]] = Merge(id[node][1 ^ here[s1]], id[s0][1]);\n      swap(s0, s1);\n    }\n    here[node] = (here[s0] ^ here[s1]);\n    return;\n  }\n  if (data[node].tp == 1) {\n    for (tmp = 0; tmp < 2; tmp++) {\n      id[node][0 | here[s1]] = Merge(id[node][0 | here[s1]], id[s0][0]);\n      id[node][1 | here[s1]] = Merge(id[node][1 | here[s1]], id[s0][1]);\n      swap(s0, s1);\n    }\n    here[node] = (here[s0] | here[s1]);\n    return;\n  }\n  if (data[node].tp == 0) {\n    for (tmp = 0; tmp < 2; tmp++) {\n      id[node][0 & here[s1]] = Merge(id[node][0 & here[s1]], id[s0][0]);\n      id[node][1 & here[s1]] = Merge(id[node][1 & here[s1]], id[s0][1]);\n      swap(s0, s1);\n    }\n    here[node] = (here[s0] & here[s1]);\n    return;\n  }\n}\nint main() {\n  scanf(\"%d\\n\", &n);\n  for (i = 1; i <= n; i++) {\n    scanf(\"%s%d\", s + 1, &x);\n    if (s[1] == 'A') data[i].tp = 0;\n    if (s[1] == 'O') data[i].tp = 1;\n    if (s[1] == 'X') data[i].tp = 2;\n    if (s[1] == 'N') data[i].tp = 3;\n    if (s[1] == 'I') data[i].tp = 4;\n    data[i].son[0] = x;\n    if (data[i].tp <= 2) scanf(\"%d\", &data[i].son[1]);\n    scanf(\"\\n\");\n  }\n  solve(1);\n  for (auto e : stor[id[1][1]]) ans[e] = 1;\n  for (i = 1; i <= n; i++)\n    if (data[i].tp == 4) printf(\"%d\", ans[i]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e6 + 1;\nconst int INF = 1e9 + 9;\nconst int B = 1e9 + 7;\nint n;\nvector<long long> g[N];\nint val[N], tp[N], def[N];\nvector<pair<int, int> > ans;\nvoid build(int x) {\n  if (tp[x] == 4) {\n    def[x] = val[x];\n    return;\n  }\n  for (auto to : g[x]) build(to);\n  if (tp[x] == 0) def[x] = (def[g[x][0]] & def[g[x][1]]);\n  if (tp[x] == 1) def[x] = (def[g[x][0]] | def[g[x][1]]);\n  if (tp[x] == 2) def[x] = (def[g[x][0]] ^ def[g[x][1]]);\n  if (tp[x] == 3) def[x] = (!def[g[x][0]]);\n}\nvoid dfs(int x, int xo, int found) {\n  if (tp[x] == 4) {\n    int b = found == -1 ? (val[x] ^ 1) : found;\n    ans.push_back({x, b ^ xo});\n    return;\n  }\n  if (tp[x] == 0) {\n    if (found == -1) {\n      dfs(g[x][0], xo, def[g[x][1]] == 0 ? 0 : found);\n      dfs(g[x][1], xo, def[g[x][0]] == 0 ? 0 : found);\n    } else {\n      dfs(g[x][0], xo, found);\n      dfs(g[x][1], xo, found);\n    }\n  }\n  if (tp[x] == 1) {\n    if (found == -1) {\n      dfs(g[x][0], xo, def[g[x][1]] == 1 ? 1 : found);\n      dfs(g[x][1], xo, def[g[x][0]] == 1 ? 1 : found);\n    } else {\n      dfs(g[x][0], xo, found);\n      dfs(g[x][1], xo, found);\n    }\n  }\n  if (tp[x] == 2) {\n    if (found == -1) {\n      dfs(g[x][0], xo ^ def[g[x][1]], found);\n      dfs(g[x][1], xo ^ def[g[x][0]], found);\n    } else {\n      dfs(g[x][0], xo, found);\n      dfs(g[x][1], xo, found);\n    }\n  }\n  if (tp[x] == 3)\n    if (found == -1) {\n      dfs(g[x][0], xo ^ 1, found);\n    } else {\n      dfs(g[x][0], xo, found);\n    }\n}\nint main() {\n  ios_base ::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  map<char, int> mp;\n  mp['A'] = 0;\n  mp['O'] = 1;\n  mp['X'] = 2;\n  mp['N'] = 3;\n  mp['I'] = 4;\n  for (int i = int(1); i <= int(n); ++i) {\n    string s;\n    int a, b;\n    cin >> s >> a;\n    tp[i] = mp[s[0]];\n    if (tp[i] == 4) {\n      val[i] = a;\n      continue;\n    }\n    g[i].push_back(a);\n    if (tp[i] <= 2) {\n      cin >> b;\n      g[i].push_back(b);\n    }\n  }\n  build(1);\n  dfs(1, 0, -1);\n  sort(ans.begin(), ans.end());\n  for (auto p : ans) cout << p.second;\n  cout << \"\\n\";\n  return 0;\n}\n"], "original_code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxm = 1000005;\nvector<int> v[maxm];\nint a[maxm], val[maxm], ans[maxm];\nchar str[maxm];\nvoid dfs_1(int k) {\n  for (int i = 0; i < v[k].size(); i++) dfs_1(v[k][i]);\n  if (a[k] == 1)\n    val[k] = val[v[k][0]] & val[v[k][1]];\n  else if (a[k] == 2)\n    val[k] = val[v[k][0]] | val[v[k][1]];\n  else if (a[k] == 3)\n    val[k] = val[v[k][0]] ^ val[v[k][1]];\n  else if (a[k] == 4)\n    val[k] = val[v[k][0]] ^ 1;\n}\nvoid dfs_2(int k, int flag) {\n  if (a[k] == 5)\n    ans[k] = val[1] ^ flag;\n  else if (a[k] == 1) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 0 && val[y] == 0 || val[x] == 1 && val[y] == 0)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 0 && val[y] == 0 || val[x] == 0 && val[y] == 1)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 2) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 1 && val[y] == 1 || val[x] == 0 && val[y] == 1)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 1 && val[y] == 1 || val[x] == 1 && val[y] == 0)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 3) {\n    int x = v[k][0], y = v[k][1];\n    dfs_2(x, min(flag, 1));\n    dfs_2(y, min(flag, 1));\n  } else\n    dfs_2(v[k][0], min(flag, 1));\n}\nint main() {\n  int n, i, j, k, sum, x, y;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    ans[i] = -1;\n    scanf(\"%s\", str);\n    if (str[0] == 'I') {\n      scanf(\"%d\", &k);\n      val[i] = k, a[i] = 5;\n    } else if (str[0] == 'N') {\n      scanf(\"%d\", &k);\n      v[i].push_back(k), a[i] = 4;\n    } else if (str[0] == 'A') {\n      scanf(\"%d%d\", &x, &y), a[i] = 1;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'O') {\n      scanf(\"%d%d\", &x, &y), a[i] = 2;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'X') {\n      scanf(\"%d%d\", &x, &y), a[i] = 3;\n      v[i].push_back(x), v[i].push_back(y);\n    }\n  }\n  dfs_1(1);\n  dfs_2(1, 1);\n  for (i = 1; i <= n; i++)\n    if (ans[i] != -1) printf(\"%d\", ans[i]);\n  printf(\"\\n\");\n}\n", "language": "cpp"}, "status": "success", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxm = 1000005;\nvector<int> v[maxm];\nint a[maxm], val[maxm], ans[maxm];\nchar str[maxm];\nvoid dfs_1(int k) {\n  for (int i = 0; i < v[k].size(); i++) dfs_1(v[k][i]);\n  if (a[k] == 1)\n    val[k] = val[v[k][0]] & val[v[k][1]];\n  else if (a[k] == 2)\n    val[k] = val[v[k][0]] | val[v[k][1]];\n  else if (a[k] == 3)\n    val[k] = val[v[k][0]] ^ val[v[k][1]];\n  else if (a[k] == 4)\n    val[k] = val[v[k][0]] ^ 1;\n}\nvoid dfs_2(int k, int flag) {\n  if (a[k] == 5)\n    ans[k] = val[1] ^ flag;\n  else if (a[k] == 1) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 0 && val[y] == 0 || val[x] == 1 && val[y] == 0)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 0 && val[y] == 0 || val[x] == 0 && val[y] == 1)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 2) {\n    int x = v[k][0], y = v[k][1];\n    if (val[x] == 1 && val[y] == 1 || val[x] == 0 && val[y] == 1)\n      dfs_2(x, min(flag, 0));\n    else\n      dfs_2(x, min(flag, 1));\n    if (val[x] == 1 && val[y] == 1 || val[x] == 1 && val[y] == 0)\n      dfs_2(y, min(flag, 0));\n    else\n      dfs_2(y, min(flag, 1));\n  } else if (a[k] == 3) {\n    int x = v[k][0], y = v[k][1];\n    dfs_2(x, min(flag, 1));\n    dfs_2(y, min(flag, 1));\n  } else\n    dfs_2(v[k][0], min(flag, 1));\n}\nint main() {\n  int n, i, j, k, sum, x, y;\n  scanf(\"%d\", &n);\n  for (i = 1; i <= n; i++) {\n    ans[i] = -1;\n    scanf(\"%s\", str);\n    if (str[0] == 'I') {\n      scanf(\"%d\", &k);\n      val[i] = k, a[i] = 5;\n    } else if (str[0] == 'N') {\n      scanf(\"%d\", &k);\n      v[i].push_back(k), a[i] = 4;\n    } else if (str[0] == 'A') {\n      scanf(\"%d%d\", &x, &y), a[i] = 1;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'O') {\n      scanf(\"%d%d\", &x, &y), a[i] = 2;\n      v[i].push_back(x), v[i].push_back(y);\n    } else if (str[0] == 'X') {\n      scanf(\"%d%d\", &x, &y), a[i] = 3;\n      v[i].push_back(x), v[i].push_back(y);\n    }\n  }\n  dfs_1(1);\n  dfs_2(1, 1);\n  for (i = 1; i <= n; i++)\n    if (ans[i] != -1) printf(\"%d\", ans[i]);\n  printf(\"\\n\");\n}\n", "pass_ratio": 1.0, "tests_passed": 1, "tests_total": 1, "iterations": 1, "history": [], "model_type": "human", "model_name": "human"}, {"problem": {"problem_id": 680, "question": "Natasha travels around Mars in the Mars rover. But suddenly it broke down, namely \u2014 the logical scheme inside it. The scheme is an undirected tree (connected acyclic graph) with a root in the vertex 1, in which every leaf (excluding root) is an input, and all other vertices are logical elements, including the root, which is output. One bit is fed to each input. One bit is returned at the output.\n\nThere are four types of logical elements: [AND](https://en.wikipedia.org/wiki/Logical_conjunction) (2 inputs), [OR](https://en.wikipedia.org/wiki/Logical_disjunction) (2 inputs), [XOR](https://en.wikipedia.org/wiki/Exclusive_or) (2 inputs), [NOT](https://en.wikipedia.org/wiki/Negation) (1 input). Logical elements take values from their direct descendants (inputs) and return the result of the function they perform. Natasha knows the logical scheme of the Mars rover, as well as the fact that only one input is broken. In order to fix the Mars rover, she needs to change the value on this input.\n\nFor each input, determine what the output will be if Natasha changes this input.\n\nInput\n\nThe first line contains a single integer n (2 \u2264 n \u2264 10^6) \u2014 the number of vertices in the graph (both inputs and elements).\n\nThe i-th of the next n lines contains a description of i-th vertex: the first word \"AND\", \"OR\", \"XOR\", \"NOT\" or \"IN\" (means the input of the scheme) is the vertex type. If this vertex is \"IN\", then the value of this input follows (0 or 1), otherwise follow the indices of input vertices of this element: \"AND\", \"OR\", \"XOR\" have 2 inputs, whereas \"NOT\" has 1 input. The vertices are numbered from one.\n\nIt is guaranteed that input data contains a correct logical scheme with an output produced by the vertex 1.\n\nOutput\n\nPrint a string of characters '0' and '1' (without quotes) \u2014 answers to the problem for each input in the ascending order of their vertex indices.\n\nExample\n\nInput\n\n10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n\n\nOutput\n\n10110\n\nNote\n\nThe original scheme from the example (before the input is changed):\n\n<image>\n\nGreen indicates bits '1', yellow indicates bits '0'.\n\nIf Natasha changes the input bit 2 to 0, then the output will be 1.\n\nIf Natasha changes the input bit 3 to 0, then the output will be 0.\n\nIf Natasha changes the input bit 6 to 1, then the output will be 1.\n\nIf Natasha changes the input bit 8 to 0, then the output will be 1.\n\nIf Natasha changes the input bit 9 to 0, then the output will be 0.", "tests": [{"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "10110\n"}, {"stdin": "3\nAND 2 3\nIN 1\nIN 0\n", "stdout": "01\n"}, {"stdin": "3\nOR 2 3\nIN 1\nIN 1\n", "stdout": "11\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111\n"}, {"stdin": "3\nOR 2 3\nIN 0\nIN 1\n", "stdout": "10\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 1\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 0\nAND 13 39\n", "stdout": "000000000000000000000000011\n"}, {"stdin": "3\nOR 2 3\nIN 1\nIN 0\n", "stdout": "01\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "2\nNOT 2\nIN 1\n", "stdout": "1\n"}, {"stdin": "3\nXOR 2 3\nIN 1\nIN 0\n", "stdout": "00\n"}, {"stdin": "3\nAND 2 3\nIN 0\nIN 1\n", "stdout": "10\n"}, {"stdin": "3\nAND 2 3\nIN 1\nIN 1\n", "stdout": "00\n"}, {"stdin": "2\nNOT 2\nIN 0\n", "stdout": "0\n"}, {"stdin": "30\nXOR 4 11\nXOR 6 25\nNOT 29\nNOT 9\nNOT 17\nNOT 26\nNOT 30\nNOT 27\nNOT 14\nIN 1\nNOT 5\nNOT 15\nNOT 22\nIN 0\nNOT 24\nIN 1\nNOT 3\nNOT 19\nNOT 8\nNOT 16\nNOT 23\nNOT 28\nNOT 7\nNOT 2\nNOT 10\nNOT 13\nNOT 12\nNOT 20\nNOT 21\nNOT 18\n", "stdout": "000\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 0\n", "stdout": "01011\n"}, {"stdin": "3\nXOR 2 3\nIN 0\nIN 1\n", "stdout": "00\n"}, {"stdin": "3\nOR 2 3\nIN 0\nIN 0\n", "stdout": "11\n"}, {"stdin": "3\nAND 2 3\nIN 0\nIN 0\n", "stdout": "00\n"}, {"stdin": "3\nXOR 2 3\nIN 1\nIN 1\n", "stdout": "11\n"}, {"stdin": "3\nXOR 2 3\nIN 0\nIN 0\n", "stdout": "11\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111111111111111\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 1\n", "stdout": "01010\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 1\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 0\n", "stdout": "00111\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 0\nAND 2 8\n", "stdout": "00000\n"}, {"stdin": "9\nAND 2 3\nIN 0\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 0\nIN 1\n", "stdout": "10000\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 0\nOR 24 17\n", "stdout": "0110111111111111111\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 0\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "00100\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 0\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1000110010010000011\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 1\nIN 0\n", "stdout": "01001\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 1\nAND 6 7\nIN 1\nOR 8 9\nIN 1\nIN 0\n", "stdout": "01111\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11110111\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 1\nNOT 10\nIN 1\nIN 0\nAND 2 8\n", "stdout": "00001\n"}, {"stdin": "60\nAND 20 4\nNOT 42\nAND 48 59\nOR 17 7\nIN 0\nAND 36 37\nIN 1\nIN 0\nIN 1\nNOT 47\nAND 52 49\nOR 44 35\nIN 0\nIN 1\nAND 33 56\nIN 0\nIN 0\nIN 0\nAND 31 41\nOR 15 3\nOR 43 46\nIN 1\nXOR 22 28\nIN 1\nIN 1\nIN 1\nAND 34 21\nIN 1\nIN 1\nIN 0\nXOR 51 23\nXOR 10 54\nOR 57 40\nIN 0\nNOT 18\nNOT 25\nIN 1\nAND 5 50\nIN 0\nAND 60 53\nAND 45 8\nIN 0\nIN 1\nNOT 27\nIN 0\nIN 1\nAND 19 2\nOR 29 32\nAND 58 24\nNOT 16\nXOR 55 11\nIN 0\nNOT 30\nAND 12 38\nAND 14 9\nIN 1\nIN 0\nOR 26 6\nIN 1\nAND 13 39\n", "stdout": "101111111111111111111111110\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 0\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111011111111111\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 1\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11011010\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 0\nXOR 6 5\nAND 3 7\nIN 1\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "11010\n"}, {"stdin": "9\nAND 2 3\nIN 1\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 1\nIN 1\n", "stdout": "01011\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 1\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0001001000000000010\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 1\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 0\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 0\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1101001101101010110\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 1\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 1\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111111111\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 0\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 1\nAND 2 8\n", "stdout": "01100\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "40\nOR 9 2\nAND 30 31\nIN 1\nIN 1\nIN 0\nOR 25 21\nIN 1\nXOR 20 10\nAND 24 34\nIN 0\nIN 0\nNOT 16\nAND 14 4\nIN 0\nAND 18 27\nIN 1\nAND 15 22\nOR 26 12\nIN 0\nAND 36 3\nXOR 11 38\nIN 1\nIN 1\nNOT 29\nIN 0\nXOR 32 13\nIN 1\nIN 0\nNOT 8\nIN 1\nXOR 37 39\nXOR 7 23\nIN 1\nXOR 33 5\nIN 0\nOR 40 28\nIN 1\nIN 0\nAND 35 17\nXOR 6 19\n", "stdout": "1111111111111101101\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 1\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111111111111111\n"}, {"stdin": "10\nAND 9 4\nIN 1\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 0\nIN 1\nAND 2 8\n", "stdout": "10000\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 0\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 0\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 1\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11110111\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 1\nNOT 10\nIN 1\nIN 0\nAND 2 8\n", "stdout": "00000\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 1\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "10\nAND 9 4\nIN 0\nIN 1\nXOR 6 5\nAND 3 7\nIN 0\nNOT 10\nIN 1\nIN 0\nAND 2 8\n", "stdout": "00001\n"}, {"stdin": "9\nAND 2 3\nIN 0\nOR 4 5\nIN 0\nAND 6 7\nIN 1\nOR 8 9\nIN 1\nIN 0\n", "stdout": "10000\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 0\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 0\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 1\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 1\nOR 24 17\n", "stdout": "0110111111111111111\n"}, {"stdin": "20\nOR 17 10\nIN 0\nIN 1\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 1\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "50\nNOT 37\nOR 23 10\nIN 1\nAND 28 48\nIN 0\nIN 0\nIN 1\nAND 39 21\nNOT 6\nNOT 40\nAND 18 36\nIN 0\nIN 1\nOR 33 43\nNOT 27\nNOT 25\nNOT 35\nXOR 16 34\nNOT 22\nIN 1\nAND 4 13\nNOT 46\nIN 1\nNOT 3\nOR 5 49\nXOR 30 15\nOR 41 31\nIN 0\nIN 0\nOR 8 38\nIN 1\nAND 7 20\nNOT 11\nIN 1\nXOR 2 32\nXOR 29 9\nAND 50 44\nIN 1\nIN 0\nOR 42 47\nIN 0\nNOT 14\nIN 1\nNOT 19\nIN 1\nIN 0\nNOT 26\nOR 45 12\nIN 0\nOR 24 17\n", "stdout": "0001001000000000010\n"}, {"stdin": "20\nOR 17 10\nIN 1\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 0\nNOT 8\nNOT 12\nIN 1\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}, {"stdin": "20\nOR 17 10\nIN 1\nIN 0\nNOT 6\nOR 18 14\nIN 1\nOR 16 3\nXOR 5 4\nIN 1\nXOR 11 9\nNOT 15\nAND 20 19\nIN 0\nIN 0\nIN 0\nNOT 8\nNOT 12\nIN 0\nAND 13 7\nNOT 2\n", "stdout": "11111111\n"}], "source": "codeforces", "difficulty": 2000, "human_solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst long long INF = 0x3f3f3f3f3f3f3f3f;\nconst long long mod = (int)1e9 + 7;\nconst int N = 1e6 + 100;\nint n;\nint op[N];\nint ok[N];\nint val[N];\nint ans[2];\nchar s[10];\nvector<int> son[N];\nvoid dfs(int u) {\n  if (op[u] == 4) return;\n  for (int i = 0; i < son[u].size(); i++) dfs(son[u][i]);\n  int x = son[u][0];\n  if (op[u] == 3) {\n    val[u] = 1 ^ val[x];\n    ok[x] = 1;\n  }\n  int y = son[u][1];\n  if (op[u] == 1) {\n    val[u] = val[x] & val[y];\n    if (val[y] == 1) ok[x] = 1;\n    if (val[x] == 1) ok[y] = 1;\n  } else if (op[u] == 2) {\n    val[u] = val[x] ^ val[y];\n    ok[x] = ok[y] = 1;\n  } else if (op[u] == 5) {\n    val[u] = val[x] | val[y];\n    if (val[x] == 1 && val[y] == 0) ok[x] = 1;\n    if (val[x] == 0 && val[y] == 1) ok[y] = 1;\n    if (val[x] == 0 && val[y] == 0) ok[x] = ok[y] = 1;\n  }\n}\nvoid dfs2(int u, int flag) {\n  ok[u] &= flag;\n  for (int i = 0; i < son[u].size(); i++) dfs2(son[u][i], ok[u]);\n}\nint main() {\n  scanf(\"%d\", &n);\n  int u, v;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", s + 1);\n    if (s[1] == 'I')\n      op[i] = 4, scanf(\"%d\", &val[i]);\n    else if (s[1] == 'N') {\n      scanf(\"%d\", &u);\n      son[i].push_back(u);\n      op[i] = 3;\n    } else {\n      scanf(\"%d%d\", &u, &v);\n      son[i].push_back(u);\n      son[i].push_back(v);\n      if (s[1] == 'A') op[i] = 1;\n      if (s[1] == 'X') op[i] = 2;\n      if (s[1] == 'O') op[i] = 5;\n    }\n  }\n  dfs(1);\n  ok[1] = 1;\n  dfs2(1, 1);\n  ans[0] = val[1];\n  ans[1] = val[1] ^ 1;\n  for (int i = 1; i <= n; i++)\n    if (op[i] == 4) printf(\"%d\", ans[ok[i]]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nvector<bool> used;\nvector<vector<int> > g;\nvector<int> type;\nvector<int> val;\nint ans = 0;\nvoid dfs1(int v) {\n  for (int i = 0; i < g[v].size(); i++) {\n    dfs1(g[v][i]);\n  }\n  if (type[v] == 0) {\n    val[v] = val[g[v][0]] | val[g[v][1]];\n  } else if (type[v] == 1) {\n    val[v] = val[g[v][0]] ^ val[g[v][1]];\n  } else if (type[v] == 2) {\n    val[v] = val[g[v][0]] & val[g[v][1]];\n  } else if (type[v] == 3) {\n    val[v] = 1 - val[g[v][0]];\n  }\n}\nvoid dfs2(int v) {\n  used[v] = true;\n  if (type[v] == 0) {\n    if (val[g[v][0]] == 0) {\n      dfs2(g[v][1]);\n    }\n    if (val[g[v][1]] == 0) {\n      dfs2(g[v][0]);\n    }\n  } else if (type[v] == 1) {\n    dfs2(g[v][0]);\n    dfs2(g[v][1]);\n  } else if (type[v] == 2) {\n    if (val[g[v][0]] == 1) {\n      dfs2(g[v][1]);\n    }\n    if (val[g[v][1]] == 1) {\n      dfs2(g[v][0]);\n    }\n  } else if (type[v] == 3) {\n    dfs2(g[v][0]);\n  }\n}\nsigned main() {\n  int n;\n  cin >> n;\n  used.resize(n);\n  g.resize(n);\n  type.resize(n);\n  val.resize(n);\n  vector<int> ver;\n  for (int i = 0; i < n; i++) {\n    string t;\n    int a, b;\n    cin >> t;\n    if (t == \"OR\") {\n      cin >> a >> b;\n      type[i] = 0;\n      a--;\n      b--;\n      g[i].push_back(a);\n      g[i].push_back(b);\n    } else if (t == \"XOR\") {\n      cin >> a >> b;\n      a--;\n      b--;\n      type[i] = 1;\n      g[i].push_back(a);\n      g[i].push_back(b);\n    } else if (t == \"AND\") {\n      cin >> a >> b;\n      a--;\n      b--;\n      type[i] = 2;\n      g[i].push_back(a);\n      g[i].push_back(b);\n    } else if (t == \"NOT\") {\n      cin >> a;\n      a--;\n      type[i] = 3;\n      g[i].push_back(a);\n    } else {\n      type[i] = 4;\n      ver.push_back(i);\n      cin >> val[i];\n    }\n  }\n  dfs1(0);\n  dfs2(0);\n  ans = val[0];\n  for (int i = 0; i < ver.size(); i++) {\n    if (!used[ver[i]]) {\n      cout << ans;\n    } else {\n      cout << 1 - ans;\n    }\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> g;\nvector<char> t;\nvector<bool> b, d;\nbool calc(int v) {\n  if (t[v] == 'A') return b[v] = calc(g[v][0]) & calc(g[v][1]);\n  if (t[v] == 'O') return b[v] = calc(g[v][0]) | calc(g[v][1]);\n  if (t[v] == 'X') return b[v] = calc(g[v][0]) ^ calc(g[v][1]);\n  if (t[v] == 'N') return b[v] = !calc(g[v][0]);\n  return b[v];\n}\nvoid dfs(int v) {\n  if (t[v] == 'A') {\n    d[g[v][0]] = d[g[v][1]] = d[v];\n    if (!b[g[v][1]]) d[g[v][0]] = false;\n    if (!b[g[v][0]]) d[g[v][1]] = false;\n  } else if (t[v] == 'O') {\n    d[g[v][0]] = d[g[v][1]] = d[v];\n    if (b[g[v][1]]) d[g[v][0]] = false;\n    if (b[g[v][0]]) d[g[v][1]] = false;\n  } else if (t[v] == 'X')\n    d[g[v][0]] = d[g[v][1]] = d[v];\n  else if (t[v] == 'N')\n    d[g[v][0]] = d[v];\n  for (int i = 0; i < g[v].size(); ++i) dfs(g[v][i]);\n}\nint main() {\n  int n, a;\n  scanf(\"%d\", &n);\n  g.resize(n);\n  t.resize(n);\n  b.resize(n);\n  d.resize(n);\n  for (int i = 0; i < n; ++i) {\n    char s[4];\n    scanf(\"%s\", s);\n    t[i] = s[0];\n    if (t[i] == 'I') {\n      scanf(\"%d\", &a);\n      b[i] = a;\n    } else if (t[i] == 'N') {\n      scanf(\"%d\", &a);\n      g[i].push_back(a - 1);\n    } else {\n      scanf(\"%d\", &a);\n      g[i].push_back(a - 1);\n      scanf(\"%d\", &a);\n      g[i].push_back(a - 1);\n    }\n  }\n  calc(0);\n  d[0] = true;\n  dfs(0);\n  for (int i = 0; i < n; ++i)\n    if (t[i] == 'I') printf(\"%d\", b[0] ^ d[i]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint p[1000042];\nint l[1000042];\nint r[1000042];\nstring type[1000042];\nint val[1000042];\nbool changes[1000042];\nvoid ev(int i) {\n  if (type[i] == \"NOT\") {\n    ev(l[i]);\n    val[i] = 1 - val[l[i]];\n  }\n  if (type[i] == \"AND\") {\n    ev(l[i]);\n    ev(r[i]);\n    val[i] = val[l[i]] & val[r[i]];\n  }\n  if (type[i] == \"OR\") {\n    ev(l[i]);\n    ev(r[i]);\n    val[i] = val[l[i]] | val[r[i]];\n  }\n  if (type[i] == \"XOR\") {\n    ev(l[i]);\n    ev(r[i]);\n    val[i] = val[l[i]] ^ val[r[i]];\n  }\n}\nvoid ch(int i) {\n  if (!changes[p[i]]) {\n    changes[i] = false;\n  } else {\n    if (type[p[i]] == \"NOT\")\n      changes[i] = true;\n    else {\n      if (type[p[i]] == \"AND\") {\n        val[i] = 1 - val[i];\n        if (i == l[p[i]]) {\n          if (val[p[i]] != (val[i] & val[r[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        } else {\n          if (val[p[i]] != (val[i] & val[l[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        }\n        val[i] = 1 - val[i];\n      }\n      if (type[p[i]] == \"OR\") {\n        val[i] = 1 - val[i];\n        if (i == l[p[i]]) {\n          if (val[p[i]] != (val[i] || val[r[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        } else {\n          if (val[p[i]] != (val[i] || val[l[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        }\n        val[i] = 1 - val[i];\n      }\n      if (type[p[i]] == \"XOR\") {\n        val[i] = 1 - val[i];\n        if (i == l[p[i]]) {\n          if (val[p[i]] != (val[i] ^ val[r[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        } else {\n          if (val[p[i]] != (val[i] ^ val[l[p[i]]]))\n            changes[i] = true;\n          else\n            changes[i] = false;\n        }\n        val[i] = 1 - val[i];\n      }\n    }\n  }\n  if (type[i] != \"IN\") ch(l[i]);\n  if (type[i] != \"IN\" and type[i] != \"NOT\") ch(r[i]);\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    int x, y;\n    string act;\n    cin >> act;\n    type[i] = act;\n    if (act == \"IN\") {\n      cin >> val[i];\n    } else {\n      if (act == \"NOT\") {\n        cin >> x;\n        p[x] = i;\n        l[i] = x;\n      } else {\n        cin >> x >> y;\n        p[x] = i;\n        l[i] = x;\n        p[y] = i;\n        r[i] = y;\n      }\n    }\n  }\n  ev(1);\n  p[1] = 0;\n  changes[0] = true;\n  type[0] = \"NOT\";\n  ch(1);\n  string ans = \"\";\n  for (int i = 1; i <= n; i++) {\n    if (type[i] != \"IN\") continue;\n    if (changes[i])\n      ans += (val[1]) ? '0' : '1';\n    else\n      ans += (val[1]) ? '1' : '0';\n  }\n  cout << ans;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 7;\nint ch[N][2];\nchar t[N];\nbool val[N];\nbool calc(int u = 1) {\n  bool v1 = -1, v2 = -1, res;\n  if (ch[u][0]) v1 = calc(ch[u][0]);\n  if (ch[u][1]) v2 = calc(ch[u][1]);\n  switch (t[u]) {\n    case 'I':\n      res = val[u];\n      break;\n    case 'N':\n      res = !v1;\n      break;\n    case 'A':\n      res = v1 & v2;\n      break;\n    case 'X':\n      res = v1 ^ v2;\n      break;\n    case 'O':\n      res = v1 | v2;\n      break;\n  }\n  return val[u] = res;\n}\nbool changes[N];\nvoid dfs(int u = 1, bool c = true) {\n  changes[u] = c;\n  if (!c) {\n    if (ch[u][0]) dfs(ch[u][0], c);\n    if (ch[u][1]) dfs(ch[u][1], c);\n    return;\n  }\n  switch (t[u]) {\n    case 'N':\n      dfs(ch[u][0]);\n      break;\n    case 'O':\n      if (((val[ch[u][0]] ^ 1) | val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) | val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n    case 'A':\n      if (((val[ch[u][0]] ^ 1) & val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) & val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n    case 'X':\n      if (((val[ch[u][0]] ^ 1) ^ val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) ^ val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n  }\n}\nint main() {\n  char str[4];\n  int x;\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%s%d\", str, &x);\n    t[i] = str[0];\n    if (t[i] == 'I')\n      val[i] = x;\n    else {\n      ch[i][0] = x;\n      if (t[i] != 'N') {\n        scanf(\"%d\", &x);\n        ch[i][1] = x;\n      }\n    }\n  }\n  int val = calc();\n  changes[1] = true;\n  dfs();\n  for (int i = 1; i <= n; ++i)\n    if (t[i] == 'I') {\n      if (changes[i])\n        printf(\"%d\", val ^ 1);\n      else\n        printf(\"%d\", val);\n    }\n  printf(\"\\n\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000010;\nint n, fa[maxn], son[2][maxn], col[maxn], v[maxn], a[maxn], cnt;\nint st[maxn << 1], to[maxn << 1], nt[maxn << 1], topt;\nint dfn[maxn], line[maxn], sum[maxn], ss[maxn], dfn_num, si[maxn];\nbool ok[maxn];\nchar s[100];\nvoid add(int x, int y) {\n  to[++topt] = y;\n  nt[topt] = st[x];\n  st[x] = topt;\n}\nvoid dfs(int x) {\n  int p = st[x];\n  dfn[x] = ++dfn_num;\n  line[topt] = x;\n  si[x] = 1;\n  while (p) {\n    dfs(to[p]);\n    si[x] += si[to[p]];\n    p = nt[p];\n  }\n  if (col[x] == 1) v[x] = v[son[0][x]] && v[son[1][x]];\n  if (col[x] == 2) v[x] = v[son[0][x]] || v[son[1][x]];\n  if (col[x] == 3) v[x] = v[son[0][x]] ^ v[son[1][x]];\n  if (col[x] == 4) v[x] = !v[son[0][x]];\n}\nvoid fz(int x) {\n  ok[x] = 0;\n  int p = st[x];\n  while (p) {\n    fz(to[p]);\n    p = nt[p];\n  }\n}\nvoid work(int x) {\n  if (si[x] == 1 || !x) return;\n  if (col[x] == 1) {\n    bool fa = 0, fb = 0;\n    if (v[son[0][x]] == 0) fz(son[1][x]), fb = 1;\n    if (v[son[1][x]] == 0) fz(son[0][x]), fa = 1;\n    if (!fa) work(son[0][x]);\n    if (!fb) work(son[1][x]);\n  } else if (col[x] == 2) {\n    bool fa = 0, fb = 0;\n    if (v[son[0][x]] == 1) fz(son[1][x]), fb = 1;\n    if (v[son[1][x]] == 1) fz(son[0][x]), fa = 1;\n    if (!fa) work(son[0][x]);\n    if (!fb) work(son[1][x]);\n  } else {\n    work(son[0][x]);\n    work(son[1][x]);\n  }\n}\nint read() {\n  int xx = 0, ff = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') ff = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    xx = (xx << 1) + (xx << 3) + c - '0';\n    c = getchar();\n  }\n  return xx * ff;\n}\nint main() {\n  scanf(\"%d\", &n);\n  memset(ok, 1, sizeof ok);\n  register int i;\n  for (i = 1; i <= n; i++) {\n    scanf(\"%s\", s + 1);\n    if (s[1] == 'I') {\n      a[++cnt] = i;\n      v[i] = read();\n    } else if (s[1] == 'N') {\n      int x;\n      x = read();\n      son[0][i] = x;\n      fa[x] = i;\n      col[i] = 4;\n      add(i, x);\n    } else if (s[1] == 'A') {\n      int x, y;\n      x = read();\n      y = read();\n      son[0][i] = x;\n      son[1][i] = y;\n      fa[x] = i;\n      fa[y] = i;\n      col[i] = 1;\n      add(i, x);\n      add(i, y);\n    } else if (s[1] == 'O') {\n      int x, y;\n      x = read();\n      y = read();\n      son[0][i] = x;\n      son[1][i] = y;\n      fa[x] = i;\n      fa[y] = i;\n      col[i] = 2;\n      add(i, x);\n      add(i, y);\n    } else if (s[1] == 'X') {\n      int x, y;\n      x = read();\n      y = read();\n      son[0][i] = x;\n      son[1][i] = y;\n      fa[x] = i;\n      fa[y] = i;\n      col[i] = 3;\n      add(i, x);\n      add(i, y);\n    }\n  }\n  dfs(1);\n  work(1);\n  for (int i = 1; i <= cnt; i++)\n    if (!ok[a[i]])\n      printf(\"%d\", v[1]);\n    else\n      printf(\"%d\", !v[1]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nconst int maxn = 1e6 + 7;\nint n;\nbool st[maxn], cg[maxn];\nchar buf[10];\nstruct node {\n  int t, l, r;\n  void read() {\n    scanf(\"%s%d\", buf, &l);\n    switch (buf[0]) {\n      case 'I':\n        t = 0;\n        break;\n      case 'N':\n        t = 1;\n        break;\n      case 'A':\n        t = 2;\n        scanf(\"%d\", &r);\n        break;\n      case 'O':\n        t = 3;\n        scanf(\"%d\", &r);\n        break;\n      case 'X':\n        t = 4;\n        scanf(\"%d\", &r);\n        break;\n      default:\n        break;\n    }\n  }\n} np[maxn];\nvoid calcSt(int k) {\n  switch (np[k].t) {\n    case 0:\n      break;\n    case 1:\n      calcSt(np[k].l);\n      break;\n    case 2:\n      calcSt(np[k].l);\n      calcSt(np[k].r);\n      break;\n    case 3:\n      calcSt(np[k].l);\n      calcSt(np[k].r);\n      break;\n    case 4:\n      calcSt(np[k].l);\n      calcSt(np[k].r);\n      break;\n    default:\n      break;\n  }\n  switch (np[k].t) {\n    case 0:\n      st[k] = np[k].l;\n      break;\n    case 1:\n      st[k] = !st[np[k].l];\n      break;\n    case 2:\n      st[k] = st[np[k].l] && st[np[k].r];\n      break;\n    case 3:\n      st[k] = st[np[k].l] || st[np[k].r];\n      break;\n    case 4:\n      st[k] = st[np[k].l] ^ st[np[k].r];\n      break;\n    default:\n      break;\n  }\n}\nvoid checkCg(int k) {\n  if (!cg[k]) return;\n  switch (np[k].t) {\n    case 0:\n      break;\n    case 1:\n      cg[np[k].l] = cg[k];\n      checkCg(np[k].l);\n      break;\n    case 2:\n      if (st[k]) {\n        cg[np[k].l] = cg[k];\n        cg[np[k].r] = cg[k];\n        checkCg(np[k].l);\n        checkCg(np[k].r);\n      } else {\n        if (!st[np[k].l] && st[np[k].r]) {\n          cg[np[k].l] = cg[k];\n          checkCg(np[k].l);\n        }\n        if (!st[np[k].r] && st[np[k].l]) {\n          cg[np[k].r] = cg[k];\n          checkCg(np[k].r);\n        }\n      }\n      break;\n    case 3:\n      if (!st[k]) {\n        cg[np[k].l] = cg[k];\n        cg[np[k].r] = cg[k];\n        checkCg(np[k].l);\n        checkCg(np[k].r);\n      } else {\n        if (st[np[k].l] && !st[np[k].r]) {\n          cg[np[k].l] = cg[k];\n          checkCg(np[k].l);\n        }\n        if (st[np[k].r] && !st[np[k].l]) {\n          cg[np[k].r] = cg[k];\n          checkCg(np[k].r);\n        }\n      }\n      break;\n    case 4:\n      cg[np[k].l] = cg[k];\n      cg[np[k].r] = cg[k];\n      checkCg(np[k].l);\n      checkCg(np[k].r);\n      break;\n    default:\n      break;\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    np[i].read();\n  }\n  calcSt(1);\n  cg[1] = true;\n  checkCg(1);\n  for (int i = 1; i <= n; ++i)\n    if (np[i].t == 0) {\n      putchar((cg[i] ^ st[1]) ? '1' : '0');\n    }\n  putchar('\\n');\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nstring op[1000005];\nint a[2][1000005];\nbool c[1000005];\nbool p[2][1000005];\nbool cal(int i) {\n  if (op[i] == \"IN\") {\n    c[i] = a[0][i];\n    return c[i];\n  }\n  bool y, x = cal(a[0][i] - 1);\n  if (op[i] == \"NOT\") {\n    c[i] = !x;\n  } else {\n    y = cal(a[1][i] - 1);\n    if (op[i] == \"AND\") {\n      c[i] = x && y;\n    }\n    if (op[i] == \"OR\") {\n      c[i] = x || y;\n    }\n    if (op[i] == \"XOR\") {\n      c[i] = x ^ y;\n    }\n  }\n  return c[i];\n}\nvoid poss(int i) {\n  if (op[i] == \"NOT\") {\n    p[0][a[0][i] - 1] = p[1][i];\n    p[1][a[0][i] - 1] = p[0][i];\n    if (op[a[0][i] - 1] != \"IN\") poss(a[0][i] - 1);\n    return;\n  }\n  if (op[i] == \"AND\") {\n    p[0][a[0][i] - 1] = p[0][i];\n    p[1][a[0][i] - 1] = p[c[a[1][i] - 1]][i];\n    p[0][a[1][i] - 1] = p[0][i];\n    p[1][a[1][i] - 1] = p[c[a[0][i] - 1]][i];\n  } else if (op[i] == \"OR\") {\n    p[0][a[0][i] - 1] = p[c[a[1][i] - 1]][i];\n    p[1][a[0][i] - 1] = p[1][i];\n    p[0][a[1][i] - 1] = p[c[a[0][i] - 1]][i];\n    p[1][a[1][i] - 1] = p[1][i];\n  } else if (op[i] == \"XOR\") {\n    p[0][a[0][i] - 1] = p[c[a[1][i] - 1]][i];\n    p[1][a[0][i] - 1] = p[!c[a[1][i] - 1]][i];\n    p[0][a[1][i] - 1] = p[c[a[0][i] - 1]][i];\n    p[1][a[1][i] - 1] = p[!c[a[0][i] - 1]][i];\n  }\n  if (op[a[0][i] - 1] != \"IN\") poss(a[0][i] - 1);\n  if (op[a[1][i] - 1] != \"IN\") poss(a[1][i] - 1);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> op[i];\n    if (op[i] == \"NOT\" || op[i] == \"IN\")\n      cin >> a[0][i];\n    else\n      cin >> a[0][i] >> a[1][i];\n  }\n  cal(0);\n  p[0][0] = 0;\n  p[1][0] = 1;\n  poss(0);\n  for (int i = 0; i < n; i++)\n    if (op[i] == \"IN\") cout << p[!a[0][i]][i];\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 7;\nint ch[N][2];\nchar t[N];\nbool val[N];\nbool calc(int u = 1) {\n  bool v1 = -1, v2 = -1, res;\n  if (ch[u][0]) v1 = calc(ch[u][0]);\n  if (ch[u][1]) v2 = calc(ch[u][1]);\n  switch (t[u]) {\n    case 'I':\n      res = val[u];\n      break;\n    case 'N':\n      res = !v1;\n      break;\n    case 'A':\n      res = v1 & v2;\n      break;\n    case 'X':\n      res = v1 ^ v2;\n      break;\n    case 'O':\n      res = v1 | v2;\n      break;\n  }\n  return val[u] = res;\n}\nbool changes[N];\nvoid dfs(int u = 1, bool c = true) {\n  changes[u] = c;\n  if (!c) {\n    if (ch[u][0]) dfs(ch[u][0], c);\n    if (ch[u][1]) dfs(ch[u][1], c);\n    return;\n  }\n  switch (t[u]) {\n    case 'N':\n      dfs(ch[u][0]);\n      break;\n    case 'O':\n      if (((val[ch[u][0]] ^ 1) | val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) | val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n    case 'A':\n      if (((val[ch[u][0]] ^ 1) & val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) & val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n    case 'X':\n      if (((val[ch[u][0]] ^ 1) ^ val[ch[u][1]]) == val[u])\n        dfs(ch[u][0], false);\n      else\n        dfs(ch[u][0], true);\n      if (((val[ch[u][1]] ^ 1) ^ val[ch[u][0]]) == val[u])\n        dfs(ch[u][1], false);\n      else\n        dfs(ch[u][1], true);\n      break;\n  }\n}\nint main() {\n  char str[4];\n  int x;\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%s%d\", str, &x);\n    t[i] = str[0];\n    if (t[i] == 'I')\n      val[i] = x;\n    else {\n      ch[i][0] = x;\n      if (t[i] != 'N') {\n        cin >> x;\n        ch[i][1] = x;\n      }\n    }\n  }\n  int val = calc();\n  changes[1] = true;\n  dfs();\n  for (int i = 1; i <= n; ++i)\n    if (t[i] == 'I') {\n      if (changes[i])\n        printf(\"%d\", val ^ 1);\n      else\n        printf(\"%d\", val);\n    }\n  printf(\"\\n\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nconst int _ML = 228;\nconst char _inpf[] = \"\";\nconst char _outf[] = \"\";\n#pragma GCC optimize(\"O3,no-stack-protector\")\nusing namespace std;\nconst double PI = 3.14159265358979323846;\nmt19937 rd(228);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T, class U>\ninline istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T>\ninline istream &operator>>(istream &, vector<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const multiset<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_set<T> &);\ntemplate <class T>\ninline ostream &operator<<(ostream &, const unordered_multiset<T> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const map<T, U> &);\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &, const unordered_map<T, U> &);\nconst int N = 1000 * 1000 + 229;\nchar t[N];\nint val[N];\nint inp[N][2];\nint def[N];\nint dp[N][2][2];\nint w[N][2];\nstring ans;\nint op(int v, int first, int second) {\n  if (v == 0) {\n    return first;\n  }\n  if (t[v] == 'n') {\n    return 1 - first;\n  }\n  if (t[v] == 'a') {\n    return (first && second);\n  } else if (t[v] == 'o') {\n    return (first || second);\n  } else if (t[v] == 'x') {\n    return (first ^ second);\n  } else {\n    assert(false);\n  }\n}\nvoid dfs(int v, int p, int s) {\n  if (t[v] == '.') {\n    def[v] = val[v];\n    return;\n  } else if (t[v] == 'n') {\n    dfs(inp[v][0], v, 0);\n    def[v] = !def[inp[v][0]];\n    w[v][0] = def[inp[v][0]];\n    w[v][1] = 0;\n  } else {\n    int a = inp[v][0];\n    int b = inp[v][1];\n    dfs(inp[v][0], v, 0);\n    dfs(inp[v][1], v, 1);\n    w[v][0] = def[a];\n    w[v][1] = def[b];\n    if (t[v] == 'x') {\n      def[v] = (def[a] ^ def[b]);\n    } else if (t[v] == 'a') {\n      def[v] = (def[a] && def[b]);\n    } else if (t[v] == 'o') {\n      def[v] = (def[a] || def[b]);\n    }\n  }\n}\nvoid dfs2(int v, int p, int s) {\n  if (t[v] == '.') {\n    if (s == 0) {\n      ans[v] = (char)('0' + dp[p][1 - val[v]][w[p][1]]);\n    } else {\n      ans[v] = (char)('0' + dp[p][w[p][0]][1 - val[v]]);\n    }\n    return;\n  } else if (t[v] == 'n') {\n    for (int i = 0; i < 2; ++i) {\n      if (s == 0) {\n        dp[v][i][0] = dp[v][i][1] = dp[p][1 - i][w[p][1]];\n      } else {\n        dp[v][i][0] = dp[v][i][1] = dp[p][w[p][0]][1 - i];\n      }\n    }\n    dfs2(inp[v][0], v, 0);\n  } else {\n    int a = inp[v][0];\n    int b = inp[v][1];\n    for (int i = 0; i < 2; ++i) {\n      if (s == 0) {\n        dp[v][i][def[b]] = dp[p][op(v, i, def[b])][w[p][1]];\n      } else {\n        dp[v][i][def[b]] = dp[p][w[p][0]][op(v, i, def[b])];\n      }\n    }\n    for (int i = 0; i < 2; ++i) {\n      if (s == 0) {\n        dp[v][def[a]][i] = dp[p][op(v, i, def[a])][w[p][1]];\n      } else {\n        dp[v][def[a]][i] = dp[p][w[p][0]][op(v, i, def[a])];\n      }\n    }\n    dfs2(inp[v][0], v, 0);\n    dfs2(inp[v][1], v, 1);\n  }\n}\ninline void _main_function() {\n  int n;\n  cin >> n;\n  ans.assign(n + 1, '-');\n  for (int i = 1; i <= n; ++i) {\n    string s;\n    cin >> s;\n    int first, second;\n    cin >> first;\n    if (s == \"IN\") {\n      t[i] = '.';\n      val[i] = first;\n    } else if (s == \"NOT\") {\n      t[i] = 'n';\n      inp[i][0] = first;\n    } else {\n      cin >> second;\n      inp[i][0] = first;\n      inp[i][1] = second;\n      t[i] = (char)tolower(s[0]);\n    }\n  }\n  dfs(1, 0, 0);\n  dp[0][1][0] = dp[0][1][1] = 1;\n  dfs2(1, 0, 0);\n  string s;\n  for (char c : ans) {\n    if (isdigit(c)) {\n      s += c;\n    }\n  }\n  cout << s << '\\n';\n}\nint main() {\n  if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n  if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  cout << setprecision(20);\n  _main_function();\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const pair<T, U> &_p) {\n  _out << _p.first << ' ' << _p.second;\n  return _out;\n}\ntemplate <class T, class U>\ninline istream &operator>>(istream &_in, pair<T, U> &_p) {\n  _in >> _p.first >> _p.second;\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const vector<T> &_v) {\n  if (_v.empty()) {\n    return _out;\n  }\n  _out << *_v.begin();\n  for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline istream &operator>>(istream &_in, vector<T> &_v) {\n  for (auto &_i : _v) {\n    _in >> _i;\n  }\n  return _in;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_set<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T>\ninline ostream &operator<<(ostream &_out, const unordered_multiset<T> &_s) {\n  if (_s.empty()) {\n    return _out;\n  }\n  _out << *_s.begin();\n  for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) {\n    _out << ' ' << *_it;\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\ntemplate <class T, class U>\ninline ostream &operator<<(ostream &_out, const unordered_map<T, U> &_m) {\n  if (_m.empty()) {\n    return _out;\n  }\n  _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')';\n  for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) {\n    _out << \", (\" << _it->first << \": \" << _it->second << ')';\n  }\n  return _out;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1000100;\nconst int inf = 2147483647;\nint n, m;\nint Son[maxN][2], Opt[maxN];\nchar str[10];\nint F[maxN], Cover[maxN], Cnt[maxN];\nvoid dfs1(int u);\nvoid dfs2(int u, int c);\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", str);\n    if (str[0] == 'A') {\n      Opt[i] = 1;\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      Son[i][0] = u;\n      Son[i][1] = v;\n    }\n    if (str[0] == 'O') {\n      Opt[i] = 2;\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      Son[i][0] = u;\n      Son[i][1] = v;\n    }\n    if (str[0] == 'X') {\n      Opt[i] = 3;\n      Cnt[i] = 1;\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      Son[i][0] = u;\n      Son[i][1] = v;\n    }\n    if (str[0] == 'N') {\n      Opt[i] = 4;\n      Cnt[i] = 1;\n      int u;\n      scanf(\"%d\", &u);\n      Son[i][0] = u;\n    }\n    if (str[0] == 'I') {\n      Opt[i] = 5;\n      scanf(\"%d\", &F[i]);\n    }\n  }\n  dfs1(1);\n  for (int i = 1; i <= n; i++)\n    if (Opt[i] == 1) {\n      if (F[Son[i][0]] == 0) Cover[Son[i][1]] = 1;\n      if (F[Son[i][1]] == 0) Cover[Son[i][0]] = 1;\n    } else if (Opt[i] == 2) {\n      if (F[Son[i][0]] == 1) Cover[Son[i][1]] = 1;\n      if (F[Son[i][1]] == 1) Cover[Son[i][0]] = 1;\n    }\n  dfs2(1, Cover[1]);\n  for (int i = 1; i <= n; i++)\n    if (Opt[i] == 5) {\n      if (Cover[i])\n        printf(\"%d\", F[1]);\n      else\n        printf(\"%d\", F[1] ^ 1);\n    }\n  return 0;\n}\nvoid dfs1(int u) {\n  if (Opt[u] == 5)\n    return;\n  else if (Opt[u] == 4) {\n    Cnt[Son[u][0]] += Cnt[u];\n    dfs1(Son[u][0]);\n    F[u] = !F[Son[u][0]];\n  } else {\n    Cnt[Son[u][0]] += Cnt[u];\n    Cnt[Son[u][1]] += Cnt[u];\n    dfs1(Son[u][0]);\n    dfs1(Son[u][1]);\n    if (Opt[u] == 1) F[u] = F[Son[u][0]] & F[Son[u][1]];\n    if (Opt[u] == 2) F[u] = F[Son[u][0]] | F[Son[u][1]];\n    if (Opt[u] == 3) F[u] = F[Son[u][0]] ^ F[Son[u][1]];\n  }\n  return;\n}\nvoid dfs2(int u, int c) {\n  Cover[u] |= c;\n  if (Opt[u] == 5)\n    return;\n  else if (Opt[u] == 4)\n    dfs2(Son[u][0], Cover[u]);\n  else {\n    dfs2(Son[u][0], Cover[u]);\n    dfs2(Son[u][1], Cover[u]);\n  }\n  return;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 1;\nint n;\npair<char, pair<int, int> > g[N];\nbool val[N];\nvoid dfs(int v) {\n  int f = g[v].second.first, s = g[v].second.second;\n  if (g[v].first == 'i')\n    val[v] = f;\n  else if (g[v].first == 'n') {\n    dfs(f);\n    val[v] = !val[f];\n  } else if (g[v].first == 'a') {\n    dfs(f);\n    dfs(s);\n    val[v] = val[f] && val[s];\n  } else if (g[v].first == 'o') {\n    dfs(f);\n    dfs(s);\n    val[v] = val[f] || val[s];\n  } else {\n    dfs(f);\n    dfs(s);\n    val[v] = (val[f] != val[s]);\n  }\n}\nbool ans[N];\nvoid ans_dfs(int v, bool b) {\n  int f = g[v].second.first, s = g[v].second.second;\n  if (g[v].first == 'i')\n    ans[v] = b;\n  else if (g[v].first == 'n')\n    ans_dfs(f, b);\n  else if (g[v].first == 'a') {\n    ans_dfs(f, b || !val[s]);\n    ans_dfs(s, b || !val[f]);\n  } else if (g[v].first == 'o') {\n    ans_dfs(f, b || val[s]);\n    ans_dfs(s, b || val[f]);\n  } else {\n    ans_dfs(f, b);\n    ans_dfs(s, b);\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  cout.tie(0);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    string s;\n    cin >> s;\n    if (s == \"IN\") {\n      int t;\n      cin >> t;\n      g[i] = make_pair('i', make_pair(t, 0));\n    } else if (s == \"AND\") {\n      int a, b;\n      cin >> a >> b;\n      g[i] = make_pair('a', make_pair(a, b));\n    } else if (s == \"OR\") {\n      int a, b;\n      cin >> a >> b;\n      g[i] = make_pair('o', make_pair(a, b));\n    } else if (s == \"XOR\") {\n      int a, b;\n      cin >> a >> b;\n      g[i] = make_pair('x', make_pair(a, b));\n    } else {\n      int a;\n      cin >> a;\n      g[i] = make_pair('n', make_pair(a, 0));\n    }\n  }\n  dfs(1);\n  ans_dfs(1, 0);\n  for (int i = 1; i <= n; ++i)\n    if (g[i].first == 'i') cout << (ans[i] == val[1]);\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 50;\nint op[maxn], f[maxn], a[maxn], b[maxn], ans[maxn];\nint n;\nstring s;\nint getf(int i) {\n  if (op[i] == 1)\n    f[i] = a[i];\n  else if (op[i] == 2)\n    f[i] = getf(a[i]) ^ 1;\n  else if (op[i] == 3)\n    f[i] = getf(a[i]) & getf(b[i]);\n  else if (op[i] == 4)\n    f[i] = getf(a[i]) | getf(b[i]);\n  else if (op[i] == 5)\n    f[i] = getf(a[i]) ^ getf(b[i]);\n  return f[i];\n}\nvoid slove(int i) {\n  if (op[i] == 1) {\n    ans[i] = 1;\n    return;\n  } else if (op[i] == 2)\n    slove(a[i]);\n  else if (op[i] == 3) {\n    if (f[a[i]]) slove(b[i]);\n    if (f[b[i]]) slove(a[i]);\n  } else if (op[i] == 4) {\n    if (!f[a[i]]) slove(b[i]);\n    if (!f[b[i]]) slove(a[i]);\n  } else\n    slove(a[i]), slove(b[i]);\n}\nint main() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> s;\n    if (s[0] == 'I')\n      cin >> a[i], op[i] = 1;\n    else if (s[0] == 'N')\n      cin >> a[i], op[i] = 2;\n    else if (s[0] == 'A')\n      cin >> a[i] >> b[i], op[i] = 3;\n    else if (s[0] == 'O')\n      cin >> a[i] >> b[i], op[i] = 4;\n    else if (s[0] == 'X')\n      cin >> a[i] >> b[i], op[i] = 5;\n  }\n  getf(1), slove(1);\n  for (int i = 1; i <= n; i++)\n    if (op[i] == 1) printf(\"%d\", ans[i] ^ f[1]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\n public:\n  Node() : left(0), right(0), p(0), change(false) {}\n  bool value;\n  int left, right, p;\n  string op;\n  bool change;\n};\nvector<Node> T;\nset<int> leaf;\nbool dfs(int i) {\n  bool ans;\n  if (T[i].op == \"IN\")\n    ans = T[i].value;\n  else {\n    bool a = dfs(T[i].left);\n    bool b = false;\n    if (T[i].op != \"NOT\") b = dfs(T[i].right);\n    if (T[i].op == \"AND\") ans = a && b;\n    if (T[i].op == \"OR\") ans = a || b;\n    if (T[i].op == \"XOR\") ans = a != b;\n    if (T[i].op == \"NOT\") ans = !a;\n  }\n  T[i].value = ans;\n  return T[i].value;\n}\nvoid dfs2(int i) {\n  if (T[i].op == \"IN\") return;\n  if (T[i].change == false) {\n    T[T[i].left].change = false;\n    if (T[i].op != \"NOT\") T[T[i].right].change = false;\n  } else {\n    if (T[i].op == \"AND\") {\n      T[T[i].left].change = T[T[i].right].value;\n      T[T[i].right].change = T[T[i].left].value;\n    }\n    if (T[i].op == \"OR\") {\n      T[T[i].right].change = !T[T[i].left].value;\n      T[T[i].left].change = !T[T[i].right].value;\n    }\n    if (T[i].op == \"XOR\") {\n      T[T[i].left].change = true;\n      T[T[i].right].change = true;\n    }\n    if (T[i].op == \"NOT\") {\n      T[T[i].left].change = true;\n    }\n  }\n  dfs2(T[i].left);\n  if (T[i].op != \"NOT\") dfs2(T[i].right);\n}\nint main() {\n  int n;\n  cin >> n;\n  T.resize(n + 1);\n  for (int i = 1; i <= n; i++) {\n    cin >> T[i].op;\n    if (T[i].op == \"IN\") {\n      int t;\n      cin >> t;\n      T[i].value = (t == 1);\n      leaf.insert(i);\n    } else if (T[i].op == \"NOT\") {\n      cin >> T[i].left;\n      T[T[i].left].p = i;\n    } else {\n      cin >> T[i].left >> T[i].right;\n      T[T[i].left].p = i;\n      T[T[i].right].p = i;\n    }\n  }\n  dfs(1);\n  T[1].change = true;\n  dfs2(1);\n  for (auto i : leaf) {\n    printf(\"%d\", T[1].value != T[i].change);\n  }\n  cout << endl;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nint leaf[1000005], child1[1000005], child2[1000005], value[1000005],\n    dp[1000005];\nstring type[1000005];\nvoid dfs1(int cur) {\n  if (leaf[cur]) return;\n  if (child1[cur]) dfs1(child1[cur]);\n  if (child2[cur]) dfs1(child2[cur]);\n  if (type[cur] == \"NOT\")\n    value[cur] = (1 - value[child1[cur]]);\n  else if (type[cur] == \"AND\")\n    value[cur] = value[child1[cur]] & value[child2[cur]];\n  else if (type[cur] == \"OR\")\n    value[cur] = value[child1[cur]] | value[child2[cur]];\n  else\n    value[cur] = value[child1[cur]] ^ value[child2[cur]];\n  return;\n}\nvoid dfs2(int cur) {\n  if (leaf[cur]) return;\n  if (dp[cur] == 0) {\n    dp[child1[cur]] = 0;\n    dp[child2[cur]] = 0;\n  } else {\n    if (type[cur] == \"NOT\")\n      dp[child1[cur]] = 1;\n    else if (type[cur] == \"AND\") {\n      if (value[child1[cur]] == 0 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 0;\n        dp[child2[cur]] = 0;\n      } else if (value[child1[cur]] == 0 && value[child2[cur]] == 1) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 0;\n      } else if (value[child1[cur]] == 1 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 0;\n        dp[child2[cur]] = 1;\n      } else {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      }\n    } else if (type[cur] == \"OR\") {\n      if (value[child1[cur]] == 0 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      } else if (value[child1[cur]] == 0 && value[child2[cur]] == 1) {\n        dp[child1[cur]] = 0;\n        dp[child2[cur]] = 1;\n      } else if (value[child1[cur]] == 1 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 0;\n      } else {\n        dp[child1[cur]] = 0;\n        dp[child2[cur]] = 0;\n      }\n    } else if (type[cur] == \"XOR\") {\n      if (value[child1[cur]] == 0 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      } else if (value[child1[cur]] == 0 && value[child2[cur]] == 1) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      } else if (value[child1[cur]] == 1 && value[child2[cur]] == 0) {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      } else {\n        dp[child1[cur]] = 1;\n        dp[child2[cur]] = 1;\n      }\n    }\n  }\n  if (child1[cur]) dfs2(child1[cur]);\n  if (child2[cur]) dfs2(child2[cur]);\n  return;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  ;\n  cin.tie(0);\n  ;\n  int i, n;\n  cin >> n;\n  for (i = 1; i <= n; i++) {\n    cin >> type[i];\n    if (type[i] == \"IN\") {\n      cin >> value[i];\n      leaf[i] = 1;\n    } else {\n      if (type[i] == \"NOT\")\n        cin >> child1[i];\n      else\n        cin >> child1[i] >> child2[i];\n    }\n  }\n  dfs1(1);\n  dp[1] = 1;\n  dfs2(1);\n  for (i = 1; i <= n; i++) {\n    if (!leaf[i]) continue;\n    if (dp[i])\n      cout << (1 - value[1]);\n    else\n      cout << value[1];\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntemplate <typename T>\nconstexpr int infValue =\n    std::is_same<T, int>::value ? 2000100007 : 8600000000000000007ll;\ntemplate <typename T>\nconstexpr int maxValue =\n    std::is_same<T, int>::value ? 1000000007 : 1000000000000000001ll;\nconst int INF = 10000000007;\nconst long long MOD = 1000000007ll;\nconst double EPS = 1e-6;\nconst int MAX = maxValue<int>;\nusing pr = pair<int, int>;\nint n;\nint dp[1000011][2], op[1000011], val[1000011];\nvector<int> g[1000011];\nint par[1000011];\nint in[1000011];\nint dfs(int v) {\n  if (op[v] == 0)\n    val[v] = in[v];\n  else if (op[v] == 1)\n    val[v] = dfs(g[v][0]) & dfs(g[v][1]);\n  else if (op[v] == 2)\n    val[v] = dfs(g[v][0]) | dfs(g[v][1]);\n  else if (op[v] == 3)\n    val[v] = dfs(g[v][0]) ^ dfs(g[v][1]);\n  else if (op[v] == 4)\n    val[v] = !dfs(g[v][0]);\n  return val[v];\n}\nvoid dfs_find(int v) {\n  if (v != 1) {\n    int p = par[v];\n    if (op[p] == 4)\n      dp[v][0] = dp[p][1], dp[v][1] = dp[p][0];\n    else {\n      int v1 = val[g[p][0] == v ? g[p][1] : g[p][0]];\n      if (op[p] == 1)\n        dp[v][0] = dp[p][0], dp[v][1] = dp[p][v1];\n      else if (op[p] == 2)\n        dp[v][0] = dp[p][v1], dp[v][1] = dp[p][1];\n      else if (op[p] == 3)\n        dp[v][0] = dp[p][v1], dp[v][1] = dp[p][!v1];\n    }\n  }\n  for (const int &ch : g[v]) dfs_find(ch);\n}\nchar sop[10];\nint main(void) {\n  scanf(\"%d\", &n);\n  int a, b;\n  for (register int i = 1; i <= (n); ++i) {\n    scanf(\"%s\", sop);\n    if (!strcmp(sop, \"IN\"))\n      op[i] = 0;\n    else if (!strcmp(sop, \"AND\"))\n      op[i] = 1;\n    else if (!strcmp(sop, \"OR\"))\n      op[i] = 2;\n    else if (!strcmp(sop, \"XOR\"))\n      op[i] = 3;\n    else if (!strcmp(sop, \"NOT\"))\n      op[i] = 4;\n    if (op[i] == 0)\n      scanf(\"%d\", in + i);\n    else if (op[i] < 4) {\n      scanf(\"%d %d\", &a, &b);\n      g[i].push_back(a);\n      g[i].push_back(b);\n      par[a] = (i);\n      par[b] = (i);\n    } else {\n      scanf(\"%d\", &a);\n      g[i].push_back(a);\n      par[a] = (i);\n    }\n  }\n  dfs(1);\n  dp[1][0] = 0, dp[1][1] = 1;\n  dfs_find(1);\n  for (register int i = 1; i <= (n); ++i)\n    if (op[i] == 0) printf(\"%d\", dp[i][!in[i]]);\n  putc('\\n', stdout);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nvector<int> v[N];\nint Dp[N][2], Bits[N], par[N], Ans[N];\nstring s[N];\nint DFS(int x, int p) {\n  par[x] = p;\n  if (s[x] == \"IN\") return Bits[x];\n  for (auto j : v[x]) {\n    if (j != p) {\n      if (s[x] == \"NOT\") {\n        Ans[x] = !DFS(j, x);\n      } else if (s[x] == \"AND\") {\n        Ans[x] &= DFS(j, x);\n      } else if (s[x] == \"OR\") {\n        Ans[x] |= DFS(j, x);\n      } else {\n        Ans[x] ^= DFS(j, x);\n      }\n    }\n  }\n  return Ans[x];\n}\nint Solve(int x, int bit) {\n  if (x == 1) return bit;\n  if (Dp[x][bit] != -1) return Dp[x][bit];\n  int p = par[x];\n  int Node;\n  vector<int> temp;\n  for (auto j : v[p]) temp.push_back(j);\n  for (auto j : temp)\n    if (j != x && j != par[p]) Node = j;\n  if (s[p] == \"NOT\") {\n    return Dp[x][bit] = Solve(p, !bit);\n  } else if (s[p] == \"XOR\") {\n    return Dp[x][bit] = Solve(p, bit ^ Ans[Node]);\n  } else if (s[p] == \"OR\") {\n    return Dp[x][bit] = Solve(p, bit | Ans[Node]);\n  } else {\n    return Dp[x][bit] = Solve(p, bit & Ans[Node]);\n  }\n}\nint main() {\n  memset(Dp, -1, sizeof(Dp));\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++) {\n    cin >> s[i];\n    if (s[i] == \"AND\") Ans[i] = 1;\n    if (s[i] == \"IN\")\n      scanf(\"%d\", &Bits[i]), Ans[i] = Bits[i];\n    else {\n      int x, y;\n      if (s[i] == \"NOT\") {\n        scanf(\"%d\", &x);\n        v[i].push_back(x);\n        v[x].push_back(i);\n      } else {\n        scanf(\"%d%d\", &x, &y);\n        v[i].push_back(x);\n        v[x].push_back(i);\n        v[i].push_back(y);\n        v[y].push_back(i);\n      }\n    }\n  }\n  DFS(1, -1);\n  for (int i = 1; i <= n; i++) {\n    if (s[i] == \"IN\") printf(\"%d\", Solve(i, !Bits[i]));\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxm = 1e6 + 5;\nvector<int> g[maxm];\nint mark[maxm];\nint d[maxm];\nint v[maxm];\nint n;\nint dfs(int x) {\n  if (d[x] == 1)\n    return v[x] = dfs(g[x][0]) & dfs(g[x][1]);\n  else if (d[x] == 2)\n    return v[x] = dfs(g[x][0]) | dfs(g[x][1]);\n  else if (d[x] == 3)\n    return v[x] = dfs(g[x][0]) ^ dfs(g[x][1]);\n  else if (d[x] == 4)\n    return v[x] = !dfs(g[x][0]);\n  else\n    return v[x];\n}\nvoid dfs2(int x) {\n  if (d[x] == 1) {\n    if (v[x] == 1) {\n      dfs2(g[x][0]);\n      dfs2(g[x][1]);\n    } else {\n      if (!v[g[x][0]] && v[g[x][1]]) dfs2(g[x][0]);\n      if (v[g[x][0]] && !v[g[x][1]]) dfs2(g[x][1]);\n    }\n  } else if (d[x] == 2) {\n    if (v[g[x][0]] && !v[g[x][1]]) dfs2(g[x][0]);\n    if (!v[g[x][0]] && v[g[x][1]]) dfs2(g[x][1]);\n    if (!v[g[x][0]] && !v[g[x][1]]) {\n      dfs2(g[x][0]);\n      dfs2(g[x][1]);\n    }\n  } else if (d[x] == 3) {\n    dfs2(g[x][0]);\n    dfs2(g[x][1]);\n  } else if (d[x] == 4) {\n    dfs2(g[x][0]);\n  } else if (d[x] == 5) {\n    mark[x] = 1;\n  }\n}\nsigned main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n;\n  string s;\n  int l, r;\n  for (int i = 1; i <= n; i++) {\n    cin >> s;\n    if (s[0] == 'A') {\n      d[i] = 1;\n      cin >> l >> r;\n      g[i].push_back(l);\n      g[i].push_back(r);\n    } else if (s[0] == 'O') {\n      d[i] = 2;\n      cin >> l >> r;\n      g[i].push_back(l);\n      g[i].push_back(r);\n    } else if (s[0] == 'X') {\n      d[i] = 3;\n      cin >> l >> r;\n      g[i].push_back(l);\n      g[i].push_back(r);\n    } else if (s[0] == 'N') {\n      d[i] = 4;\n      cin >> l;\n      g[i].push_back(l);\n    } else if (s[0] == 'I') {\n      d[i] = 5;\n      cin >> v[i];\n    }\n  }\n  dfs(1);\n  dfs2(1);\n  for (int i = 1; i <= n; i++) {\n    if (d[i] == 5) {\n      if (mark[i])\n        cout << !v[1];\n      else\n        cout << v[1];\n    }\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nint dr[] = {2, 2, -2, -2, 1, -1, 1, -1};\nint dc[] = {1, -1, 1, -1, 2, 2, -2, -2};\nint dr1[] = {0, 0, 1, 1, 1, -1, -1, -1};\nint dc1[] = {1, -1, 1, 0, -1, 0, 1, -1};\nint dr2[] = {0, 0, 1, -1};\nint dc2[] = {1, -1, 0, 0};\nusing namespace std;\nvector<int> adj[1000005];\nint a[1000005], b[1000005], dp1[1000005];\nlong long get(string t) {\n  if (t == \"IN\") return 0;\n  if (t == \"AND\") return 1;\n  if (t == \"XOR\") return 2;\n  if (t == \"OR\") return 3;\n  if (t == \"NOT\") return 4;\n}\nlong long get1(long long x, long long y, long long v) {\n  if (a[v] == 1) return (x & y);\n  if (a[v] == 2) return (x ^ y);\n  if (a[v] == 3) return (x | y);\n}\nlong long dfs(long long u) {\n  if (a[u] == 0) {\n    dp1[u] = b[u];\n    return dp1[u];\n  }\n  long long i, j;\n  if (adj[u].size() == 1) {\n    long long p = adj[u][0];\n    long long r = dfs(p) ^ 1;\n    dp1[u] = r;\n    return r;\n  } else {\n    long long p = adj[u][0];\n    long long q = adj[u][1];\n    p = dfs(p);\n    q = dfs(q);\n    long long r;\n    if (a[u] == 1)\n      r = p & q;\n    else if (a[u] == 2)\n      r = p ^ q;\n    else if (a[u] == 3)\n      r = p | q;\n    dp1[u] = r;\n    return r;\n  }\n}\nint dp[1000005][2][2];\nlong long cal(long long x, long long f, long long f1) {\n  if (f1 == 0) return (dp1[x] == f);\n  if (a[x] == 0) {\n    if (b[x] ^ 1 == f) return 1;\n    return 0;\n  }\n  int &r = dp[x][f][f1];\n  if (r != -1) return r;\n  r = 0;\n  if (adj[x].size() == 1) {\n    long long p = adj[x][0];\n    r = cal(p, f ^ 1, f1);\n    return r;\n  } else {\n    long long i, j;\n    long long p = adj[x][0];\n    long long q = adj[x][1];\n    for (i = 0; i < 2; i++) {\n      for (j = 0; j < 2; j++) {\n        long long p1 = get1(i, j, x);\n        if (p1 == f) {\n          long long r1 = cal(p, i, f1) & cal(q, j, 1 - f1);\n          long long r2 = cal(p, i, 1 - f1) & cal(q, j, f1);\n          r |= r1;\n          r |= r2;\n        }\n      }\n    }\n    return r;\n  }\n}\nint mark[1000005];\nvoid print(long long x, long long f, long long f1) {\n  if (a[x] == 0) {\n    mark[x] = 1;\n    return;\n  }\n  if (adj[x].size() == 1) {\n    long long p = adj[x][0];\n    print(p, f ^ 1, f1);\n    return;\n  }\n  long long i, j;\n  long long p = adj[x][0];\n  long long q = adj[x][1];\n  for (i = 0; i < 2; i++) {\n    for (j = 0; j < 2; j++) {\n      long long p1 = get1(i, j, x);\n      if (p1 == f) {\n        long long r1 = cal(p, i, f1) & cal(q, j, 1 - f1);\n        if (r1 == 1) {\n          print(p, i, f1);\n        }\n        r1 = cal(p, i, 1 - f1) & cal(q, j, f1);\n        if (r1 == 1) {\n          print(q, j, f1);\n        }\n      }\n    }\n  }\n}\nint main() {\n  int n, i, j, x, y;\n  while (cin >> n) {\n    for (i = 1; i <= n; i++) {\n      string t;\n      cin >> t;\n      a[i] = get(t);\n      if (a[i] == 0 || a[i] == 4) {\n        cin >> x;\n        if (a[i] == 0)\n          b[i] = x;\n        else\n          adj[i].push_back(x);\n      } else {\n        cin >> x >> y;\n        adj[i].push_back(x);\n        adj[i].push_back(y);\n      }\n    }\n    long long ans = dfs(1);\n    memset(dp, -1, sizeof(dp));\n    long long p = cal(1, ans ^ 1, 1);\n    print(1, ans ^ 1, 1);\n    for (i = 1; i <= n; i++) {\n      if (a[i] == 0) {\n        if (mark[i] == 0)\n          cout << ans;\n        else\n          cout << (ans ^ 1);\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 100;\nvector<int> adj[maxn];\nstring s[maxn];\nint a[maxn];\nbool mark[maxn];\nvoid dfs(int v, int par) {\n  if (s[v] == \"AND\") a[v] = 1;\n  if (s[v] == \"OR\") a[v] = 0;\n  if (s[v] == \"XOR\") a[v] = 0;\n  for (int i = 0; i < adj[v].size(); i++) {\n    int u = adj[v][i];\n    if (u != par) {\n      dfs(u, v);\n      if (s[v] == \"AND\") a[v] &= a[u];\n      if (s[v] == \"OR\") a[v] |= a[u];\n      if (s[v] == \"XOR\") a[v] ^= a[u];\n      if (s[v] == \"NOT\") a[v] = !a[u];\n    }\n  }\n}\nvoid dfs_2(int v) {\n  mark[v] = true;\n  if (s[v] == \"IN\") return;\n  if (s[v] == \"NOT\") {\n    dfs_2(adj[v][0]);\n    return;\n  }\n  int l = adj[v][0], r = adj[v][1];\n  if (s[v] == \"XOR\") {\n    dfs_2(l);\n    dfs_2(r);\n    return;\n  }\n  if (s[v] == \"AND\") {\n    if (a[l] == 0 && a[r] == 1) dfs_2(l);\n    if (a[l] == 1 && a[r] == 0) dfs_2(r);\n    if (a[l] == 1 && a[r] == 1) {\n      dfs_2(l);\n      dfs_2(r);\n    }\n    return;\n  }\n  if (s[v] == \"OR\") {\n    if (a[l] == 0 && a[r] == 0) {\n      dfs_2(l);\n      dfs_2(r);\n    }\n    if (a[l] == 0 && a[r] == 1) dfs_2(r);\n    if (a[l] == 1 && a[r] == 0) dfs_2(l);\n    return;\n  }\n}\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    if (s[i] == \"IN\") {\n      cin >> a[i];\n    } else if (s[i] == \"NOT\") {\n      int v;\n      cin >> v;\n      v--;\n      adj[i].push_back(v);\n    } else {\n      int v, u;\n      cin >> v >> u;\n      v--, u--;\n      adj[i].push_back(u);\n      adj[i].push_back(v);\n    }\n  }\n  dfs(0, -1);\n  dfs_2(0);\n  for (int i = 1; i < n; i++)\n    if (adj[i].size() == 0) cout << (mark[i] ? !a[0] : a[0]);\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nbool GetResult(char type, bool v1, bool v2) {\n  switch (type) {\n    case 1:\n      return v1 && v2;\n      break;\n    case 2:\n      return v1 || v2;\n      break;\n    case 3:\n      return v1 xor v2;\n      break;\n  }\n  return false;\n}\nstruct vertex {\n  char type;\n  bool val;\n  bool lval;\n  bool rval;\n  bool isleft;\n  bool isright;\n  int l;\n  int r = -1;\n};\nvoid dfs1(int i, vector<vertex> &mgr) {\n  if (i == -1 || mgr[i].type == 0) return;\n  vertex &cur_vert = mgr[i];\n  dfs1(cur_vert.l, mgr);\n  if (mgr[i].type == 4) {\n    cur_vert.val = !mgr[cur_vert.l].val;\n    return;\n  }\n  dfs1(mgr[i].r, mgr);\n  cur_vert.val =\n      GetResult(cur_vert.type, mgr[cur_vert.l].val, mgr[cur_vert.r].val);\n  cur_vert.isleft =\n      (cur_vert.val !=\n       GetResult(cur_vert.type, !mgr[cur_vert.l].val, mgr[cur_vert.r].val));\n  cur_vert.isright =\n      (cur_vert.val !=\n       GetResult(cur_vert.type, mgr[cur_vert.l].val, !mgr[cur_vert.r].val));\n  return;\n}\nstatic vector<bool> ans;\nvoid dfs2(int i, const vector<vertex> &mgr) {\n  const vertex &cur_vert = mgr[i];\n  if (cur_vert.type == 0) ans[i] = !ans[i];\n  if (cur_vert.isleft) dfs2(cur_vert.l, mgr);\n  if (cur_vert.type == 4) return;\n  if (cur_vert.isright) dfs2(cur_vert.r, mgr);\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<vertex> mgr(n);\n  for (int i = 0; i < n; ++i) {\n    static string type;\n    int u;\n    cin >> type;\n    if (type == \"IN\" or type == \"NOT\") {\n      cin >> u;\n      if (type == \"IN\") {\n        mgr[i].type = 0;\n        mgr[i].val = u;\n      } else {\n        mgr[i].type = 4;\n        mgr[i].isleft = true;\n        --u;\n        mgr[i].l = u;\n      }\n    } else {\n      cin >> mgr[i].l >> mgr[i].r;\n      --mgr[i].l;\n      --mgr[i].r;\n      mgr[i].type = (type == \"AND\") ? 1 : (type == \"OR\") ? 2 : 3;\n    }\n  }\n  dfs1(0, mgr);\n  ans = vector<bool>(n, mgr[0].val);\n  dfs2(0, mgr);\n  for (int i = 0; i < n; ++i) {\n    if (mgr[i].type == 0) cout << ans[i];\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000051;\nlong long n;\nstring c;\nstruct btree {\n  int chnum;\n  int child[2];\n  int num;\n  int typ;\n  int id;\n} tre[N];\nint dfx[N][2];\nint tot = 0;\nint has[N];\nvoid predfs(int x) {\n  if (tre[x].typ == 0) return;\n  if (tre[x].typ == 1) {\n    predfs(tre[x].child[0]);\n    predfs(tre[x].child[1]);\n    tre[x].num = tre[tre[x].child[0]].num & tre[tre[x].child[1]].num;\n  }\n  if (tre[x].typ == 2) {\n    predfs(tre[x].child[0]);\n    predfs(tre[x].child[1]);\n    tre[x].num = tre[tre[x].child[0]].num | tre[tre[x].child[1]].num;\n  }\n  if (tre[x].typ == 3) {\n    predfs(tre[x].child[0]);\n    predfs(tre[x].child[1]);\n    tre[x].num = tre[tre[x].child[0]].num ^ tre[tre[x].child[1]].num;\n  }\n  if (tre[x].typ == 4) {\n    predfs(tre[x].child[0]);\n    tre[x].num = !tre[tre[x].child[0]].num;\n  }\n}\nvoid dfs(int x) {\n  if (tre[x].typ == 0) has[tre[x].id] = dfx[tot][tre[x].num ^ 1];\n  if (tre[x].typ == 1) {\n    tot++;\n    dfx[tot][0] = dfx[tot - 1][0 & tre[tre[x].child[1]].num];\n    dfx[tot][1] = dfx[tot - 1][1 & tre[tre[x].child[1]].num];\n    dfs(tre[x].child[0]);\n    dfx[tot][0] = dfx[tot - 1][0 & tre[tre[x].child[0]].num];\n    dfx[tot][1] = dfx[tot - 1][1 & tre[tre[x].child[0]].num];\n    dfs(tre[x].child[1]);\n    tot--;\n  }\n  if (tre[x].typ == 2) {\n    tot++;\n    dfx[tot][0] = dfx[tot - 1][0 | tre[tre[x].child[1]].num];\n    dfx[tot][1] = dfx[tot - 1][1 | tre[tre[x].child[1]].num];\n    dfs(tre[x].child[0]);\n    dfx[tot][0] = dfx[tot - 1][0 | tre[tre[x].child[0]].num];\n    dfx[tot][1] = dfx[tot - 1][1 | tre[tre[x].child[0]].num];\n    dfs(tre[x].child[1]);\n    tot--;\n  }\n  if (tre[x].typ == 3) {\n    tot++;\n    dfx[tot][0] = dfx[tot - 1][0 ^ tre[tre[x].child[1]].num];\n    dfx[tot][1] = dfx[tot - 1][1 ^ tre[tre[x].child[1]].num];\n    dfs(tre[x].child[0]);\n    dfx[tot][0] = dfx[tot - 1][0 ^ tre[tre[x].child[0]].num];\n    dfx[tot][1] = dfx[tot - 1][1 ^ tre[tre[x].child[0]].num];\n    dfs(tre[x].child[1]);\n    tot--;\n  }\n  if (tre[x].typ == 4) {\n    tot++;\n    dfx[tot][0] = dfx[tot - 1][1];\n    dfx[tot][1] = dfx[tot - 1][0];\n    dfs(tre[x].child[0]);\n    tot--;\n  }\n}\nvoid init() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) has[i] = -1;\n  for (int i = 1; i <= n; i++) {\n    cin >> c;\n    tre[i].id = i;\n    if (c == \"IN\") {\n      tre[i].chnum = 0;\n      tre[i].typ = 0;\n      scanf(\"%d\", &tre[i].num);\n    }\n    if (c == \"AND\") {\n      tre[i].chnum = 2;\n      tre[i].typ = 1;\n      tre[i].num = -1;\n      scanf(\"%d%d\", &tre[i].child[0], &tre[i].child[1]);\n    }\n    if (c == \"OR\") {\n      tre[i].chnum = 2;\n      tre[i].typ = 2;\n      tre[i].num = -1;\n      scanf(\"%d%d\", &tre[i].child[0], &tre[i].child[1]);\n    }\n    if (c == \"XOR\") {\n      tre[i].chnum = 2;\n      tre[i].typ = 3;\n      tre[i].num = -1;\n      scanf(\"%d%d\", &tre[i].child[0], &tre[i].child[1]);\n    }\n    if (c == \"NOT\") {\n      tre[i].chnum = 1;\n      tre[i].typ = 4;\n      tre[i].num = -1;\n      scanf(\"%d\", &tre[i].child[0]);\n    }\n  }\n  dfx[0][0] = 0;\n  dfx[0][1] = 1;\n  predfs(1);\n  dfs(1);\n  for (int i = 1; i <= n; i++)\n    if (has[i] != -1) printf(\"%d\", has[i]);\n  printf(\"\\n\");\n}\nint main() {\n  int T;\n  T = 1;\n  while (T--) init();\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e6 + 5;\nint lson[MAXN];\nint rson[MAXN];\nint tp[MAXN];\nint val[MAXN];\nint chg[MAXN];\nint ans[MAXN];\nchar op[5];\nvoid dfs1(int x) {\n  if (tp[x] == 1) {\n    return;\n  } else if (tp[x] == 2) {\n    dfs1(lson[x]);\n    dfs1(rson[x]);\n    val[x] = val[lson[x]] & val[rson[x]];\n  } else if (tp[x] == 3) {\n    dfs1(lson[x]);\n    dfs1(rson[x]);\n    val[x] = val[lson[x]] | val[rson[x]];\n  } else if (tp[x] == 4) {\n    dfs1(lson[x]);\n    dfs1(rson[x]);\n    val[x] = val[lson[x]] ^ val[rson[x]];\n  } else {\n    dfs1(lson[x]);\n    val[x] = val[lson[x]] ^ 1;\n  }\n}\nvoid dfs2(int x) {\n  if (tp[x] == 1) {\n    chg[x] = 1;\n    return;\n  } else if (tp[x] == 2) {\n    if (val[x]) {\n      dfs2(lson[x]);\n      dfs2(rson[x]);\n    } else if (val[lson[x]]) {\n      dfs2(rson[x]);\n    } else if (val[rson[x]]) {\n      dfs2(lson[x]);\n    }\n  } else if (tp[x] == 3) {\n    if (!val[x]) {\n      dfs2(lson[x]);\n      dfs2(rson[x]);\n    } else if (!val[lson[x]]) {\n      dfs2(rson[x]);\n    } else if (!val[rson[x]]) {\n      dfs2(lson[x]);\n    }\n  } else if (tp[x] == 4) {\n    dfs2(lson[x]);\n    dfs2(rson[x]);\n  } else {\n    dfs2(lson[x]);\n  }\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int index = 0;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", op);\n    if (op[0] == 'I') {\n      tp[i] = 1;\n      scanf(\"%d\", &val[i]);\n      ans[++index] = i;\n    } else if (op[0] == 'A') {\n      tp[i] = 2;\n      scanf(\"%d%d\", &lson[i], &rson[i]);\n    } else if (op[0] == 'O') {\n      tp[i] = 3;\n      scanf(\"%d%d\", &lson[i], &rson[i]);\n    } else if (op[0] == 'X') {\n      tp[i] = 4;\n      scanf(\"%d%d\", &lson[i], &rson[i]);\n    } else {\n      tp[i] = 5;\n      scanf(\"%d\", &lson[i]);\n    }\n  }\n  dfs1(1);\n  dfs2(1);\n  for (int i = 1; i <= index; i++) {\n    printf(\"%d\", chg[ans[i]] ? val[1] ^ 1 : val[1]);\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Node {\n  Node* left;\n  Node* right;\n  Node* parent;\n  int _type;\n  bool val;\n  bool evaled;\n  bool leftChild;\n  bool flipped;\n  int index;\n  Node(int t) {\n    left = nullptr;\n    right = nullptr;\n    parent = nullptr;\n    leftChild = false;\n    evaled = false;\n    flipped = false;\n    index = t;\n  }\n  bool eval() {\n    bool ll, rr;\n    switch (_type) {\n      case 0:\n        return val;\n      case 1:\n        if (left->evaled)\n          ll = left->val;\n        else\n          ll = left->eval();\n        if (right->evaled)\n          rr = right->val;\n        else\n          rr = right->eval();\n        val = ll & rr;\n        evaled = true;\n        return val;\n      case 2:\n        if (left->evaled)\n          ll = left->val;\n        else\n          ll = left->eval();\n        if (right->evaled)\n          rr = right->val;\n        else\n          rr = right->eval();\n        val = ll | rr;\n        evaled = true;\n        return val;\n      case 3:\n        if (left->evaled)\n          ll = left->val;\n        else\n          ll = left->eval();\n        if (right->evaled)\n          rr = right->val;\n        else\n          rr = right->eval();\n        val = ll ^ rr;\n        evaled = true;\n        return val;\n      case 4:\n        if (left->evaled)\n          ll = left->val;\n        else\n          ll = left->eval();\n        val = !ll;\n        evaled = true;\n        return val;\n      default:\n        return val;\n    }\n  }\n} Node;\nvoid topdown(Node* node) {\n  switch (node->_type) {\n    case 0:\n      node->flipped = true;\n      break;\n    case 1:\n      if (node->val) {\n        topdown(node->left);\n        topdown(node->right);\n      } else {\n        if (node->left->val)\n          topdown(node->right);\n        else if (node->right->val)\n          topdown(node->left);\n      }\n      break;\n    case 2:\n      if (node->val) {\n        if (node->left->val && !node->right->val)\n          topdown(node->left);\n        else if (!node->left->val && node->right->val)\n          topdown(node->right);\n      } else {\n        topdown(node->left);\n        topdown(node->right);\n      }\n      break;\n    case 3:\n      topdown(node->left);\n      topdown(node->right);\n      break;\n    case 4:\n      topdown(node->left);\n      break;\n    default:\n      break;\n  }\n}\nNode* root;\nint main() {\n  int N;\n  cin >> N;\n  vector<Node*> nodes(N + 1);\n  for (int i = 1; i <= N; i++) nodes[i] = new Node(i);\n  vector<Node*> leaves(N + 1);\n  int n = 0;\n  string st;\n  int l, r, t;\n  for (int i = 1; i <= N; i++) {\n    cin >> st;\n    if (st[0] == 'I') {\n      nodes[i]->_type = 0;\n      cin >> t;\n      nodes[i]->val = (t == 1);\n      leaves[n] = nodes[i];\n      n = n + 1;\n      nodes[i]->evaled = true;\n    } else if (st[0] == 'A') {\n      nodes[i]->_type = 1;\n      cin >> l >> r;\n      nodes[i]->left = nodes[l];\n      nodes[i]->right = nodes[r];\n    } else if (st[0] == 'O') {\n      nodes[i]->_type = 2;\n      cin >> l >> r;\n      nodes[i]->left = nodes[l];\n      nodes[i]->right = nodes[r];\n    } else if (st[0] == 'X') {\n      nodes[i]->_type = 3;\n      cin >> l >> r;\n      nodes[i]->left = nodes[l];\n      nodes[i]->right = nodes[r];\n    } else if (st[0] == 'N') {\n      nodes[i]->_type = 4;\n      cin >> t;\n      nodes[i]->left = nodes[t];\n    }\n  }\n  root = nodes[1];\n  root->eval();\n  topdown(root);\n  bool output = root->val;\n  for (int i = 0; i < n; i++)\n    if (leaves[i]->flipped)\n      cout << !output;\n    else\n      cout << output;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nstruct node {\n  string type;\n  int val;\n  int left, right;\n};\nvector<int> vals;\nvector<node> nodes;\nvector<int> depths;\nvector<list<int>> changes;\nvoid dfs(int x, int depth) {\n  depths[x] = depth;\n  if (nodes[x].type == \"IN\")\n    vals[x] = nodes[x].val;\n  else {\n    dfs(nodes[x].left, depth + 1);\n    if (nodes[x].right >= 0) dfs(nodes[x].right, depth + 1);\n    if (nodes[x].type == \"AND\")\n      vals[x] = vals[nodes[x].left] & vals[nodes[x].right];\n    else if (nodes[x].type == \"OR\")\n      vals[x] = vals[nodes[x].left] | vals[nodes[x].right];\n    else if (nodes[x].type == \"XOR\")\n      vals[x] = vals[nodes[x].left] ^ vals[nodes[x].right];\n    else if (nodes[x].type == \"NOT\")\n      vals[x] = 1 - vals[nodes[x].left];\n  }\n}\nint main(int argc, char** argv) {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  if (argc == 2 && atoi(argv[1]) == 123456789)\n    freopen(\"d:\\\\code\\\\cpp\\\\stdin\", \"r\", stdin);\n  int n;\n  cin >> n;\n  vals.resize(n);\n  nodes.resize(n);\n  depths.resize(n);\n  int nrleafs = 0;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    nodes[i].type = s;\n    if (s == \"IN\") {\n      cin >> nodes[i].val;\n      nrleafs++;\n    } else if (s == \"NOT\") {\n      int li;\n      cin >> li;\n      li--;\n      nodes[i].left = li;\n      nodes[i].right = -1;\n    } else {\n      int li, ri;\n      cin >> li >> ri;\n      li--;\n      ri--;\n      nodes[i].left = li;\n      nodes[i].right = ri;\n    }\n  }\n  dfs(0, 0);\n  vector<pair<int, int>> order;\n  for (int i = 0; i < n; i++) order.push_back(make_pair(-depths[i], i));\n  sort(order.begin(), order.end());\n  changes.resize(n);\n  for (int i = 0; i < n; i++) {\n    int x = order[i].second;\n    if (nodes[x].type == \"IN\")\n      changes[x].push_back(x);\n    else {\n      if (nodes[x].type == \"AND\") {\n        if (((1 - vals[nodes[x].left]) & vals[nodes[x].right]) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].left]);\n        if ((vals[nodes[x].left] & (1 - vals[nodes[x].right])) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].right]);\n      } else if (nodes[x].type == \"OR\") {\n        if (((1 - vals[nodes[x].left]) | vals[nodes[x].right]) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].left]);\n        if ((vals[nodes[x].left] | (1 - vals[nodes[x].right])) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].right]);\n      } else if (nodes[x].type == \"XOR\") {\n        if (((1 - vals[nodes[x].left]) ^ vals[nodes[x].right]) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].left]);\n        if ((vals[nodes[x].left] ^ (1 - vals[nodes[x].right])) != vals[x])\n          changes[x].splice(changes[x].begin(), changes[nodes[x].right]);\n      } else if (nodes[x].type == \"NOT\") {\n        changes[x].splice(changes[x].begin(), changes[nodes[x].left]);\n      }\n    }\n  }\n  vector<int> xx;\n  for (int x : changes[0]) xx.push_back(x);\n  sort(xx.begin(), xx.end());\n  int posx = 0;\n  for (int i = 0; i < n; i++)\n    if (nodes[i].type == \"IN\") {\n      if (posx < xx.size() && xx[posx] == i) {\n        cout << 1 - vals[0];\n        posx++;\n      } else\n        cout << vals[0];\n    }\n  cout << endl;\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000005;\nint n, m;\nint t[N], s[N];\nint G[N][3];\nbool flip[N];\nint calc(int u, int v, int type) {\n  switch (type) {\n    case 1:\n      return u & v;\n    case 2:\n      return u ^ v;\n    case 3:\n      return u | v;\n  }\n}\nint dfs(int u) {\n  if (t[u] <= 3)\n    return s[u] = calc(dfs(G[u][0]), dfs(G[u][1]), t[u]);\n  else if (t[u] == 4)\n    return s[u];\n  else\n    return s[u] = 1 ^ dfs(G[u][0]);\n}\nvoid dfs2(int u, int cf) {\n  if (t[u] == 4) {\n    flip[u] = cf;\n  } else if (t[u] == 5) {\n    dfs2(G[u][0], cf);\n  } else if (t[u] == 2) {\n    dfs2(G[u][0], cf);\n    dfs2(G[u][1], cf);\n  } else if (cf) {\n    int nows = s[u], nxts;\n    int s1 = s[G[u][0]];\n    int s2 = s[G[u][1]];\n    nxts = calc(s1 ^ 1, s2, t[u]);\n    if (nxts != nows)\n      dfs2(G[u][0], 1);\n    else\n      dfs2(G[u][0], 0);\n    nxts = calc(s1, s2 ^ 1, t[u]);\n    if (nxts != nows)\n      dfs2(G[u][1], 1);\n    else\n      dfs2(G[u][1], 0);\n  } else {\n    dfs2(G[u][0], cf);\n    dfs2(G[u][1], cf);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, x, y; i <= n; i++) {\n    char st[5];\n    scanf(\"%s\", st);\n    if (st[0] == 'A') {\n      scanf(\"%d%d\", &G[i][0], &G[i][1]);\n      t[i] = 1;\n    } else if (st[0] == 'X') {\n      scanf(\"%d%d\", &G[i][0], &G[i][1]);\n      t[i] = 2;\n    } else if (st[0] == 'O') {\n      scanf(\"%d%d\", &G[i][0], &G[i][1]);\n      t[i] = 3;\n    } else if (st[0] == 'I') {\n      scanf(\"%d\", &s[i]);\n      t[i] = 4;\n    } else {\n      scanf(\"%d\", &G[i][0]);\n      t[i] = 5;\n    }\n  }\n  dfs(1);\n  dfs2(1, 1);\n  for (int i = 1; i <= n; i++) {\n    if (t[i] == 4) printf(\"%d\", flip[i] ? !s[1] : s[1]);\n  }\n  puts(\"\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000005;\nint n;\nint tp[MAXN];\nint son[MAXN][2];\nint f[MAXN], g[MAXN], h[MAXN];\nvoid dfs(int o) {\n  if (tp[o] == 0) return;\n  if (tp[o] == 4) {\n    dfs(son[o][0]);\n    f[o] = !f[son[o][0]];\n  } else {\n    dfs(son[o][0]), dfs(son[o][1]);\n    int a = f[son[o][0]], b = f[son[o][1]];\n    f[o] = tp[o] == 1 ? (a & b) : (tp[o] == 2 ? (a | b) : (a ^ b));\n  }\n}\nvoid dfs_1(int o) {\n  if (tp[o] == 0) return;\n  if (tp[o] == 4)\n    g[son[o][0]] = g[o], dfs_1(son[o][0]);\n  else {\n    int a = son[o][0], b = son[o][1];\n    int x = f[a], y = f[b], c, d;\n    int res;\n    c = !x, d = y;\n    res = tp[o] == 1 ? (c & d) : (tp[o] == 2 ? (c | d) : (c ^ d));\n    g[a] = res != f[o] ? g[o] : h[o];\n    c = x, d = !y;\n    res = tp[o] == 1 ? (c & d) : (tp[o] == 2 ? (c | d) : (c ^ d));\n    g[b] = res != f[o] ? g[o] : h[o];\n    dfs_1(a), dfs_1(b);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) f[i] = -1;\n  char s[5];\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", s);\n    if (s[0] == 'A' || s[0] == 'X' || s[0] == 'O') {\n      scanf(\"%d %d\", &son[i][0], &son[i][1]);\n      tp[i] = s[0] == 'A' ? 1 : (s[0] == 'O' ? 2 : 3);\n    } else if (s[0] == 'N')\n      scanf(\"%d\", &son[i][0]), tp[i] = 4;\n    else\n      scanf(\"%d\", &f[i]);\n  }\n  dfs(1);\n  g[1] = !f[1];\n  for (int i = 1; i <= n; i++) h[i] = f[1];\n  dfs_1(1);\n  for (int i = 1; i <= n; i++)\n    if (tp[i] == 0) printf(\"%d\", g[i]);\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Node {\n  int left, right, p;\n  int type;\n  bool val, isl;\n  bool dp[4];\n} Node;\nconst int N = 1111111;\nNode tree[N];\nbool dp[N][2];\nstring ans;\nint n;\nbool getval(bool a, bool b, int type) {\n  if (type == 1) {\n    return !a;\n  } else if (type == 2) {\n    return a | b;\n  } else if (type == 3) {\n    return a & b;\n  } else if (type == 4) {\n    return a ^ b;\n  }\n  return false;\n}\nvoid dfs(int id) {\n  Node &u = tree[id], &l = tree[u.left], &r = tree[u.right];\n  if (u.left) dfs(u.left);\n  if (u.right) dfs(u.right);\n  if (u.type) {\n    u.val = getval(l.val, r.val, u.type);\n    for (int i = (0); i <= (3); i++) {\n      u.dp[i] = getval(i >> 1, i & 1, u.type);\n    }\n  }\n}\nvoid dfs2(int id) {\n  Node &u = tree[id], &l = tree[u.left], &r = tree[u.right], &p = tree[u.p];\n  if (u.p == 0) {\n    dp[id][0] = 0;\n    dp[id][1] = 1;\n  } else {\n    if (u.val) {\n      bool lv = 0, rv = u.isl ? tree[p.right].val : tree[p.left].val;\n      int x = lv * 2 + rv;\n      dp[id][0] = dp[u.p][p.dp[x]];\n      dp[id][1] = dp[u.p][p.val];\n    } else {\n      bool lv = 1, rv = u.isl ? tree[p.right].val : tree[p.left].val;\n      int x = lv * 2 + rv;\n      dp[id][0] = dp[u.p][p.val];\n      dp[id][1] = dp[u.p][p.dp[x]];\n    }\n  }\n  if (u.left) dfs2(u.left);\n  if (u.right) dfs2(u.right);\n}\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n;\n  for (int i = (1); i <= (n); i++) {\n    string type;\n    cin >> type;\n    if (type == \"IN\") {\n      int val;\n      cin >> val;\n      tree[i].val = val;\n    } else if (type == \"NOT\") {\n      cin >> tree[i].left;\n      tree[tree[i].left].p = i;\n      tree[tree[i].left].isl = true;\n      tree[i].type = 1;\n    } else {\n      cin >> tree[i].left >> tree[i].right;\n      tree[tree[i].left].p = i;\n      tree[tree[i].left].isl = true;\n      tree[tree[i].right].p = i;\n      if (type == \"OR\") {\n        tree[i].type = 2;\n      } else if (type == \"AND\") {\n        tree[i].type = 3;\n      } else {\n        tree[i].type = 4;\n      }\n    }\n  }\n  dfs(1);\n  dfs2(1);\n  for (int i = (1); i <= (n); i++) {\n    if (tree[i].type == 0) {\n      ans += '0' + dp[i][!tree[i].val];\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nenum Op { NOT, AND, IN, XOR, OR };\nstruct Node {\n  Op op;\n  int input[2];\n  int output;\n  int cache[2];\n  int value;\n  int get() {\n    if (value == -1) {\n      return run();\n    } else {\n      return value;\n    }\n  }\n  int run();\n} nodes[1000006];\nint Node::run() {\n  int ret;\n  if (op == NOT) {\n    ret = !nodes[input[0]].get();\n  } else if (op == OR) {\n    ret = nodes[input[0]].get() | nodes[input[1]].get();\n  } else if (op == XOR) {\n    ret = nodes[input[0]].get() ^ nodes[input[1]].get();\n  } else if (op == AND) {\n    ret = nodes[input[0]].get() & nodes[input[1]].get();\n  } else if (op == IN) {\n    ret = value;\n  }\n  value = ret;\n  return ret;\n}\nint solve(int i, int v) {\n  if (i == 1) {\n    return v;\n  }\n  if (nodes[i].cache[v] != -1) {\n    return nodes[i].cache[v];\n  }\n  int ov = nodes[i].value;\n  int ret = nodes[i].cache[ov];\n  nodes[i].value = v;\n  Node &nxt = nodes[nodes[i].output];\n  int nxt_v = nxt.value;\n  if (nxt.run() != nxt_v) {\n    nxt.value = nxt_v;\n    ret = solve(nodes[i].output, !nxt_v);\n  }\n  nxt.value = nxt_v;\n  nodes[i].value = ov;\n  nodes[i].cache[v] = ret;\n  return ret;\n}\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int> ins;\n  for (int i = 1; i <= n; i++) {\n    nodes[i].cache[0] = -1;\n    nodes[i].cache[1] = -1;\n    nodes[i].value = -1;\n    char t[5];\n    int a, b;\n    scanf(\"%s%d\", t, &a);\n    nodes[a].output = i;\n    switch (t[0]) {\n      case 'I':\n        nodes[i].op = IN;\n        nodes[i].value = a;\n        ins.push_back(i);\n        break;\n      case 'N':\n        nodes[i].op = NOT;\n        nodes[i].input[0] = a;\n        break;\n      case 'O':\n        nodes[i].op = OR;\n        nodes[i].input[0] = a;\n        scanf(\"%d\", &b);\n        nodes[i].input[1] = b;\n        nodes[b].output = i;\n        break;\n      case 'X':\n        nodes[i].op = XOR;\n        nodes[i].input[0] = a;\n        scanf(\"%d\", &b);\n        nodes[i].input[1] = b;\n        nodes[b].output = i;\n        break;\n      case 'A':\n        nodes[i].op = AND;\n        nodes[i].input[0] = a;\n        scanf(\"%d\", &b);\n        nodes[i].input[1] = b;\n        nodes[b].output = i;\n        break;\n    }\n  }\n  nodes[1].run();\n  for (int i = 1; i <= n; i++) {\n    int v = nodes[i].value;\n    nodes[i].cache[v] = nodes[1].value;\n  }\n  for (auto in : ins) {\n    int ans = solve(in, !nodes[in].value);\n    printf(\"%d\", ans);\n  }\n  puts(\"\");\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct {\n  int x, y, id;\n  char str[15];\n} Point;\nPoint s[1000005];\nint ans[1000005], flag[1000005];\nint Sech(int u) {\n  int i, p1, p2;\n  if (s[u].str[1] == 'I') return s[u].x;\n  if (s[u].str[1] == 'N') return Sech(s[u].x) ^ 1;\n  if (s[u].str[1] == 'X') return Sech(s[u].x) ^ Sech(s[u].y);\n  if (s[u].str[1] == 'A') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 0) flag[s[u].y] = 1;\n    if (p2 == 0) flag[s[u].x] = 1;\n    return p1 & p2;\n  }\n  if (s[u].str[1] == 'O') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 1) flag[s[u].y] = 1;\n    if (p2 == 1) flag[s[u].x] = 1;\n    return p1 | p2;\n  }\n  printf(\"WA\\n\");\n  return -1;\n}\nvoid Sech2(int u) {\n  int i, p1, p2;\n  if (flag[u]) return;\n  if (s[u].str[1] == 'I') ans[s[u].id] = 1;\n  if (s[u].str[1] == 'N') Sech2(s[u].x);\n  if (s[u].str[1] == 'X' || s[u].str[1] == 'A' || s[u].str[1] == 'O') {\n    Sech2(s[u].x);\n    Sech2(s[u].y);\n  }\n}\nint main(void) {\n  int n, i, now;\n  scanf(\"%d\", &n);\n  memset(ans, -1, sizeof(ans));\n  for (i = 1; i <= n; i++) {\n    scanf(\"%s\", s[i].str + 1);\n    if (s[i].str[1] == 'I' || s[i].str[1] == 'N')\n      scanf(\"%d\", &s[i].x);\n    else\n      scanf(\"%d%d\", &s[i].x, &s[i].y);\n    s[i].id = i;\n    if (s[i].str[1] == 'I') ans[i] = 0;\n  }\n  now = Sech(1);\n  Sech2(1);\n  for (i = 1; i <= n; i++) {\n    if (ans[i] == -1) continue;\n    printf(\"%d\", now ^ ans[i]);\n  }\n  puts(\"\");\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long INF = 1000000007;\nconst long long INF2 = 1000000007LL * 1000000007LL;\nconst long double EPS = 1e-9;\nconst int SIZE = 1001000;\nint n, a, b;\nstring fn[SIZE];\nint val[SIZE], ans[SIZE];\nint z[SIZE];\nvector<int> g[SIZE];\nvoid setVal(int v) {\n  if (fn[v][0] == 'I') {\n    return;\n  }\n  for (auto& i : g[v]) setVal(i);\n  if (fn[v][0] == 'A') {\n    val[v] = val[g[v][0]] && val[g[v][1]];\n    return;\n  }\n  if (fn[v][0] == 'O') {\n    val[v] = val[g[v][0]] || val[g[v][1]];\n    return;\n  }\n  if (fn[v][0] == 'X') {\n    val[v] = (val[g[v][0]] + val[g[v][1]]) % 2;\n    return;\n  }\n  val[v] = !val[g[v][0]];\n}\nvoid dfs(int v, int zn) {\n  if (fn[v][0] == 'I') {\n    z[v] = zn;\n    return;\n  }\n  if (zn == 0) {\n    for (auto& i : g[v]) dfs(i, 0);\n    return;\n  }\n  if (fn[v][0] == 'A') {\n    if (val[v] == 1) {\n      for (auto& i : g[v]) dfs(i, 1);\n    } else {\n      if (!val[g[v][0]] && val[g[v][1]]) {\n        dfs(g[v][0], 1);\n        dfs(g[v][1], 0);\n      } else if (val[g[v][0]] && !val[g[v][1]]) {\n        dfs(g[v][0], 0);\n        dfs(g[v][1], 1);\n      } else {\n        for (auto& i : g[v]) dfs(i, 0);\n      }\n    }\n    return;\n  }\n  if (fn[v][0] == 'O') {\n    if (val[v] == 0) {\n      for (auto& i : g[v]) dfs(i, 1);\n    } else {\n      if (val[g[v][0]] && val[g[v][1]]) {\n        dfs(g[v][0], 0);\n        dfs(g[v][1], 0);\n      } else if (!val[g[v][0]] && val[g[v][1]]) {\n        dfs(g[v][0], 0);\n        dfs(g[v][1], 1);\n      } else if (val[g[v][0]] && !val[g[v][1]]) {\n        dfs(g[v][0], 1);\n        dfs(g[v][1], 0);\n      }\n    }\n    return;\n  }\n  for (auto& i : g[v]) dfs(i, zn);\n}\nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> fn[i];\n    if (fn[i] == \"IN\") {\n      cin >> val[i];\n    } else if (fn[i] == \"NOT\") {\n      cin >> a;\n      --a;\n      g[i].push_back(a);\n    } else {\n      cin >> a;\n      --a;\n      g[i].push_back(a);\n      cin >> a;\n      --a;\n      g[i].push_back(a);\n    }\n  }\n  setVal(0);\n  dfs(0, 1);\n  for (int i = 0; i < n; ++i) {\n    if (fn[i][0] == 'I') {\n      if (z[i])\n        cout << !val[0];\n      else\n        cout << val[0];\n    }\n  }\n  return 0;\n}\n", "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = (int)1e6 + 10;\nint v1[N], v2[N], v[N], tp[N], op1[N], op2[N];\nint n;\nstruct UF {\n  int p[N], r[N];\n  void init() {\n    for (int i = 1; i <= n; i++) {\n      p[i] = i;\n      r[i] = 0;\n    }\n  }\n  int find(int x) {\n    if (p[x] == x) return x;\n    return p[x] = find(p[x]);\n  }\n  void merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (r[u] < r[v]) swap(u, v);\n    p[v] = u;\n    if (r[u] == r[v]) ++r[u];\n  }\n} uf;\nvoid dfs(int u) {\n  if (tp[u] == 1) {\n    v1[u] = op1[u];\n    v[u] = op1[u];\n    return;\n  }\n  if (tp[u] == 4) {\n    dfs(op1[u]);\n    v1[u] = v[u] = !v[op1[u]];\n    uf.merge(u, op1[u]);\n    return;\n  }\n  dfs(op1[u]);\n  dfs(op2[u]);\n  v1[u] = v[op1[u]];\n  v2[u] = v[op2[u]];\n  if (tp[u] == 2) {\n    v[u] = v1[u] & v2[u];\n    if (v1[u]) uf.merge(u, op2[u]);\n    if (v2[u]) uf.merge(u, op1[u]);\n  } else if (tp[u] == 3) {\n    v[u] = v1[u] ^ v2[u];\n    uf.merge(u, op1[u]);\n    uf.merge(u, op2[u]);\n  } else {\n    v[u] = v1[u] | v2[u];\n    if (!v1[u]) uf.merge(u, op2[u]);\n    if (!v2[u]) uf.merge(u, op1[u]);\n  }\n}\nint main() {\n  scanf(\"%d\", &n);\n  char cmd[30];\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%s\", cmd);\n    if (cmd[0] == 'I') {\n      tp[i] = 1;\n      scanf(\"%d\", op1 + i);\n    } else if (cmd[0] == 'A') {\n      tp[i] = 2;\n      scanf(\"%d%d\", op1 + i, op2 + i);\n    } else if (cmd[0] == 'X') {\n      tp[i] = 3;\n      scanf(\"%d%d\", op1 + i, op2 + i);\n    } else if (cmd[0] == 'N') {\n      tp[i] = 4;\n      scanf(\"%d\", op1 + i);\n    } else {\n      tp[i] = 5;\n      scanf(\"%d%d\", op1 + i, op2 + i);\n    }\n  }\n  uf.init();\n  dfs(1);\n  int t = uf.find(1);\n  for (int i = 1; i <= n; i++) {\n    if (tp[i] == 1) {\n      if (uf.find(i) == t)\n        printf(\"%d\", v[1] ^ 1);\n      else\n        printf(\"%d\", v[1]);\n    }\n  }\n  puts(\"\");\n}\n"], "original_code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct {\n  int x, y, id;\n  char str[15];\n} Point;\nPoint s[1000005];\nint ans[1000005], flag[1000005];\nint Sech(int u) {\n  int i, p1, p2;\n  if (s[u].str[1] == 'I') return s[u].x;\n  if (s[u].str[1] == 'N') return Sech(s[u].x) ^ 1;\n  if (s[u].str[1] == 'X') return Sech(s[u].x) ^ Sech(s[u].y);\n  if (s[u].str[1] == 'A') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 0) flag[s[u].y] = 1;\n    if (p2 == 0) flag[s[u].x] = 1;\n    return p1 & p2;\n  }\n  if (s[u].str[1] == 'O') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 1) flag[s[u].y] = 1;\n    if (p2 == 1) flag[s[u].x] = 1;\n    return p1 | p2;\n  }\n  printf(\"WA\\n\");\n  return -1;\n}\nvoid Sech2(int u) {\n  int i, p1, p2;\n  if (flag[u]) return;\n  if (s[u].str[1] == 'I') ans[s[u].id] = 1;\n  if (s[u].str[1] == 'N') Sech2(s[u].x);\n  if (s[u].str[1] == 'X' || s[u].str[1] == 'A' || s[u].str[1] == 'O') {\n    Sech2(s[u].x);\n    Sech2(s[u].y);\n  }\n}\nint main(void) {\n  int n, i, now;\n  scanf(\"%d\", &n);\n  memset(ans, -1, sizeof(ans));\n  for (i = 1; i <= n; i++) {\n    scanf(\"%s\", s[i].str + 1);\n    if (s[i].str[1] == 'I' || s[i].str[1] == 'N')\n      scanf(\"%d\", &s[i].x);\n    else\n      scanf(\"%d%d\", &s[i].x, &s[i].y);\n    s[i].id = i;\n    if (s[i].str[1] == 'I') ans[i] = 0;\n  }\n  now = Sech(1);\n  Sech2(1);\n  for (i = 1; i <= n; i++) {\n    if (ans[i] == -1) continue;\n    printf(\"%d\", now ^ ans[i]);\n  }\n  puts(\"\");\n  return 0;\n}\n", "language": "cpp"}, "status": "success", "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct {\n  int x, y, id;\n  char str[15];\n} Point;\nPoint s[1000005];\nint ans[1000005], flag[1000005];\nint Sech(int u) {\n  int i, p1, p2;\n  if (s[u].str[1] == 'I') return s[u].x;\n  if (s[u].str[1] == 'N') return Sech(s[u].x) ^ 1;\n  if (s[u].str[1] == 'X') return Sech(s[u].x) ^ Sech(s[u].y);\n  if (s[u].str[1] == 'A') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 0) flag[s[u].y] = 1;\n    if (p2 == 0) flag[s[u].x] = 1;\n    return p1 & p2;\n  }\n  if (s[u].str[1] == 'O') {\n    p1 = Sech(s[u].x), p2 = Sech(s[u].y);\n    if (p1 == 1) flag[s[u].y] = 1;\n    if (p2 == 1) flag[s[u].x] = 1;\n    return p1 | p2;\n  }\n  printf(\"WA\\n\");\n  return -1;\n}\nvoid Sech2(int u) {\n  int i, p1, p2;\n  if (flag[u]) return;\n  if (s[u].str[1] == 'I') ans[s[u].id] = 1;\n  if (s[u].str[1] == 'N') Sech2(s[u].x);\n  if (s[u].str[1] == 'X' || s[u].str[1] == 'A' || s[u].str[1] == 'O') {\n    Sech2(s[u].x);\n    Sech2(s[u].y);\n  }\n}\nint main(void) {\n  int n, i, now;\n  scanf(\"%d\", &n);\n  memset(ans, -1, sizeof(ans));\n  for (i = 1; i <= n; i++) {\n    scanf(\"%s\", s[i].str + 1);\n    if (s[i].str[1] == 'I' || s[i].str[1] == 'N')\n      scanf(\"%d\", &s[i].x);\n    else\n      scanf(\"%d%d\", &s[i].x, &s[i].y);\n    s[i].id = i;\n    if (s[i].str[1] == 'I') ans[i] = 0;\n  }\n  now = Sech(1);\n  Sech2(1);\n  for (i = 1; i <= n; i++) {\n    if (ans[i] == -1) continue;\n    printf(\"%d\", now ^ ans[i]);\n  }\n  puts(\"\");\n  return 0;\n}\n", "pass_ratio": 1.0, "tests_passed": 1, "tests_total": 1, "iterations": 1, "history": [], "model_type": "human", "model_name": "human"}]