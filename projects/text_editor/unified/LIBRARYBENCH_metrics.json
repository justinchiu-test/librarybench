{
    "total_logprobs": -46953.285033604756,
    "total_tokens": 92467,
    "unified/tests/student/conftest.py": {
        "logprobs": -201.032355782793,
        "metrics": {
            "loc": 7,
            "sloc": 1,
            "lloc": 2,
            "comments": 1,
            "multi": 3,
            "blank": 2,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/writer_text_editor/utils/__init__.py": {
        "logprobs": -200.068299298726,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/study/manager.py": {
        "logprobs": -1803.2921492793178,
        "metrics": {
            "loc": 636,
            "sloc": 310,
            "lloc": 233,
            "comments": 41,
            "multi": 160,
            "blank": 127,
            "cyclomatic": 90,
            "internal_imports": [
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n\n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(event_type=\"start\", details=\"Session started\")\n        )\n\n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n\n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(StudySessionEvent(event_type=\"pause\", details=reason))\n\n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(\n            StudySessionEvent(event_type=\"resume\", details=\"Session resumed\")\n        )\n\n    def complete(\n        self, achievements: Optional[List[str]] = None, rating: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Complete the study session.\n\n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n\n        if achievements:\n            self.achievements = achievements\n\n        if rating:\n            self.rating = rating\n\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=\"Session completed\")\n        )\n\n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n\n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=f\"Session cancelled: {reason}\")\n        )\n\n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n\n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(StudySessionEvent(event_type=\"note\", details=note))\n\n    def record_distraction(\n        self, details: Optional[str] = None, duration_seconds: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n\n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\", details=details, duration=duration_seconds\n            )\n        )\n\n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n\n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n\n        end_time = self.actual_end_time or time.time()\n\n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n\n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= event.timestamp - pause_start\n                pause_start = None\n\n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= end_time - pause_start\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n\n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n\n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n\n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n\n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n\n        if total_minutes <= 0:\n            return 0\n\n        return max(\n            0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100)\n        )",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n\n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(event_type=\"start\", details=\"Session started\")\n        )\n\n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n\n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(StudySessionEvent(event_type=\"pause\", details=reason))\n\n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(\n            StudySessionEvent(event_type=\"resume\", details=\"Session resumed\")\n        )\n\n    def complete(\n        self, achievements: Optional[List[str]] = None, rating: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Complete the study session.\n\n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n\n        if achievements:\n            self.achievements = achievements\n\n        if rating:\n            self.rating = rating\n\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=\"Session completed\")\n        )\n\n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n\n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=f\"Session cancelled: {reason}\")\n        )\n\n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n\n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(StudySessionEvent(event_type=\"note\", details=note))\n\n    def record_distraction(\n        self, details: Optional[str] = None, duration_seconds: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n\n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\", details=details, duration=duration_seconds\n            )\n        )\n\n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n\n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n\n        end_time = self.actual_end_time or time.time()\n\n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n\n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= event.timestamp - pause_start\n                pause_start = None\n\n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= end_time - pause_start\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n\n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n\n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n\n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n\n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n\n        if total_minutes <= 0:\n            return 0\n\n        return max(\n            0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100)\n        )",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n\n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(event_type=\"start\", details=\"Session started\")\n        )\n\n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n\n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(StudySessionEvent(event_type=\"pause\", details=reason))\n\n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(\n            StudySessionEvent(event_type=\"resume\", details=\"Session resumed\")\n        )\n\n    def complete(\n        self, achievements: Optional[List[str]] = None, rating: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Complete the study session.\n\n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n\n        if achievements:\n            self.achievements = achievements\n\n        if rating:\n            self.rating = rating\n\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=\"Session completed\")\n        )\n\n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n\n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=f\"Session cancelled: {reason}\")\n        )\n\n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n\n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(StudySessionEvent(event_type=\"note\", details=note))\n\n    def record_distraction(\n        self, details: Optional[str] = None, duration_seconds: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n\n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\", details=details, duration=duration_seconds\n            )\n        )\n\n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n\n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n\n        end_time = self.actual_end_time or time.time()\n\n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n\n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= event.timestamp - pause_start\n                pause_start = None\n\n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= end_time - pause_start\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n\n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n\n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n\n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n\n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n\n        if total_minutes <= 0:\n            return 0\n\n        return max(\n            0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100)\n        )",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n\n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(event_type=\"start\", details=\"Session started\")\n        )\n\n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n\n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(StudySessionEvent(event_type=\"pause\", details=reason))\n\n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n\n        self.events.append(\n            StudySessionEvent(event_type=\"resume\", details=\"Session resumed\")\n        )\n\n    def complete(\n        self, achievements: Optional[List[str]] = None, rating: Optional[int] = None\n    ) -> None:\n        \"\"\"\n        Complete the study session.\n\n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n\n        if achievements:\n            self.achievements = achievements\n\n        if rating:\n            self.rating = rating\n\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=\"Session completed\")\n        )\n\n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n\n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(event_type=\"end\", details=f\"Session cancelled: {reason}\")\n        )\n\n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n\n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(StudySessionEvent(event_type=\"note\", details=note))\n\n    def record_distraction(\n        self, details: Optional[str] = None, duration_seconds: Optional[float] = None\n    ) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n\n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\", details=details, duration=duration_seconds\n            )\n        )\n\n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n\n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n\n        end_time = self.actual_end_time or time.time()\n\n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n\n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= event.timestamp - pause_start\n                pause_start = None\n\n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= end_time - pause_start\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n\n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n\n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n\n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n\n        return total_seconds / 60  # Convert to minutes\n\n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n\n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n\n        if total_minutes <= 0:\n            return 0\n\n        return max(\n            0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100)\n        )",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(\n        default_factory=SpacedRepetitionAlgorithm\n    )\n\n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n\n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n\n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n\n        Args:\n            session_id: ID of the session to retrieve\n\n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n\n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look ahead\n\n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n\n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look back\n\n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if (\n                session.status == StudySessionStatus.COMPLETED\n                or session.status == StudySessionStatus.CANCELLED\n            )\n            and session.planned_start_time >= cutoff\n        ]\n\n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n\n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.planned_start_time = new_start_time\n        return True\n\n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n\n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.cancel(reason)\n        return True\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(\n        default_factory=SpacedRepetitionAlgorithm\n    )\n\n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n\n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n\n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n\n        Args:\n            session_id: ID of the session to retrieve\n\n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n\n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look ahead\n\n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n\n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look back\n\n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if (\n                session.status == StudySessionStatus.COMPLETED\n                or session.status == StudySessionStatus.CANCELLED\n            )\n            and session.planned_start_time >= cutoff\n        ]\n\n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n\n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.planned_start_time = new_start_time\n        return True\n\n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n\n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.cancel(reason)\n        return True\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(\n        default_factory=SpacedRepetitionAlgorithm\n    )\n\n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n\n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n\n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n\n        Args:\n            session_id: ID of the session to retrieve\n\n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n\n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look ahead\n\n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n\n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look back\n\n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if (\n                session.status == StudySessionStatus.COMPLETED\n                or session.status == StudySessionStatus.CANCELLED\n            )\n            and session.planned_start_time >= cutoff\n        ]\n\n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n\n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.planned_start_time = new_start_time\n        return True\n\n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n\n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.cancel(reason)\n        return True\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(\n        default_factory=SpacedRepetitionAlgorithm\n    )\n\n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n\n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n\n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n\n        Args:\n            session_id: ID of the session to retrieve\n\n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n\n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look ahead\n\n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n\n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n\n        Args:\n            days: Number of days to look back\n\n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n\n        return [\n            session\n            for session in self.sessions.values()\n            if (\n                session.status == StudySessionStatus.COMPLETED\n                or session.status == StudySessionStatus.CANCELLED\n            )\n            and session.planned_start_time >= cutoff\n        ]\n\n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n\n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.planned_start_time = new_start_time\n        return True\n\n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n\n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n\n        session.cancel(reason)\n        return True\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n\n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = (\n                2.5  # This would be stored with the topic in a real implementation\n            )\n            repetition_count = topic.repetition_count\n\n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (\n                    topic.next_review - topic.last_studied\n                ) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n\n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)),\n            ),\n        )\n\n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n\n        # Cap the interval\n        interval_days = min(\n            self.interval_max_days, max(self.interval_min_days, interval_days)\n        )\n\n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n\n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n\n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = (\n                2.5  # This would be stored with the topic in a real implementation\n            )\n            repetition_count = topic.repetition_count\n\n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (\n                    topic.next_review - topic.last_studied\n                ) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n\n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)),\n            ),\n        )\n\n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n\n        # Cap the interval\n        interval_days = min(\n            self.interval_max_days, max(self.interval_min_days, interval_days)\n        )\n\n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n\n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n\n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = (\n                2.5  # This would be stored with the topic in a real implementation\n            )\n            repetition_count = topic.repetition_count\n\n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (\n                    topic.next_review - topic.last_studied\n                ) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n\n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)),\n            ),\n        )\n\n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n\n        # Cap the interval\n        interval_days = min(\n            self.interval_max_days, max(self.interval_min_days, interval_days)\n        )\n\n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n\n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n\n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n\n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n\n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n\n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = (\n                2.5  # This would be stored with the topic in a real implementation\n            )\n            repetition_count = topic.repetition_count\n\n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (\n                    topic.next_review - topic.last_studied\n                ) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n\n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)),\n            ),\n        )\n\n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n\n        # Cap the interval\n        interval_days = min(\n            self.interval_max_days, max(self.interval_min_days, interval_days)\n        )\n\n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n\n        return next_review"
            ]
        }
    },
    "unified/text_editor/core/history.py": {
        "logprobs": -864.1315884565153,
        "metrics": {
            "loc": 287,
            "sloc": 160,
            "lloc": 111,
            "comments": 12,
            "multi": 72,
            "blank": 45,
            "cyclomatic": 38,
            "internal_imports": [
                "class History(BaseHistory):\n    \"\"\"\n    Manages the history of editing operations for undo/redo functionality.\n\n    This class extends the common library's History class to maintain\n    backward compatibility with the original History.\n    \"\"\"\n\n    def record_insert(self, line: int, col: int, text: str) -> None:\n        \"\"\"\n        Record an insert operation.\n\n        Args:\n            line: Line where text was inserted\n            col: Column where text was inserted\n            text: Text that was inserted\n        \"\"\"\n        position = LineColumnPosition(line=line, column=col)\n        operation = self.create_insert_operation(position, text)\n        self.record_operation(operation)\n\n    def record_delete(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a delete operation.\n\n        Args:\n            start_line: Starting line of deleted text\n            start_col: Starting column of deleted text\n            end_line: Ending line of deleted text\n            end_col: Ending column of deleted text\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_delete_operation(\n            start_position, end_position, deleted_text\n        )\n        self.record_operation(operation)\n\n    def record_replace(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a replace operation.\n\n        Args:\n            start_line: Starting line of replaced text\n            start_col: Starting column of replaced text\n            end_line: Ending line of replaced text\n            end_col: Ending column of replaced text\n            new_text: The text that was inserted\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_replace_operation(\n            start_position, end_position, new_text, deleted_text\n        )\n        self.record_operation(operation)\n\n    # Add compatibility methods for the old API\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return super().can_undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return super().can_redo()\n\n    def undo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last operation for undoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will undo the operation.\n\n        Args:\n            content: Optional content object to apply the undo to\n\n        Returns:\n            The operation to undo, or None if there are no operations to undo\n        \"\"\"\n        if not self.can_undo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.undo_stack[-1]\n\n        # If content is provided, apply the undo\n        if content is not None:\n            super().undo(content)\n        else:\n            # Just remove from the undo stack and add to redo stack without applying\n            self.undo_stack.pop()\n            self.redo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def redo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last undone operation for redoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will redo the operation.\n\n        Args:\n            content: Optional content object to apply the redo to\n\n        Returns:\n            The operation to redo, or None if there are no operations to redo\n        \"\"\"\n        if not self.can_redo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.redo_stack[-1]\n\n        # If content is provided, apply the redo\n        if content is not None:\n            super().redo(content)\n        else:\n            # Just remove from the redo stack and add to undo stack without applying\n            self.redo_stack.pop()\n            self.undo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        super().clear()",
                "class History(BaseModel):\n    \"\"\"\n    Tracks and manages the history of operations for undo/redo functionality.\n    \"\"\"\n\n    undo_stack: List[Operation] = Field(default_factory=list)\n    redo_stack: List[Operation] = Field(default_factory=list)\n    max_history_size: int = 1000\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n\n        arbitrary_types_allowed = True\n\n    def record_operation(self, operation: Operation) -> None:\n        \"\"\"\n        Record an operation in the history.\n\n        Args:\n            operation: The operation to record\n        \"\"\"\n        self.undo_stack.append(operation)\n        self.redo_stack.clear()  # Clear redo stack when a new operation is recorded\n\n        # Limit history size\n        if len(self.undo_stack) > self.max_history_size:\n            self.undo_stack.pop(0)\n\n    def undo(self, content: TextContent) -> bool:\n        \"\"\"\n        Undo the last operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        if not self.undo_stack:\n            return False\n\n        operation = self.undo_stack.pop()\n        operation.undo(content)\n        self.redo_stack.append(operation)\n        return True\n\n    def redo(self, content: TextContent) -> bool:\n        \"\"\"\n        Redo the last undone operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        if not self.redo_stack:\n            return False\n\n        operation = self.redo_stack.pop()\n        operation.apply(content)\n        self.undo_stack.append(operation)\n        return True\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return len(self.undo_stack) > 0\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return len(self.redo_stack) > 0\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        self.undo_stack.clear()\n        self.redo_stack.clear()\n\n    @staticmethod\n    def create_insert_operation(position: Position, text: str) -> InsertOperation:\n        \"\"\"\n        Create an insert operation.\n\n        Args:\n            position: The position where text was inserted\n            text: The text that was inserted\n\n        Returns:\n            An InsertOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize position based on type\n        if isinstance(position, LineColumnPosition):\n            position_dict = {\"line\": position.line, \"column\": position.column}\n        elif isinstance(position, StructuredPosition):\n            position_dict = position.dict()\n        else:\n            raise ValueError(f\"Unsupported position type: {type(position)}\")\n\n        return InsertOperation(position=position_dict, text=text)\n\n    @staticmethod\n    def create_delete_operation(\n        start: Position, end: Position, deleted_text: str\n    ) -> DeleteOperation:\n        \"\"\"\n        Create a delete operation.\n\n        Args:\n            start: The start position of deleted text\n            end: The end position of deleted text\n            deleted_text: The text that was deleted\n\n        Returns:\n            A DeleteOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return DeleteOperation(\n            start_position=start_dict, end_position=end_dict, deleted_text=deleted_text\n        )\n\n    @staticmethod\n    def create_replace_operation(\n        start: Position, end: Position, new_text: str, old_text: str\n    ) -> ReplaceOperation:\n        \"\"\"\n        Create a replace operation.\n\n        Args:\n            start: The start position of replaced text\n            end: The end position of replaced text\n            new_text: The text that was inserted\n            old_text: The text that was replaced\n\n        Returns:\n            A ReplaceOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return ReplaceOperation(\n            start_position=start_dict,\n            end_position=end_dict,\n            new_text=new_text,\n            old_text=old_text,\n        )",
                "class Operation(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for operations that can be applied, undone, and redone.\n\n    Operations represent atomic changes to text content that can be\n    tracked, undone, and redone by a history system.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n\n    @abstractmethod\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass",
                "class InsertOperation(Operation):\n    \"\"\"\n    An operation that inserts text at a specified position.\n    \"\"\"\n\n    position: Dict[str, Any]  # Serialized position\n    text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"insert\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.position)\n\n        content.insert(position, self.text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            start_position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n\n            # Calculate end position based on inserted text\n            lines = self.text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"],\n                    column=self.position[\"column\"] + len(self.text),\n                )\n            else:\n                # Multi-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"] + len(lines) - 1, column=len(lines[-1])\n                )\n        else:\n            # For structured positions, we can only undo by position\n            # This is a simplification; real implementation would need more context\n            start_position = StructuredPosition(**self.position)\n            end_position = start_position\n\n        content.delete(start_position, end_position)",
                "class DeleteOperation(Operation):\n    \"\"\"\n    An operation that deletes text between specified positions.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    deleted_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"delete\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.delete(start_position, end_position)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.start_position)\n\n        content.insert(position, self.deleted_text)",
                "class ReplaceOperation(Operation):\n    \"\"\"\n    An operation that replaces text between specified positions with new text.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    new_text: str\n    old_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"replace\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.new_text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n\n            # Calculate end position based on new text\n            lines = self.new_text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"],\n                    column=self.start_position[\"column\"] + len(self.new_text),\n                )\n            else:\n                # Multi-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"] + len(lines) - 1,\n                    column=len(lines[-1]),\n                )\n        else:\n            # For structured positions, we use the original end position\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.old_text)",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass"
            ]
        }
    },
    "unified/common/core/__init__.py": {
        "logprobs": -332.03043772291136,
        "metrics": {
            "loc": 21,
            "sloc": 14,
            "lloc": 5,
            "comments": 0,
            "multi": 5,
            "blank": 2,
            "cyclomatic": 0,
            "internal_imports": [
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass",
                "class LineBasedTextContent(TextContent):\n    \"\"\"\n    A text content implementation that stores text as a list of lines.\n\n    This implementation is suited for simple line-based text editors,\n    where operations are primarily performed using line and column coordinates.\n    \"\"\"\n\n    lines: List[str] = Field(default_factory=lambda: [\"\"])\n\n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new line-based text content with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__()\n        self.lines = content.split(\"\\n\") if content else [\"\"]\n\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted (must be LineColumnPosition)\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid or not a LineColumnPosition\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        if not isinstance(position, LineColumnPosition):\n            raise ValueError(\"Position must be a LineColumnPosition\")\n\n        line, column = position.line, position.column\n\n        # Ensure position is valid\n        if not (0 <= line < len(self.lines)):\n            raise ValueError(f\"Line number {line} out of range\")\n\n        current_line = self.lines[line]\n        if not (0 <= column <= len(current_line)):\n            raise ValueError(f\"Column number {column} out of range for line {line}\")\n\n        # Handle multi-line insertion\n        if \"\\n\" in text:\n            # Split the text into lines\n            new_lines = text.split(\"\\n\")\n\n            # Handle the first line (insert at the current position)\n            first_part = current_line[:column]\n            last_part = current_line[column:]\n\n            # Create the new set of lines\n            new_content = [first_part + new_lines[0]]\n            new_content.extend(new_lines[1:-1])\n            new_content.append(new_lines[-1] + last_part)\n\n            # Update the buffer\n            self.lines[line : line + 1] = new_content\n        else:\n            # Simple single-line insertion\n            new_line = current_line[:column] + text + current_line[column:]\n            self.lines[line] = new_line\n\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete (must be LineColumnPosition)\n            end: The end position of the text to delete (must be LineColumnPosition)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        if not isinstance(start, LineColumnPosition) or not isinstance(\n            end, LineColumnPosition\n        ):\n            raise ValueError(\"Positions must be LineColumnPositions\")\n\n        start_line, start_col = start.line, start.column\n        end_line, end_col = end.line, end.column\n\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n\n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise ValueError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise ValueError(f\"End line {end_line} out of range\")\n\n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n\n        if not (0 <= start_col <= len(start_line_text)):\n            raise ValueError(\n                f\"Start column {start_col} out of range for line {start_line}\"\n            )\n        if not (0 <= end_col <= len(end_line_text)):\n            raise ValueError(f\"End column {end_col} out of range for line {end_line}\")\n\n        # Handle deletion within a single line\n        if start_line == end_line:\n            deleted_text = start_line_text[start_col:end_col]\n            self.lines[start_line] = (\n                start_line_text[:start_col] + start_line_text[end_col:]\n            )\n            return deleted_text\n\n        # Handle multi-line deletion\n        deleted_lines = []\n\n        # Get the first partial line\n        deleted_lines.append(start_line_text[start_col:])\n\n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            deleted_lines.extend(self.lines[start_line + 1 : end_line])\n\n        # Get the last partial line\n        deleted_lines.append(end_line_text[:end_col])\n\n        # Join the deleted text\n        deleted_text = \"\\n\".join(deleted_lines)\n\n        # Update the buffer\n        new_line = start_line_text[:start_col] + end_line_text[end_col:]\n        self.lines[start_line : end_line + 1] = [new_line]\n\n        return deleted_text\n\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace (must be LineColumnPosition)\n            end: The end position of the text to replace (must be LineColumnPosition)\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        # Delete the text first and get what was deleted\n        deleted_text = self.delete(start, end)\n\n        # Insert the new text\n        self.insert(start, text)\n\n        return deleted_text\n\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        # If no positions provided, return all content\n        if start is None and end is None:\n            return \"\\n\".join(self.lines)\n\n        # Convert None to start/end of content\n        if start is None:\n            start = LineColumnPosition(line=0, column=0)\n        if end is None:\n            last_line = len(self.lines) - 1\n            end = LineColumnPosition(line=last_line, column=len(self.lines[last_line]))\n\n        # Validate position types\n        if not isinstance(start, LineColumnPosition) or not isinstance(\n            end, LineColumnPosition\n        ):\n            raise ValueError(\"Positions must be LineColumnPositions\")\n\n        start_line, start_col = start.line, start.column\n        end_line, end_col = end.line, end.column\n\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n\n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise ValueError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise ValueError(f\"End line {end_line} out of range\")\n\n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n\n        if not (0 <= start_col <= len(start_line_text)):\n            raise ValueError(\n                f\"Start column {start_col} out of range for line {start_line}\"\n            )\n        if not (0 <= end_col <= len(end_line_text)):\n            raise ValueError(f\"End column {end_col} out of range for line {end_line}\")\n\n        # Handle text within a single line\n        if start_line == end_line:\n            return start_line_text[start_col:end_col]\n\n        # Handle multi-line text\n        result_lines = []\n\n        # Get the first partial line\n        result_lines.append(start_line_text[start_col:])\n\n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            result_lines.extend(self.lines[start_line + 1 : end_line])\n\n        # Get the last partial line\n        result_lines.append(end_line_text[:end_col])\n\n        # Join and return the text\n        return \"\\n\".join(result_lines)\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        return len(self.lines)\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        if 0 <= line_number < len(self.lines):\n            return self.lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        return len(re.findall(r\"\\b\\w+\\b\", self.get_text()))\n\n    def clear(self) -> None:\n        \"\"\"Clear the content, removing all text.\"\"\"\n        self.lines = [\"\"]",
                "class StructuredTextContent(TextContent):\n    \"\"\"\n    A text content implementation that stores text in a structured document.\n\n    This implementation is suited for complex document structures with\n    sections, segments, and revision tracking.\n    \"\"\"\n\n    title: str\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n\n        arbitrary_types_allowed = True\n\n    def __init__(self, title: str = \"Untitled\", **data: Any):\n        \"\"\"\n        Initialize a new structured text content with the given title.\n\n        Args:\n            title: Document title (default: \"Untitled\")\n        \"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(title=title, current_revision=initial_revision, **data)\n        self.revisions[\"Initial\"] = initial_revision\n\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted (must be StructuredPosition)\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid or not a StructuredPosition\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(position, StructuredPosition):\n            raise ValueError(\"Position must be a StructuredPosition\")\n\n        # Handle different element types\n        if position.element_type == StructuredElementType.SECTION:\n            # Find the section\n            for section in self.current_revision.sections:\n                if section.id == position.element_id:\n                    # Add a new segment with the text\n                    section.add_segment(text)\n                    self.updated_at = datetime.now()\n                    return\n            raise ValueError(f\"Section with ID {position.element_id} not found\")\n\n        elif position.element_type == StructuredElementType.SEGMENT:\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == position.element_id:\n                        # Append text to the segment\n                        segment.content += text\n                        self.updated_at = datetime.now()\n                        return\n            raise ValueError(f\"Segment with ID {position.element_id} not found\")\n\n        else:\n            raise ValueError(f\"Unsupported element type: {position.element_type}\")\n\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete (must be StructuredPosition)\n            end: The end position of the text to delete (must be StructuredPosition)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(start, StructuredPosition) or not isinstance(\n            end, StructuredPosition\n        ):\n            raise ValueError(\"Positions must be StructuredPositions\")\n\n        # Simple case: delete a segment\n        if (\n            start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for i, segment in enumerate(section.segments):\n                    if segment.id == start.element_id:\n                        deleted_text = segment.content\n                        section.delete_segment(i)\n                        self.updated_at = datetime.now()\n                        return deleted_text\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex deletion across multiple elements would be implemented here\n        raise NotImplementedError(\n            \"Deletion across multiple elements is not yet implemented\"\n        )\n\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace (must be StructuredPosition)\n            end: The end position of the text to replace (must be StructuredPosition)\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(start, StructuredPosition) or not isinstance(\n            end, StructuredPosition\n        ):\n            raise ValueError(\"Positions must be StructuredPositions\")\n\n        # Simple case: replace a segment\n        if (\n            start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == start.element_id:\n                        old_text = segment.content\n                        segment.content = text\n                        self.updated_at = datetime.now()\n                        return old_text\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex replacement across multiple elements would be implemented here\n        raise NotImplementedError(\n            \"Replacement across multiple elements is not yet implemented\"\n        )\n\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        # If no positions provided, return all content\n        if start is None and end is None:\n            return \"\\n\\n\".join(\n                [\n                    f\"# {section.title}\\n\\n{section.get_content()}\"\n                    for section in self.current_revision.sections\n                ]\n            )\n\n        if start is not None and not isinstance(start, StructuredPosition):\n            raise ValueError(\"Start position must be a StructuredPosition\")\n\n        if end is not None and not isinstance(end, StructuredPosition):\n            raise ValueError(\"End position must be a StructuredPosition\")\n\n        # Simple case: get text of a segment\n        if (\n            start is not None\n            and end is not None\n            and start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == start.element_id:\n                        return segment.content\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # Simple case: get text of a section\n        if (\n            start is not None\n            and end is not None\n            and start.element_type == StructuredElementType.SECTION\n            and end.element_type == StructuredElementType.SECTION\n            and start.element_id == end.element_id\n        ):\n            # Find the section\n            for section in self.current_revision.sections:\n                if section.id == start.element_id:\n                    return f\"# {section.title}\\n\\n{section.get_content()}\"\n\n            raise ValueError(f\"Section with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex text retrieval across multiple elements would be implemented here\n        if start is not None and end is not None:\n            raise NotImplementedError(\n                \"Text retrieval across multiple elements is not yet implemented\"\n            )\n\n        # If only start is provided, get text from that element to the end\n        if start is not None:\n            if start.element_type == StructuredElementType.SECTION:\n                found = False\n                section_texts = []\n\n                for section in self.current_revision.sections:\n                    if section.id == start.element_id or found:\n                        section_texts.append(\n                            f\"# {section.title}\\n\\n{section.get_content()}\"\n                        )\n                        found = True\n\n                if found:\n                    return \"\\n\\n\".join(section_texts)\n\n                raise ValueError(f\"Section with ID {start.element_id} not found\")\n\n            elif start.element_type == StructuredElementType.SEGMENT:\n                found_section = None\n                found_index = -1\n\n                # Find the segment and its section\n                for section in self.current_revision.sections:\n                    for i, segment in enumerate(section.segments):\n                        if segment.id == start.element_id:\n                            found_section = section\n                            found_index = i\n                            break\n                    if found_section:\n                        break\n\n                if found_section:\n                    # Get remaining segments in this section\n                    section_texts = [\n                        segment.content\n                        for segment in found_section.segments[found_index:]\n                    ]\n\n                    # Get all following sections\n                    found = False\n                    for section in self.current_revision.sections:\n                        if section.id == found_section.id:\n                            found = True\n                            continue\n\n                        if found:\n                            section_texts.append(\n                                f\"# {section.title}\\n\\n{section.get_content()}\"\n                            )\n\n                    return \"\\n\\n\".join(section_texts)\n\n                raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # If only end is provided, get text from the beginning to that element\n        if end is not None:\n            # Similar implementation to the start-only case, but from beginning to end\n            # Omitted for brevity\n            pass\n\n        # This point should not be reached due to the checks above\n        return \"\"\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        This is an approximation for structured content.\n\n        Returns:\n            The approximate number of lines\n        \"\"\"\n        # Count newlines in the full content\n        return self.get_text().count(\"\\n\") + 1\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        This is an approximation for structured content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        lines = self.get_text().split(\"\\n\")\n        if 0 <= line_number < len(lines):\n            return lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        return sum(\n            section.get_word_count() for section in self.current_revision.sections\n        )\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"\n        Add a new section to the document.\n\n        Args:\n            title: The section title\n            metadata: Optional metadata for the section\n\n        Returns:\n            The newly created section\n        \"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"\n        Create a new revision of the document.\n\n        Args:\n            name: The revision name\n            metadata: Optional metadata for the revision\n\n        Returns:\n            The newly created revision\n        \"\"\"\n        # Deep copy the current revision\n        import copy\n\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n\n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n\n        return new_revision",
                "class Position(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for positions within text content.\n\n    This class defines the interface for all position types, with methods for\n    moving the position in different directions and validating against content.\n    \"\"\"\n\n    @abstractmethod\n    def move_up(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position up by the specified number of units.\n\n        Args:\n            count: Number of units to move up (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_down(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position down by the specified number of units.\n\n        Args:\n            count: Number of units to move down (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_left(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position left by the specified number of units.\n\n        Args:\n            count: Number of units to move left (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_right(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position right by the specified number of units.\n\n        Args:\n            count: Number of units to move right (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        pass",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class History(BaseHistory):\n    \"\"\"\n    Manages the history of editing operations for undo/redo functionality.\n\n    This class extends the common library's History class to maintain\n    backward compatibility with the original History.\n    \"\"\"\n\n    def record_insert(self, line: int, col: int, text: str) -> None:\n        \"\"\"\n        Record an insert operation.\n\n        Args:\n            line: Line where text was inserted\n            col: Column where text was inserted\n            text: Text that was inserted\n        \"\"\"\n        position = LineColumnPosition(line=line, column=col)\n        operation = self.create_insert_operation(position, text)\n        self.record_operation(operation)\n\n    def record_delete(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a delete operation.\n\n        Args:\n            start_line: Starting line of deleted text\n            start_col: Starting column of deleted text\n            end_line: Ending line of deleted text\n            end_col: Ending column of deleted text\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_delete_operation(\n            start_position, end_position, deleted_text\n        )\n        self.record_operation(operation)\n\n    def record_replace(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a replace operation.\n\n        Args:\n            start_line: Starting line of replaced text\n            start_col: Starting column of replaced text\n            end_line: Ending line of replaced text\n            end_col: Ending column of replaced text\n            new_text: The text that was inserted\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_replace_operation(\n            start_position, end_position, new_text, deleted_text\n        )\n        self.record_operation(operation)\n\n    # Add compatibility methods for the old API\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return super().can_undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return super().can_redo()\n\n    def undo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last operation for undoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will undo the operation.\n\n        Args:\n            content: Optional content object to apply the undo to\n\n        Returns:\n            The operation to undo, or None if there are no operations to undo\n        \"\"\"\n        if not self.can_undo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.undo_stack[-1]\n\n        # If content is provided, apply the undo\n        if content is not None:\n            super().undo(content)\n        else:\n            # Just remove from the undo stack and add to redo stack without applying\n            self.undo_stack.pop()\n            self.redo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def redo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last undone operation for redoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will redo the operation.\n\n        Args:\n            content: Optional content object to apply the redo to\n\n        Returns:\n            The operation to redo, or None if there are no operations to redo\n        \"\"\"\n        if not self.can_redo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.redo_stack[-1]\n\n        # If content is provided, apply the redo\n        if content is not None:\n            super().redo(content)\n        else:\n            # Just remove from the redo stack and add to undo stack without applying\n            self.redo_stack.pop()\n            self.undo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        super().clear()",
                "class History(BaseModel):\n    \"\"\"\n    Tracks and manages the history of operations for undo/redo functionality.\n    \"\"\"\n\n    undo_stack: List[Operation] = Field(default_factory=list)\n    redo_stack: List[Operation] = Field(default_factory=list)\n    max_history_size: int = 1000\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n\n        arbitrary_types_allowed = True\n\n    def record_operation(self, operation: Operation) -> None:\n        \"\"\"\n        Record an operation in the history.\n\n        Args:\n            operation: The operation to record\n        \"\"\"\n        self.undo_stack.append(operation)\n        self.redo_stack.clear()  # Clear redo stack when a new operation is recorded\n\n        # Limit history size\n        if len(self.undo_stack) > self.max_history_size:\n            self.undo_stack.pop(0)\n\n    def undo(self, content: TextContent) -> bool:\n        \"\"\"\n        Undo the last operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        if not self.undo_stack:\n            return False\n\n        operation = self.undo_stack.pop()\n        operation.undo(content)\n        self.redo_stack.append(operation)\n        return True\n\n    def redo(self, content: TextContent) -> bool:\n        \"\"\"\n        Redo the last undone operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        if not self.redo_stack:\n            return False\n\n        operation = self.redo_stack.pop()\n        operation.apply(content)\n        self.undo_stack.append(operation)\n        return True\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return len(self.undo_stack) > 0\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return len(self.redo_stack) > 0\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        self.undo_stack.clear()\n        self.redo_stack.clear()\n\n    @staticmethod\n    def create_insert_operation(position: Position, text: str) -> InsertOperation:\n        \"\"\"\n        Create an insert operation.\n\n        Args:\n            position: The position where text was inserted\n            text: The text that was inserted\n\n        Returns:\n            An InsertOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize position based on type\n        if isinstance(position, LineColumnPosition):\n            position_dict = {\"line\": position.line, \"column\": position.column}\n        elif isinstance(position, StructuredPosition):\n            position_dict = position.dict()\n        else:\n            raise ValueError(f\"Unsupported position type: {type(position)}\")\n\n        return InsertOperation(position=position_dict, text=text)\n\n    @staticmethod\n    def create_delete_operation(\n        start: Position, end: Position, deleted_text: str\n    ) -> DeleteOperation:\n        \"\"\"\n        Create a delete operation.\n\n        Args:\n            start: The start position of deleted text\n            end: The end position of deleted text\n            deleted_text: The text that was deleted\n\n        Returns:\n            A DeleteOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return DeleteOperation(\n            start_position=start_dict, end_position=end_dict, deleted_text=deleted_text\n        )\n\n    @staticmethod\n    def create_replace_operation(\n        start: Position, end: Position, new_text: str, old_text: str\n    ) -> ReplaceOperation:\n        \"\"\"\n        Create a replace operation.\n\n        Args:\n            start: The start position of replaced text\n            end: The end position of replaced text\n            new_text: The text that was inserted\n            old_text: The text that was replaced\n\n        Returns:\n            A ReplaceOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return ReplaceOperation(\n            start_position=start_dict,\n            end_position=end_dict,\n            new_text=new_text,\n            old_text=old_text,\n        )",
                "class Operation(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for operations that can be applied, undone, and redone.\n\n    Operations represent atomic changes to text content that can be\n    tracked, undone, and redone by a history system.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n\n    @abstractmethod\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass",
                "class InsertOperation(Operation):\n    \"\"\"\n    An operation that inserts text at a specified position.\n    \"\"\"\n\n    position: Dict[str, Any]  # Serialized position\n    text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"insert\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.position)\n\n        content.insert(position, self.text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            start_position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n\n            # Calculate end position based on inserted text\n            lines = self.text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"],\n                    column=self.position[\"column\"] + len(self.text),\n                )\n            else:\n                # Multi-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"] + len(lines) - 1, column=len(lines[-1])\n                )\n        else:\n            # For structured positions, we can only undo by position\n            # This is a simplification; real implementation would need more context\n            start_position = StructuredPosition(**self.position)\n            end_position = start_position\n\n        content.delete(start_position, end_position)",
                "class DeleteOperation(Operation):\n    \"\"\"\n    An operation that deletes text between specified positions.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    deleted_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"delete\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.delete(start_position, end_position)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.start_position)\n\n        content.insert(position, self.deleted_text)",
                "class ReplaceOperation(Operation):\n    \"\"\"\n    An operation that replaces text between specified positions with new text.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    new_text: str\n    old_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"replace\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.new_text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n\n            # Calculate end position based on new text\n            lines = self.new_text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"],\n                    column=self.start_position[\"column\"] + len(self.new_text),\n                )\n            else:\n                # Multi-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"] + len(lines) - 1,\n                    column=len(lines[-1]),\n                )\n        else:\n            # For structured positions, we use the original end position\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.old_text)",
                "class FileManager(BaseFileManager):\n    \"\"\"\n    Manages file operations for the text editor.\n\n    This class extends the common library's FileManager to maintain\n    backward compatibility with the original FileManager.\n    \"\"\"\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n        \"\"\"\n        return super().load_file(file_path)\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        super().save_file(content, file_path)\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        return super().is_file_modified(file_path)\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return super().get_current_path()",
                "class FileManager(BaseModel):\n    \"\"\"\n    Manages file operations for text editors.\n\n    This class provides functionality for loading from and saving to files,\n    tracking file state, and handling file-related operations.\n    \"\"\"\n\n    current_path: Optional[str] = None\n    last_saved_time: Optional[float] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            UnicodeDecodeError: If the file encoding is not supported\n        \"\"\"\n        start_time = time.time()\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"utf-8\"\n\n            return content\n\n        except UnicodeDecodeError:\n            # Try with latin-1 encoding as a fallback\n            with open(file_path, \"r\", encoding=\"latin-1\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"latin-1\"\n\n            return content\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"encoding\"] = \"utf-8\"\n\n    def save_structured_content(\n        self, content: Any, file_path: Optional[str] = None, format: str = \"json\"\n    ) -> None:\n        \"\"\"\n        Save structured content to a file in a specified format.\n\n        Args:\n            content: The content to save (must be serializable)\n            file_path: Path to save to (if None, uses current_path)\n            format: The format to save in (currently only \"json\" is supported)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set,\n                       or if the format is not supported\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if format.lower() == \"json\":\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(content, f, indent=2)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"format\"] = format\n\n    def load_structured_content(self, file_path: str, format: str = \"json\") -> Any:\n        \"\"\"\n        Load structured content from a file.\n\n        Args:\n            file_path: Path to the file to load\n            format: The format of the file (currently only \"json\" is supported)\n\n        Returns:\n            The loaded structured content\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            ValueError: If the format is not supported\n            json.JSONDecodeError: If the file is not valid JSON\n        \"\"\"\n        start_time = time.time()\n\n        if format.lower() == \"json\":\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = json.load(f)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = file_path\n        self.last_saved_time = os.path.getmtime(file_path)\n\n        # Store file metadata\n        self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(file_path)\n        self.metadata[\"format\"] = format\n\n        return content\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return True\n\n        if not self.last_saved_time:\n            return True\n\n        return os.path.getmtime(path) > self.last_saved_time\n\n    def get_file_info(self, file_path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get information about the file.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            A dictionary with file information\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return {\"exists\": False}\n\n        return {\n            \"exists\": True,\n            \"size\": os.path.getsize(path),\n            \"modified_time\": os.path.getmtime(path),\n            \"created_time\": os.path.getctime(path),\n            \"is_directory\": os.path.isdir(path),\n            \"file_name\": os.path.basename(path),\n            \"directory\": os.path.dirname(path),\n            \"extension\": os.path.splitext(path)[1],\n        }\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.current_path"
            ]
        }
    },
    "unified/text_editor/features/__init__.py": {
        "logprobs": -210.63775348431997,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/interview/__init__.py": {
        "logprobs": -197.8320560527843,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/writer_text_editor/navigation.py": {
        "logprobs": -2462.8008286240397,
        "metrics": {
            "loc": 1240,
            "sloc": 854,
            "lloc": 694,
            "comments": 153,
            "multi": 3,
            "blank": 215,
            "cyclomatic": 237,
            "internal_imports": [
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n\n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n\n    def _find_element_occurrences(\n        self, element_name: str, aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n\n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = (\n            r\"\\b(\" + \"|\".join(re.escape(name) for name in names_to_search) + r\")\\b\"\n        )\n        regex = re.compile(pattern, re.IGNORECASE)\n\n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n\n                    results.append((section, segment, match.start(), context))\n\n        return results\n\n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n\n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set(),\n        }\n\n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n\n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n\n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n\n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(\n                    re.findall(r\"\\b\" + re.escape(element) + r\"\\b\", text, re.IGNORECASE)\n                )\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element\n                        in [e.name for e in self.elements.values()],\n                    }\n\n        return results\n\n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n\n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n\n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n\n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n\n                co_occurrences = 0\n                for context in contexts:\n                    pattern = (\n                        r\"\\b(\"\n                        + \"|\".join(\n                            [re.escape(other_element.name)]\n                            + [re.escape(alias) for alias in other_element.aliases]\n                        )\n                        + r\")\\b\"\n                    )\n\n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n\n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n\n        return connections\n\n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n\n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n\n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n\n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n\n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n\n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(\n                        char_timeline_sections, key=lambda s: timeline_sections[s]\n                    )\n\n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n\n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(\n                                        ConsistencyIssue(\n                                            id=str(len(issues) + 1),\n                                            issue_type=\"timeline\",\n                                            elements_involved=[char_id],\n                                            description=(\n                                                f\"Character appears in non-sequential timeline points: \"\n                                                f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[k]]}\"\n                                            ),\n                                            locations=[\n                                                (sorted_sections[i], \"\"),\n                                                (sorted_sections[j], \"\"),\n                                                (sorted_sections[k], \"\"),\n                                            ],\n                                            severity=3,\n                                        )\n                                    )\n\n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n\n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n\n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name) :]\n\n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r\"\\s+was\\s+(\\w+)\",\n                        r\"\\s+had\\s+(\\w+)\",\n                        r\"\\s+with\\s+(\\w+)\",\n                        r\",\\s+a\\s+(\\w+)\",\n                        r\",\\s+the\\s+(\\w+)\",\n                    ]\n\n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append(\n                                (\n                                    occurrence.section_id,\n                                    occurrence.segment_id,\n                                    match.group(1),\n                                    context,\n                                )\n                            )\n\n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n\n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\"),\n                ]\n\n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(\n                            ConsistencyIssue(\n                                id=str(len(issues) + 1),\n                                issue_type=\"contradiction\",\n                                elements_involved=[element_id],\n                                description=(\n                                    f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                                ),\n                                locations=[\n                                    (\n                                        descriptions[word1][0][0],\n                                        descriptions[word1][0][1],\n                                    ),\n                                    (\n                                        descriptions[word2][0][0],\n                                        descriptions[word2][0][1],\n                                    ),\n                                ],\n                                severity=4,\n                            )\n                        )\n\n        return issues\n\n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None,\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n\n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(\n            name, aliases\n        ):\n            occurrences.append(\n                ElementOccurrence(\n                    element_id=element_id,\n                    section_id=section.id,\n                    segment_id=segment.id,\n                    position=position,\n                    context=context,\n                )\n            )\n\n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None,\n        )\n\n        self.elements[element_id] = element\n        return element\n\n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n\n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: [],\n        }\n\n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name, element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n\n        # Update element relationships\n        self.update_element_relationships()\n\n        # Detect consistency issues\n        self.check_consistency()\n\n        return tracked_elements\n\n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n\n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n\n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n\n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n\n        element = self.elements[element_id]\n        appearances = []\n\n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n\n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n\n            if section and segment:\n                appearances.append(\n                    {\n                        \"section_title\": section.title,\n                        \"section_id\": section.id,\n                        \"segment_id\": segment.id,\n                        \"segment_position\": segment.position,\n                        \"context\": occurrence.context,\n                        \"mentioned_with\": [\n                            self.elements[e_id].name\n                            for e_id in occurrence.mentioned_with\n                            if e_id in self.elements\n                        ],\n                    }\n                )\n\n        return appearances\n\n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n\n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": [],\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n\n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append(\n                    {\n                        \"section_id\": section.id,\n                        \"section_title\": sections[section.id][\"section_title\"],\n                        \"appearances\": sorted(\n                            sections[section.id][\"appearances\"],\n                            key=lambda a: a[\"segment_position\"],\n                        ),\n                    }\n                )\n\n        return ordered_sections\n\n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n\n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n\n        self._stop_background_thread = False\n\n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n\n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n\n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n\n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n\n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class NarrativeElement(BaseModel):\n    \"\"\"A tracked narrative element such as a character or plot element.\"\"\"\n\n    id: str\n    name: str\n    element_type: ElementType\n    aliases: List[str] = Field(default_factory=list)\n    description: str = \"\"\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    occurrences: List[ElementOccurrence] = Field(default_factory=list)\n    related_elements: Dict[str, float] = Field(\n        default_factory=dict\n    )  # Element ID to relationship strength\n    first_appearance: Optional[datetime] = None\n    last_appearance: Optional[datetime] = None"
            ]
        }
    },
    "unified/writer_text_editor/revision.py": {
        "logprobs": -1738.3392538677736,
        "metrics": {
            "loc": 734,
            "sloc": 523,
            "lloc": 343,
            "comments": 70,
            "multi": 8,
            "blank": 120,
            "cyclomatic": 170,
            "internal_imports": [
                "class Operation(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for operations that can be applied, undone, and redone.\n\n    Operations represent atomic changes to text content that can be\n    tracked, undone, and redone by a history system.\n    \"\"\"\n\n    timestamp: float = Field(default_factory=time.time)\n\n    @abstractmethod\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        pass",
                "class InsertOperation(Operation):\n    \"\"\"\n    An operation that inserts text at a specified position.\n    \"\"\"\n\n    position: Dict[str, Any]  # Serialized position\n    text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"insert\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.position)\n\n        content.insert(position, self.text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.position and \"column\" in self.position:\n            start_position = LineColumnPosition(\n                line=self.position[\"line\"], column=self.position[\"column\"]\n            )\n\n            # Calculate end position based on inserted text\n            lines = self.text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"],\n                    column=self.position[\"column\"] + len(self.text),\n                )\n            else:\n                # Multi-line insertion\n                end_position = LineColumnPosition(\n                    line=self.position[\"line\"] + len(lines) - 1, column=len(lines[-1])\n                )\n        else:\n            # For structured positions, we can only undo by position\n            # This is a simplification; real implementation would need more context\n            start_position = StructuredPosition(**self.position)\n            end_position = start_position\n\n        content.delete(start_position, end_position)",
                "class DeleteOperation(Operation):\n    \"\"\"\n    An operation that deletes text between specified positions.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    deleted_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"delete\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.delete(start_position, end_position)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize position based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n        else:\n            position = StructuredPosition(**self.start_position)\n\n        content.insert(position, self.deleted_text)",
                "class ReplaceOperation(Operation):\n    \"\"\"\n    An operation that replaces text between specified positions with new text.\n    \"\"\"\n\n    start_position: Dict[str, Any]  # Serialized start position\n    end_position: Dict[str, Any]  # Serialized end position\n    new_text: str\n    old_text: str\n\n    @property\n    def type(self) -> str:\n        \"\"\"Type of the operation for compatibility with original History.\"\"\"\n        return \"replace\"\n\n    def apply(self, content: TextContent) -> None:\n        \"\"\"\n        Apply this operation to the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n            end_position = LineColumnPosition(\n                line=self.end_position[\"line\"], column=self.end_position[\"column\"]\n            )\n        else:\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.new_text)\n\n    def undo(self, content: TextContent) -> None:\n        \"\"\"\n        Undo this operation on the given content.\n\n        Args:\n            content: The text content to modify\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Deserialize positions based on type\n        if \"line\" in self.start_position and \"column\" in self.start_position:\n            start_position = LineColumnPosition(\n                line=self.start_position[\"line\"], column=self.start_position[\"column\"]\n            )\n\n            # Calculate end position based on new text\n            lines = self.new_text.split(\"\\n\")\n            if len(lines) == 1:\n                # Single-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"],\n                    column=self.start_position[\"column\"] + len(self.new_text),\n                )\n            else:\n                # Multi-line replacement\n                end_position = LineColumnPosition(\n                    line=self.start_position[\"line\"] + len(lines) - 1,\n                    column=len(lines[-1]),\n                )\n        else:\n            # For structured positions, we use the original end position\n            start_position = StructuredPosition(**self.start_position)\n            end_position = StructuredPosition(**self.end_position)\n\n        content.replace(start_position, end_position, self.old_text)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()",
                "class Revision(CommonRevision):\n    \"\"\"A revision of a document.\"\"\""
            ]
        }
    },
    "unified/common/core/history.py": {
        "logprobs": -893.0574093342219,
        "metrics": {
            "loc": 435,
            "sloc": 207,
            "lloc": 206,
            "comments": 26,
            "multi": 118,
            "blank": 85,
            "cyclomatic": 63,
            "internal_imports": [
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass",
                "class Position(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for positions within text content.\n\n    This class defines the interface for all position types, with methods for\n    moving the position in different directions and validating against content.\n    \"\"\"\n\n    @abstractmethod\n    def move_up(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position up by the specified number of units.\n\n        Args:\n            count: Number of units to move up (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_down(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position down by the specified number of units.\n\n        Args:\n            count: Number of units to move down (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_left(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position left by the specified number of units.\n\n        Args:\n            count: Number of units to move left (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_right(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position right by the specified number of units.\n\n        Args:\n            count: Number of units to move right (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        pass",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0"
            ]
        }
    },
    "unified/tests/student/__init__.py": {
        "logprobs": -184.41774451744797,
        "metrics": {
            "loc": 3,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 3,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/core/buffer.py": {
        "logprobs": -582.5649588046382,
        "metrics": {
            "loc": 130,
            "sloc": 46,
            "lloc": 45,
            "comments": 3,
            "multi": 55,
            "blank": 25,
            "cyclomatic": 14,
            "internal_imports": [
                "class LineBasedTextContent(TextContent):\n    \"\"\"\n    A text content implementation that stores text as a list of lines.\n\n    This implementation is suited for simple line-based text editors,\n    where operations are primarily performed using line and column coordinates.\n    \"\"\"\n\n    lines: List[str] = Field(default_factory=lambda: [\"\"])\n\n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new line-based text content with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__()\n        self.lines = content.split(\"\\n\") if content else [\"\"]\n\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted (must be LineColumnPosition)\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid or not a LineColumnPosition\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        if not isinstance(position, LineColumnPosition):\n            raise ValueError(\"Position must be a LineColumnPosition\")\n\n        line, column = position.line, position.column\n\n        # Ensure position is valid\n        if not (0 <= line < len(self.lines)):\n            raise ValueError(f\"Line number {line} out of range\")\n\n        current_line = self.lines[line]\n        if not (0 <= column <= len(current_line)):\n            raise ValueError(f\"Column number {column} out of range for line {line}\")\n\n        # Handle multi-line insertion\n        if \"\\n\" in text:\n            # Split the text into lines\n            new_lines = text.split(\"\\n\")\n\n            # Handle the first line (insert at the current position)\n            first_part = current_line[:column]\n            last_part = current_line[column:]\n\n            # Create the new set of lines\n            new_content = [first_part + new_lines[0]]\n            new_content.extend(new_lines[1:-1])\n            new_content.append(new_lines[-1] + last_part)\n\n            # Update the buffer\n            self.lines[line : line + 1] = new_content\n        else:\n            # Simple single-line insertion\n            new_line = current_line[:column] + text + current_line[column:]\n            self.lines[line] = new_line\n\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete (must be LineColumnPosition)\n            end: The end position of the text to delete (must be LineColumnPosition)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        if not isinstance(start, LineColumnPosition) or not isinstance(\n            end, LineColumnPosition\n        ):\n            raise ValueError(\"Positions must be LineColumnPositions\")\n\n        start_line, start_col = start.line, start.column\n        end_line, end_col = end.line, end.column\n\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n\n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise ValueError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise ValueError(f\"End line {end_line} out of range\")\n\n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n\n        if not (0 <= start_col <= len(start_line_text)):\n            raise ValueError(\n                f\"Start column {start_col} out of range for line {start_line}\"\n            )\n        if not (0 <= end_col <= len(end_line_text)):\n            raise ValueError(f\"End column {end_col} out of range for line {end_line}\")\n\n        # Handle deletion within a single line\n        if start_line == end_line:\n            deleted_text = start_line_text[start_col:end_col]\n            self.lines[start_line] = (\n                start_line_text[:start_col] + start_line_text[end_col:]\n            )\n            return deleted_text\n\n        # Handle multi-line deletion\n        deleted_lines = []\n\n        # Get the first partial line\n        deleted_lines.append(start_line_text[start_col:])\n\n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            deleted_lines.extend(self.lines[start_line + 1 : end_line])\n\n        # Get the last partial line\n        deleted_lines.append(end_line_text[:end_col])\n\n        # Join the deleted text\n        deleted_text = \"\\n\".join(deleted_lines)\n\n        # Update the buffer\n        new_line = start_line_text[:start_col] + end_line_text[end_col:]\n        self.lines[start_line : end_line + 1] = [new_line]\n\n        return deleted_text\n\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace (must be LineColumnPosition)\n            end: The end position of the text to replace (must be LineColumnPosition)\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        # Delete the text first and get what was deleted\n        deleted_text = self.delete(start, end)\n\n        # Insert the new text\n        self.insert(start, text)\n\n        return deleted_text\n\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid, not a LineColumnPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import LineColumnPosition\n\n        # If no positions provided, return all content\n        if start is None and end is None:\n            return \"\\n\".join(self.lines)\n\n        # Convert None to start/end of content\n        if start is None:\n            start = LineColumnPosition(line=0, column=0)\n        if end is None:\n            last_line = len(self.lines) - 1\n            end = LineColumnPosition(line=last_line, column=len(self.lines[last_line]))\n\n        # Validate position types\n        if not isinstance(start, LineColumnPosition) or not isinstance(\n            end, LineColumnPosition\n        ):\n            raise ValueError(\"Positions must be LineColumnPositions\")\n\n        start_line, start_col = start.line, start.column\n        end_line, end_col = end.line, end.column\n\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n\n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise ValueError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise ValueError(f\"End line {end_line} out of range\")\n\n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n\n        if not (0 <= start_col <= len(start_line_text)):\n            raise ValueError(\n                f\"Start column {start_col} out of range for line {start_line}\"\n            )\n        if not (0 <= end_col <= len(end_line_text)):\n            raise ValueError(f\"End column {end_col} out of range for line {end_line}\")\n\n        # Handle text within a single line\n        if start_line == end_line:\n            return start_line_text[start_col:end_col]\n\n        # Handle multi-line text\n        result_lines = []\n\n        # Get the first partial line\n        result_lines.append(start_line_text[start_col:])\n\n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            result_lines.extend(self.lines[start_line + 1 : end_line])\n\n        # Get the last partial line\n        result_lines.append(end_line_text[:end_col])\n\n        # Join and return the text\n        return \"\\n\".join(result_lines)\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        return len(self.lines)\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        if 0 <= line_number < len(self.lines):\n            return self.lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        return len(re.findall(r\"\\b\\w+\\b\", self.get_text()))\n\n    def clear(self) -> None:\n        \"\"\"Clear the content, removing all text.\"\"\"\n        self.lines = [\"\"]",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)"
            ]
        }
    },
    "unified/text_editor/features/manager.py": {
        "logprobs": -1510.0148885580738,
        "metrics": {
            "loc": 410,
            "sloc": 272,
            "lloc": 104,
            "comments": 20,
            "multi": 68,
            "blank": 53,
            "cyclomatic": 41,
            "internal_imports": [
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n\n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n\n        self.feature_usage_count[feature_id] += count\n\n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if (\n            feature_id in self.feature_usage_count\n            and self.feature_usage_count[feature_id] <= 10\n        ):\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n\n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n\n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n\n        # Check if the user should level up based on experience points\n        if self.skill_level == SkillLevel.BEGINNER and self.experience_points >= 100:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (\n            self.skill_level == SkillLevel.INTERMEDIATE\n            and self.experience_points >= 300\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif self.skill_level == SkillLevel.ADVANCED and self.experience_points >= 600:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n\n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n\n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n\n        # Record this event in progress history\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"feature_unlocked\",\n                \"feature_id\": feature_id,\n            }\n        )\n\n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n\n        Args:\n            feature_id: The ID of the feature to check\n\n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n\n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"level_up\",\n                \"new_level\": self.skill_level.name,\n                \"experience_points\": self.experience_points,\n            }\n        )\n\n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n\n        # Simple assessment: count number of different features used\n        unique_features_used = len(\n            [k for k, v in self.feature_usage_count.items() if v > 5]\n        )\n\n        # Update skill level based on unique features used\n        if (\n            unique_features_used >= 15\n            and self.skill_level.value < SkillLevel.EXPERT.value\n        ):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif (\n            unique_features_used >= 10\n            and self.skill_level.value < SkillLevel.ADVANCED.value\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (\n            unique_features_used >= 5\n            and self.skill_level.value < SkillLevel.INTERMEDIATE.value\n        ):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n\n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n\n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), key=lambda x: x[1], reverse=True\n            )[:5]\n            if self.feature_usage_count\n            else [],\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n\n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n\n        self.feature_usage_count[feature_id] += count\n\n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if (\n            feature_id in self.feature_usage_count\n            and self.feature_usage_count[feature_id] <= 10\n        ):\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n\n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n\n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n\n        # Check if the user should level up based on experience points\n        if self.skill_level == SkillLevel.BEGINNER and self.experience_points >= 100:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (\n            self.skill_level == SkillLevel.INTERMEDIATE\n            and self.experience_points >= 300\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif self.skill_level == SkillLevel.ADVANCED and self.experience_points >= 600:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n\n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n\n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n\n        # Record this event in progress history\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"feature_unlocked\",\n                \"feature_id\": feature_id,\n            }\n        )\n\n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n\n        Args:\n            feature_id: The ID of the feature to check\n\n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n\n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"level_up\",\n                \"new_level\": self.skill_level.name,\n                \"experience_points\": self.experience_points,\n            }\n        )\n\n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n\n        # Simple assessment: count number of different features used\n        unique_features_used = len(\n            [k for k, v in self.feature_usage_count.items() if v > 5]\n        )\n\n        # Update skill level based on unique features used\n        if (\n            unique_features_used >= 15\n            and self.skill_level.value < SkillLevel.EXPERT.value\n        ):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif (\n            unique_features_used >= 10\n            and self.skill_level.value < SkillLevel.ADVANCED.value\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (\n            unique_features_used >= 5\n            and self.skill_level.value < SkillLevel.INTERMEDIATE.value\n        ):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n\n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n\n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), key=lambda x: x[1], reverse=True\n            )[:5]\n            if self.feature_usage_count\n            else [],\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n\n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n\n        self.feature_usage_count[feature_id] += count\n\n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if (\n            feature_id in self.feature_usage_count\n            and self.feature_usage_count[feature_id] <= 10\n        ):\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n\n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n\n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n\n        # Check if the user should level up based on experience points\n        if self.skill_level == SkillLevel.BEGINNER and self.experience_points >= 100:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (\n            self.skill_level == SkillLevel.INTERMEDIATE\n            and self.experience_points >= 300\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif self.skill_level == SkillLevel.ADVANCED and self.experience_points >= 600:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n\n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n\n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n\n        # Record this event in progress history\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"feature_unlocked\",\n                \"feature_id\": feature_id,\n            }\n        )\n\n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n\n        Args:\n            feature_id: The ID of the feature to check\n\n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n\n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"level_up\",\n                \"new_level\": self.skill_level.name,\n                \"experience_points\": self.experience_points,\n            }\n        )\n\n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n\n        # Simple assessment: count number of different features used\n        unique_features_used = len(\n            [k for k, v in self.feature_usage_count.items() if v > 5]\n        )\n\n        # Update skill level based on unique features used\n        if (\n            unique_features_used >= 15\n            and self.skill_level.value < SkillLevel.EXPERT.value\n        ):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif (\n            unique_features_used >= 10\n            and self.skill_level.value < SkillLevel.ADVANCED.value\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (\n            unique_features_used >= 5\n            and self.skill_level.value < SkillLevel.INTERMEDIATE.value\n        ):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n\n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n\n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), key=lambda x: x[1], reverse=True\n            )[:5]\n            if self.feature_usage_count\n            else [],\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n\n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n\n        self.feature_usage_count[feature_id] += count\n\n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if (\n            feature_id in self.feature_usage_count\n            and self.feature_usage_count[feature_id] <= 10\n        ):\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n\n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n\n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n\n        # Check if the user should level up based on experience points\n        if self.skill_level == SkillLevel.BEGINNER and self.experience_points >= 100:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (\n            self.skill_level == SkillLevel.INTERMEDIATE\n            and self.experience_points >= 300\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif self.skill_level == SkillLevel.ADVANCED and self.experience_points >= 600:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n\n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n\n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n\n        # Record this event in progress history\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"feature_unlocked\",\n                \"feature_id\": feature_id,\n            }\n        )\n\n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n\n        Args:\n            feature_id: The ID of the feature to check\n\n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n\n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"level_up\",\n                \"new_level\": self.skill_level.name,\n                \"experience_points\": self.experience_points,\n            }\n        )\n\n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n\n        # Simple assessment: count number of different features used\n        unique_features_used = len(\n            [k for k, v in self.feature_usage_count.items() if v > 5]\n        )\n\n        # Update skill level based on unique features used\n        if (\n            unique_features_used >= 15\n            and self.skill_level.value < SkillLevel.EXPERT.value\n        ):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif (\n            unique_features_used >= 10\n            and self.skill_level.value < SkillLevel.ADVANCED.value\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (\n            unique_features_used >= 5\n            and self.skill_level.value < SkillLevel.INTERMEDIATE.value\n        ):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n\n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n\n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), key=lambda x: x[1], reverse=True\n            )[:5]\n            if self.feature_usage_count\n            else [],\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n\n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n\n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n\n        self.feature_usage_count[feature_id] += count\n\n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if (\n            feature_id in self.feature_usage_count\n            and self.feature_usage_count[feature_id] <= 10\n        ):\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n\n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n\n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n\n        # Check if the user should level up based on experience points\n        if self.skill_level == SkillLevel.BEGINNER and self.experience_points >= 100:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (\n            self.skill_level == SkillLevel.INTERMEDIATE\n            and self.experience_points >= 300\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif self.skill_level == SkillLevel.ADVANCED and self.experience_points >= 600:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n\n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n\n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n\n        # Record this event in progress history\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"feature_unlocked\",\n                \"feature_id\": feature_id,\n            }\n        )\n\n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n\n        Args:\n            feature_id: The ID of the feature to check\n\n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n\n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append(\n            {\n                \"timestamp\": time.time(),\n                \"event\": \"level_up\",\n                \"new_level\": self.skill_level.name,\n                \"experience_points\": self.experience_points,\n            }\n        )\n\n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n\n        # Simple assessment: count number of different features used\n        unique_features_used = len(\n            [k for k, v in self.feature_usage_count.items() if v > 5]\n        )\n\n        # Update skill level based on unique features used\n        if (\n            unique_features_used >= 15\n            and self.skill_level.value < SkillLevel.EXPERT.value\n        ):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif (\n            unique_features_used >= 10\n            and self.skill_level.value < SkillLevel.ADVANCED.value\n        ):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (\n            unique_features_used >= 5\n            and self.skill_level.value < SkillLevel.INTERMEDIATE.value\n        ):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n\n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n\n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), key=lambda x: x[1], reverse=True\n            )[:5]\n            if self.feature_usage_count\n            else [],\n        }",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\""
            ]
        }
    },
    "unified/writer_text_editor/__init__.py": {
        "logprobs": -444.6282582623815,
        "metrics": {
            "loc": 32,
            "sloc": 28,
            "lloc": 10,
            "comments": 0,
            "multi": 0,
            "blank": 3,
            "cyclomatic": 0,
            "internal_imports": [
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()",
                "class Revision(CommonRevision):\n    \"\"\"A revision of a document.\"\"\"",
                "class FocusMode:\n    \"\"\"The focus mode system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the focus mode system with the given document.\"\"\"\n        self.document = document\n        self.active_focus: Optional[FocusContext] = None\n        self.focus_history: List[FocusContext] = []\n\n    def is_active(self) -> bool:\n        \"\"\"Check if focus mode is currently active.\"\"\"\n        return self.active_focus is not None\n\n    def get_focus_context(self) -> Optional[FocusContext]:\n        \"\"\"Get the current focus context if focus mode is active.\"\"\"\n        return self.active_focus\n\n    def enter_focus(\n        self,\n        section_index: int,\n        segment_index: int,\n        level: FocusLevel = FocusLevel.PARAGRAPH,\n    ) -> Optional[FocusContext]:\n        \"\"\"Enter focus mode for the specified section and segment.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n\n        segment = section.get_segment(segment_index)\n        if not segment:\n            return None\n\n        # Create position object\n        position = StructuredPosition(\n            view_id=\"focus\",\n            element_id=segment.id,\n            element_type=StructuredElementType.SEGMENT,\n            section_index=section_index,\n            segment_index=segment_index,\n            offset_in_segment=0\n        )\n        \n        self.active_focus = FocusContext(\n            document=self.document, \n            section=section, \n            segment=segment, \n            level=level,\n            position=position\n        )\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n\n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        if self.active_focus:\n            self.active_focus = None\n            return True\n        return False\n\n    def move_focus(self, direction: int = 1) -> Optional[FocusContext]:\n        \"\"\"Move the focus to the next or previous segment.\"\"\"\n        if not self.active_focus:\n            return None\n\n        current_segment = self.active_focus.segment\n        current_section = self.active_focus.section\n        current_position = self.active_focus.position\n        \n        if not current_position:\n            return None\n\n        # Find the next segment within the current section\n        next_segment_index = current_position.segment_index + direction\n        next_segment = current_section.get_segment(next_segment_index)\n\n        if next_segment:\n            # Move focus within the same section\n            new_position = StructuredPosition(\n                view_id=current_position.view_id,\n                element_id=next_segment.id,\n                element_type=StructuredElementType.SEGMENT,\n                section_index=current_position.section_index,\n                segment_index=next_segment_index,\n                offset_in_segment=0\n            )\n            \n            self.active_focus = FocusContext(\n                document=self.document,\n                section=current_section,\n                segment=next_segment,\n                level=self.active_focus.level,\n                position=new_position\n            )\n            self.focus_history.append(self.active_focus)\n            return self.active_focus\n\n        # Try to move to a different section\n        current_section_idx = current_position.section_index\n        next_section_idx = current_section_idx + direction\n\n        if 0 <= next_section_idx < len(self.document.current_revision.sections):\n            next_section = self.document.current_revision.sections[next_section_idx]\n\n            # Get the first or last segment of the next section depending on direction\n            target_segment_index = 0 if direction > 0 else len(next_section.segments) - 1\n            if 0 <= target_segment_index < len(next_section.segments):\n                next_segment = next_section.segments[target_segment_index]\n                \n                new_position = StructuredPosition(\n                    view_id=current_position.view_id,\n                    element_id=next_segment.id,\n                    element_type=StructuredElementType.SEGMENT,\n                    section_index=next_section_idx,\n                    segment_index=target_segment_index,\n                    offset_in_segment=0\n                )\n\n                self.active_focus = FocusContext(\n                    document=self.document,\n                    section=next_section,\n                    segment=next_segment,\n                    level=self.active_focus.level,\n                    position=new_position\n                )\n                self.focus_history.append(self.active_focus)\n                return self.active_focus\n\n        return None\n\n    def change_focus_level(self, level: FocusLevel) -> Optional[FocusContext]:\n        \"\"\"Change the level of focus.\"\"\"\n        if not self.active_focus:\n            return None\n\n        self.active_focus.level = level\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n\n    def edit_focused_content(self, new_content: str) -> Optional[TextSegment]:\n        \"\"\"Edit the content of the focused segment.\"\"\"\n        if not self.active_focus:\n            return None\n\n        self.active_focus.segment.content = new_content\n        self.document.updated_at = time.time()\n        return self.active_focus.segment\n\n    def get_focus_time(self) -> float:\n        \"\"\"Get the time spent in the current focus session in seconds.\"\"\"\n        if not self.active_focus:\n            return 0.0\n\n        return time.time() - self.active_focus.start_time\n\n    def get_surrounding_context(self, context_size: int = 2) -> List[TextSegment]:\n        \"\"\"Get the surrounding segments around the focused segment.\"\"\"\n        if not self.active_focus or not self.active_focus.position:\n            return []\n\n        section = self.active_focus.section\n        position = self.active_focus.position.segment_index\n\n        start = max(0, position - context_size)\n        end = min(len(section.segments), position + context_size + 1)\n\n        return section.segments[start:end]",
                "class FocusLevel(str, Enum):\n    \"\"\"The level of focus.\"\"\"\n\n    PARAGRAPH = \"paragraph\"\n    SENTENCE = \"sentence\"\n    SECTION = \"section\"",
                "class FocusContext(BaseModel):\n    \"\"\"Context information about the focused element.\"\"\"\n\n    document: Document\n    section: Section\n    segment: TextSegment\n    level: FocusLevel\n    start_time: float = Field(default_factory=time.time)\n    position: Optional[StructuredPosition] = None\n\n    class Config:\n        arbitrary_types_allowed = True\n        \n    def __init__(self, **data):\n        super().__init__(**data)\n        # Create structured position if not provided\n        if not self.position and self.section and self.segment:\n            self.position = StructuredPosition(\n                view_id=\"focus\",\n                element_id=self.segment.id,\n                element_type=StructuredElementType.SEGMENT,\n                section_index=self.document.current_revision.sections.index(self.section),\n                segment_index=self.section.segments.index(self.segment),\n                offset_in_segment=0\n            )",
                "class WritingStatistics:\n    \"\"\"Writing statistics tracking system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the writing statistics system with the given document.\"\"\"\n        self.document = document\n        self.stats_history: List[DocumentStats] = []\n        self.pace_history: List[WritingPace] = []\n        self.progress_trackers: Dict[str, ProgressTracker] = {}\n        self._last_word_count: int = 0\n        self._last_check_time: float = time.time()\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n\n    def _count_sentences(self, text: str) -> int:\n        \"\"\"Count the number of sentences in the text.\"\"\"\n        # Simple sentence counting - this could be improved with NLP\n        return len(re.findall(r\"[.!?]+\\s+\", text)) + 1\n\n    def _identify_sentence_type(self, sentence: str) -> str:\n        \"\"\"Identify the type of a sentence.\"\"\"\n        sentence = sentence.strip()\n        if not sentence:\n            return \"unknown\"\n\n        if sentence.endswith(\"?\"):\n            return \"interrogative\"\n        elif sentence.endswith(\"!\"):\n            return \"exclamatory\"\n        elif \",\" in sentence and (\n            \"but\" in sentence.lower() or \"however\" in sentence.lower()\n        ):\n            return \"complex\"\n        else:\n            return \"declarative\"\n\n    def _is_complex_sentence(self, sentence: str) -> bool:\n        \"\"\"Check if a sentence is complex (has multiple clauses).\"\"\"\n        # Simple check for coordinating conjunctions and subordinating conjunctions\n        coordinating_conjunctions = [\n            \" and \",\n            \" but \",\n            \" or \",\n            \" nor \",\n            \" so \",\n            \" for \",\n            \" yet \",\n        ]\n\n        subordinating_conjunctions = [\n            \" because \",\n            \" although \",\n            \" though \",\n            \" since \",\n            \" unless \",\n            \" if \",\n            \" when \",\n            \" where \",\n            \" while \",\n        ]\n\n        # Check for conjunction at beginning of sentence too\n        sentence_starts = [\n            \"when \",\n            \"if \",\n            \"while \",\n            \"because \",\n            \"although \",\n            \"though \",\n            \"since \",\n            \"unless \",\n            \"where \",\n        ]\n\n        sentence = sentence.lower()\n\n        # Check for any coordinating conjunctions within the sentence\n        has_coordinating = any(conj in sentence for conj in coordinating_conjunctions)\n\n        # Check for any subordinating conjunctions within the sentence\n        has_subordinating = any(conj in sentence for conj in subordinating_conjunctions)\n\n        # Check if the sentence starts with a subordinating conjunction\n        starts_with_subordinating = any(\n            sentence.startswith(start) for start in sentence_starts\n        )\n\n        return has_coordinating or has_subordinating or starts_with_subordinating\n\n    def _calculate_vocabulary_richness(\n        self, total_words: int, unique_words: int\n    ) -> float:\n        \"\"\"Calculate vocabulary richness (Type-Token Ratio).\"\"\"\n        if total_words == 0:\n            return 0.0\n        return unique_words / total_words\n\n    def calculate_stats(self) -> DocumentStats:\n        \"\"\"Calculate the current document statistics.\"\"\"\n        text = self.document.get_content()\n\n        # Basic counts\n        word_count = len(re.findall(r\"\\b\\w+\\b\", text))\n        character_count = len(text)\n        paragraph_count = len(re.findall(r\"\\n\\s*\\n\", text)) + 1\n\n        # Split into sentences for sentence analysis\n        sentences = re.split(r\"[.!?]+\\s+\", text)\n        sentence_count = len(sentences)\n\n        # Analyze sentence structure\n        sentence_lengths = [\n            len(re.findall(r\"\\b\\w+\\b\", s)) for s in sentences if s.strip()\n        ]\n        avg_sentence_length = (\n            statistics.mean(sentence_lengths) if sentence_lengths else 0\n        )\n        sentence_length_variance = (\n            statistics.variance(sentence_lengths) if len(sentence_lengths) > 1 else 0\n        )\n\n        complex_sentences = sum(1 for s in sentences if self._is_complex_sentence(s))\n\n        sentence_types = {}\n        for s in sentences:\n            if not s.strip():\n                continue\n            sent_type = self._identify_sentence_type(s)\n            sentence_types[sent_type] = sentence_types.get(sent_type, 0) + 1\n\n        # Analyze word usage\n        words = re.findall(r\"\\b\\w+\\b\", text.lower())\n        unique_words = len(set(words))\n\n        word_lengths = [len(w) for w in words]\n        avg_word_length = statistics.mean(word_lengths) if word_lengths else 0\n\n        # Count word frequencies\n        word_frequencies = {}\n        for word in words:\n            if len(word) > 3:  # Ignore very short words\n                word_frequencies[word] = word_frequencies.get(word, 0) + 1\n\n        # Get most common words (top 20)\n        most_common = dict(\n            sorted(word_frequencies.items(), key=lambda x: x[1], reverse=True)[:20]\n        )\n\n        # Calculate reading level metrics\n        reading_level = {\n            ReadingLevel.FLESCH_KINCAID_GRADE.value: textstat.flesch_kincaid_grade(\n                text\n            ),\n            ReadingLevel.FLESCH_READING_EASE.value: textstat.flesch_reading_ease(text),\n            ReadingLevel.GUNNING_FOG.value: textstat.gunning_fog(text),\n            ReadingLevel.SMOG_INDEX.value: textstat.smog_index(text),\n            ReadingLevel.AUTOMATED_READABILITY_INDEX.value: textstat.automated_readability_index(\n                text\n            ),\n            ReadingLevel.COLEMAN_LIAU_INDEX.value: textstat.coleman_liau_index(text),\n        }\n\n        # Create stats objects\n        word_stats = WordStats(\n            total_words=word_count,\n            unique_words=unique_words,\n            average_word_length=avg_word_length,\n            most_common_words=most_common,\n            vocabulary_richness=self._calculate_vocabulary_richness(\n                word_count, unique_words\n            ),\n        )\n\n        sentence_stats = SentenceStats(\n            total_sentences=sentence_count,\n            average_sentence_length=avg_sentence_length,\n            sentence_length_variance=sentence_length_variance,\n            complex_sentences=complex_sentences,\n            sentence_types=sentence_types,\n        )\n\n        document_stats = DocumentStats(\n            word_count=word_count,\n            character_count=character_count,\n            paragraph_count=paragraph_count,\n            sentence_count=sentence_count,\n            reading_level=reading_level,\n            word_stats=word_stats,\n            sentence_stats=sentence_stats,\n        )\n\n        # Update history\n        self.stats_history.append(document_stats)\n\n        # Update last word count for pace tracking\n        self._last_word_count = word_count\n\n        return document_stats\n\n    def calculate_writing_pace(self) -> WritingPace:\n        \"\"\"Calculate the current writing pace.\"\"\"\n        current_time = time.time()\n        current_word_count = self.document.get_word_count()\n\n        time_diff_seconds = current_time - self._last_check_time\n        word_diff = current_word_count - self._last_word_count\n\n        if time_diff_seconds <= 0:\n            words_per_minute = 0.0\n        else:\n            # Calculate words per minute\n            words_per_minute = (word_diff / time_diff_seconds) * 60\n\n        # Update for next calculation\n        self._last_check_time = current_time\n        self._last_word_count = current_word_count\n\n        # Create pace object\n        pace = WritingPace(\n            words_per_minute=words_per_minute,\n            words_per_hour=words_per_minute * 60,\n            words_per_day=words_per_minute * 60 * 24,\n        )\n\n        # Update history\n        self.pace_history.append(pace)\n\n        return pace\n\n    def set_progress_goal(\n        self,\n        goal_id: str,\n        goal_type: str,\n        target: int,\n        deadline: Optional[datetime] = None,\n    ) -> ProgressTracker:\n        \"\"\"Set a new progress goal.\"\"\"\n        tracker = ProgressTracker(\n            start_date=datetime.now(),\n            goal_type=goal_type,\n            goal_target=target,\n            goal_deadline=deadline,\n        )\n\n        self.progress_trackers[goal_id] = tracker\n        return tracker\n\n    def update_progress(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Update the progress for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n\n        tracker = self.progress_trackers[goal_id]\n        current_stats = self.calculate_stats()\n\n        progress_entry = {\n            \"timestamp\": datetime.now(),\n            \"word_count\": current_stats.word_count,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n        }\n\n        if tracker.goal_type == \"word_count\":\n            progress_entry[\"progress_percentage\"] = (\n                current_stats.word_count / tracker.goal_target\n            ) * 100\n            progress_entry[\"remaining\"] = max(\n                0, tracker.goal_target - current_stats.word_count\n            )\n\n        if tracker.goal_deadline:\n            now = datetime.now()\n            if now < tracker.goal_deadline:\n                time_remaining = tracker.goal_deadline - now\n                progress_entry[\"time_remaining_days\"] = time_remaining.days\n\n                # Estimate completion date based on current pace\n                if self.pace_history and tracker.goal_type == \"word_count\":\n                    latest_pace = self.pace_history[-1]\n                    words_remaining = max(\n                        0, tracker.goal_target - current_stats.word_count\n                    )\n\n                    if latest_pace.words_per_day > 0:\n                        days_needed = words_remaining / latest_pace.words_per_day\n                        progress_entry[\"estimated_completion_date\"] = now + timedelta(\n                            days=days_needed\n                        )\n\n        tracker.progress_history.append(progress_entry)\n        return progress_entry\n\n    def get_progress_report(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a detailed progress report for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n\n        tracker = self.progress_trackers[goal_id]\n        current_progress = self.update_progress(goal_id)\n\n        if not current_progress or not tracker.progress_history:\n            return None\n\n        report = {\n            \"goal_id\": goal_id,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n            \"start_date\": tracker.start_date,\n            \"deadline\": tracker.goal_deadline,\n            \"current_progress\": current_progress,\n            \"history_summary\": {\n                \"start_value\": tracker.progress_history[0].get(\"word_count\", 0),\n                \"current_value\": current_progress.get(\"word_count\", 0),\n                \"total_progress\": current_progress.get(\"word_count\", 0)\n                - tracker.progress_history[0].get(\"word_count\", 0),\n            },\n        }\n\n        # Calculate average daily progress\n        if len(tracker.progress_history) > 1:\n            first_entry = tracker.progress_history[0]\n            last_entry = tracker.progress_history[-1]\n\n            first_time = first_entry[\"timestamp\"]\n            last_time = last_entry[\"timestamp\"]\n\n            time_diff_days = (\n                last_time - first_time\n            ).days or 1  # Avoid division by zero\n            progress_diff = last_entry.get(\"word_count\", 0) - first_entry.get(\n                \"word_count\", 0\n            )\n\n            report[\"average_daily_progress\"] = progress_diff / time_diff_days\n\n        return report\n\n    def start_background_tracking(self, interval_seconds: int = 60) -> None:\n        \"\"\"Start tracking statistics in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n\n        self._stop_background_thread = False\n\n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.calculate_stats()\n                    self.calculate_writing_pace()\n\n                    # Update all progress trackers\n                    for goal_id in self.progress_trackers:\n                        self.update_progress(goal_id)\n                except Exception as e:\n                    print(f\"Error in background tracking: {e}\")\n\n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n\n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n\n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)\n\n    def get_trend_analysis(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"Analyze trends in writing statistics over the specified number of days.\"\"\"\n        now = datetime.now()\n        cutoff_date = now - timedelta(days=days)\n\n        # Filter history to the specified time range\n        recent_stats = [s for s in self.stats_history if s.timestamp >= cutoff_date]\n        recent_pace = [p for p in self.pace_history if p.timestamp >= cutoff_date]\n\n        if not recent_stats:\n            return {\"error\": \"Not enough data for trend analysis\"}\n\n        # Calculate daily word counts\n        daily_word_counts = {}\n        for stats in recent_stats:\n            day_key = stats.timestamp.strftime(\"%Y-%m-%d\")\n            if day_key not in daily_word_counts:\n                daily_word_counts[day_key] = []\n            daily_word_counts[day_key].append(stats.word_count)\n\n        # Get the last word count for each day\n        daily_progress = {day: counts[-1] for day, counts in daily_word_counts.items()}\n\n        # Calculate daily difference\n        days_sorted = sorted(daily_progress.keys())\n        daily_change = {}\n        for i in range(1, len(days_sorted)):\n            prev_day = days_sorted[i - 1]\n            curr_day = days_sorted[i]\n            daily_change[curr_day] = daily_progress[curr_day] - daily_progress[prev_day]\n\n        # Calculate reading level trends\n        reading_level_trends = {}\n        for level_type in ReadingLevel:\n            level_values = [\n                s.reading_level.get(level_type.value, 0) for s in recent_stats\n            ]\n            if level_values:\n                reading_level_trends[level_type.value] = {\n                    \"start\": level_values[0],\n                    \"end\": level_values[-1],\n                    \"change\": level_values[-1] - level_values[0],\n                    \"average\": sum(level_values) / len(level_values),\n                }\n\n        # Calculate pace trends\n        pace_trends = {}\n        if recent_pace:\n            wpm_values = [p.words_per_minute for p in recent_pace]\n            pace_trends[\"words_per_minute\"] = {\n                \"start\": wpm_values[0],\n                \"end\": wpm_values[-1],\n                \"change\": wpm_values[-1] - wpm_values[0],\n                \"average\": sum(wpm_values) / len(wpm_values),\n            }\n\n        return {\n            \"period_days\": days,\n            \"total_word_count_change\": recent_stats[-1].word_count\n            - recent_stats[0].word_count,\n            \"daily_progress\": daily_progress,\n            \"daily_change\": daily_change,\n            \"average_daily_change\": sum(daily_change.values()) / len(daily_change)\n            if daily_change\n            else 0,\n            \"reading_level_trends\": reading_level_trends,\n            \"pace_trends\": pace_trends,\n            \"vocabulary_richness_change\": (\n                recent_stats[-1].word_stats.vocabulary_richness\n                - recent_stats[0].word_stats.vocabulary_richness\n            ),\n        }",
                "class ReadingLevel(str, Enum):\n    \"\"\"Different reading level metrics.\"\"\"\n\n    FLESCH_KINCAID_GRADE = \"flesch_kincaid_grade\"\n    FLESCH_READING_EASE = \"flesch_reading_ease\"\n    GUNNING_FOG = \"gunning_fog\"\n    SMOG_INDEX = \"smog_index\"\n    AUTOMATED_READABILITY_INDEX = \"automated_readability_index\"\n    COLEMAN_LIAU_INDEX = \"coleman_liau_index\"\n    DALE_CHALL_READABILITY_SCORE = \"dale_chall_readability_score\"\n    LINSEAR_WRITE_FORMULA = \"linsear_write_formula\"\n    SPACHE_READABILITY = \"spache_readability\"",
                "class DocumentStats(BaseModel):\n    \"\"\"Overall document statistics.\"\"\"\n\n    word_count: int\n    character_count: int\n    paragraph_count: int\n    sentence_count: int\n    reading_level: Dict[str, float]\n    word_stats: WordStats\n    sentence_stats: SentenceStats\n    timestamp: datetime = Field(default_factory=datetime.now)",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n\n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n\n    def _find_element_occurrences(\n        self, element_name: str, aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n\n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = (\n            r\"\\b(\" + \"|\".join(re.escape(name) for name in names_to_search) + r\")\\b\"\n        )\n        regex = re.compile(pattern, re.IGNORECASE)\n\n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n\n                    results.append((section, segment, match.start(), context))\n\n        return results\n\n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n\n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set(),\n        }\n\n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n\n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n\n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n\n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(\n                    re.findall(r\"\\b\" + re.escape(element) + r\"\\b\", text, re.IGNORECASE)\n                )\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element\n                        in [e.name for e in self.elements.values()],\n                    }\n\n        return results\n\n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n\n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n\n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n\n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n\n                co_occurrences = 0\n                for context in contexts:\n                    pattern = (\n                        r\"\\b(\"\n                        + \"|\".join(\n                            [re.escape(other_element.name)]\n                            + [re.escape(alias) for alias in other_element.aliases]\n                        )\n                        + r\")\\b\"\n                    )\n\n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n\n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n\n        return connections\n\n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n\n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n\n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n\n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n\n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n\n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(\n                        char_timeline_sections, key=lambda s: timeline_sections[s]\n                    )\n\n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n\n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(\n                                        ConsistencyIssue(\n                                            id=str(len(issues) + 1),\n                                            issue_type=\"timeline\",\n                                            elements_involved=[char_id],\n                                            description=(\n                                                f\"Character appears in non-sequential timeline points: \"\n                                                f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[k]]}\"\n                                            ),\n                                            locations=[\n                                                (sorted_sections[i], \"\"),\n                                                (sorted_sections[j], \"\"),\n                                                (sorted_sections[k], \"\"),\n                                            ],\n                                            severity=3,\n                                        )\n                                    )\n\n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n\n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n\n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name) :]\n\n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r\"\\s+was\\s+(\\w+)\",\n                        r\"\\s+had\\s+(\\w+)\",\n                        r\"\\s+with\\s+(\\w+)\",\n                        r\",\\s+a\\s+(\\w+)\",\n                        r\",\\s+the\\s+(\\w+)\",\n                    ]\n\n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append(\n                                (\n                                    occurrence.section_id,\n                                    occurrence.segment_id,\n                                    match.group(1),\n                                    context,\n                                )\n                            )\n\n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n\n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\"),\n                ]\n\n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(\n                            ConsistencyIssue(\n                                id=str(len(issues) + 1),\n                                issue_type=\"contradiction\",\n                                elements_involved=[element_id],\n                                description=(\n                                    f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                                ),\n                                locations=[\n                                    (\n                                        descriptions[word1][0][0],\n                                        descriptions[word1][0][1],\n                                    ),\n                                    (\n                                        descriptions[word2][0][0],\n                                        descriptions[word2][0][1],\n                                    ),\n                                ],\n                                severity=4,\n                            )\n                        )\n\n        return issues\n\n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None,\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n\n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(\n            name, aliases\n        ):\n            occurrences.append(\n                ElementOccurrence(\n                    element_id=element_id,\n                    section_id=section.id,\n                    segment_id=segment.id,\n                    position=position,\n                    context=context,\n                )\n            )\n\n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None,\n        )\n\n        self.elements[element_id] = element\n        return element\n\n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n\n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: [],\n        }\n\n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name, element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n\n        # Update element relationships\n        self.update_element_relationships()\n\n        # Detect consistency issues\n        self.check_consistency()\n\n        return tracked_elements\n\n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n\n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n\n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n\n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n\n        element = self.elements[element_id]\n        appearances = []\n\n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n\n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n\n            if section and segment:\n                appearances.append(\n                    {\n                        \"section_title\": section.title,\n                        \"section_id\": section.id,\n                        \"segment_id\": segment.id,\n                        \"segment_position\": segment.position,\n                        \"context\": occurrence.context,\n                        \"mentioned_with\": [\n                            self.elements[e_id].name\n                            for e_id in occurrence.mentioned_with\n                            if e_id in self.elements\n                        ],\n                    }\n                )\n\n        return appearances\n\n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n\n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": [],\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n\n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append(\n                    {\n                        \"section_id\": section.id,\n                        \"section_title\": sections[section.id][\"section_title\"],\n                        \"appearances\": sorted(\n                            sections[section.id][\"appearances\"],\n                            key=lambda a: a[\"segment_position\"],\n                        ),\n                    }\n                )\n\n        return ordered_sections\n\n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n\n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n\n        self._stop_background_thread = False\n\n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n\n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n\n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n\n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n\n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class NarrativeElement(BaseModel):\n    \"\"\"A tracked narrative element such as a character or plot element.\"\"\"\n\n    id: str\n    name: str\n    element_type: ElementType\n    aliases: List[str] = Field(default_factory=list)\n    description: str = \"\"\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    occurrences: List[ElementOccurrence] = Field(default_factory=list)\n    related_elements: Dict[str, float] = Field(\n        default_factory=dict\n    )  # Element ID to relationship strength\n    first_appearance: Optional[datetime] = None\n    last_appearance: Optional[datetime] = None",
                "class DocumentNavigator:\n    \"\"\"Non-linear document navigation system.\"\"\"\n\n    def __init__(\n        self, document: Document, narrative_tracker: Optional[NarrativeTracker] = None\n    ):\n        \"\"\"Initialize the navigation system with the given document.\"\"\"\n        self.document = document\n        self.narrative_tracker = narrative_tracker\n        self.elements: Dict[str, NavigationElement] = {}\n        self.views: Dict[str, NavigationView] = {}\n        self.tags: Dict[str, NavigationTag] = {}\n        self.links: Dict[str, NavigationLink] = {}\n        self.current_position: Optional[NavigationPosition] = None\n\n        # Initialize with default linear view\n        self._initialize_linear_view()\n\n    def _initialize_linear_view(self) -> None:\n        \"\"\"Initialize the default linear view of the document.\"\"\"\n        # Create view\n        view_id = \"view_linear\"\n        view = NavigationView(\n            id=view_id, name=\"Linear View\", view_type=NavigationViewType.LINEAR\n        )\n\n        # Create elements for sections and segments\n        root_elements = []\n\n        for section_idx, section in enumerate(self.document.current_revision.sections):\n            # Create element for the section\n            section_element_id = f\"element_section_{section.id}\"\n            section_element = NavigationElement(\n                id=section_element_id,\n                element_type=\"section\",\n                name=section.title,\n                original_id=section.id,\n            )\n\n            # Add to elements\n            self.elements[section_element_id] = section_element\n            root_elements.append(section_element_id)\n\n            # Create elements for segments\n            for segment_idx, segment in enumerate(section.segments):\n                segment_element_id = f\"element_segment_{segment.id}\"\n                segment_element = NavigationElement(\n                    id=segment_element_id,\n                    element_type=\"segment\",\n                    name=f\"Paragraph {segment_idx + 1}\",\n                    original_id=segment.id,\n                )\n\n                # Add to elements\n                self.elements[segment_element_id] = segment_element\n\n                # Add to section's children\n                section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        # Set current position to the first section if available\n        if root_elements:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=root_elements[0]\n            )\n            # Initialize a structured position for the first section\n            if self.document.current_revision.sections:\n                first_section = self.document.current_revision.sections[0]\n                element_type = StructuredElementType.SECTION\n                self.current_position.position = StructuredPosition(\n                    view_id=view_id,\n                    element_id=first_section.id,\n                    element_type=element_type,\n                    section_index=0,\n                    segment_index=0,\n                    offset_in_segment=0\n                )\n\n    def _create_character_view(self) -> str:\n        \"\"\"Create a view organized by characters.\"\"\"\n        if not self.narrative_tracker:\n            return \"\"\n\n        # Create view\n        view_id = \"view_character\"\n        view = NavigationView(\n            id=view_id, name=\"Character View\", view_type=NavigationViewType.CHARACTER\n        )\n\n        # Get character elements from the narrative tracker\n        character_elements = [\n            element\n            for element in self.narrative_tracker.elements.values()\n            if element.element_type == ElementType.CHARACTER\n        ]\n\n        # Create elements for each character\n        root_elements = []\n\n        for character in character_elements:\n            # Create element for the character\n            character_element_id = f\"element_character_{character.id}\"\n            character_element = NavigationElement(\n                id=character_element_id,\n                element_type=\"character\",\n                name=character.name,\n                original_id=character.id,\n                metadata={\"description\": character.description},\n            )\n\n            # Add to elements\n            self.elements[character_element_id] = character_element\n            root_elements.append(character_element_id)\n\n            # Get appearances of this character\n            appearances = self.narrative_tracker.get_element_appearances(character.id)\n\n            # Group by section\n            section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n            for appearance in appearances:\n                section_id = appearance[\"section_id\"]\n                if section_id not in section_appearances:\n                    section_appearances[section_id] = []\n                section_appearances[section_id].append(appearance)\n\n            # Create elements for each section with appearances\n            for section_id, section_apps in section_appearances.items():\n                # Get the section\n                section = None\n                for s in self.document.current_revision.sections:\n                    if s.id == section_id:\n                        section = s\n                        break\n\n                if not section:\n                    continue\n\n                # Create element for the section\n                section_element_id = (\n                    f\"element_character_section_{character.id}_{section.id}\"\n                )\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n\n                # Add to character's children\n                character_element.children.append(section_element_id)\n\n                # Create elements for each appearance\n                for appearance in section_apps:\n                    segment_id = appearance[\"segment_id\"]\n\n                    # Get the segment\n                    segment = None\n                    for seg in section.segments:\n                        if seg.id == segment_id:\n                            segment = seg\n                            break\n\n                    if not segment:\n                        continue\n\n                    # Create element for the segment\n                    segment_element_id = (\n                        f\"element_character_segment_{character.id}_{segment.id}\"\n                    )\n\n                    # Skip if already added\n                    if segment_element_id in self.elements:\n                        continue\n\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Appearance {len(section_element.children) + 1}\",\n                        original_id=segment.id,\n                        metadata={\"context\": appearance[\"context\"]},\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def _create_plot_view(self) -> str:\n        \"\"\"Create a view organized by plot elements.\"\"\"\n        # Create view\n        view_id = \"view_plot\"\n        view = NavigationView(\n            id=view_id, name=\"Plot View\", view_type=NavigationViewType.PLOT\n        )\n\n        # First, look for plot-related metadata in the document\n        plot_elements = []\n\n        # Check for plot tags\n        plot_tags = [tag for tag in self.tags.values() if \"plot\" in tag.name.lower()]\n\n        if plot_tags:\n            # Organize by plot tags\n            for tag in plot_tags:\n                # Create element for the tag\n                tag_element_id = f\"element_plot_tag_{tag.id}\"\n                tag_element = NavigationElement(\n                    id=tag_element_id,\n                    element_type=\"tag\",\n                    name=tag.name,\n                    original_id=tag.id,\n                )\n\n                # Add to elements\n                self.elements[tag_element_id] = tag_element\n                plot_elements.append(tag_element_id)\n\n                # Find elements with this tag\n                for element_id, element in self.elements.items():\n                    if tag.id in element.tags:\n                        # Create a reference element\n                        ref_element_id = f\"element_plot_ref_{tag.id}_{element.id}\"\n                        ref_element = NavigationElement(\n                            id=ref_element_id,\n                            element_type=element.element_type,\n                            name=element.name,\n                            original_id=element.original_id,\n                        )\n\n                        # Add to elements\n                        self.elements[ref_element_id] = ref_element\n\n                        # Add to tag's children\n                        tag_element.children.append(ref_element_id)\n\n        # If we have a narrative tracker, use plot elements from there\n        elif self.narrative_tracker:\n            # Get plot elements from the narrative tracker\n            plot_narrative_elements = [\n                element\n                for element in self.narrative_tracker.elements.values()\n                if element.element_type\n                in (ElementType.EVENT, ElementType.ITEM, ElementType.TERM)\n            ]\n\n            for plot_element in plot_narrative_elements:\n                # Create element for the plot element\n                plot_element_id = f\"element_plot_{plot_element.id}\"\n                plot_nav_element = NavigationElement(\n                    id=plot_element_id,\n                    element_type=\"plot\",\n                    name=plot_element.name,\n                    original_id=plot_element.id,\n                    metadata={\"description\": plot_element.description},\n                )\n\n                # Add to elements\n                self.elements[plot_element_id] = plot_nav_element\n                plot_elements.append(plot_element_id)\n\n                # Get appearances of this plot element\n                appearances = self.narrative_tracker.get_element_appearances(\n                    plot_element.id\n                )\n\n                # Group by section\n                section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n                for appearance in appearances:\n                    section_id = appearance[\"section_id\"]\n                    if section_id not in section_appearances:\n                        section_appearances[section_id] = []\n                    section_appearances[section_id].append(appearance)\n\n                # Create elements for each section with appearances\n                for section_id, section_apps in section_appearances.items():\n                    # Get the section\n                    section = None\n                    for s in self.document.current_revision.sections:\n                        if s.id == section_id:\n                            section = s\n                            break\n\n                    if not section:\n                        continue\n\n                    # Create element for the section\n                    section_element_id = (\n                        f\"element_plot_section_{plot_element.id}_{section.id}\"\n                    )\n                    section_element = NavigationElement(\n                        id=section_element_id,\n                        element_type=\"section\",\n                        name=section.title,\n                        original_id=section.id,\n                    )\n\n                    # Add to elements\n                    self.elements[section_element_id] = section_element\n\n                    # Add to plot element's children\n                    plot_nav_element.children.append(section_element_id)\n\n                    # Create elements for each appearance\n                    for appearance in section_apps:\n                        segment_id = appearance[\"segment_id\"]\n\n                        # Get the segment\n                        segment = None\n                        for seg in section.segments:\n                            if seg.id == segment_id:\n                                segment = seg\n                                break\n\n                        if not segment:\n                            continue\n\n                        # Create element for the segment\n                        segment_element_id = (\n                            f\"element_plot_segment_{plot_element.id}_{segment.id}\"\n                        )\n\n                        # Skip if already added\n                        if segment_element_id in self.elements:\n                            continue\n\n                        segment_element = NavigationElement(\n                            id=segment_element_id,\n                            element_type=\"segment\",\n                            name=f\"Reference {len(section_element.children) + 1}\",\n                            original_id=segment.id,\n                            metadata={\"context\": appearance[\"context\"]},\n                        )\n\n                        # Add to elements\n                        self.elements[segment_element_id] = segment_element\n\n                        # Add to section's children\n                        section_element.children.append(segment_element_id)\n\n        # If we don't have plot tags or narrative tracker, create a dummy structure\n        if not plot_elements:\n            # Create a default \"plot\" element\n            plot_element_id = \"element_plot_default\"\n            plot_element = NavigationElement(\n                id=plot_element_id, element_type=\"plot\", name=\"Main Plot\"\n            )\n\n            # Add to elements\n            self.elements[plot_element_id] = plot_element\n            plot_elements.append(plot_element_id)\n\n            # Add all sections as children\n            for section in self.document.current_revision.sections:\n                # Create element for the section\n                section_element_id = f\"element_plot_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n\n                # Add to plot's children\n                plot_element.children.append(section_element_id)\n\n        # Update view\n        view.root_elements = plot_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def _create_timeline_view(self) -> str:\n        \"\"\"Create a view organized by timeline/chronology.\"\"\"\n        # Create view\n        view_id = \"view_timeline\"\n        view = NavigationView(\n            id=view_id, name=\"Timeline View\", view_type=NavigationViewType.TIMELINE\n        )\n\n        # Check for timeline metadata in sections\n        timeline_sections = []\n\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections.append((section, section.metadata[\"timeline\"]))\n\n        # If we have timeline metadata, use it to organize the view\n        if timeline_sections:\n            # Sort sections by timeline value\n            timeline_sections.sort(key=lambda x: x[1])\n\n            # Create elements for each section in chronological order\n            root_elements = []\n\n            for section, timeline in timeline_sections:\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=f\"{timeline}: {section.title}\",\n                    original_id=section.id,\n                    metadata={\"timeline\": timeline},\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n\n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id,\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        else:\n            # Create a simple chronological view (same as linear)\n            root_elements = []\n\n            for section_idx, section in enumerate(\n                self.document.current_revision.sections\n            ):\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                    metadata={\"position\": section_idx},\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n\n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id,\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def create_view(self, name: str, view_type: NavigationViewType) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        if view_type == NavigationViewType.CHARACTER:\n            return self._create_character_view()\n        elif view_type == NavigationViewType.PLOT:\n            return self._create_plot_view()\n        elif view_type == NavigationViewType.TIMELINE:\n            return self._create_timeline_view()\n        elif view_type == NavigationViewType.CUSTOM:\n            # Create a custom view\n            view_id = f\"view_custom_{len(self.views) + 1}\"\n            view = NavigationView(id=view_id, name=name, view_type=view_type)\n\n            self.views[view_id] = view\n            return view_id\n        else:\n            # Linear view already exists\n            return \"view_linear\"\n\n    def create_tag(self, name: str, color: str = \"#CCCCCC\") -> str:\n        \"\"\"Create a new tag for navigation elements.\"\"\"\n        tag_id = f\"tag_{len(self.tags) + 1}\"\n        tag = NavigationTag(id=tag_id, name=name, color=color)\n\n        self.tags[tag_id] = tag\n        return tag_id\n\n    def add_tag_to_element(self, element_id: str, tag_id: str) -> bool:\n        \"\"\"Add a tag to a navigation element.\"\"\"\n        if element_id not in self.elements or tag_id not in self.tags:\n            return False\n\n        element = self.elements[element_id]\n        if tag_id not in element.tags:\n            element.tags.append(tag_id)\n\n        return True\n\n    def create_link(\n        self,\n        source_type: str,\n        source_id: str,\n        target_type: str,\n        target_id: str,\n        link_type: str,\n    ) -> str:\n        \"\"\"Create a link between two navigation elements.\"\"\"\n        link_id = f\"link_{len(self.links) + 1}\"\n        link = NavigationLink(\n            id=link_id,\n            source_type=source_type,\n            source_id=source_id,\n            target_type=target_type,\n            target_id=target_id,\n            link_type=link_type,\n        )\n\n        self.links[link_id] = link\n        return link_id\n\n    def add_element_to_view(\n        self, view_id: str, element_id: str, parent_id: Optional[str] = None\n    ) -> bool:\n        \"\"\"Add an element to a view, optionally as a child of another element.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n\n        view = self.views[view_id]\n\n        if parent_id:\n            if parent_id not in self.elements:\n                return False\n\n            parent = self.elements[parent_id]\n            if element_id not in parent.children:\n                parent.children.append(element_id)\n        else:\n            if element_id not in view.root_elements:\n                view.root_elements.append(element_id)\n\n        return True\n\n    def get_current_element(self) -> Optional[NavigationElement]:\n        \"\"\"Get the current navigation element.\"\"\"\n        if not self.current_position:\n            return None\n\n        element_id = self.current_position.element_id\n        return self.elements.get(element_id)\n\n    def get_element_content(self, element_id: str) -> Optional[str]:\n        \"\"\"Get the content of a navigation element.\"\"\"\n        if element_id not in self.elements:\n            return None\n\n        element = self.elements[element_id]\n        original_id = element.original_id\n\n        if not original_id:\n            return None\n\n        if element.element_type == \"section\":\n            # Find the section\n            for section in self.document.current_revision.sections:\n                if section.id == original_id:\n                    return section.get_content()\n\n        elif element.element_type == \"segment\":\n            # Find the segment\n            for section in self.document.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == original_id:\n                        return segment.content\n\n        return None\n\n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n\n        # Find the element to navigate to\n        nav_element = self.elements.get(element_id)\n        if not nav_element or not nav_element.original_id:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=element_id\n            )\n            return True\n            \n        # Create a structured position based on the element type\n        element_type = None\n        section_index = 0\n        segment_index = 0\n        \n        if nav_element.element_type == \"section\":\n            element_type = StructuredElementType.SECTION\n            # Find section index\n            for i, section in enumerate(self.document.current_revision.sections):\n                if section.id == nav_element.original_id:\n                    section_index = i\n                    break\n        elif nav_element.element_type == \"segment\":\n            element_type = StructuredElementType.SEGMENT\n            # Find section and segment indices\n            for i, section in enumerate(self.document.current_revision.sections):\n                for j, segment in enumerate(section.segments):\n                    if segment.id == nav_element.original_id:\n                        section_index = i\n                        segment_index = j\n                        break\n                if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                    break\n                    \n        if element_type:\n            position = StructuredPosition(\n                view_id=view_id,\n                element_id=nav_element.original_id,\n                element_type=element_type,\n                section_index=section_index,\n                segment_index=segment_index,\n                offset_in_segment=0\n            )\n            self.current_position = NavigationPosition(\n                view_id=view_id, \n                element_id=element_id,\n                position=position\n            )\n        else:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=element_id\n            )\n            \n        return True\n\n        return True\n\n    def navigate_to_related(\n        self, link_type: Optional[str] = None\n    ) -> List[NavigationElement]:\n        \"\"\"Navigate to elements related to the current element.\"\"\"\n        if not self.current_position:\n            return []\n\n        current_element_id = self.current_position.element_id\n\n        # Find links with this element as source\n        related_links = []\n        for link in self.links.values():\n            if link.source_id == current_element_id:\n                if not link_type or link.link_type == link_type:\n                    related_links.append(link)\n\n        # Get related elements\n        related_elements = []\n        for link in related_links:\n            target_id = link.target_id\n            if target_id in self.elements:\n                related_elements.append(self.elements[target_id])\n\n        return related_elements\n\n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Find parent element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Navigate to parent\n            nav_element = self.elements.get(parent_id)\n            if not nav_element or not nav_element.original_id:\n                self.current_position = NavigationPosition(\n                    view_id=view_id, element_id=parent_id\n                )\n                return True\n                \n            # Create a structured position\n            element_type = None\n            section_index = 0\n            segment_index = 0\n            \n            if nav_element.element_type == \"section\":\n                element_type = StructuredElementType.SECTION\n                # Find section index\n                for i, section in enumerate(self.document.current_revision.sections):\n                    if section.id == nav_element.original_id:\n                        section_index = i\n                        break\n            \n            if element_type:\n                position = StructuredPosition(\n                    view_id=view_id,\n                    element_id=nav_element.original_id,\n                    element_type=element_type,\n                    section_index=section_index,\n                    segment_index=segment_index,\n                    offset_in_segment=0\n                )\n                self.current_position = NavigationPosition(\n                    view_id=view_id, \n                    element_id=parent_id,\n                    position=position\n                )\n            else:\n                self.current_position = NavigationPosition(\n                    view_id=view_id, element_id=parent_id\n                )\n                \n            return True\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Already at top level\n            return False\n\n        return False\n\n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Check if this element is a child of another element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n\n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n\n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(siblings):\n                    next_id = siblings[current_index + 1]\n                    # Navigate to next sibling\n                    nav_element = self.elements.get(next_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=next_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n\n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(view.root_elements):\n                    next_id = view.root_elements[current_index + 1]\n                    # Navigate to next root element\n                    nav_element = self.elements.get(next_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=next_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        return False\n\n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Check if this element is a child of another element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n\n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n\n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = siblings[current_index - 1]\n                    # Navigate to previous sibling\n                    nav_element = self.elements.get(prev_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=prev_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n\n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = view.root_elements[current_index - 1]\n                    # Navigate to previous root element\n                    nav_element = self.elements.get(prev_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=prev_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        return False\n\n    def navigate_children(self) -> List[NavigationElement]:\n        \"\"\"Get the children of the current element.\"\"\"\n        if not self.current_position:\n            return []\n\n        current_element_id = self.current_position.element_id\n\n        # Get element\n        element = self.elements.get(current_element_id)\n        if not element:\n            return []\n\n        # Get children\n        children = []\n        for child_id in element.children:\n            if child_id in self.elements:\n                children.append(self.elements[child_id])\n\n        return children\n\n    def find_elements_by_tag(self, tag_id: str) -> List[NavigationElement]:\n        \"\"\"Find all elements with a specific tag.\"\"\"\n        if tag_id not in self.tags:\n            return []\n\n        # Find elements with this tag\n        tagged_elements = []\n        for element_id, element in self.elements.items():\n            if tag_id in element.tags:\n                tagged_elements.append(element)\n\n        return tagged_elements\n\n    def find_elements_by_name(self, name: str) -> List[NavigationElement]:\n        \"\"\"Find elements by name (case-insensitive partial match).\"\"\"\n        name = name.lower()\n\n        matching_elements = []\n        for element_id, element in self.elements.items():\n            if name in element.name.lower():\n                matching_elements.append(element)\n\n        return matching_elements\n\n    def get_path_to_element(self, element_id: str) -> List[str]:\n        \"\"\"Get the path from root to the specified element.\"\"\"\n        if element_id not in self.elements:\n            return []\n\n        # Find view that contains this element\n        view_id = None\n        for view_id, view in self.views.items():\n            if element_id in view.root_elements:\n                break\n\n            # Check if it's a descendant of any root element\n            for root_id in view.root_elements:\n                if self._is_descendant(root_id, element_id):\n                    view_id = view_id\n                    break\n\n            if view_id:\n                break\n\n        if not view_id:\n            return []\n\n        # Find path\n        path = []\n        current_id = element_id\n\n        while current_id:\n            path.insert(0, current_id)\n\n            # Find parent\n            parent_id = None\n            for element_id, element in self.elements.items():\n                if current_id in element.children:\n                    parent_id = element_id\n                    break\n\n            # If no parent, check if it's a root element\n            if not parent_id:\n                # If it's a root element, we've reached the top\n                if current_id in self.views[view_id].root_elements:\n                    break\n\n            current_id = parent_id\n\n        return path\n\n    def _is_descendant(self, ancestor_id: str, descendant_id: str) -> bool:\n        \"\"\"Check if descendant_id is a descendant of ancestor_id.\"\"\"\n        if ancestor_id not in self.elements:\n            return False\n\n        # Check direct children\n        ancestor = self.elements[ancestor_id]\n        if descendant_id in ancestor.children:\n            return True\n\n        # Check descendants recursively\n        for child_id in ancestor.children:\n            if self._is_descendant(child_id, descendant_id):\n                return True\n\n        return False",
                "class NavigationViewType(str, Enum):\n    \"\"\"Types of navigation views.\"\"\"\n\n    LINEAR = \"linear\"  # Traditional linear document view\n    CHAPTER = \"chapter\"  # Organized by chapters/sections\n    CHARACTER = \"character\"  # Organized by character appearances\n    PLOT = \"plot\"  # Organized by plot elements/arcs\n    TIMELINE = \"timeline\"  # Organized by timeline/chronology\n    CUSTOM = \"custom\"",
                "class RevisionManager:\n    \"\"\"Revision management system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the revision manager with the given document.\"\"\"\n        self.document = document\n        self.diffs: Dict[str, RevisionDiff] = {}\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        return self.document.create_revision(name=name, metadata=metadata)\n\n    def compare_revisions(\n        self, old_revision_name: str, new_revision_name: str\n    ) -> Optional[RevisionDiff]:\n        \"\"\"Compare two revisions and generate a diff.\"\"\"\n        old_revision = self.document.get_revision(old_revision_name)\n        new_revision = self.document.get_revision(new_revision_name)\n\n        if not old_revision or not new_revision:\n            return None\n\n        # Create a unique ID for this diff\n        diff_id = f\"{old_revision_name}_{new_revision_name}\"\n\n        # Check if we already have this diff\n        if diff_id in self.diffs:\n            return self.diffs[diff_id]\n\n        # Create a new diff\n        revision_diff = RevisionDiff(\n            old_revision_id=old_revision.id,\n            new_revision_id=new_revision.id,\n            old_revision_name=old_revision_name,\n            new_revision_name=new_revision_name,\n        )\n\n        # Compare sections\n        old_sections_by_id = {section.id: section for section in old_revision.sections}\n        new_sections_by_id = {section.id: section for section in new_revision.sections}\n\n        # Find common section IDs\n        common_section_ids = set(old_sections_by_id.keys()) & set(\n            new_sections_by_id.keys()\n        )\n\n        # Find added and removed sections\n        added_section_ids = set(new_sections_by_id.keys()) - set(\n            old_sections_by_id.keys()\n        )\n        removed_section_ids = set(old_sections_by_id.keys()) - set(\n            new_sections_by_id.keys()\n        )\n\n        # Process added sections\n        for section_id in added_section_ids:\n            section = new_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.INSERT,\n                section_id=section_id,\n                new_title=section.title,\n            )\n\n            # Add all segments as inserted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment.id,\n                    new_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            revision_diff.section_diffs.append(section_diff)\n\n        # Process removed sections\n        for section_id in removed_section_ids:\n            section = old_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.DELETE,\n                section_id=section_id,\n                old_title=section.title,\n            )\n\n            # Add all segments as deleted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment.id,\n                    old_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            revision_diff.section_diffs.append(section_diff)\n\n        # Process common sections\n        for section_id in common_section_ids:\n            old_section = old_sections_by_id[section_id]\n            new_section = new_sections_by_id[section_id]\n\n            # Check if title changed\n            if old_section.title != new_section.title:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.REPLACE,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title,\n                )\n            else:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.EQUAL,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title,\n                )\n\n            # Compare segments within the section\n            old_segments_by_id = {\n                segment.id: segment for segment in old_section.segments\n            }\n            new_segments_by_id = {\n                segment.id: segment for segment in new_section.segments\n            }\n\n            # Find common segment IDs\n            common_segment_ids = set(old_segments_by_id.keys()) & set(\n                new_segments_by_id.keys()\n            )\n\n            # Find added and removed segments\n            added_segment_ids = set(new_segments_by_id.keys()) - set(\n                old_segments_by_id.keys()\n            )\n            removed_segment_ids = set(old_segments_by_id.keys()) - set(\n                new_segments_by_id.keys()\n            )\n\n            # Process added segments\n            for segment_id in added_segment_ids:\n                segment = new_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment_id,\n                    new_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            # Process removed segments\n            for segment_id in removed_segment_ids:\n                segment = old_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment_id,\n                    old_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            # Process common segments\n            for segment_id in common_segment_ids:\n                old_segment = old_segments_by_id[segment_id]\n                new_segment = new_segments_by_id[segment_id]\n\n                # Check if content changed\n                if old_segment.content != new_segment.content:\n                    segment_diff = SegmentDiff(\n                        diff_type=DiffType.REPLACE,\n                        segment_id=segment_id,\n                        old_content=old_segment.content,\n                        new_content=new_segment.content,\n                        position=new_segment.position,\n                    )\n                    section_diff.segment_diffs.append(segment_diff)\n\n            # Only add section diff if there are changes\n            if section_diff.diff_type != DiffType.EQUAL or section_diff.segment_diffs:\n                revision_diff.section_diffs.append(section_diff)\n\n        # Store and return the diff\n        self.diffs[diff_id] = revision_diff\n        return revision_diff\n\n    def get_html_diff(self, old_content: str, new_content: str) -> str:\n        \"\"\"Generate an HTML diff of two texts.\"\"\"\n        differ = difflib.HtmlDiff()\n        return differ.make_file(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            context=True,\n        )\n\n    def get_unified_diff(\n        self, old_content: str, new_content: str, context_lines: int = 3\n    ) -> str:\n        \"\"\"Generate a unified diff of two texts.\"\"\"\n        return \"\\n\".join(\n            difflib.unified_diff(\n                old_content.splitlines(),\n                new_content.splitlines(),\n                \"Old Version\",\n                \"New Version\",\n                n=context_lines,\n            )\n        )\n\n    def get_detailed_segment_diff(\n        self, old_content: str, new_content: str\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate a detailed word-level diff of two segment contents.\"\"\"\n        # Split into words\n        old_words = old_content.split()\n        new_words = new_content.split()\n\n        # Get opcodes\n        matcher = difflib.SequenceMatcher(None, old_words, new_words)\n        opcodes = matcher.get_opcodes()\n\n        result = []\n        for tag, i1, i2, j1, j2 in opcodes:\n            if tag == \"equal\":\n                result.append({\"type\": \"equal\", \"content\": \" \".join(old_words[i1:i2])})\n            elif tag == \"replace\":\n                result.append({\"type\": \"delete\", \"content\": \" \".join(old_words[i1:i2])})\n                result.append({\"type\": \"insert\", \"content\": \" \".join(new_words[j1:j2])})\n            elif tag == \"delete\":\n                result.append({\"type\": \"delete\", \"content\": \" \".join(old_words[i1:i2])})\n            elif tag == \"insert\":\n                result.append({\"type\": \"insert\", \"content\": \" \".join(new_words[j1:j2])})\n\n        return result\n\n    def apply_diff(\n        self, diff: RevisionDiff, target_revision_name: Optional[str] = None\n    ) -> Optional[Revision]:\n        \"\"\"Apply a diff to a revision to create a new revision.\"\"\"\n        # If target_revision_name is not provided, create a new revision\n        if not target_revision_name:\n            target_revision_name = (\n                f\"Merged_{diff.old_revision_name}_{diff.new_revision_name}\"\n            )\n\n        # Create a new revision based on the old revision\n        old_revision = self.document.get_revision(diff.old_revision_name)\n        if not old_revision:\n            return None\n\n        # Create a deep copy of the old revision\n        target_revision = self.create_revision(\n            name=target_revision_name,\n            metadata={\"merged_from\": [diff.old_revision_name, diff.new_revision_name]},\n        )\n\n        # Apply section changes\n        for section_diff in diff.section_diffs:\n            section_id = section_diff.section_id\n\n            if section_diff.diff_type == DiffType.INSERT:\n                # Add new section\n                new_section = Section(\n                    id=section_id, title=section_diff.new_title or \"\", segments=[]\n                )\n\n                # Add segment diffs\n                for segment_diff in section_diff.segment_diffs:\n                    if segment_diff.diff_type == DiffType.INSERT:\n                        segment = TextSegment(\n                            id=segment_diff.segment_id or \"\",\n                            content=segment_diff.new_content or \"\",\n                            position=segment_diff.position or 0,\n                        )\n                        new_section.segments.append(segment)\n\n                # Add to target revision\n                target_revision.sections.append(new_section)\n\n            elif section_diff.diff_type == DiffType.DELETE:\n                # Remove section\n                for i, section in enumerate(target_revision.sections):\n                    if section.id == section_id:\n                        target_revision.sections.pop(i)\n                        break\n\n            elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                # Update section title if it changed\n                for section in target_revision.sections:\n                    if section.id == section_id:\n                        if section_diff.new_title:\n                            section.title = section_diff.new_title\n\n                        # Process segment changes\n                        for segment_diff in section_diff.segment_diffs:\n                            segment_id = segment_diff.segment_id\n\n                            if segment_diff.diff_type == DiffType.INSERT:\n                                # Add new segment\n                                segment = TextSegment(\n                                    id=segment_id or \"\",\n                                    content=segment_diff.new_content or \"\",\n                                    position=segment_diff.position or 0,\n                                )\n\n                                # Insert at the right position\n                                if segment_diff.position is not None:\n                                    if segment_diff.position < len(section.segments):\n                                        section.segments.insert(\n                                            segment_diff.position, segment\n                                        )\n                                    else:\n                                        section.segments.append(segment)\n                                else:\n                                    section.segments.append(segment)\n\n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n\n                            elif segment_diff.diff_type == DiffType.DELETE:\n                                # Remove segment\n                                for i, segment in enumerate(section.segments):\n                                    if segment.id == segment_id:\n                                        section.segments.pop(i)\n                                        break\n\n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n\n                            elif segment_diff.diff_type == DiffType.REPLACE:\n                                # Update segment content\n                                for segment in section.segments:\n                                    if (\n                                        segment.id == segment_id\n                                        and segment_diff.new_content\n                                    ):\n                                        segment.content = segment_diff.new_content\n                                        break\n\n                        break\n\n        # Update document's current revision\n        self.document.current_revision = target_revision\n\n        return target_revision\n\n    def merge_revisions(\n        self,\n        base_revision_name: str,\n        revision_names: List[str],\n        merge_strategy: Dict[str, str] = None,\n    ) -> Optional[Revision]:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        # Get base revision\n        base_revision = self.document.get_revision(base_revision_name)\n        if not base_revision:\n            return None\n\n        # Create a new revision based on the base revision\n        merged_revision_name = f\"Merged_{base_revision_name}_{'_'.join(revision_names)}\"\n        merged_revision = self.create_revision(\n            name=merged_revision_name,\n            metadata={\"merged_from\": [base_revision_name] + revision_names},\n        )\n\n        # Default merge strategy: last writer wins\n        if not merge_strategy:\n            merge_strategy = {}\n\n        # Apply diffs from each revision\n        for revision_name in revision_names:\n            # Compare with base revision\n            diff = self.compare_revisions(base_revision_name, revision_name)\n            if not diff:\n                continue\n\n            # Apply changes\n            for section_diff in diff.section_diffs:\n                section_id = section_diff.section_id\n\n                # Check merge strategy for this section\n                section_strategy = merge_strategy.get(section_id, \"last_writer_wins\")\n\n                if section_strategy == \"ignore\":\n                    # Skip this section\n                    continue\n\n                if section_diff.diff_type == DiffType.INSERT:\n                    # Add new section\n                    new_section = Section(\n                        id=section_id, title=section_diff.new_title or \"\", segments=[]\n                    )\n\n                    # Add segment diffs\n                    for segment_diff in section_diff.segment_diffs:\n                        if segment_diff.diff_type == DiffType.INSERT:\n                            segment = TextSegment(\n                                id=segment_diff.segment_id or \"\",\n                                content=segment_diff.new_content or \"\",\n                                position=segment_diff.position or 0,\n                            )\n                            new_section.segments.append(segment)\n\n                    # Add to merged revision\n                    merged_revision.sections.append(new_section)\n\n                elif section_diff.diff_type == DiffType.DELETE:\n                    if section_strategy == \"last_writer_wins\":\n                        # Remove section\n                        for i, section in enumerate(merged_revision.sections):\n                            if section.id == section_id:\n                                merged_revision.sections.pop(i)\n                                break\n\n                elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                    # Update section title if it changed\n                    for section in merged_revision.sections:\n                        if section.id == section_id:\n                            if (\n                                section_diff.new_title\n                                and section_strategy == \"last_writer_wins\"\n                            ):\n                                section.title = section_diff.new_title\n\n                            # Process segment changes\n                            for segment_diff in section_diff.segment_diffs:\n                                segment_id = segment_diff.segment_id\n\n                                # Check merge strategy for this segment\n                                segment_strategy = merge_strategy.get(\n                                    f\"{section_id}_{segment_id}\", section_strategy\n                                )\n\n                                if segment_strategy == \"ignore\":\n                                    # Skip this segment\n                                    continue\n\n                                if segment_diff.diff_type == DiffType.INSERT:\n                                    # Add new segment\n                                    segment = TextSegment(\n                                        id=segment_id or \"\",\n                                        content=segment_diff.new_content or \"\",\n                                        position=segment_diff.position or 0,\n                                    )\n\n                                    # Insert at the right position\n                                    if segment_diff.position is not None:\n                                        if segment_diff.position < len(\n                                            section.segments\n                                        ):\n                                            section.segments.insert(\n                                                segment_diff.position, segment\n                                            )\n                                        else:\n                                            section.segments.append(segment)\n                                    else:\n                                        section.segments.append(segment)\n\n                                    # Update positions\n                                    for i, seg in enumerate(section.segments):\n                                        seg.position = i\n\n                                elif segment_diff.diff_type == DiffType.DELETE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Remove segment\n                                        for i, segment in enumerate(section.segments):\n                                            if segment.id == segment_id:\n                                                section.segments.pop(i)\n                                                break\n\n                                        # Update positions\n                                        for i, seg in enumerate(section.segments):\n                                            seg.position = i\n\n                                elif segment_diff.diff_type == DiffType.REPLACE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Update segment content\n                                        for segment in section.segments:\n                                            if (\n                                                segment.id == segment_id\n                                                and segment_diff.new_content\n                                            ):\n                                                segment.content = (\n                                                    segment_diff.new_content\n                                                )\n                                                break\n\n                            break\n\n        # Update document's current revision\n        self.document.current_revision = merged_revision\n\n        return merged_revision\n\n    def export_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Export the revision history as a structured dictionary.\"\"\"\n        history = {\n            \"current_revision\": self.document.current_revision.name,\n            \"revisions\": {},\n        }\n\n        for name, revision in self.document.revisions.items():\n            history[\"revisions\"][name] = {\n                \"id\": revision.id,\n                \"timestamp\": revision.timestamp.isoformat(),\n                \"metadata\": revision.metadata,\n                \"section_count\": len(revision.sections),\n                \"word_count\": sum(\n                    sum(segment.get_word_count() for segment in section.segments)\n                    for section in revision.sections\n                ),\n            }\n\n        return history\n\n    def get_revision_by_timestamp(self, timestamp: datetime) -> Optional[Revision]:\n        \"\"\"Get the revision closest to the specified timestamp.\"\"\"\n        closest_revision = None\n        min_diff = None\n\n        for revision in self.document.revisions.values():\n            diff = abs((revision.timestamp - timestamp).total_seconds())\n\n            if min_diff is None or diff < min_diff:\n                min_diff = diff\n                closest_revision = revision\n\n        return closest_revision",
                "class DiffType(str, Enum):\n    \"\"\"Types of differences.\"\"\"\n\n    EQUAL = \"equal\"\n    INSERT = \"insert\"\n    DELETE = \"delete\"\n    REPLACE = \"replace\"",
                "class WriterTextEditor:\n    \"\"\"Main client class for the writer text editor.\"\"\"\n\n    def __init__(self, document_title: str = \"Untitled Document\"):\n        \"\"\"Initialize the text editor with a new document.\"\"\"\n        self.document = Document(title=document_title)\n        self.focus_mode = FocusMode(self.document)\n        self.statistics = WritingStatistics(self.document)\n        self.narrative_tracker = NarrativeTracker(self.document)\n        self.navigator = DocumentNavigator(self.document, self.narrative_tracker)\n        self.revision_manager = RevisionManager(self.document)\n\n        # Start the background tracking\n        self.statistics.start_background_tracking()\n        self.narrative_tracker.start_background_tracking()\n\n    def close(self):\n        \"\"\"Clean up resources when closing the editor.\"\"\"\n        self.statistics.stop_background_tracking()\n        self.narrative_tracker.stop_background_tracking()\n\n    # Document operations\n\n    def get_document(self) -> Document:\n        \"\"\"Get the current document.\"\"\"\n        return self.document\n\n    def add_section(self, title: str) -> str:\n        \"\"\"Add a new section to the document and return its ID.\"\"\"\n        section = self.document.add_section(title)\n        return section.id\n\n    def add_paragraph(self, section_index: int, content: str) -> Optional[str]:\n        \"\"\"Add a paragraph to a section and return its ID.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n\n        segment = section.add_segment(content)\n        return segment.id\n\n    def get_document_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return self.document.get_content()\n\n    # Focus mode operations\n\n    def enter_focus(\n        self,\n        section_index: int,\n        paragraph_index: int,\n        level: FocusLevel = FocusLevel.PARAGRAPH,\n    ) -> bool:\n        \"\"\"Enter focus mode for a specific paragraph.\"\"\"\n        focus_context = self.focus_mode.enter_focus(\n            section_index=section_index, segment_index=paragraph_index, level=level\n        )\n        return focus_context is not None\n\n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        return self.focus_mode.exit_focus()\n\n    def edit_in_focus(self, new_content: str) -> bool:\n        \"\"\"Edit the content in focus mode.\"\"\"\n        result = self.focus_mode.edit_focused_content(new_content)\n        return result is not None\n\n    def move_focus(self, direction: int = 1) -> bool:\n        \"\"\"Move focus to the next or previous paragraph.\"\"\"\n        result = self.focus_mode.move_focus(direction)\n        return result is not None\n\n    def get_focus_context(self) -> Dict[str, Any]:\n        \"\"\"Get information about the current focus context.\"\"\"\n        context = self.focus_mode.get_focus_context()\n        if not context:\n            return {\"active\": False}\n\n        return {\n            \"active\": True,\n            \"section_title\": context.section.title,\n            \"content\": context.segment.content,\n            \"level\": context.level.value,\n            \"focus_time\": self.focus_mode.get_focus_time(),\n        }\n\n    # Statistics operations\n\n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get the current document statistics.\"\"\"\n        stats = self.statistics.calculate_stats()\n\n        return {\n            \"word_count\": stats.word_count,\n            \"character_count\": stats.character_count,\n            \"paragraph_count\": stats.paragraph_count,\n            \"sentence_count\": stats.sentence_count,\n            \"reading_level\": stats.reading_level,\n            \"vocabulary_richness\": stats.word_stats.vocabulary_richness,\n            \"avg_sentence_length\": stats.sentence_stats.average_sentence_length,\n        }\n\n    def get_writing_pace(self) -> Dict[str, float]:\n        \"\"\"Get the current writing pace.\"\"\"\n        pace = self.statistics.calculate_writing_pace()\n\n        return {\n            \"words_per_minute\": pace.words_per_minute,\n            \"words_per_hour\": pace.words_per_hour,\n            \"words_per_day\": pace.words_per_day,\n        }\n\n    def set_writing_goal(\n        self, goal_id: str, target: int, days: int = 30\n    ) -> Dict[str, Any]:\n        \"\"\"Set a writing goal for word count.\"\"\"\n        from datetime import datetime, timedelta\n\n        deadline = datetime.now() + timedelta(days=days)\n        tracker = self.statistics.set_progress_goal(\n            goal_id=goal_id, goal_type=\"word_count\", target=target, deadline=deadline\n        )\n\n        progress = self.statistics.update_progress(goal_id)\n\n        return {\n            \"goal_id\": goal_id,\n            \"target\": target,\n            \"deadline_days\": days,\n            \"current_word_count\": progress[\"word_count\"],\n            \"progress_percentage\": progress[\"progress_percentage\"],\n            \"remaining\": progress[\"remaining\"],\n        }\n\n    def get_goal_progress(self, goal_id: str) -> Dict[str, Any]:\n        \"\"\"Get progress for a specific goal.\"\"\"\n        report = self.statistics.get_progress_report(goal_id)\n        if not report:\n            return {\"error\": f\"Goal {goal_id} not found\"}\n\n        return report\n\n    # Narrative element operations\n\n    def detect_characters(self) -> List[Dict[str, Any]]:\n        \"\"\"Detect and track characters in the document.\"\"\"\n        elements = self.narrative_tracker.detect_elements()\n        characters = elements.get(ElementType.CHARACTER.value, [])\n\n        return [\n            {\"id\": char.id, \"name\": char.name, \"occurrences\": len(char.occurrences)}\n            for char in characters\n        ]\n\n    def get_character_timeline(self, character_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of a character's appearances.\"\"\"\n        timeline = self.narrative_tracker.get_element_timeline(character_id)\n\n        return timeline\n\n    def check_narrative_consistency(self) -> List[Dict[str, Any]]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        issues = self.narrative_tracker.check_consistency()\n\n        return [\n            {\n                \"id\": issue.id,\n                \"type\": issue.issue_type,\n                \"description\": issue.description,\n                \"severity\": issue.severity,\n                \"resolved\": issue.resolved,\n            }\n            for issue in issues\n        ]\n\n    # Navigation operations\n\n    def create_navigation_view(self, name: str, view_type: str) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        nav_type = NavigationViewType(view_type)\n        view_id = self.navigator.create_view(name, nav_type)\n\n        return view_id\n\n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        return self.navigator.navigate_to(view_id, element_id)\n\n    def get_current_location(self) -> Dict[str, Any]:\n        \"\"\"Get information about the current navigation location.\"\"\"\n        element = self.navigator.get_current_element()\n        if not element:\n            return {\"error\": \"No current position\"}\n\n        content = self.navigator.get_element_content(element.id)\n\n        return {\n            \"view_id\": self.navigator.current_position.view_id,\n            \"element_id\": element.id,\n            \"element_type\": element.element_type,\n            \"name\": element.name,\n            \"content\": content,\n        }\n\n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        return self.navigator.navigate_next()\n\n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        return self.navigator.navigate_previous()\n\n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        return self.navigator.navigate_parent()\n\n    def get_navigation_children(self) -> List[Dict[str, Any]]:\n        \"\"\"Get the children of the current element.\"\"\"\n        children = self.navigator.navigate_children()\n\n        return [\n            {\"id\": child.id, \"type\": child.element_type, \"name\": child.name}\n            for child in children\n        ]\n\n    # Revision operations\n\n    def create_revision(self, name: str) -> str:\n        \"\"\"Create a new revision of the document.\"\"\"\n        revision = self.revision_manager.create_revision(name)\n        return revision.id\n\n    def compare_revisions(self, old_revision: str, new_revision: str) -> Dict[str, Any]:\n        \"\"\"Compare two revisions and return the differences.\"\"\"\n        diff = self.revision_manager.compare_revisions(old_revision, new_revision)\n        if not diff:\n            return {\"error\": \"Could not compare revisions\"}\n\n        # Convert diff to a simplified format\n        result = {\n            \"old_revision\": old_revision,\n            \"new_revision\": new_revision,\n            \"timestamp\": diff.timestamp.isoformat(),\n            \"sections\": [],\n        }\n\n        for section_diff in diff.section_diffs:\n            section_info = {\n                \"id\": section_diff.section_id,\n                \"type\": section_diff.diff_type.value,\n                \"old_title\": section_diff.old_title,\n                \"new_title\": section_diff.new_title,\n                \"segments\": [],\n            }\n\n            for segment_diff in section_diff.segment_diffs:\n                segment_info = {\n                    \"id\": segment_diff.segment_id,\n                    \"type\": segment_diff.diff_type.value,\n                    \"position\": segment_diff.position,\n                    \"has_content_change\": segment_diff.old_content\n                    != segment_diff.new_content,\n                }\n                section_info[\"segments\"].append(segment_info)\n\n            result[\"sections\"].append(section_info)\n\n        return result\n\n    def switch_revision(self, revision_name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        return self.document.switch_to_revision(revision_name)\n\n    def get_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Get the revision history.\"\"\"\n        return self.revision_manager.export_revision_history()\n\n    def merge_revisions(self, base_revision: str, revisions: List[str]) -> str:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        merged = self.revision_manager.merge_revisions(base_revision, revisions)\n        if not merged:\n            return \"\"\n\n        return merged.name"
            ]
        }
    },
    "unified/common/core/file_manager.py": {
        "logprobs": -750.6530854533663,
        "metrics": {
            "loc": 246,
            "sloc": 100,
            "lloc": 103,
            "comments": 9,
            "multi": 77,
            "blank": 60,
            "cyclomatic": 25,
            "internal_imports": [
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass"
            ]
        }
    },
    "unified/text_editor/interview/models.py": {
        "logprobs": -778.2472262188282,
        "metrics": {
            "loc": 245,
            "sloc": 122,
            "lloc": 175,
            "comments": 8,
            "multi": 66,
            "blank": 48,
            "cyclomatic": 27,
            "internal_imports": []
        }
    },
    "unified/common/core/text_operations.py": {
        "logprobs": -1079.0626045685399,
        "metrics": {
            "loc": 293,
            "sloc": 120,
            "lloc": 110,
            "comments": 17,
            "multi": 90,
            "blank": 69,
            "cyclomatic": 32,
            "internal_imports": []
        }
    },
    "unified/writer_text_editor/narrative.py": {
        "logprobs": -2417.4175888826794,
        "metrics": {
            "loc": 555,
            "sloc": 403,
            "lloc": 313,
            "comments": 56,
            "multi": 0,
            "blank": 85,
            "cyclomatic": 113,
            "internal_imports": [
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()"
            ]
        }
    },
    "unified/text_editor/study/models.py": {
        "logprobs": -1391.819485454477,
        "metrics": {
            "loc": 448,
            "sloc": 215,
            "lloc": 230,
            "comments": 25,
            "multi": 125,
            "blank": 92,
            "cyclomatic": 69,
            "internal_imports": []
        }
    },
    "unified/common/core/position.py": {
        "logprobs": -1903.4366294950637,
        "metrics": {
            "loc": 732,
            "sloc": 346,
            "lloc": 350,
            "comments": 66,
            "multi": 186,
            "blank": 140,
            "cyclomatic": 58,
            "internal_imports": [
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass"
            ]
        }
    },
    "unified/text_editor/core/file_manager.py": {
        "logprobs": -441.6091800470473,
        "metrics": {
            "loc": 75,
            "sloc": 14,
            "lloc": 20,
            "comments": 0,
            "multi": 42,
            "blank": 19,
            "cyclomatic": 6,
            "internal_imports": [
                "class FileManager(BaseFileManager):\n    \"\"\"\n    Manages file operations for the text editor.\n\n    This class extends the common library's FileManager to maintain\n    backward compatibility with the original FileManager.\n    \"\"\"\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n        \"\"\"\n        return super().load_file(file_path)\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        super().save_file(content, file_path)\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        return super().is_file_modified(file_path)\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return super().get_current_path()",
                "class FileManager(BaseModel):\n    \"\"\"\n    Manages file operations for text editors.\n\n    This class provides functionality for loading from and saving to files,\n    tracking file state, and handling file-related operations.\n    \"\"\"\n\n    current_path: Optional[str] = None\n    last_saved_time: Optional[float] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            UnicodeDecodeError: If the file encoding is not supported\n        \"\"\"\n        start_time = time.time()\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"utf-8\"\n\n            return content\n\n        except UnicodeDecodeError:\n            # Try with latin-1 encoding as a fallback\n            with open(file_path, \"r\", encoding=\"latin-1\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"latin-1\"\n\n            return content\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"encoding\"] = \"utf-8\"\n\n    def save_structured_content(\n        self, content: Any, file_path: Optional[str] = None, format: str = \"json\"\n    ) -> None:\n        \"\"\"\n        Save structured content to a file in a specified format.\n\n        Args:\n            content: The content to save (must be serializable)\n            file_path: Path to save to (if None, uses current_path)\n            format: The format to save in (currently only \"json\" is supported)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set,\n                       or if the format is not supported\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if format.lower() == \"json\":\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(content, f, indent=2)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"format\"] = format\n\n    def load_structured_content(self, file_path: str, format: str = \"json\") -> Any:\n        \"\"\"\n        Load structured content from a file.\n\n        Args:\n            file_path: Path to the file to load\n            format: The format of the file (currently only \"json\" is supported)\n\n        Returns:\n            The loaded structured content\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            ValueError: If the format is not supported\n            json.JSONDecodeError: If the file is not valid JSON\n        \"\"\"\n        start_time = time.time()\n\n        if format.lower() == \"json\":\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = json.load(f)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = file_path\n        self.last_saved_time = os.path.getmtime(file_path)\n\n        # Store file metadata\n        self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(file_path)\n        self.metadata[\"format\"] = format\n\n        return content\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return True\n\n        if not self.last_saved_time:\n            return True\n\n        return os.path.getmtime(path) > self.last_saved_time\n\n    def get_file_info(self, file_path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get information about the file.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            A dictionary with file information\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return {\"exists\": False}\n\n        return {\n            \"exists\": True,\n            \"size\": os.path.getsize(path),\n            \"modified_time\": os.path.getmtime(path),\n            \"created_time\": os.path.getctime(path),\n            \"is_directory\": os.path.isdir(path),\n            \"file_name\": os.path.basename(path),\n            \"directory\": os.path.dirname(path),\n            \"extension\": os.path.splitext(path)[1],\n        }\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.current_path"
            ]
        }
    },
    "unified/writer_text_editor/focus.py": {
        "logprobs": -985.4263906452844,
        "metrics": {
            "loc": 216,
            "sloc": 151,
            "lloc": 123,
            "comments": 6,
            "multi": 3,
            "blank": 43,
            "cyclomatic": 37,
            "internal_imports": [
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()"
            ]
        }
    },
    "unified/text_editor/features/integration.py": {
        "logprobs": -1535.0704228277716,
        "metrics": {
            "loc": 379,
            "sloc": 156,
            "lloc": 165,
            "comments": 32,
            "multi": 108,
            "blank": 78,
            "cyclomatic": 61,
            "internal_imports": [
                "class Editor(BaseModel):\n    \"\"\"\n    Core editor class that combines buffer and cursor functionality.\n\n    This class provides the basic editing operations that form the foundation\n    of the text editor, including text insertion, deletion, navigation, and\n    other fundamental operations.\n    \"\"\"\n\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n    cursor: Cursor = None\n    file_manager: FileManager = Field(default_factory=FileManager)\n    history: History = Field(default_factory=History)\n\n    def __init__(self, content: str = \"\", file_path: Optional[str] = None):\n        \"\"\"\n        Initialize a new editor with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n            file_path: Path to the file being edited (optional)\n        \"\"\"\n        super().__init__()\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.file_manager = FileManager(current_path=file_path)\n        self.history = History()\n\n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the editor.\n\n        Returns:\n            The content as a string\n        \"\"\"\n        return self.buffer.get_text()\n\n    def get_cursor_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return self.cursor.get_position()\n\n    def insert_text(self, text: str) -> None:\n        \"\"\"\n        Insert text at the current cursor position.\n\n        Args:\n            text: The text to insert\n        \"\"\"\n        line, column = self.cursor.get_position()\n        position = LineColumnPosition(line=line, column=column)\n\n        # Insert the text using the buffer\n        self.buffer.insert(position, text)\n\n        # Record the operation in history\n        self.history.record_insert(line, column, text)\n\n        # Update cursor position\n        if \"\\n\" in text:\n            # Move to the end of the inserted text\n            lines = text.split(\"\\n\")\n            new_line = line + len(lines) - 1\n            new_column = len(lines[-1])\n            self.cursor.move_to(new_line, new_column)\n        else:\n            # Move cursor forward by the length of the inserted text\n            self.cursor.move_to(line, column + len(text))\n\n    def delete_char_before_cursor(self) -> None:\n        \"\"\"Delete the character before the cursor (backspace operation).\"\"\"\n        line, column = self.cursor.get_position()\n\n        if column > 0:\n            # Delete character in the current line\n            start_position = LineColumnPosition(line=line, column=column - 1)\n            end_position = LineColumnPosition(line=line, column=column)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, column - 1, line, column, deleted_text)\n            self.cursor.move_to(line, column - 1)\n        elif line > 0:\n            # At the beginning of a line, join with the previous line\n            prev_line_length = len(self.buffer.get_line(line - 1))\n\n            start_position = LineColumnPosition(line=line - 1, column=prev_line_length)\n            end_position = LineColumnPosition(line=line, column=0)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(\n                line - 1, prev_line_length, line, 0, deleted_text\n            )\n            self.cursor.move_to(line - 1, prev_line_length)\n\n    def delete_char_after_cursor(self) -> None:\n        \"\"\"Delete the character after the cursor (delete key operation).\"\"\"\n        line, column = self.cursor.get_position()\n        line_length = len(self.buffer.get_line(line))\n\n        if column < line_length:\n            # Delete character in the current line\n            start_position = LineColumnPosition(line=line, column=column)\n            end_position = LineColumnPosition(line=line, column=column + 1)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, column, line, column + 1, deleted_text)\n        elif line < self.buffer.get_line_count() - 1:\n            # At the end of a line, join with the next line\n            start_position = LineColumnPosition(line=line, column=line_length)\n            end_position = LineColumnPosition(line=line + 1, column=0)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, line_length, line + 1, 0, deleted_text)\n\n    def new_line(self) -> None:\n        \"\"\"Insert a new line at the cursor position.\"\"\"\n        self.insert_text(\"\\n\")\n\n    def move_cursor(self, direction: str, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor in the specified direction.\n\n        Args:\n            direction: One of \"up\", \"down\", \"left\", \"right\",\n                      \"line_start\", \"line_end\", \"buffer_start\", \"buffer_end\"\n            count: Number of units to move (for up, down, left, right)\n        \"\"\"\n        if direction == \"up\":\n            self.cursor.move_up(count)\n        elif direction == \"down\":\n            self.cursor.move_down(count)\n        elif direction == \"left\":\n            self.cursor.move_left(count)\n        elif direction == \"right\":\n            self.cursor.move_right(count)\n        elif direction == \"line_start\":\n            self.cursor.move_to_line_start()\n        elif direction == \"line_end\":\n            self.cursor.move_to_line_end()\n        elif direction == \"buffer_start\":\n            self.cursor.move_to_buffer_start()\n        elif direction == \"buffer_end\":\n            self.cursor.move_to_buffer_end()\n        else:\n            raise ValueError(f\"Unknown direction: {direction}\")\n\n    def set_cursor_position(self, line: int, column: int) -> None:\n        \"\"\"\n        Set the cursor to the specified position.\n\n        Args:\n            line: Line number (0-indexed)\n            column: Column number (0-indexed)\n        \"\"\"\n        self.cursor.move_to(line, column)\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line as a string\n        \"\"\"\n        return self.buffer.get_line(line_number)\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        return self.buffer.get_line_count()\n\n    def replace_text(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n    ) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        deleted_text = self.buffer.replace(start_position, end_position, new_text)\n        self.history.record_replace(\n            start_line, start_col, end_line, end_col, new_text, deleted_text\n        )\n        return deleted_text\n\n    def clear(self) -> None:\n        \"\"\"Clear the editor, removing all content.\"\"\"\n        content = self.buffer.get_text()\n        if content:\n            line_count = self.buffer.get_line_count()\n            last_line_length = len(self.buffer.get_line(line_count - 1))\n\n            start_position = LineColumnPosition(line=0, column=0)\n            end_position = LineColumnPosition(\n                line=line_count - 1, column=last_line_length\n            )\n\n            self.history.record_delete(0, 0, line_count - 1, last_line_length, content)\n\n        self.buffer.clear()\n        self.cursor.move_to_buffer_start()\n\n    def undo(self) -> bool:\n        \"\"\"\n        Undo the last operation.\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        return self.history.undo(self.buffer)\n\n    def redo(self) -> bool:\n        \"\"\"\n        Redo the last undone operation.\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        return self.history.redo(self.buffer)\n\n    def load_file(self, file_path: str) -> None:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n        \"\"\"\n        content = self.file_manager.load_file(file_path)\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.history.clear()\n\n    def save_file(self, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            file_path: Path to save to (if None, uses current path)\n        \"\"\"\n        content = self.buffer.get_text()\n        self.file_manager.save_file(content, file_path)\n\n    def get_current_file_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.file_manager.get_current_path()\n\n    def is_file_modified(self) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Returns:\n            True if the file has been modified, False otherwise\n        \"\"\"\n        return self.file_manager.is_file_modified()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n\n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n\n        # Enable all beginner features by default\n        self._enable_beginner_features()\n\n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n\n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n\n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n\n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n\n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n\n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids for prereq in feature.prerequisites\n                )\n\n                if prerequisites_met:\n                    pending.append(feature)\n\n        return pending\n\n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n\n        Args:\n            feature_id: ID of the feature to unlock\n\n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n\n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n\n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n\n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n\n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n\n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n\n        return feature\n\n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n\n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n\n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n\n        return newly_unlocked\n\n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n\n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n\n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (\n                last_assessment is None\n                or time.time() - last_assessment > self.assessment_interval\n            ):\n                self.user_progress.assess_skill()\n\n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n\n    def register_feature_hook(\n        self, feature_id: str, hook: Callable[[Feature], None]\n    ) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n\n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n\n        self.feature_hooks[feature_id].append(hook)\n\n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n\n        Args:\n            feature_id: ID of the feature to check\n\n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return feature_id in self.features and self.features[feature_id].is_enabled()\n\n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n\n        Args:\n            feature_id: ID of the feature to get guidance for\n\n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation,\n        }\n\n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n\n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n\n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n\n        Args:\n            level: The new skill level to set\n\n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n\n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n\n        # Enable all beginner features by default\n        self._enable_beginner_features()\n\n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n\n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n\n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n\n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n\n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n\n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids for prereq in feature.prerequisites\n                )\n\n                if prerequisites_met:\n                    pending.append(feature)\n\n        return pending\n\n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n\n        Args:\n            feature_id: ID of the feature to unlock\n\n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n\n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n\n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n\n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n\n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n\n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n\n        return feature\n\n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n\n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n\n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n\n        return newly_unlocked\n\n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n\n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n\n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (\n                last_assessment is None\n                or time.time() - last_assessment > self.assessment_interval\n            ):\n                self.user_progress.assess_skill()\n\n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n\n    def register_feature_hook(\n        self, feature_id: str, hook: Callable[[Feature], None]\n    ) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n\n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n\n        self.feature_hooks[feature_id].append(hook)\n\n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n\n        Args:\n            feature_id: ID of the feature to check\n\n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return feature_id in self.features and self.features[feature_id].is_enabled()\n\n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n\n        Args:\n            feature_id: ID of the feature to get guidance for\n\n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation,\n        }\n\n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n\n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n\n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n\n        Args:\n            level: The new skill level to set\n\n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n\n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n\n        # Enable all beginner features by default\n        self._enable_beginner_features()\n\n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n\n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n\n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n\n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n\n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n\n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids for prereq in feature.prerequisites\n                )\n\n                if prerequisites_met:\n                    pending.append(feature)\n\n        return pending\n\n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n\n        Args:\n            feature_id: ID of the feature to unlock\n\n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n\n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n\n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n\n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n\n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n\n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n\n        return feature\n\n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n\n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n\n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n\n        return newly_unlocked\n\n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n\n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n\n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (\n                last_assessment is None\n                or time.time() - last_assessment > self.assessment_interval\n            ):\n                self.user_progress.assess_skill()\n\n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n\n    def register_feature_hook(\n        self, feature_id: str, hook: Callable[[Feature], None]\n    ) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n\n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n\n        self.feature_hooks[feature_id].append(hook)\n\n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n\n        Args:\n            feature_id: ID of the feature to check\n\n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return feature_id in self.features and self.features[feature_id].is_enabled()\n\n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n\n        Args:\n            feature_id: ID of the feature to get guidance for\n\n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation,\n        }\n\n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n\n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n\n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n\n        Args:\n            level: The new skill level to set\n\n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n\n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n\n        # Enable all beginner features by default\n        self._enable_beginner_features()\n\n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n\n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n\n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n\n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n\n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n\n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids for prereq in feature.prerequisites\n                )\n\n                if prerequisites_met:\n                    pending.append(feature)\n\n        return pending\n\n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n\n        Args:\n            feature_id: ID of the feature to unlock\n\n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n\n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n\n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n\n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n\n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n\n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n\n        return feature\n\n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n\n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n\n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n\n        return newly_unlocked\n\n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n\n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n\n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (\n                last_assessment is None\n                or time.time() - last_assessment > self.assessment_interval\n            ):\n                self.user_progress.assess_skill()\n\n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n\n    def register_feature_hook(\n        self, feature_id: str, hook: Callable[[Feature], None]\n    ) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n\n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n\n        self.feature_hooks[feature_id].append(hook)\n\n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n\n        Args:\n            feature_id: ID of the feature to check\n\n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return feature_id in self.features and self.features[feature_id].is_enabled()\n\n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n\n        Args:\n            feature_id: ID of the feature to get guidance for\n\n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation,\n        }\n\n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n\n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n\n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n\n        Args:\n            level: The new skill level to set\n\n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n\n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n\n        # Enable all beginner features by default\n        self._enable_beginner_features()\n\n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n\n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n\n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n\n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n\n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n\n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids for prereq in feature.prerequisites\n                )\n\n                if prerequisites_met:\n                    pending.append(feature)\n\n        return pending\n\n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n\n        Args:\n            feature_id: ID of the feature to unlock\n\n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n\n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n\n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n\n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n\n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n\n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n\n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n\n        return feature\n\n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n\n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n\n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n\n        return newly_unlocked\n\n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n\n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n\n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (\n                last_assessment is None\n                or time.time() - last_assessment > self.assessment_interval\n            ):\n                self.user_progress.assess_skill()\n\n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n\n    def register_feature_hook(\n        self, feature_id: str, hook: Callable[[Feature], None]\n    ) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n\n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n\n        self.feature_hooks[feature_id].append(hook)\n\n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n\n        Args:\n            feature_id: ID of the feature to check\n\n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return feature_id in self.features and self.features[feature_id].is_enabled()\n\n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n\n        Args:\n            feature_id: ID of the feature to get guidance for\n\n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n\n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation,\n        }\n\n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n\n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n\n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n\n        Args:\n            level: The new skill level to set\n\n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n\n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n\n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled"
            ]
        }
    },
    "unified/text_editor/learning/models.py": {
        "logprobs": -739.3617880373865,
        "metrics": {
            "loc": 174,
            "sloc": 77,
            "lloc": 120,
            "comments": 5,
            "multi": 56,
            "blank": 38,
            "cyclomatic": 16,
            "internal_imports": []
        }
    },
    "unified/text_editor/study/__init__.py": {
        "logprobs": -199.1601942779523,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/features/models.py": {
        "logprobs": -880.483469126309,
        "metrics": {
            "loc": 212,
            "sloc": 123,
            "lloc": 116,
            "comments": 7,
            "multi": 41,
            "blank": 35,
            "cyclomatic": 36,
            "internal_imports": []
        }
    },
    "unified/conftest.py": {
        "logprobs": -239.20750057715196,
        "metrics": {
            "loc": 4,
            "sloc": 1,
            "lloc": 2,
            "comments": 1,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/__init__.py": {
        "logprobs": -193.72301054019,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/interview/manager.py": {
        "logprobs": -2014.6750166502204,
        "metrics": {
            "loc": 575,
            "sloc": 307,
            "lloc": 188,
            "comments": 51,
            "multi": 106,
            "blank": 115,
            "cyclomatic": 60,
            "internal_imports": [
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n\n    def complete(\n        self,\n        is_correct: bool,\n        execution_time_ms: Optional[float] = None,\n        memory_usage_mb: Optional[float] = None,\n        passed_test_cases: int = 0,\n        total_test_cases: int = 0,\n        runtime_error: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n\n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n\n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n\n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n\n        return self.end_time - self.start_time",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n\n    def complete(\n        self,\n        is_correct: bool,\n        execution_time_ms: Optional[float] = None,\n        memory_usage_mb: Optional[float] = None,\n        passed_test_cases: int = 0,\n        total_test_cases: int = 0,\n        runtime_error: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n\n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n\n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n\n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n\n        return self.end_time - self.start_time",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n\n    def complete(\n        self,\n        is_correct: bool,\n        execution_time_ms: Optional[float] = None,\n        memory_usage_mb: Optional[float] = None,\n        passed_test_cases: int = 0,\n        total_test_cases: int = 0,\n        runtime_error: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n\n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n\n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n\n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n\n        return self.end_time - self.start_time",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n\n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n\n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n\n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n\n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n\n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n\n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n\n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n\n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n\n        Args:\n            difficulty: The difficulty level to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n\n        Args:\n            category: The problem category to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n\n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n\n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n\n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n\n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n\n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n\n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n\n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n\n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n\n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n\n        Args:\n            difficulty: The difficulty level to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n\n        Args:\n            category: The problem category to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n\n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n\n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n\n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n\n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n\n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n\n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n\n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n\n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n\n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n\n        Args:\n            difficulty: The difficulty level to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n\n        Args:\n            category: The problem category to check\n\n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n\n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n\n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n\n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "def get_problem(problem_id: str) -> Optional[InterviewProblem]:\n    \"\"\"\n    Get a specific interview problem by ID.\n\n    Args:\n        problem_id: ID of the problem to retrieve\n\n    Returns:\n        The InterviewProblem object, or None if not found\n    \"\"\"\n    return SAMPLE_PROBLEMS.get(problem_id)",
                "def get_all_problems() -> List[InterviewProblem]:\n    \"\"\"\n    Get all available interview problems.\n\n    Returns:\n        List of all InterviewProblem objects\n    \"\"\"\n    return list(SAMPLE_PROBLEMS.values())",
                "def get_problems_by_difficulty(difficulty: DifficultyLevel) -> List[InterviewProblem]:\n    \"\"\"\n    Get problems filtered by difficulty.\n\n    Args:\n        difficulty: Difficulty level to filter by\n\n    Returns:\n        List of InterviewProblem objects at the specified difficulty\n    \"\"\"\n    return [p for p in SAMPLE_PROBLEMS.values() if p.difficulty == difficulty]",
                "def get_problems_by_category(category: ProblemCategory) -> List[InterviewProblem]:\n    \"\"\"\n    Get problems filtered by category.\n\n    Args:\n        category: Category to filter by\n\n    Returns:\n        List of InterviewProblem objects in the specified category\n    \"\"\"\n    return [p for p in SAMPLE_PROBLEMS.values() if p.category == category]"
            ]
        }
    },
    "unified/text_editor/core/editor.py": {
        "logprobs": -1127.258427900468,
        "metrics": {
            "loc": 303,
            "sloc": 136,
            "lloc": 148,
            "comments": 9,
            "multi": 97,
            "blank": 57,
            "cyclomatic": 35,
            "internal_imports": [
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class TextContent(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for text content storage.\n\n    This class defines the interface for all text content implementations,\n    with methods for inserting, deleting, replacing, and retrieving text.\n    \"\"\"\n\n    @abstractmethod\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete\n            end: The end position of the text to delete\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace\n            end: The end position of the text to replace\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid or if end comes before start\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        pass",
                "class TextBuffer(LineBasedTextContent):\n    \"\"\"\n    A text buffer that stores the content of a file as a list of lines.\n\n    This is the core data structure for the text editor, handling storage,\n    insertion, deletion, and retrieval of text.\n    \"\"\"\n\n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new text buffer with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__(content=content)\n\n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the buffer as a string.\n\n        Returns:\n            The content of the buffer as a string with lines joined by newlines\n        \"\"\"\n        return self.get_text()\n\n    def insert_text(self, line: int, column: int, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position in the buffer.\n\n        Args:\n            line: Line number where text should be inserted (0-indexed)\n            column: Column number where text should be inserted (0-indexed)\n            text: The text to insert\n\n        Raises:\n            IndexError: If the line or column is out of range\n        \"\"\"\n        position = LineColumnPosition(line=line, column=column)\n\n        try:\n            self.insert(position, text)\n        except ValueError as e:\n            # Convert ValueError to IndexError for backward compatibility\n            raise IndexError(str(e))\n\n    def delete_text(\n        self, start_line: int, start_col: int, end_line: int, end_col: int\n    ) -> str:\n        \"\"\"\n        Delete text between the specified positions and return the deleted text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        try:\n            return self.delete(start_position, end_position)\n        except ValueError as e:\n            # Convert ValueError to appropriate error for backward compatibility\n            if \"End position must come after start position\" in str(e):\n                raise ValueError(str(e))\n            else:\n                raise IndexError(str(e))\n\n    def replace_text(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n    ) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n\n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        try:\n            return self.replace(start_position, end_position, new_text)\n        except ValueError as e:\n            # Convert ValueError to appropriate error for backward compatibility\n            if \"End position must come after start position\" in str(e):\n                raise ValueError(str(e))\n            else:\n                raise IndexError(str(e))\n\n    def clear(self) -> None:\n        \"\"\"Clear the buffer, removing all content.\"\"\"\n        super().clear()",
                "class Cursor(BaseModel):\n    \"\"\"\n    Represents a cursor position within a text buffer.\n\n    The cursor tracks the current position in the buffer and provides methods\n    for moving the cursor and ensuring it remains within valid bounds.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n\n    def move_to(self, line: int, column: int) -> None:\n        \"\"\"\n        Move the cursor to the specified position.\n\n        Args:\n            line: Target line number (0-indexed)\n            column: Target column number (0-indexed)\n\n        Raises:\n            IndexError: If the position is invalid\n        \"\"\"\n        position = LineColumnPosition(line=line, column=column)\n\n        if not position.is_valid(self.buffer):\n            if not (0 <= line < self.buffer.get_line_count()):\n                raise IndexError(f\"Line number {line} out of range\")\n            else:\n                line_length = len(self.buffer.get_line(line))\n                raise IndexError(f\"Column number {column} out of range for line {line}\")\n\n        self.line = line\n        self.column = column\n\n    def get_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)\n\n    def move_up(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n        \"\"\"\n        target_line = max(0, self.line - count)\n        # Ensure column is valid in the new line\n        target_column = min(self.column, len(self.buffer.get_line(target_line)))\n        self.move_to(target_line, target_column)\n\n    def move_down(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n        \"\"\"\n        target_line = min(self.buffer.get_line_count() - 1, self.line + count)\n        # Ensure column is valid in the new line\n        target_column = min(self.column, len(self.buffer.get_line(target_line)))\n        self.move_to(target_line, target_column)\n\n    def move_left(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor left by the specified number of characters.\n\n        If the cursor is at the beginning of a line, it will move to the\n        end of the previous line.\n\n        Args:\n            count: Number of characters to move left (default: 1)\n        \"\"\"\n        remaining_moves = count\n\n        while remaining_moves > 0:\n            if self.column > 0:\n                # We can move left within the current line\n                move_amount = min(remaining_moves, self.column)\n                self.column -= move_amount\n                remaining_moves -= move_amount\n            elif self.line > 0:\n                # Move to the end of the previous line\n                self.line -= 1\n                self.column = len(self.buffer.get_line(self.line))\n                remaining_moves -= 1\n            else:\n                # Already at the start of the buffer\n                break\n\n    def move_right(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor right by the specified number of characters.\n\n        If the cursor is at the end of a line, it will move to the\n        beginning of the next line.\n\n        Args:\n            count: Number of characters to move right (default: 1)\n        \"\"\"\n        remaining_moves = count\n\n        while remaining_moves > 0:\n            current_line_length = len(self.buffer.get_line(self.line))\n\n            if self.column < current_line_length:\n                # We can move right within the current line\n                move_amount = min(remaining_moves, current_line_length - self.column)\n                self.column += move_amount\n                remaining_moves -= move_amount\n            elif self.line < self.buffer.get_line_count() - 1:\n                # Move to the beginning of the next line\n                self.line += 1\n                self.column = 0\n                remaining_moves -= 1\n            else:\n                # Already at the end of the buffer\n                break\n\n    def move_to_line_start(self) -> None:\n        \"\"\"Move the cursor to the start of the current line.\"\"\"\n        self.column = 0\n\n    def move_to_line_end(self) -> None:\n        \"\"\"Move the cursor to the end of the current line.\"\"\"\n        self.column = len(self.buffer.get_line(self.line))\n\n    def move_to_buffer_start(self) -> None:\n        \"\"\"Move the cursor to the start of the buffer.\"\"\"\n        self.line = 0\n        self.column = 0\n\n    def move_to_buffer_end(self) -> None:\n        \"\"\"Move the cursor to the end of the buffer.\"\"\"\n        self.line = self.buffer.get_line_count() - 1\n        self.column = len(self.buffer.get_line(self.line))\n\n    def to_position(self) -> LineColumnPosition:\n        \"\"\"\n        Convert the cursor to a LineColumnPosition.\n\n        Returns:\n            A LineColumnPosition representing the cursor position\n        \"\"\"\n        return LineColumnPosition(line=self.line, column=self.column)",
                "class FileManager(BaseFileManager):\n    \"\"\"\n    Manages file operations for the text editor.\n\n    This class extends the common library's FileManager to maintain\n    backward compatibility with the original FileManager.\n    \"\"\"\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n        \"\"\"\n        return super().load_file(file_path)\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        super().save_file(content, file_path)\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        return super().is_file_modified(file_path)\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return super().get_current_path()",
                "class FileManager(BaseModel):\n    \"\"\"\n    Manages file operations for text editors.\n\n    This class provides functionality for loading from and saving to files,\n    tracking file state, and handling file-related operations.\n    \"\"\"\n\n    current_path: Optional[str] = None\n    last_saved_time: Optional[float] = None\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n\n        Returns:\n            The file content as a string\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            UnicodeDecodeError: If the file encoding is not supported\n        \"\"\"\n        start_time = time.time()\n\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"utf-8\"\n\n            return content\n\n        except UnicodeDecodeError:\n            # Try with latin-1 encoding as a fallback\n            with open(file_path, \"r\", encoding=\"latin-1\") as f:\n                content = f.read()\n\n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n\n            # Store file metadata\n            self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n            self.metadata[\"file_size\"] = os.path.getsize(file_path)\n            self.metadata[\"encoding\"] = \"latin-1\"\n\n            return content\n\n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"encoding\"] = \"utf-8\"\n\n    def save_structured_content(\n        self, content: Any, file_path: Optional[str] = None, format: str = \"json\"\n    ) -> None:\n        \"\"\"\n        Save structured content to a file in a specified format.\n\n        Args:\n            content: The content to save (must be serializable)\n            file_path: Path to save to (if None, uses current_path)\n            format: The format to save in (currently only \"json\" is supported)\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set,\n                       or if the format is not supported\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n\n        # Use the provided path or the current path\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if format.lower() == \"json\":\n            with open(path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(content, f, indent=2)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = path\n        self.last_saved_time = time.time()\n\n        # Update file metadata\n        self.metadata[\"save_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(path)\n        self.metadata[\"format\"] = format\n\n    def load_structured_content(self, file_path: str, format: str = \"json\") -> Any:\n        \"\"\"\n        Load structured content from a file.\n\n        Args:\n            file_path: Path to the file to load\n            format: The format of the file (currently only \"json\" is supported)\n\n        Returns:\n            The loaded structured content\n\n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n            ValueError: If the format is not supported\n            json.JSONDecodeError: If the file is not valid JSON\n        \"\"\"\n        start_time = time.time()\n\n        if format.lower() == \"json\":\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                content = json.load(f)\n        else:\n            raise ValueError(f\"Unsupported format: {format}\")\n\n        self.current_path = file_path\n        self.last_saved_time = os.path.getmtime(file_path)\n\n        # Store file metadata\n        self.metadata[\"load_time_ms\"] = (time.time() - start_time) * 1000\n        self.metadata[\"file_size\"] = os.path.getsize(file_path)\n        self.metadata[\"format\"] = format\n\n        return content\n\n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            True if the file has been modified, False otherwise\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return True\n\n        if not self.last_saved_time:\n            return True\n\n        return os.path.getmtime(path) > self.last_saved_time\n\n    def get_file_info(self, file_path: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get information about the file.\n\n        Args:\n            file_path: Path to check (if None, uses current_path)\n\n        Returns:\n            A dictionary with file information\n\n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n\n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n\n        if not os.path.exists(path):\n            return {\"exists\": False}\n\n        return {\n            \"exists\": True,\n            \"size\": os.path.getsize(path),\n            \"modified_time\": os.path.getmtime(path),\n            \"created_time\": os.path.getctime(path),\n            \"is_directory\": os.path.isdir(path),\n            \"file_name\": os.path.basename(path),\n            \"directory\": os.path.dirname(path),\n            \"extension\": os.path.splitext(path)[1],\n        }\n\n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.current_path",
                "class History(BaseHistory):\n    \"\"\"\n    Manages the history of editing operations for undo/redo functionality.\n\n    This class extends the common library's History class to maintain\n    backward compatibility with the original History.\n    \"\"\"\n\n    def record_insert(self, line: int, col: int, text: str) -> None:\n        \"\"\"\n        Record an insert operation.\n\n        Args:\n            line: Line where text was inserted\n            col: Column where text was inserted\n            text: Text that was inserted\n        \"\"\"\n        position = LineColumnPosition(line=line, column=col)\n        operation = self.create_insert_operation(position, text)\n        self.record_operation(operation)\n\n    def record_delete(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a delete operation.\n\n        Args:\n            start_line: Starting line of deleted text\n            start_col: Starting column of deleted text\n            end_line: Ending line of deleted text\n            end_col: Ending column of deleted text\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_delete_operation(\n            start_position, end_position, deleted_text\n        )\n        self.record_operation(operation)\n\n    def record_replace(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n        deleted_text: str,\n    ) -> None:\n        \"\"\"\n        Record a replace operation.\n\n        Args:\n            start_line: Starting line of replaced text\n            start_col: Starting column of replaced text\n            end_line: Ending line of replaced text\n            end_col: Ending column of replaced text\n            new_text: The text that was inserted\n            deleted_text: The text that was deleted\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n        operation = self.create_replace_operation(\n            start_position, end_position, new_text, deleted_text\n        )\n        self.record_operation(operation)\n\n    # Add compatibility methods for the old API\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return super().can_undo()\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return super().can_redo()\n\n    def undo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last operation for undoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will undo the operation.\n\n        Args:\n            content: Optional content object to apply the undo to\n\n        Returns:\n            The operation to undo, or None if there are no operations to undo\n        \"\"\"\n        if not self.can_undo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.undo_stack[-1]\n\n        # If content is provided, apply the undo\n        if content is not None:\n            super().undo(content)\n        else:\n            # Just remove from the undo stack and add to redo stack without applying\n            self.undo_stack.pop()\n            self.redo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def redo(self, content: Optional[TextContent] = None) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last undone operation for redoing.\n\n        This method maintains backward compatibility with the original History.\n        If a content object is provided, it will redo the operation.\n\n        Args:\n            content: Optional content object to apply the redo to\n\n        Returns:\n            The operation to redo, or None if there are no operations to redo\n        \"\"\"\n        if not self.can_redo():\n            return None\n\n        # Get the operation without removing it from the stack\n        operation = self.redo_stack[-1]\n\n        # If content is provided, apply the redo\n        if content is not None:\n            super().redo(content)\n        else:\n            # Just remove from the redo stack and add to undo stack without applying\n            self.redo_stack.pop()\n            self.undo_stack.append(operation)\n\n        # Convert to EditOperation for backward compatibility\n        if isinstance(operation, InsertOperation):\n            return EditOperation(\n                type=\"insert\",\n                start_line=operation.position.get(\"line\", 0),\n                start_col=operation.position.get(\"column\", 0),\n                text=operation.text,\n            )\n        elif isinstance(operation, DeleteOperation):\n            return EditOperation(\n                type=\"delete\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                deleted_text=operation.deleted_text,\n            )\n        elif isinstance(operation, ReplaceOperation):\n            return EditOperation(\n                type=\"replace\",\n                start_line=operation.start_position.get(\"line\", 0),\n                start_col=operation.start_position.get(\"column\", 0),\n                end_line=operation.end_position.get(\"line\", 0),\n                end_col=operation.end_position.get(\"column\", 0),\n                text=operation.new_text,\n                deleted_text=operation.old_text,\n            )\n\n        return None\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        super().clear()",
                "class History(BaseModel):\n    \"\"\"\n    Tracks and manages the history of operations for undo/redo functionality.\n    \"\"\"\n\n    undo_stack: List[Operation] = Field(default_factory=list)\n    redo_stack: List[Operation] = Field(default_factory=list)\n    max_history_size: int = 1000\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n\n        arbitrary_types_allowed = True\n\n    def record_operation(self, operation: Operation) -> None:\n        \"\"\"\n        Record an operation in the history.\n\n        Args:\n            operation: The operation to record\n        \"\"\"\n        self.undo_stack.append(operation)\n        self.redo_stack.clear()  # Clear redo stack when a new operation is recorded\n\n        # Limit history size\n        if len(self.undo_stack) > self.max_history_size:\n            self.undo_stack.pop(0)\n\n    def undo(self, content: TextContent) -> bool:\n        \"\"\"\n        Undo the last operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        if not self.undo_stack:\n            return False\n\n        operation = self.undo_stack.pop()\n        operation.undo(content)\n        self.redo_stack.append(operation)\n        return True\n\n    def redo(self, content: TextContent) -> bool:\n        \"\"\"\n        Redo the last undone operation on the given content.\n\n        Args:\n            content: The text content to modify\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        if not self.redo_stack:\n            return False\n\n        operation = self.redo_stack.pop()\n        operation.apply(content)\n        self.undo_stack.append(operation)\n        return True\n\n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n\n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return len(self.undo_stack) > 0\n\n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n\n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return len(self.redo_stack) > 0\n\n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        self.undo_stack.clear()\n        self.redo_stack.clear()\n\n    @staticmethod\n    def create_insert_operation(position: Position, text: str) -> InsertOperation:\n        \"\"\"\n        Create an insert operation.\n\n        Args:\n            position: The position where text was inserted\n            text: The text that was inserted\n\n        Returns:\n            An InsertOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize position based on type\n        if isinstance(position, LineColumnPosition):\n            position_dict = {\"line\": position.line, \"column\": position.column}\n        elif isinstance(position, StructuredPosition):\n            position_dict = position.dict()\n        else:\n            raise ValueError(f\"Unsupported position type: {type(position)}\")\n\n        return InsertOperation(position=position_dict, text=text)\n\n    @staticmethod\n    def create_delete_operation(\n        start: Position, end: Position, deleted_text: str\n    ) -> DeleteOperation:\n        \"\"\"\n        Create a delete operation.\n\n        Args:\n            start: The start position of deleted text\n            end: The end position of deleted text\n            deleted_text: The text that was deleted\n\n        Returns:\n            A DeleteOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return DeleteOperation(\n            start_position=start_dict, end_position=end_dict, deleted_text=deleted_text\n        )\n\n    @staticmethod\n    def create_replace_operation(\n        start: Position, end: Position, new_text: str, old_text: str\n    ) -> ReplaceOperation:\n        \"\"\"\n        Create a replace operation.\n\n        Args:\n            start: The start position of replaced text\n            end: The end position of replaced text\n            new_text: The text that was inserted\n            old_text: The text that was replaced\n\n        Returns:\n            A ReplaceOperation instance\n        \"\"\"\n        from common.core.position import LineColumnPosition, StructuredPosition\n\n        # Serialize positions based on type\n        if isinstance(start, LineColumnPosition) and isinstance(\n            end, LineColumnPosition\n        ):\n            start_dict = {\"line\": start.line, \"column\": start.column}\n            end_dict = {\"line\": end.line, \"column\": end.column}\n        elif isinstance(start, StructuredPosition) and isinstance(\n            end, StructuredPosition\n        ):\n            start_dict = start.dict()\n            end_dict = end.dict()\n        else:\n            raise ValueError(f\"Unsupported position types: {type(start)}, {type(end)}\")\n\n        return ReplaceOperation(\n            start_position=start_dict,\n            end_position=end_dict,\n            new_text=new_text,\n            old_text=old_text,\n        )",
                "class EditOperation(BaseModel):\n    \"\"\"\n    Represents an editing operation that can be undone or redone.\n\n    This class maintains backward compatibility with the original EditOperation.\n    \"\"\"\n\n    type: str  # \"insert\", \"delete\", \"replace\"\n    start_line: int\n    start_col: int\n    end_line: Optional[int] = None\n    end_col: Optional[int] = None\n    text: str = \"\"  # For insert and replace, this is the text that was inserted\n    deleted_text: str = \"\"  # For delete and replace, this is the text that was deleted\n    timestamp: float = Field(default_factory=time.time)\n\n    def to_common_operation(self) -> Operation:\n        \"\"\"\n        Convert this EditOperation to a common library Operation.\n\n        Returns:\n            A common library Operation\n        \"\"\"\n        if self.type == \"insert\":\n            position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            return InsertOperation(position=position_dict, text=self.text)\n\n        elif self.type == \"delete\":\n            if self.end_line is None or self.end_col is None:\n                raise ValueError(\"End position is required for delete operations\")\n\n            start_position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            end_position_dict = {\"line\": self.end_line, \"column\": self.end_col}\n            return DeleteOperation(\n                start_position=start_position_dict,\n                end_position=end_position_dict,\n                deleted_text=self.deleted_text,\n            )\n\n        elif self.type == \"replace\":\n            if self.end_line is None or self.end_col is None:\n                raise ValueError(\"End position is required for replace operations\")\n\n            start_position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            end_position_dict = {\"line\": self.end_line, \"column\": self.end_col}\n            return ReplaceOperation(\n                start_position=start_position_dict,\n                end_position=end_position_dict,\n                new_text=self.text,\n                old_text=self.deleted_text,\n            )\n\n        else:\n            raise ValueError(f\"Unknown operation type: {self.type}\")",
                "class EditOperation(BaseModel):\n    \"\"\"\n    Represents an editing operation that can be undone or redone.\n\n    This class maintains backward compatibility with the original EditOperation.\n    \"\"\"\n\n    type: str  # \"insert\", \"delete\", \"replace\"\n    start_line: int\n    start_col: int\n    end_line: Optional[int] = None\n    end_col: Optional[int] = None\n    text: str = \"\"  # For insert and replace, this is the text that was inserted\n    deleted_text: str = \"\"  # For delete and replace, this is the text that was deleted\n    timestamp: float = Field(default_factory=time.time)\n\n    def to_common_operation(self) -> Operation:\n        \"\"\"\n        Convert this EditOperation to a common library Operation.\n\n        Returns:\n            A common library Operation\n        \"\"\"\n        if self.type == \"insert\":\n            position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            return InsertOperation(position=position_dict, text=self.text)\n\n        elif self.type == \"delete\":\n            if self.end_line is None or self.end_col is None:\n                raise ValueError(\"End position is required for delete operations\")\n\n            start_position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            end_position_dict = {\"line\": self.end_line, \"column\": self.end_col}\n            return DeleteOperation(\n                start_position=start_position_dict,\n                end_position=end_position_dict,\n                deleted_text=self.deleted_text,\n            )\n\n        elif self.type == \"replace\":\n            if self.end_line is None or self.end_col is None:\n                raise ValueError(\"End position is required for replace operations\")\n\n            start_position_dict = {\"line\": self.start_line, \"column\": self.start_col}\n            end_position_dict = {\"line\": self.end_line, \"column\": self.end_col}\n            return ReplaceOperation(\n                start_position=start_position_dict,\n                end_position=end_position_dict,\n                new_text=self.text,\n                old_text=self.deleted_text,\n            )\n\n        else:\n            raise ValueError(f\"Unknown operation type: {self.type}\")"
            ]
        }
    },
    "unified/text_editor/learning/manager.py": {
        "logprobs": -2729.2218727214927,
        "metrics": {
            "loc": 855,
            "sloc": 610,
            "lloc": 139,
            "comments": 35,
            "multi": 100,
            "blank": 118,
            "cyclomatic": 54,
            "internal_imports": [
                "class Concept(BaseModel):\n    \"\"\"\n    Represents a computer science concept that can be learned.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: ConceptCategory\n    difficulty: ConceptDifficulty\n    prerequisites: List[str] = Field(default_factory=list)\n    related_concepts: List[str] = Field(default_factory=list)\n    resources: List[Dict[str, str]] = Field(default_factory=list)\n    examples: List[str] = Field(default_factory=list)\n    module_path: Optional[str] = None",
                "class Concept(BaseModel):\n    \"\"\"\n    Represents a computer science concept that can be learned.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: ConceptCategory\n    difficulty: ConceptDifficulty\n    prerequisites: List[str] = Field(default_factory=list)\n    related_concepts: List[str] = Field(default_factory=list)\n    resources: List[Dict[str, str]] = Field(default_factory=list)\n    examples: List[str] = Field(default_factory=list)\n    module_path: Optional[str] = None",
                "class ConceptCategory(Enum):\n    \"\"\"Categories of computer science concepts.\"\"\"\n\n    DATA_STRUCTURES = \"data_structures\"\n    ALGORITHMS = \"algorithms\"\n    DESIGN_PATTERNS = \"design_patterns\"\n    EDITOR_INTERNALS = \"editor_internals\"\n    PERFORMANCE = \"performance\"\n    PROGRAMMING_LANGUAGES = \"programming_languages\"\n    SOFTWARE_ARCHITECTURE = \"software_architecture\"\n    USER_INTERFACE = \"user_interface\"",
                "class ConceptCategory(Enum):\n    \"\"\"Categories of computer science concepts.\"\"\"\n\n    DATA_STRUCTURES = \"data_structures\"\n    ALGORITHMS = \"algorithms\"\n    DESIGN_PATTERNS = \"design_patterns\"\n    EDITOR_INTERNALS = \"editor_internals\"\n    PERFORMANCE = \"performance\"\n    PROGRAMMING_LANGUAGES = \"programming_languages\"\n    SOFTWARE_ARCHITECTURE = \"software_architecture\"\n    USER_INTERFACE = \"user_interface\"",
                "class ConceptDifficulty(Enum):\n    \"\"\"Difficulty levels for computer science concepts.\"\"\"\n\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ConceptDifficulty(Enum):\n    \"\"\"Difficulty levels for computer science concepts.\"\"\"\n\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class Annotation(BaseModel):\n    \"\"\"\n    Represents an annotation on source code that explains a concept.\n    \"\"\"\n\n    concept_id: str\n    start_line: int\n    end_line: int\n    text: str\n    code_snippet: str",
                "class Annotation(BaseModel):\n    \"\"\"\n    Represents an annotation on source code that explains a concept.\n    \"\"\"\n\n    concept_id: str\n    start_line: int\n    end_line: int\n    text: str\n    code_snippet: str",
                "class ExtensionProject(BaseModel):\n    \"\"\"\n    Represents a guided extension project for learning.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    difficulty: ConceptDifficulty\n    concepts: List[str]  # List of concept IDs\n    requirements: List[str]\n    starter_code: Optional[str] = None\n    solution_code: Optional[str] = None\n    tests: List[str] = Field(default_factory=list)\n    hints: List[str] = Field(default_factory=list)\n    estimated_time_minutes: int = 60",
                "class ExtensionProject(BaseModel):\n    \"\"\"\n    Represents a guided extension project for learning.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    difficulty: ConceptDifficulty\n    concepts: List[str]  # List of concept IDs\n    requirements: List[str]\n    starter_code: Optional[str] = None\n    solution_code: Optional[str] = None\n    tests: List[str] = Field(default_factory=list)\n    hints: List[str] = Field(default_factory=list)\n    estimated_time_minutes: int = 60",
                "class LearningProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress in learning concepts.\n    \"\"\"\n\n    completed_concepts: Set[str] = Field(default_factory=set)\n    concept_mastery: Dict[str, float] = Field(default_factory=dict)  # 0.0 to 1.0\n    completed_projects: Set[str] = Field(default_factory=set)\n    viewed_annotations: Dict[str, int] = Field(\n        default_factory=dict\n    )  # concept_id -> count\n    current_project: Optional[str] = None\n\n    def mark_concept_viewed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as having been viewed.\n\n        Args:\n            concept_id: ID of the concept that was viewed\n        \"\"\"\n        if concept_id not in self.viewed_annotations:\n            self.viewed_annotations[concept_id] = 0\n\n        self.viewed_annotations[concept_id] += 1\n\n        # Update mastery based on view count\n        views = self.viewed_annotations[concept_id]\n        if views >= 5:\n            self.concept_mastery[concept_id] = 1.0\n        else:\n            self.concept_mastery[concept_id] = views / 5.0\n\n    def mark_concept_completed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as completed/mastered.\n\n        Args:\n            concept_id: ID of the concept that was completed\n        \"\"\"\n        self.completed_concepts.add(concept_id)\n        self.concept_mastery[concept_id] = 1.0\n\n    def mark_project_completed(self, project_id: str) -> None:\n        \"\"\"\n        Mark an extension project as completed.\n\n        Args:\n            project_id: ID of the project that was completed\n        \"\"\"\n        self.completed_projects.add(project_id)\n        self.current_project = None\n\n    def set_current_project(self, project_id: str) -> None:\n        \"\"\"\n        Set the current extension project.\n\n        Args:\n            project_id: ID of the project to set as current\n        \"\"\"\n        self.current_project = project_id\n\n    def get_mastery_level(self, concept_id: str) -> float:\n        \"\"\"\n        Get the mastery level for a concept.\n\n        Args:\n            concept_id: ID of the concept to check\n\n        Returns:\n            Mastery level from 0.0 to 1.0\n        \"\"\"\n        return self.concept_mastery.get(concept_id, 0.0)\n\n    def is_concept_completed(self, concept_id: str) -> bool:\n        \"\"\"\n        Check if a concept is completed.\n\n        Args:\n            concept_id: ID of the concept to check\n\n        Returns:\n            True if the concept is completed, False otherwise\n        \"\"\"\n        return concept_id in self.completed_concepts\n\n    def is_project_completed(self, project_id: str) -> bool:\n        \"\"\"\n        Check if a project is completed.\n\n        Args:\n            project_id: ID of the project to check\n\n        Returns:\n            True if the project is completed, False otherwise\n        \"\"\"\n        return project_id in self.completed_projects",
                "class LearningProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress in learning concepts.\n    \"\"\"\n\n    completed_concepts: Set[str] = Field(default_factory=set)\n    concept_mastery: Dict[str, float] = Field(default_factory=dict)  # 0.0 to 1.0\n    completed_projects: Set[str] = Field(default_factory=set)\n    viewed_annotations: Dict[str, int] = Field(\n        default_factory=dict\n    )  # concept_id -> count\n    current_project: Optional[str] = None\n\n    def mark_concept_viewed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as having been viewed.\n\n        Args:\n            concept_id: ID of the concept that was viewed\n        \"\"\"\n        if concept_id not in self.viewed_annotations:\n            self.viewed_annotations[concept_id] = 0\n\n        self.viewed_annotations[concept_id] += 1\n\n        # Update mastery based on view count\n        views = self.viewed_annotations[concept_id]\n        if views >= 5:\n            self.concept_mastery[concept_id] = 1.0\n        else:\n            self.concept_mastery[concept_id] = views / 5.0\n\n    def mark_concept_completed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as completed/mastered.\n\n        Args:\n            concept_id: ID of the concept that was completed\n        \"\"\"\n        self.completed_concepts.add(concept_id)\n        self.concept_mastery[concept_id] = 1.0\n\n    def mark_project_completed(self, project_id: str) -> None:\n        \"\"\"\n        Mark an extension project as completed.\n\n        Args:\n            project_id: ID of the project that was completed\n        \"\"\"\n        self.completed_projects.add(project_id)\n        self.current_project = None\n\n    def set_current_project(self, project_id: str) -> None:\n        \"\"\"\n        Set the current extension project.\n\n        Args:\n            project_id: ID of the project to set as current\n        \"\"\"\n        self.current_project = project_id\n\n    def get_mastery_level(self, concept_id: str) -> float:\n        \"\"\"\n        Get the mastery level for a concept.\n\n        Args:\n            concept_id: ID of the concept to check\n\n        Returns:\n            Mastery level from 0.0 to 1.0\n        \"\"\"\n        return self.concept_mastery.get(concept_id, 0.0)\n\n    def is_concept_completed(self, concept_id: str) -> bool:\n        \"\"\"\n        Check if a concept is completed.\n\n        Args:\n            concept_id: ID of the concept to check\n\n        Returns:\n            True if the concept is completed, False otherwise\n        \"\"\"\n        return concept_id in self.completed_concepts\n\n    def is_project_completed(self, project_id: str) -> bool:\n        \"\"\"\n        Check if a project is completed.\n\n        Args:\n            project_id: ID of the project to check\n\n        Returns:\n            True if the project is completed, False otherwise\n        \"\"\"\n        return project_id in self.completed_projects"
            ]
        }
    },
    "unified/text_editor/core/__init__.py": {
        "logprobs": -209.86324405688998,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/writer_text_editor/document.py": {
        "logprobs": -888.7866815523116,
        "metrics": {
            "loc": 195,
            "sloc": 113,
            "lloc": 114,
            "comments": 14,
            "multi": 3,
            "blank": 43,
            "cyclomatic": 35,
            "internal_imports": [
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r\"\\b\\w+\\b\", self.content))",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content, position=position, metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class Revision(BaseModel):\n    \"\"\"A revision of a document.\"\"\"\n\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n    sections: List[Section] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)",
                "class StructuredTextContent(TextContent):\n    \"\"\"\n    A text content implementation that stores text in a structured document.\n\n    This implementation is suited for complex document structures with\n    sections, segments, and revision tracking.\n    \"\"\"\n\n    title: str\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    class Config:\n        \"\"\"Pydantic configuration.\"\"\"\n\n        arbitrary_types_allowed = True\n\n    def __init__(self, title: str = \"Untitled\", **data: Any):\n        \"\"\"\n        Initialize a new structured text content with the given title.\n\n        Args:\n            title: Document title (default: \"Untitled\")\n        \"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(title=title, current_revision=initial_revision, **data)\n        self.revisions[\"Initial\"] = initial_revision\n\n    def insert(self, position: Position, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position.\n\n        Args:\n            position: The position where text should be inserted (must be StructuredPosition)\n            text: The text to insert\n\n        Raises:\n            ValueError: If the position is invalid or not a StructuredPosition\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(position, StructuredPosition):\n            raise ValueError(\"Position must be a StructuredPosition\")\n\n        # Handle different element types\n        if position.element_type == StructuredElementType.SECTION:\n            # Find the section\n            for section in self.current_revision.sections:\n                if section.id == position.element_id:\n                    # Add a new segment with the text\n                    section.add_segment(text)\n                    self.updated_at = datetime.now()\n                    return\n            raise ValueError(f\"Section with ID {position.element_id} not found\")\n\n        elif position.element_type == StructuredElementType.SEGMENT:\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == position.element_id:\n                        # Append text to the segment\n                        segment.content += text\n                        self.updated_at = datetime.now()\n                        return\n            raise ValueError(f\"Segment with ID {position.element_id} not found\")\n\n        else:\n            raise ValueError(f\"Unsupported element type: {position.element_type}\")\n\n    def delete(self, start: Position, end: Position) -> str:\n        \"\"\"\n        Delete text between the specified positions.\n\n        Args:\n            start: The start position of the text to delete (must be StructuredPosition)\n            end: The end position of the text to delete (must be StructuredPosition)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(start, StructuredPosition) or not isinstance(\n            end, StructuredPosition\n        ):\n            raise ValueError(\"Positions must be StructuredPositions\")\n\n        # Simple case: delete a segment\n        if (\n            start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for i, segment in enumerate(section.segments):\n                    if segment.id == start.element_id:\n                        deleted_text = segment.content\n                        section.delete_segment(i)\n                        self.updated_at = datetime.now()\n                        return deleted_text\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex deletion across multiple elements would be implemented here\n        raise NotImplementedError(\n            \"Deletion across multiple elements is not yet implemented\"\n        )\n\n    def replace(self, start: Position, end: Position, text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start: The start position of the text to replace (must be StructuredPosition)\n            end: The end position of the text to replace (must be StructuredPosition)\n            text: The replacement text\n\n        Returns:\n            The replaced text\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        if not isinstance(start, StructuredPosition) or not isinstance(\n            end, StructuredPosition\n        ):\n            raise ValueError(\"Positions must be StructuredPositions\")\n\n        # Simple case: replace a segment\n        if (\n            start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == start.element_id:\n                        old_text = segment.content\n                        segment.content = text\n                        self.updated_at = datetime.now()\n                        return old_text\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex replacement across multiple elements would be implemented here\n        raise NotImplementedError(\n            \"Replacement across multiple elements is not yet implemented\"\n        )\n\n    def get_text(\n        self, start: Optional[Position] = None, end: Optional[Position] = None\n    ) -> str:\n        \"\"\"\n        Get text between the specified positions.\n\n        Args:\n            start: The start position (default: beginning of content)\n            end: The end position (default: end of content)\n\n        Returns:\n            The text between start and end positions\n\n        Raises:\n            ValueError: If either position is invalid, not a StructuredPosition,\n                        or if end comes before start\n        \"\"\"\n        from common.core.position import StructuredPosition, StructuredElementType\n\n        # If no positions provided, return all content\n        if start is None and end is None:\n            return \"\\n\\n\".join(\n                [\n                    f\"# {section.title}\\n\\n{section.get_content()}\"\n                    for section in self.current_revision.sections\n                ]\n            )\n\n        if start is not None and not isinstance(start, StructuredPosition):\n            raise ValueError(\"Start position must be a StructuredPosition\")\n\n        if end is not None and not isinstance(end, StructuredPosition):\n            raise ValueError(\"End position must be a StructuredPosition\")\n\n        # Simple case: get text of a segment\n        if (\n            start is not None\n            and end is not None\n            and start.element_type == StructuredElementType.SEGMENT\n            and end.element_type == StructuredElementType.SEGMENT\n            and start.element_id == end.element_id\n        ):\n            # Find the segment\n            for section in self.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == start.element_id:\n                        return segment.content\n\n            raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # Simple case: get text of a section\n        if (\n            start is not None\n            and end is not None\n            and start.element_type == StructuredElementType.SECTION\n            and end.element_type == StructuredElementType.SECTION\n            and start.element_id == end.element_id\n        ):\n            # Find the section\n            for section in self.current_revision.sections:\n                if section.id == start.element_id:\n                    return f\"# {section.title}\\n\\n{section.get_content()}\"\n\n            raise ValueError(f\"Section with ID {start.element_id} not found\")\n\n        # For now, we have a limited implementation\n        # More complex text retrieval across multiple elements would be implemented here\n        if start is not None and end is not None:\n            raise NotImplementedError(\n                \"Text retrieval across multiple elements is not yet implemented\"\n            )\n\n        # If only start is provided, get text from that element to the end\n        if start is not None:\n            if start.element_type == StructuredElementType.SECTION:\n                found = False\n                section_texts = []\n\n                for section in self.current_revision.sections:\n                    if section.id == start.element_id or found:\n                        section_texts.append(\n                            f\"# {section.title}\\n\\n{section.get_content()}\"\n                        )\n                        found = True\n\n                if found:\n                    return \"\\n\\n\".join(section_texts)\n\n                raise ValueError(f\"Section with ID {start.element_id} not found\")\n\n            elif start.element_type == StructuredElementType.SEGMENT:\n                found_section = None\n                found_index = -1\n\n                # Find the segment and its section\n                for section in self.current_revision.sections:\n                    for i, segment in enumerate(section.segments):\n                        if segment.id == start.element_id:\n                            found_section = section\n                            found_index = i\n                            break\n                    if found_section:\n                        break\n\n                if found_section:\n                    # Get remaining segments in this section\n                    section_texts = [\n                        segment.content\n                        for segment in found_section.segments[found_index:]\n                    ]\n\n                    # Get all following sections\n                    found = False\n                    for section in self.current_revision.sections:\n                        if section.id == found_section.id:\n                            found = True\n                            continue\n\n                        if found:\n                            section_texts.append(\n                                f\"# {section.title}\\n\\n{section.get_content()}\"\n                            )\n\n                    return \"\\n\\n\".join(section_texts)\n\n                raise ValueError(f\"Segment with ID {start.element_id} not found\")\n\n        # If only end is provided, get text from the beginning to that element\n        if end is not None:\n            # Similar implementation to the start-only case, but from beginning to end\n            # Omitted for brevity\n            pass\n\n        # This point should not be reached due to the checks above\n        return \"\"\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the number of lines in the content.\n\n        This is an approximation for structured content.\n\n        Returns:\n            The approximate number of lines\n        \"\"\"\n        # Count newlines in the full content\n        return self.get_text().count(\"\\n\") + 1\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the content.\n\n        This is an approximation for structured content.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line\n\n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        lines = self.get_text().split(\"\\n\")\n        if 0 <= line_number < len(lines):\n            return lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n\n    def get_word_count(self) -> int:\n        \"\"\"\n        Get the total number of words in the content.\n\n        Returns:\n            The number of words\n        \"\"\"\n        return sum(\n            section.get_word_count() for section in self.current_revision.sections\n        )\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"\n        Add a new section to the document.\n\n        Args:\n            title: The section title\n            metadata: Optional metadata for the section\n\n        Returns:\n            The newly created section\n        \"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"\n        Create a new revision of the document.\n\n        Args:\n            name: The revision name\n            metadata: Optional metadata for the revision\n\n        Returns:\n            The newly created revision\n        \"\"\"\n        # Deep copy the current revision\n        import copy\n\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n\n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n\n        return new_revision"
            ]
        }
    },
    "unified/text_editor/customization/manager.py": {
        "logprobs": -2297.7823712584195,
        "metrics": {
            "loc": 533,
            "sloc": 311,
            "lloc": 165,
            "comments": 29,
            "multi": 104,
            "blank": 85,
            "cyclomatic": 63,
            "internal_imports": [
                "class CustomizableComponent(BaseModel):\n    \"\"\"\n    Represents a component of the editor that can be customized.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: CustomizationCategory\n    difficulty: CustomizationDifficulty\n    default_implementation: str\n    alternative_implementations: Dict[str, str] = Field(default_factory=dict)\n    impact_description: str\n    implementation_hints: List[str] = Field(default_factory=list)\n    current_implementation: str = \"default\"",
                "class CustomizationCategory(Enum):\n    \"\"\"Categories of editor components that can be customized.\"\"\"\n\n    TEXT_STORAGE = \"text_storage\"\n    CURSOR_BEHAVIOR = \"cursor_behavior\"\n    EDITING_OPERATIONS = \"editing_operations\"\n    SEARCH_ALGORITHM = \"search_algorithm\"\n    UNDO_REDO = \"undo_redo\"\n    FILE_HANDLING = \"file_handling\"\n    PERFORMANCE = \"performance\"",
                "class CustomizationDifficulty(Enum):\n    \"\"\"Difficulty levels for customization tasks.\"\"\"\n\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ExperimentResults(BaseModel):\n    \"\"\"\n    Represents the results of a customization experiment.\n    \"\"\"\n\n    component_id: str\n    implementation_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    success: bool = False\n    error_message: Optional[str] = None\n    performance_metrics: Dict[str, float] = Field(default_factory=dict)\n    notes: str = \"\"\n\n    def complete(\n        self, success: bool, metrics: Dict[str, float] = None, error: str = None\n    ) -> None:\n        \"\"\"\n        Mark the experiment as complete with results.\n\n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        self.end_time = time.time()\n        self.success = success\n\n        if metrics:\n            self.performance_metrics = metrics\n\n        if error:\n            self.error_message = error\n\n    def duration(self) -> float:\n        \"\"\"\n        Get the duration of the experiment in seconds.\n\n        Returns:\n            Duration of the experiment, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            return -1\n\n        return self.end_time - self.start_time",
                "class CustomizationHistory(BaseModel):\n    \"\"\"\n    Tracks the history of customization experiments.\n    \"\"\"\n\n    experiments: List[ExperimentResults] = Field(default_factory=list)\n    snapshots: Dict[str, Any] = Field(default_factory=dict)\n\n    def add_experiment(self, experiment: ExperimentResults) -> None:\n        \"\"\"\n        Add an experiment to the history.\n\n        Args:\n            experiment: The experiment to add\n        \"\"\"\n        self.experiments.append(experiment)\n\n    def get_experiments_for_component(\n        self, component_id: str\n    ) -> List[ExperimentResults]:\n        \"\"\"\n        Get all experiments for a specific component.\n\n        Args:\n            component_id: ID of the component to get experiments for\n\n        Returns:\n            List of experiments for the component\n        \"\"\"\n        return [e for e in self.experiments if e.component_id == component_id]\n\n    def get_last_successful_experiment(\n        self, component_id: str\n    ) -> Optional[ExperimentResults]:\n        \"\"\"\n        Get the last successful experiment for a component.\n\n        Args:\n            component_id: ID of the component to check\n\n        Returns:\n            The last successful experiment, or None if none found\n        \"\"\"\n        experiments = self.get_experiments_for_component(component_id)\n        successful = [e for e in experiments if e.success]\n\n        if successful:\n            return successful[-1]\n\n        return None\n\n    def save_snapshot(self, snapshot_id: str, snapshot_data: Any) -> None:\n        \"\"\"\n        Save a snapshot of the editor state.\n\n        Args:\n            snapshot_id: ID for the snapshot\n            snapshot_data: Data to save\n        \"\"\"\n        self.snapshots[snapshot_id] = snapshot_data\n\n    def get_snapshot(self, snapshot_id: str) -> Optional[Any]:\n        \"\"\"\n        Get a saved snapshot.\n\n        Args:\n            snapshot_id: ID of the snapshot to retrieve\n\n        Returns:\n            The snapshot data, or None if not found\n        \"\"\"\n        return self.snapshots.get(snapshot_id)"
            ]
        }
    },
    "unified/common/core/text_content.py": {
        "logprobs": -1845.334659405819,
        "metrics": {
            "loc": 881,
            "sloc": 391,
            "lloc": 401,
            "comments": 61,
            "multi": 229,
            "blank": 188,
            "cyclomatic": 163,
            "internal_imports": [
                "class Position(BaseModel, ABC):\n    \"\"\"\n    Abstract base class for positions within text content.\n\n    This class defines the interface for all position types, with methods for\n    moving the position in different directions and validating against content.\n    \"\"\"\n\n    @abstractmethod\n    def move_up(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position up by the specified number of units.\n\n        Args:\n            count: Number of units to move up (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_down(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position down by the specified number of units.\n\n        Args:\n            count: Number of units to move down (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_left(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position left by the specified number of units.\n\n        Args:\n            count: Number of units to move left (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def move_right(self, count: int = 1) -> Position:\n        \"\"\"\n        Move the position right by the specified number of units.\n\n        Args:\n            count: Number of units to move right (default: 1)\n\n        Returns:\n            A new Position instance at the new location\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        pass",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\"",
                "class StructuredPosition(Position):\n    \"\"\"\n    Position within structured content with hierarchical organization.\n\n    This positioning system is used for structured documents where content\n    is organized into sections, segments, and potentially other hierarchical\n    elements with unique identifiers.\n    \"\"\"\n\n    view_id: str = \"default\"  # Default value for backward compatibility\n    element_id: str = \"root\"  # Default value for backward compatibility\n    element_type: StructuredElementType = (\n        StructuredElementType.DOCUMENT\n    )  # Default value\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n\n    # For backward compatibility with tests\n    section_index: int = 0\n    segment_index: int = 0\n    offset_in_segment: int = 0\n\n    # Field for content reference\n    content: Optional[Any] = None\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position up within the structure hierarchy.\n\n        In a structured document, 'up' typically means moving to a\n        parent element (e.g., from segment to section).\n\n        Args:\n            count: Number of levels to move up (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_down(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position down within the structure hierarchy.\n\n        In a structured document, 'down' typically means moving to a\n        child element (e.g., from section to segment).\n\n        Args:\n            count: Number of levels to move down (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_left(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position left within the structure.\n\n        In a structured document, 'left' typically means moving to a\n        previous sibling element (e.g., previous segment in the same section).\n\n        Args:\n            count: Number of siblings to move left (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def move_right(self, count: int = 1) -> StructuredPosition:\n        \"\"\"\n        Move the position right within the structure.\n\n        In a structured document, 'right' typically means moving to a\n        next sibling element (e.g., next segment in the same section).\n\n        Args:\n            count: Number of siblings to move right (default: 1)\n\n        Returns:\n            A new StructuredPosition at the new location\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        # The caller should replace this with an appropriate position\n        return self\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Note: This is a placeholder implementation\n        # Actual implementation requires context from the content\n        return True\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, StructuredPosition):\n            raise TypeError(\"Can only compare with another StructuredPosition\")\n\n        # Compare based on equality of identifiers\n        if self.element_id == other.element_id and self.view_id == other.view_id:\n            return 0\n        else:\n            # For backward compatibility with tests, use section/segment/offset\n            if self.section_index < other.section_index:\n                return -1\n            elif self.section_index > other.section_index:\n                return 1\n            else:\n                # Same section, compare segment indices\n                if self.segment_index < other.segment_index:\n                    return -1\n                elif self.segment_index > other.segment_index:\n                    return 1\n                else:\n                    # Same segment, compare offsets\n                    if self.offset_in_segment < other.offset_in_segment:\n                        return -1\n                    elif self.offset_in_segment > other.offset_in_segment:\n                        return 1\n                    else:\n                        return 0",
                "class StructuredElementType(str, Enum):\n    \"\"\"Types of elements in a structured document.\"\"\"\n\n    DOCUMENT = \"document\"\n    SECTION = \"section\"\n    SEGMENT = \"segment\"\n    CHARACTER = \"character\"\n    CUSTOM = \"custom\""
            ]
        }
    },
    "unified/common/core/config_manager.py": {
        "logprobs": -672.2269079964263,
        "metrics": {
            "loc": 277,
            "sloc": 129,
            "lloc": 116,
            "comments": 3,
            "multi": 83,
            "blank": 59,
            "cyclomatic": 42,
            "internal_imports": []
        }
    },
    "unified/writer_text_editor/statistics.py": {
        "logprobs": -1945.208681477938,
        "metrics": {
            "loc": 525,
            "sloc": 380,
            "lloc": 297,
            "comments": 38,
            "multi": 0,
            "blank": 94,
            "cyclomatic": 80,
            "internal_imports": [
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(CommonSection):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n\n    # Inherits id, title, segments, metadata from CommonSection\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return super().get_content()\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return super().get_word_count()\n\n    def add_segment(\n        self, content: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        # Convert from CommonTextSegment to our TextSegment subclass\n        common_segment = super().add_segment(content, metadata)\n\n        # Create our TextSegment with the same properties\n        segment = TextSegment(\n            id=common_segment.id,\n            content=common_segment.content,\n            position=common_segment.position,\n            metadata=common_segment.metadata,\n        )\n\n        # Replace the segment in the list with our version\n        index = len(self.segments) - 1\n        self.segments[index] = segment\n\n        return segment\n\n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        return super().get_segment(position)\n\n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        return super().update_segment(position, content)\n\n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        return super().delete_segment(position)",
                "class TextSegment(CommonTextSegment):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n\n    # Inherits id, content, position, metadata from CommonTextSegment\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return super().get_word_count()"
            ]
        }
    },
    "unified/common/core/event_system.py": {
        "logprobs": -680.3535298612827,
        "metrics": {
            "loc": 245,
            "sloc": 108,
            "lloc": 123,
            "comments": 8,
            "multi": 58,
            "blank": 60,
            "cyclomatic": 27,
            "internal_imports": []
        }
    },
    "unified/text_editor/learning/__init__.py": {
        "logprobs": -195.64494705219,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/customization/models.py": {
        "logprobs": -672.6615662574279,
        "metrics": {
            "loc": 167,
            "sloc": 71,
            "lloc": 98,
            "comments": 0,
            "multi": 56,
            "blank": 38,
            "cyclomatic": 25,
            "internal_imports": []
        }
    },
    "unified/text_editor/interview/problems.py": {
        "logprobs": -1707.8381463147168,
        "metrics": {
            "loc": 803,
            "sloc": 682,
            "lloc": 17,
            "comments": 9,
            "multi": 29,
            "blank": 91,
            "cyclomatic": 8,
            "internal_imports": [
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False"
            ]
        }
    },
    "unified/writer_text_editor/client.py": {
        "logprobs": -1573.004576470328,
        "metrics": {
            "loc": 296,
            "sloc": 195,
            "lloc": 168,
            "comments": 8,
            "multi": 0,
            "blank": 61,
            "cyclomatic": 43,
            "internal_imports": [
                "class Document(StructuredTextContent):\n    \"\"\"A document in the writer text editor.\"\"\"\n\n    # Directly add the id attribute to ensure compatibility\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n\n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        super().__init__(title=title, **data)\n\n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return super().get_word_count()\n\n    def add_section(\n        self, title: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        # Convert from CommonSection to our Section subclass\n        common_section = super().add_section(title, metadata)\n\n        # Create our Section with the same properties\n        section = Section(\n            id=common_section.id,\n            title=common_section.title,\n            segments=[],  # We'll add segments separately if needed\n            metadata=common_section.metadata,\n        )\n\n        # Replace the section in the list with our version\n        index = len(self.current_revision.sections) - 1\n        self.current_revision.sections[index] = section\n\n        return section\n\n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n\n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n\n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n\n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Convert from CommonRevision to our Revision subclass\n        common_revision = super().create_revision(name, metadata)\n\n        # Create our Revision with the same properties\n        revision = Revision(\n            id=common_revision.id,\n            name=common_revision.name,\n            timestamp=common_revision.timestamp,\n            sections=common_revision.sections.copy(),\n            metadata=common_revision.metadata.copy(),\n        )\n\n        # Replace the revision in the dict with our version\n        self.revisions[name] = revision\n        self.current_revision = revision\n\n        return revision\n\n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n\n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n\n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return super().get_text()\n\n    def find_segments_by_content(\n        self, pattern: str\n    ) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class FocusMode:\n    \"\"\"The focus mode system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the focus mode system with the given document.\"\"\"\n        self.document = document\n        self.active_focus: Optional[FocusContext] = None\n        self.focus_history: List[FocusContext] = []\n\n    def is_active(self) -> bool:\n        \"\"\"Check if focus mode is currently active.\"\"\"\n        return self.active_focus is not None\n\n    def get_focus_context(self) -> Optional[FocusContext]:\n        \"\"\"Get the current focus context if focus mode is active.\"\"\"\n        return self.active_focus\n\n    def enter_focus(\n        self,\n        section_index: int,\n        segment_index: int,\n        level: FocusLevel = FocusLevel.PARAGRAPH,\n    ) -> Optional[FocusContext]:\n        \"\"\"Enter focus mode for the specified section and segment.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n\n        segment = section.get_segment(segment_index)\n        if not segment:\n            return None\n\n        # Create position object\n        position = StructuredPosition(\n            view_id=\"focus\",\n            element_id=segment.id,\n            element_type=StructuredElementType.SEGMENT,\n            section_index=section_index,\n            segment_index=segment_index,\n            offset_in_segment=0\n        )\n        \n        self.active_focus = FocusContext(\n            document=self.document, \n            section=section, \n            segment=segment, \n            level=level,\n            position=position\n        )\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n\n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        if self.active_focus:\n            self.active_focus = None\n            return True\n        return False\n\n    def move_focus(self, direction: int = 1) -> Optional[FocusContext]:\n        \"\"\"Move the focus to the next or previous segment.\"\"\"\n        if not self.active_focus:\n            return None\n\n        current_segment = self.active_focus.segment\n        current_section = self.active_focus.section\n        current_position = self.active_focus.position\n        \n        if not current_position:\n            return None\n\n        # Find the next segment within the current section\n        next_segment_index = current_position.segment_index + direction\n        next_segment = current_section.get_segment(next_segment_index)\n\n        if next_segment:\n            # Move focus within the same section\n            new_position = StructuredPosition(\n                view_id=current_position.view_id,\n                element_id=next_segment.id,\n                element_type=StructuredElementType.SEGMENT,\n                section_index=current_position.section_index,\n                segment_index=next_segment_index,\n                offset_in_segment=0\n            )\n            \n            self.active_focus = FocusContext(\n                document=self.document,\n                section=current_section,\n                segment=next_segment,\n                level=self.active_focus.level,\n                position=new_position\n            )\n            self.focus_history.append(self.active_focus)\n            return self.active_focus\n\n        # Try to move to a different section\n        current_section_idx = current_position.section_index\n        next_section_idx = current_section_idx + direction\n\n        if 0 <= next_section_idx < len(self.document.current_revision.sections):\n            next_section = self.document.current_revision.sections[next_section_idx]\n\n            # Get the first or last segment of the next section depending on direction\n            target_segment_index = 0 if direction > 0 else len(next_section.segments) - 1\n            if 0 <= target_segment_index < len(next_section.segments):\n                next_segment = next_section.segments[target_segment_index]\n                \n                new_position = StructuredPosition(\n                    view_id=current_position.view_id,\n                    element_id=next_segment.id,\n                    element_type=StructuredElementType.SEGMENT,\n                    section_index=next_section_idx,\n                    segment_index=target_segment_index,\n                    offset_in_segment=0\n                )\n\n                self.active_focus = FocusContext(\n                    document=self.document,\n                    section=next_section,\n                    segment=next_segment,\n                    level=self.active_focus.level,\n                    position=new_position\n                )\n                self.focus_history.append(self.active_focus)\n                return self.active_focus\n\n        return None\n\n    def change_focus_level(self, level: FocusLevel) -> Optional[FocusContext]:\n        \"\"\"Change the level of focus.\"\"\"\n        if not self.active_focus:\n            return None\n\n        self.active_focus.level = level\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n\n    def edit_focused_content(self, new_content: str) -> Optional[TextSegment]:\n        \"\"\"Edit the content of the focused segment.\"\"\"\n        if not self.active_focus:\n            return None\n\n        self.active_focus.segment.content = new_content\n        self.document.updated_at = time.time()\n        return self.active_focus.segment\n\n    def get_focus_time(self) -> float:\n        \"\"\"Get the time spent in the current focus session in seconds.\"\"\"\n        if not self.active_focus:\n            return 0.0\n\n        return time.time() - self.active_focus.start_time\n\n    def get_surrounding_context(self, context_size: int = 2) -> List[TextSegment]:\n        \"\"\"Get the surrounding segments around the focused segment.\"\"\"\n        if not self.active_focus or not self.active_focus.position:\n            return []\n\n        section = self.active_focus.section\n        position = self.active_focus.position.segment_index\n\n        start = max(0, position - context_size)\n        end = min(len(section.segments), position + context_size + 1)\n\n        return section.segments[start:end]",
                "class FocusLevel(str, Enum):\n    \"\"\"The level of focus.\"\"\"\n\n    PARAGRAPH = \"paragraph\"\n    SENTENCE = \"sentence\"\n    SECTION = \"section\"",
                "class WritingStatistics:\n    \"\"\"Writing statistics tracking system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the writing statistics system with the given document.\"\"\"\n        self.document = document\n        self.stats_history: List[DocumentStats] = []\n        self.pace_history: List[WritingPace] = []\n        self.progress_trackers: Dict[str, ProgressTracker] = {}\n        self._last_word_count: int = 0\n        self._last_check_time: float = time.time()\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n\n    def _count_sentences(self, text: str) -> int:\n        \"\"\"Count the number of sentences in the text.\"\"\"\n        # Simple sentence counting - this could be improved with NLP\n        return len(re.findall(r\"[.!?]+\\s+\", text)) + 1\n\n    def _identify_sentence_type(self, sentence: str) -> str:\n        \"\"\"Identify the type of a sentence.\"\"\"\n        sentence = sentence.strip()\n        if not sentence:\n            return \"unknown\"\n\n        if sentence.endswith(\"?\"):\n            return \"interrogative\"\n        elif sentence.endswith(\"!\"):\n            return \"exclamatory\"\n        elif \",\" in sentence and (\n            \"but\" in sentence.lower() or \"however\" in sentence.lower()\n        ):\n            return \"complex\"\n        else:\n            return \"declarative\"\n\n    def _is_complex_sentence(self, sentence: str) -> bool:\n        \"\"\"Check if a sentence is complex (has multiple clauses).\"\"\"\n        # Simple check for coordinating conjunctions and subordinating conjunctions\n        coordinating_conjunctions = [\n            \" and \",\n            \" but \",\n            \" or \",\n            \" nor \",\n            \" so \",\n            \" for \",\n            \" yet \",\n        ]\n\n        subordinating_conjunctions = [\n            \" because \",\n            \" although \",\n            \" though \",\n            \" since \",\n            \" unless \",\n            \" if \",\n            \" when \",\n            \" where \",\n            \" while \",\n        ]\n\n        # Check for conjunction at beginning of sentence too\n        sentence_starts = [\n            \"when \",\n            \"if \",\n            \"while \",\n            \"because \",\n            \"although \",\n            \"though \",\n            \"since \",\n            \"unless \",\n            \"where \",\n        ]\n\n        sentence = sentence.lower()\n\n        # Check for any coordinating conjunctions within the sentence\n        has_coordinating = any(conj in sentence for conj in coordinating_conjunctions)\n\n        # Check for any subordinating conjunctions within the sentence\n        has_subordinating = any(conj in sentence for conj in subordinating_conjunctions)\n\n        # Check if the sentence starts with a subordinating conjunction\n        starts_with_subordinating = any(\n            sentence.startswith(start) for start in sentence_starts\n        )\n\n        return has_coordinating or has_subordinating or starts_with_subordinating\n\n    def _calculate_vocabulary_richness(\n        self, total_words: int, unique_words: int\n    ) -> float:\n        \"\"\"Calculate vocabulary richness (Type-Token Ratio).\"\"\"\n        if total_words == 0:\n            return 0.0\n        return unique_words / total_words\n\n    def calculate_stats(self) -> DocumentStats:\n        \"\"\"Calculate the current document statistics.\"\"\"\n        text = self.document.get_content()\n\n        # Basic counts\n        word_count = len(re.findall(r\"\\b\\w+\\b\", text))\n        character_count = len(text)\n        paragraph_count = len(re.findall(r\"\\n\\s*\\n\", text)) + 1\n\n        # Split into sentences for sentence analysis\n        sentences = re.split(r\"[.!?]+\\s+\", text)\n        sentence_count = len(sentences)\n\n        # Analyze sentence structure\n        sentence_lengths = [\n            len(re.findall(r\"\\b\\w+\\b\", s)) for s in sentences if s.strip()\n        ]\n        avg_sentence_length = (\n            statistics.mean(sentence_lengths) if sentence_lengths else 0\n        )\n        sentence_length_variance = (\n            statistics.variance(sentence_lengths) if len(sentence_lengths) > 1 else 0\n        )\n\n        complex_sentences = sum(1 for s in sentences if self._is_complex_sentence(s))\n\n        sentence_types = {}\n        for s in sentences:\n            if not s.strip():\n                continue\n            sent_type = self._identify_sentence_type(s)\n            sentence_types[sent_type] = sentence_types.get(sent_type, 0) + 1\n\n        # Analyze word usage\n        words = re.findall(r\"\\b\\w+\\b\", text.lower())\n        unique_words = len(set(words))\n\n        word_lengths = [len(w) for w in words]\n        avg_word_length = statistics.mean(word_lengths) if word_lengths else 0\n\n        # Count word frequencies\n        word_frequencies = {}\n        for word in words:\n            if len(word) > 3:  # Ignore very short words\n                word_frequencies[word] = word_frequencies.get(word, 0) + 1\n\n        # Get most common words (top 20)\n        most_common = dict(\n            sorted(word_frequencies.items(), key=lambda x: x[1], reverse=True)[:20]\n        )\n\n        # Calculate reading level metrics\n        reading_level = {\n            ReadingLevel.FLESCH_KINCAID_GRADE.value: textstat.flesch_kincaid_grade(\n                text\n            ),\n            ReadingLevel.FLESCH_READING_EASE.value: textstat.flesch_reading_ease(text),\n            ReadingLevel.GUNNING_FOG.value: textstat.gunning_fog(text),\n            ReadingLevel.SMOG_INDEX.value: textstat.smog_index(text),\n            ReadingLevel.AUTOMATED_READABILITY_INDEX.value: textstat.automated_readability_index(\n                text\n            ),\n            ReadingLevel.COLEMAN_LIAU_INDEX.value: textstat.coleman_liau_index(text),\n        }\n\n        # Create stats objects\n        word_stats = WordStats(\n            total_words=word_count,\n            unique_words=unique_words,\n            average_word_length=avg_word_length,\n            most_common_words=most_common,\n            vocabulary_richness=self._calculate_vocabulary_richness(\n                word_count, unique_words\n            ),\n        )\n\n        sentence_stats = SentenceStats(\n            total_sentences=sentence_count,\n            average_sentence_length=avg_sentence_length,\n            sentence_length_variance=sentence_length_variance,\n            complex_sentences=complex_sentences,\n            sentence_types=sentence_types,\n        )\n\n        document_stats = DocumentStats(\n            word_count=word_count,\n            character_count=character_count,\n            paragraph_count=paragraph_count,\n            sentence_count=sentence_count,\n            reading_level=reading_level,\n            word_stats=word_stats,\n            sentence_stats=sentence_stats,\n        )\n\n        # Update history\n        self.stats_history.append(document_stats)\n\n        # Update last word count for pace tracking\n        self._last_word_count = word_count\n\n        return document_stats\n\n    def calculate_writing_pace(self) -> WritingPace:\n        \"\"\"Calculate the current writing pace.\"\"\"\n        current_time = time.time()\n        current_word_count = self.document.get_word_count()\n\n        time_diff_seconds = current_time - self._last_check_time\n        word_diff = current_word_count - self._last_word_count\n\n        if time_diff_seconds <= 0:\n            words_per_minute = 0.0\n        else:\n            # Calculate words per minute\n            words_per_minute = (word_diff / time_diff_seconds) * 60\n\n        # Update for next calculation\n        self._last_check_time = current_time\n        self._last_word_count = current_word_count\n\n        # Create pace object\n        pace = WritingPace(\n            words_per_minute=words_per_minute,\n            words_per_hour=words_per_minute * 60,\n            words_per_day=words_per_minute * 60 * 24,\n        )\n\n        # Update history\n        self.pace_history.append(pace)\n\n        return pace\n\n    def set_progress_goal(\n        self,\n        goal_id: str,\n        goal_type: str,\n        target: int,\n        deadline: Optional[datetime] = None,\n    ) -> ProgressTracker:\n        \"\"\"Set a new progress goal.\"\"\"\n        tracker = ProgressTracker(\n            start_date=datetime.now(),\n            goal_type=goal_type,\n            goal_target=target,\n            goal_deadline=deadline,\n        )\n\n        self.progress_trackers[goal_id] = tracker\n        return tracker\n\n    def update_progress(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Update the progress for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n\n        tracker = self.progress_trackers[goal_id]\n        current_stats = self.calculate_stats()\n\n        progress_entry = {\n            \"timestamp\": datetime.now(),\n            \"word_count\": current_stats.word_count,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n        }\n\n        if tracker.goal_type == \"word_count\":\n            progress_entry[\"progress_percentage\"] = (\n                current_stats.word_count / tracker.goal_target\n            ) * 100\n            progress_entry[\"remaining\"] = max(\n                0, tracker.goal_target - current_stats.word_count\n            )\n\n        if tracker.goal_deadline:\n            now = datetime.now()\n            if now < tracker.goal_deadline:\n                time_remaining = tracker.goal_deadline - now\n                progress_entry[\"time_remaining_days\"] = time_remaining.days\n\n                # Estimate completion date based on current pace\n                if self.pace_history and tracker.goal_type == \"word_count\":\n                    latest_pace = self.pace_history[-1]\n                    words_remaining = max(\n                        0, tracker.goal_target - current_stats.word_count\n                    )\n\n                    if latest_pace.words_per_day > 0:\n                        days_needed = words_remaining / latest_pace.words_per_day\n                        progress_entry[\"estimated_completion_date\"] = now + timedelta(\n                            days=days_needed\n                        )\n\n        tracker.progress_history.append(progress_entry)\n        return progress_entry\n\n    def get_progress_report(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a detailed progress report for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n\n        tracker = self.progress_trackers[goal_id]\n        current_progress = self.update_progress(goal_id)\n\n        if not current_progress or not tracker.progress_history:\n            return None\n\n        report = {\n            \"goal_id\": goal_id,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n            \"start_date\": tracker.start_date,\n            \"deadline\": tracker.goal_deadline,\n            \"current_progress\": current_progress,\n            \"history_summary\": {\n                \"start_value\": tracker.progress_history[0].get(\"word_count\", 0),\n                \"current_value\": current_progress.get(\"word_count\", 0),\n                \"total_progress\": current_progress.get(\"word_count\", 0)\n                - tracker.progress_history[0].get(\"word_count\", 0),\n            },\n        }\n\n        # Calculate average daily progress\n        if len(tracker.progress_history) > 1:\n            first_entry = tracker.progress_history[0]\n            last_entry = tracker.progress_history[-1]\n\n            first_time = first_entry[\"timestamp\"]\n            last_time = last_entry[\"timestamp\"]\n\n            time_diff_days = (\n                last_time - first_time\n            ).days or 1  # Avoid division by zero\n            progress_diff = last_entry.get(\"word_count\", 0) - first_entry.get(\n                \"word_count\", 0\n            )\n\n            report[\"average_daily_progress\"] = progress_diff / time_diff_days\n\n        return report\n\n    def start_background_tracking(self, interval_seconds: int = 60) -> None:\n        \"\"\"Start tracking statistics in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n\n        self._stop_background_thread = False\n\n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.calculate_stats()\n                    self.calculate_writing_pace()\n\n                    # Update all progress trackers\n                    for goal_id in self.progress_trackers:\n                        self.update_progress(goal_id)\n                except Exception as e:\n                    print(f\"Error in background tracking: {e}\")\n\n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n\n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n\n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)\n\n    def get_trend_analysis(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"Analyze trends in writing statistics over the specified number of days.\"\"\"\n        now = datetime.now()\n        cutoff_date = now - timedelta(days=days)\n\n        # Filter history to the specified time range\n        recent_stats = [s for s in self.stats_history if s.timestamp >= cutoff_date]\n        recent_pace = [p for p in self.pace_history if p.timestamp >= cutoff_date]\n\n        if not recent_stats:\n            return {\"error\": \"Not enough data for trend analysis\"}\n\n        # Calculate daily word counts\n        daily_word_counts = {}\n        for stats in recent_stats:\n            day_key = stats.timestamp.strftime(\"%Y-%m-%d\")\n            if day_key not in daily_word_counts:\n                daily_word_counts[day_key] = []\n            daily_word_counts[day_key].append(stats.word_count)\n\n        # Get the last word count for each day\n        daily_progress = {day: counts[-1] for day, counts in daily_word_counts.items()}\n\n        # Calculate daily difference\n        days_sorted = sorted(daily_progress.keys())\n        daily_change = {}\n        for i in range(1, len(days_sorted)):\n            prev_day = days_sorted[i - 1]\n            curr_day = days_sorted[i]\n            daily_change[curr_day] = daily_progress[curr_day] - daily_progress[prev_day]\n\n        # Calculate reading level trends\n        reading_level_trends = {}\n        for level_type in ReadingLevel:\n            level_values = [\n                s.reading_level.get(level_type.value, 0) for s in recent_stats\n            ]\n            if level_values:\n                reading_level_trends[level_type.value] = {\n                    \"start\": level_values[0],\n                    \"end\": level_values[-1],\n                    \"change\": level_values[-1] - level_values[0],\n                    \"average\": sum(level_values) / len(level_values),\n                }\n\n        # Calculate pace trends\n        pace_trends = {}\n        if recent_pace:\n            wpm_values = [p.words_per_minute for p in recent_pace]\n            pace_trends[\"words_per_minute\"] = {\n                \"start\": wpm_values[0],\n                \"end\": wpm_values[-1],\n                \"change\": wpm_values[-1] - wpm_values[0],\n                \"average\": sum(wpm_values) / len(wpm_values),\n            }\n\n        return {\n            \"period_days\": days,\n            \"total_word_count_change\": recent_stats[-1].word_count\n            - recent_stats[0].word_count,\n            \"daily_progress\": daily_progress,\n            \"daily_change\": daily_change,\n            \"average_daily_change\": sum(daily_change.values()) / len(daily_change)\n            if daily_change\n            else 0,\n            \"reading_level_trends\": reading_level_trends,\n            \"pace_trends\": pace_trends,\n            \"vocabulary_richness_change\": (\n                recent_stats[-1].word_stats.vocabulary_richness\n                - recent_stats[0].word_stats.vocabulary_richness\n            ),\n        }",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n\n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n\n    def _find_element_occurrences(\n        self, element_name: str, aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n\n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = (\n            r\"\\b(\" + \"|\".join(re.escape(name) for name in names_to_search) + r\")\\b\"\n        )\n        regex = re.compile(pattern, re.IGNORECASE)\n\n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n\n                    results.append((section, segment, match.start(), context))\n\n        return results\n\n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n\n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set(),\n        }\n\n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n\n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n\n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n\n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(\n                    re.findall(r\"\\b\" + re.escape(element) + r\"\\b\", text, re.IGNORECASE)\n                )\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element\n                        in [e.name for e in self.elements.values()],\n                    }\n\n        return results\n\n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n\n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n\n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n\n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n\n                co_occurrences = 0\n                for context in contexts:\n                    pattern = (\n                        r\"\\b(\"\n                        + \"|\".join(\n                            [re.escape(other_element.name)]\n                            + [re.escape(alias) for alias in other_element.aliases]\n                        )\n                        + r\")\\b\"\n                    )\n\n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n\n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n\n        return connections\n\n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n\n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n\n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n\n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n\n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n\n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(\n                        char_timeline_sections, key=lambda s: timeline_sections[s]\n                    )\n\n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n\n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(\n                                        ConsistencyIssue(\n                                            id=str(len(issues) + 1),\n                                            issue_type=\"timeline\",\n                                            elements_involved=[char_id],\n                                            description=(\n                                                f\"Character appears in non-sequential timeline points: \"\n                                                f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                                f\"{timeline_sections[sorted_sections[k]]}\"\n                                            ),\n                                            locations=[\n                                                (sorted_sections[i], \"\"),\n                                                (sorted_sections[j], \"\"),\n                                                (sorted_sections[k], \"\"),\n                                            ],\n                                            severity=3,\n                                        )\n                                    )\n\n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n\n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n\n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name) :]\n\n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r\"\\s+was\\s+(\\w+)\",\n                        r\"\\s+had\\s+(\\w+)\",\n                        r\"\\s+with\\s+(\\w+)\",\n                        r\",\\s+a\\s+(\\w+)\",\n                        r\",\\s+the\\s+(\\w+)\",\n                    ]\n\n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append(\n                                (\n                                    occurrence.section_id,\n                                    occurrence.segment_id,\n                                    match.group(1),\n                                    context,\n                                )\n                            )\n\n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n\n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\"),\n                ]\n\n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(\n                            ConsistencyIssue(\n                                id=str(len(issues) + 1),\n                                issue_type=\"contradiction\",\n                                elements_involved=[element_id],\n                                description=(\n                                    f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                                ),\n                                locations=[\n                                    (\n                                        descriptions[word1][0][0],\n                                        descriptions[word1][0][1],\n                                    ),\n                                    (\n                                        descriptions[word2][0][0],\n                                        descriptions[word2][0][1],\n                                    ),\n                                ],\n                                severity=4,\n                            )\n                        )\n\n        return issues\n\n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None,\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n\n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(\n            name, aliases\n        ):\n            occurrences.append(\n                ElementOccurrence(\n                    element_id=element_id,\n                    section_id=section.id,\n                    segment_id=segment.id,\n                    position=position,\n                    context=context,\n                )\n            )\n\n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None,\n        )\n\n        self.elements[element_id] = element\n        return element\n\n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n\n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: [],\n        }\n\n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name, element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n\n        # Update element relationships\n        self.update_element_relationships()\n\n        # Detect consistency issues\n        self.check_consistency()\n\n        return tracked_elements\n\n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n\n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n\n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n\n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n\n        element = self.elements[element_id]\n        appearances = []\n\n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n\n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n\n            if section and segment:\n                appearances.append(\n                    {\n                        \"section_title\": section.title,\n                        \"section_id\": section.id,\n                        \"segment_id\": segment.id,\n                        \"segment_position\": segment.position,\n                        \"context\": occurrence.context,\n                        \"mentioned_with\": [\n                            self.elements[e_id].name\n                            for e_id in occurrence.mentioned_with\n                            if e_id in self.elements\n                        ],\n                    }\n                )\n\n        return appearances\n\n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n\n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": [],\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n\n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append(\n                    {\n                        \"section_id\": section.id,\n                        \"section_title\": sections[section.id][\"section_title\"],\n                        \"appearances\": sorted(\n                            sections[section.id][\"appearances\"],\n                            key=lambda a: a[\"segment_position\"],\n                        ),\n                    }\n                )\n\n        return ordered_sections\n\n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n\n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n\n        self._stop_background_thread = False\n\n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n\n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n\n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n\n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n\n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class DocumentNavigator:\n    \"\"\"Non-linear document navigation system.\"\"\"\n\n    def __init__(\n        self, document: Document, narrative_tracker: Optional[NarrativeTracker] = None\n    ):\n        \"\"\"Initialize the navigation system with the given document.\"\"\"\n        self.document = document\n        self.narrative_tracker = narrative_tracker\n        self.elements: Dict[str, NavigationElement] = {}\n        self.views: Dict[str, NavigationView] = {}\n        self.tags: Dict[str, NavigationTag] = {}\n        self.links: Dict[str, NavigationLink] = {}\n        self.current_position: Optional[NavigationPosition] = None\n\n        # Initialize with default linear view\n        self._initialize_linear_view()\n\n    def _initialize_linear_view(self) -> None:\n        \"\"\"Initialize the default linear view of the document.\"\"\"\n        # Create view\n        view_id = \"view_linear\"\n        view = NavigationView(\n            id=view_id, name=\"Linear View\", view_type=NavigationViewType.LINEAR\n        )\n\n        # Create elements for sections and segments\n        root_elements = []\n\n        for section_idx, section in enumerate(self.document.current_revision.sections):\n            # Create element for the section\n            section_element_id = f\"element_section_{section.id}\"\n            section_element = NavigationElement(\n                id=section_element_id,\n                element_type=\"section\",\n                name=section.title,\n                original_id=section.id,\n            )\n\n            # Add to elements\n            self.elements[section_element_id] = section_element\n            root_elements.append(section_element_id)\n\n            # Create elements for segments\n            for segment_idx, segment in enumerate(section.segments):\n                segment_element_id = f\"element_segment_{segment.id}\"\n                segment_element = NavigationElement(\n                    id=segment_element_id,\n                    element_type=\"segment\",\n                    name=f\"Paragraph {segment_idx + 1}\",\n                    original_id=segment.id,\n                )\n\n                # Add to elements\n                self.elements[segment_element_id] = segment_element\n\n                # Add to section's children\n                section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        # Set current position to the first section if available\n        if root_elements:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=root_elements[0]\n            )\n            # Initialize a structured position for the first section\n            if self.document.current_revision.sections:\n                first_section = self.document.current_revision.sections[0]\n                element_type = StructuredElementType.SECTION\n                self.current_position.position = StructuredPosition(\n                    view_id=view_id,\n                    element_id=first_section.id,\n                    element_type=element_type,\n                    section_index=0,\n                    segment_index=0,\n                    offset_in_segment=0\n                )\n\n    def _create_character_view(self) -> str:\n        \"\"\"Create a view organized by characters.\"\"\"\n        if not self.narrative_tracker:\n            return \"\"\n\n        # Create view\n        view_id = \"view_character\"\n        view = NavigationView(\n            id=view_id, name=\"Character View\", view_type=NavigationViewType.CHARACTER\n        )\n\n        # Get character elements from the narrative tracker\n        character_elements = [\n            element\n            for element in self.narrative_tracker.elements.values()\n            if element.element_type == ElementType.CHARACTER\n        ]\n\n        # Create elements for each character\n        root_elements = []\n\n        for character in character_elements:\n            # Create element for the character\n            character_element_id = f\"element_character_{character.id}\"\n            character_element = NavigationElement(\n                id=character_element_id,\n                element_type=\"character\",\n                name=character.name,\n                original_id=character.id,\n                metadata={\"description\": character.description},\n            )\n\n            # Add to elements\n            self.elements[character_element_id] = character_element\n            root_elements.append(character_element_id)\n\n            # Get appearances of this character\n            appearances = self.narrative_tracker.get_element_appearances(character.id)\n\n            # Group by section\n            section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n            for appearance in appearances:\n                section_id = appearance[\"section_id\"]\n                if section_id not in section_appearances:\n                    section_appearances[section_id] = []\n                section_appearances[section_id].append(appearance)\n\n            # Create elements for each section with appearances\n            for section_id, section_apps in section_appearances.items():\n                # Get the section\n                section = None\n                for s in self.document.current_revision.sections:\n                    if s.id == section_id:\n                        section = s\n                        break\n\n                if not section:\n                    continue\n\n                # Create element for the section\n                section_element_id = (\n                    f\"element_character_section_{character.id}_{section.id}\"\n                )\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n\n                # Add to character's children\n                character_element.children.append(section_element_id)\n\n                # Create elements for each appearance\n                for appearance in section_apps:\n                    segment_id = appearance[\"segment_id\"]\n\n                    # Get the segment\n                    segment = None\n                    for seg in section.segments:\n                        if seg.id == segment_id:\n                            segment = seg\n                            break\n\n                    if not segment:\n                        continue\n\n                    # Create element for the segment\n                    segment_element_id = (\n                        f\"element_character_segment_{character.id}_{segment.id}\"\n                    )\n\n                    # Skip if already added\n                    if segment_element_id in self.elements:\n                        continue\n\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Appearance {len(section_element.children) + 1}\",\n                        original_id=segment.id,\n                        metadata={\"context\": appearance[\"context\"]},\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def _create_plot_view(self) -> str:\n        \"\"\"Create a view organized by plot elements.\"\"\"\n        # Create view\n        view_id = \"view_plot\"\n        view = NavigationView(\n            id=view_id, name=\"Plot View\", view_type=NavigationViewType.PLOT\n        )\n\n        # First, look for plot-related metadata in the document\n        plot_elements = []\n\n        # Check for plot tags\n        plot_tags = [tag for tag in self.tags.values() if \"plot\" in tag.name.lower()]\n\n        if plot_tags:\n            # Organize by plot tags\n            for tag in plot_tags:\n                # Create element for the tag\n                tag_element_id = f\"element_plot_tag_{tag.id}\"\n                tag_element = NavigationElement(\n                    id=tag_element_id,\n                    element_type=\"tag\",\n                    name=tag.name,\n                    original_id=tag.id,\n                )\n\n                # Add to elements\n                self.elements[tag_element_id] = tag_element\n                plot_elements.append(tag_element_id)\n\n                # Find elements with this tag\n                for element_id, element in self.elements.items():\n                    if tag.id in element.tags:\n                        # Create a reference element\n                        ref_element_id = f\"element_plot_ref_{tag.id}_{element.id}\"\n                        ref_element = NavigationElement(\n                            id=ref_element_id,\n                            element_type=element.element_type,\n                            name=element.name,\n                            original_id=element.original_id,\n                        )\n\n                        # Add to elements\n                        self.elements[ref_element_id] = ref_element\n\n                        # Add to tag's children\n                        tag_element.children.append(ref_element_id)\n\n        # If we have a narrative tracker, use plot elements from there\n        elif self.narrative_tracker:\n            # Get plot elements from the narrative tracker\n            plot_narrative_elements = [\n                element\n                for element in self.narrative_tracker.elements.values()\n                if element.element_type\n                in (ElementType.EVENT, ElementType.ITEM, ElementType.TERM)\n            ]\n\n            for plot_element in plot_narrative_elements:\n                # Create element for the plot element\n                plot_element_id = f\"element_plot_{plot_element.id}\"\n                plot_nav_element = NavigationElement(\n                    id=plot_element_id,\n                    element_type=\"plot\",\n                    name=plot_element.name,\n                    original_id=plot_element.id,\n                    metadata={\"description\": plot_element.description},\n                )\n\n                # Add to elements\n                self.elements[plot_element_id] = plot_nav_element\n                plot_elements.append(plot_element_id)\n\n                # Get appearances of this plot element\n                appearances = self.narrative_tracker.get_element_appearances(\n                    plot_element.id\n                )\n\n                # Group by section\n                section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n                for appearance in appearances:\n                    section_id = appearance[\"section_id\"]\n                    if section_id not in section_appearances:\n                        section_appearances[section_id] = []\n                    section_appearances[section_id].append(appearance)\n\n                # Create elements for each section with appearances\n                for section_id, section_apps in section_appearances.items():\n                    # Get the section\n                    section = None\n                    for s in self.document.current_revision.sections:\n                        if s.id == section_id:\n                            section = s\n                            break\n\n                    if not section:\n                        continue\n\n                    # Create element for the section\n                    section_element_id = (\n                        f\"element_plot_section_{plot_element.id}_{section.id}\"\n                    )\n                    section_element = NavigationElement(\n                        id=section_element_id,\n                        element_type=\"section\",\n                        name=section.title,\n                        original_id=section.id,\n                    )\n\n                    # Add to elements\n                    self.elements[section_element_id] = section_element\n\n                    # Add to plot element's children\n                    plot_nav_element.children.append(section_element_id)\n\n                    # Create elements for each appearance\n                    for appearance in section_apps:\n                        segment_id = appearance[\"segment_id\"]\n\n                        # Get the segment\n                        segment = None\n                        for seg in section.segments:\n                            if seg.id == segment_id:\n                                segment = seg\n                                break\n\n                        if not segment:\n                            continue\n\n                        # Create element for the segment\n                        segment_element_id = (\n                            f\"element_plot_segment_{plot_element.id}_{segment.id}\"\n                        )\n\n                        # Skip if already added\n                        if segment_element_id in self.elements:\n                            continue\n\n                        segment_element = NavigationElement(\n                            id=segment_element_id,\n                            element_type=\"segment\",\n                            name=f\"Reference {len(section_element.children) + 1}\",\n                            original_id=segment.id,\n                            metadata={\"context\": appearance[\"context\"]},\n                        )\n\n                        # Add to elements\n                        self.elements[segment_element_id] = segment_element\n\n                        # Add to section's children\n                        section_element.children.append(segment_element_id)\n\n        # If we don't have plot tags or narrative tracker, create a dummy structure\n        if not plot_elements:\n            # Create a default \"plot\" element\n            plot_element_id = \"element_plot_default\"\n            plot_element = NavigationElement(\n                id=plot_element_id, element_type=\"plot\", name=\"Main Plot\"\n            )\n\n            # Add to elements\n            self.elements[plot_element_id] = plot_element\n            plot_elements.append(plot_element_id)\n\n            # Add all sections as children\n            for section in self.document.current_revision.sections:\n                # Create element for the section\n                section_element_id = f\"element_plot_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n\n                # Add to plot's children\n                plot_element.children.append(section_element_id)\n\n        # Update view\n        view.root_elements = plot_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def _create_timeline_view(self) -> str:\n        \"\"\"Create a view organized by timeline/chronology.\"\"\"\n        # Create view\n        view_id = \"view_timeline\"\n        view = NavigationView(\n            id=view_id, name=\"Timeline View\", view_type=NavigationViewType.TIMELINE\n        )\n\n        # Check for timeline metadata in sections\n        timeline_sections = []\n\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections.append((section, section.metadata[\"timeline\"]))\n\n        # If we have timeline metadata, use it to organize the view\n        if timeline_sections:\n            # Sort sections by timeline value\n            timeline_sections.sort(key=lambda x: x[1])\n\n            # Create elements for each section in chronological order\n            root_elements = []\n\n            for section, timeline in timeline_sections:\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=f\"{timeline}: {section.title}\",\n                    original_id=section.id,\n                    metadata={\"timeline\": timeline},\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n\n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id,\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        else:\n            # Create a simple chronological view (same as linear)\n            root_elements = []\n\n            for section_idx, section in enumerate(\n                self.document.current_revision.sections\n            ):\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                    metadata={\"position\": section_idx},\n                )\n\n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n\n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id,\n                    )\n\n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n\n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n\n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n\n        return view_id\n\n    def create_view(self, name: str, view_type: NavigationViewType) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        if view_type == NavigationViewType.CHARACTER:\n            return self._create_character_view()\n        elif view_type == NavigationViewType.PLOT:\n            return self._create_plot_view()\n        elif view_type == NavigationViewType.TIMELINE:\n            return self._create_timeline_view()\n        elif view_type == NavigationViewType.CUSTOM:\n            # Create a custom view\n            view_id = f\"view_custom_{len(self.views) + 1}\"\n            view = NavigationView(id=view_id, name=name, view_type=view_type)\n\n            self.views[view_id] = view\n            return view_id\n        else:\n            # Linear view already exists\n            return \"view_linear\"\n\n    def create_tag(self, name: str, color: str = \"#CCCCCC\") -> str:\n        \"\"\"Create a new tag for navigation elements.\"\"\"\n        tag_id = f\"tag_{len(self.tags) + 1}\"\n        tag = NavigationTag(id=tag_id, name=name, color=color)\n\n        self.tags[tag_id] = tag\n        return tag_id\n\n    def add_tag_to_element(self, element_id: str, tag_id: str) -> bool:\n        \"\"\"Add a tag to a navigation element.\"\"\"\n        if element_id not in self.elements or tag_id not in self.tags:\n            return False\n\n        element = self.elements[element_id]\n        if tag_id not in element.tags:\n            element.tags.append(tag_id)\n\n        return True\n\n    def create_link(\n        self,\n        source_type: str,\n        source_id: str,\n        target_type: str,\n        target_id: str,\n        link_type: str,\n    ) -> str:\n        \"\"\"Create a link between two navigation elements.\"\"\"\n        link_id = f\"link_{len(self.links) + 1}\"\n        link = NavigationLink(\n            id=link_id,\n            source_type=source_type,\n            source_id=source_id,\n            target_type=target_type,\n            target_id=target_id,\n            link_type=link_type,\n        )\n\n        self.links[link_id] = link\n        return link_id\n\n    def add_element_to_view(\n        self, view_id: str, element_id: str, parent_id: Optional[str] = None\n    ) -> bool:\n        \"\"\"Add an element to a view, optionally as a child of another element.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n\n        view = self.views[view_id]\n\n        if parent_id:\n            if parent_id not in self.elements:\n                return False\n\n            parent = self.elements[parent_id]\n            if element_id not in parent.children:\n                parent.children.append(element_id)\n        else:\n            if element_id not in view.root_elements:\n                view.root_elements.append(element_id)\n\n        return True\n\n    def get_current_element(self) -> Optional[NavigationElement]:\n        \"\"\"Get the current navigation element.\"\"\"\n        if not self.current_position:\n            return None\n\n        element_id = self.current_position.element_id\n        return self.elements.get(element_id)\n\n    def get_element_content(self, element_id: str) -> Optional[str]:\n        \"\"\"Get the content of a navigation element.\"\"\"\n        if element_id not in self.elements:\n            return None\n\n        element = self.elements[element_id]\n        original_id = element.original_id\n\n        if not original_id:\n            return None\n\n        if element.element_type == \"section\":\n            # Find the section\n            for section in self.document.current_revision.sections:\n                if section.id == original_id:\n                    return section.get_content()\n\n        elif element.element_type == \"segment\":\n            # Find the segment\n            for section in self.document.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == original_id:\n                        return segment.content\n\n        return None\n\n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n\n        # Find the element to navigate to\n        nav_element = self.elements.get(element_id)\n        if not nav_element or not nav_element.original_id:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=element_id\n            )\n            return True\n            \n        # Create a structured position based on the element type\n        element_type = None\n        section_index = 0\n        segment_index = 0\n        \n        if nav_element.element_type == \"section\":\n            element_type = StructuredElementType.SECTION\n            # Find section index\n            for i, section in enumerate(self.document.current_revision.sections):\n                if section.id == nav_element.original_id:\n                    section_index = i\n                    break\n        elif nav_element.element_type == \"segment\":\n            element_type = StructuredElementType.SEGMENT\n            # Find section and segment indices\n            for i, section in enumerate(self.document.current_revision.sections):\n                for j, segment in enumerate(section.segments):\n                    if segment.id == nav_element.original_id:\n                        section_index = i\n                        segment_index = j\n                        break\n                if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                    break\n                    \n        if element_type:\n            position = StructuredPosition(\n                view_id=view_id,\n                element_id=nav_element.original_id,\n                element_type=element_type,\n                section_index=section_index,\n                segment_index=segment_index,\n                offset_in_segment=0\n            )\n            self.current_position = NavigationPosition(\n                view_id=view_id, \n                element_id=element_id,\n                position=position\n            )\n        else:\n            self.current_position = NavigationPosition(\n                view_id=view_id, element_id=element_id\n            )\n            \n        return True\n\n        return True\n\n    def navigate_to_related(\n        self, link_type: Optional[str] = None\n    ) -> List[NavigationElement]:\n        \"\"\"Navigate to elements related to the current element.\"\"\"\n        if not self.current_position:\n            return []\n\n        current_element_id = self.current_position.element_id\n\n        # Find links with this element as source\n        related_links = []\n        for link in self.links.values():\n            if link.source_id == current_element_id:\n                if not link_type or link.link_type == link_type:\n                    related_links.append(link)\n\n        # Get related elements\n        related_elements = []\n        for link in related_links:\n            target_id = link.target_id\n            if target_id in self.elements:\n                related_elements.append(self.elements[target_id])\n\n        return related_elements\n\n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Find parent element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Navigate to parent\n            nav_element = self.elements.get(parent_id)\n            if not nav_element or not nav_element.original_id:\n                self.current_position = NavigationPosition(\n                    view_id=view_id, element_id=parent_id\n                )\n                return True\n                \n            # Create a structured position\n            element_type = None\n            section_index = 0\n            segment_index = 0\n            \n            if nav_element.element_type == \"section\":\n                element_type = StructuredElementType.SECTION\n                # Find section index\n                for i, section in enumerate(self.document.current_revision.sections):\n                    if section.id == nav_element.original_id:\n                        section_index = i\n                        break\n            \n            if element_type:\n                position = StructuredPosition(\n                    view_id=view_id,\n                    element_id=nav_element.original_id,\n                    element_type=element_type,\n                    section_index=section_index,\n                    segment_index=segment_index,\n                    offset_in_segment=0\n                )\n                self.current_position = NavigationPosition(\n                    view_id=view_id, \n                    element_id=parent_id,\n                    position=position\n                )\n            else:\n                self.current_position = NavigationPosition(\n                    view_id=view_id, element_id=parent_id\n                )\n                \n            return True\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Already at top level\n            return False\n\n        return False\n\n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Check if this element is a child of another element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n\n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n\n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(siblings):\n                    next_id = siblings[current_index + 1]\n                    # Navigate to next sibling\n                    nav_element = self.elements.get(next_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=next_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n\n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(view.root_elements):\n                    next_id = view.root_elements[current_index + 1]\n                    # Navigate to next root element\n                    nav_element = self.elements.get(next_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=next_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=next_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        return False\n\n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n\n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n\n        # Check if this element is a child of another element\n        parent_id = None\n\n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n\n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n\n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n\n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = siblings[current_index - 1]\n                    # Navigate to previous sibling\n                    nav_element = self.elements.get(prev_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=prev_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n\n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = view.root_elements[current_index - 1]\n                    # Navigate to previous root element\n                    nav_element = self.elements.get(prev_id)\n                    if not nav_element or not nav_element.original_id:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        return True\n                        \n                    # Create a structured position\n                    element_type = None\n                    section_index = 0\n                    segment_index = 0\n                    \n                    if nav_element.element_type == \"section\":\n                        element_type = StructuredElementType.SECTION\n                        # Find section index\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            if section.id == nav_element.original_id:\n                                section_index = i\n                                break\n                    elif nav_element.element_type == \"segment\":\n                        element_type = StructuredElementType.SEGMENT\n                        # Find section and segment indices\n                        for i, section in enumerate(self.document.current_revision.sections):\n                            for j, segment in enumerate(section.segments):\n                                if segment.id == nav_element.original_id:\n                                    section_index = i\n                                    segment_index = j\n                                    break\n                            if element_type == StructuredElementType.SEGMENT and segment_index > 0:\n                                break\n                    \n                    if element_type:\n                        position = StructuredPosition(\n                            view_id=view_id,\n                            element_id=nav_element.original_id,\n                            element_type=element_type,\n                            section_index=section_index,\n                            segment_index=segment_index,\n                            offset_in_segment=0\n                        )\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, \n                            element_id=prev_id,\n                            position=position\n                        )\n                    else:\n                        self.current_position = NavigationPosition(\n                            view_id=view_id, element_id=prev_id\n                        )\n                        \n                    return True\n            except ValueError:\n                pass\n\n        return False\n\n    def navigate_children(self) -> List[NavigationElement]:\n        \"\"\"Get the children of the current element.\"\"\"\n        if not self.current_position:\n            return []\n\n        current_element_id = self.current_position.element_id\n\n        # Get element\n        element = self.elements.get(current_element_id)\n        if not element:\n            return []\n\n        # Get children\n        children = []\n        for child_id in element.children:\n            if child_id in self.elements:\n                children.append(self.elements[child_id])\n\n        return children\n\n    def find_elements_by_tag(self, tag_id: str) -> List[NavigationElement]:\n        \"\"\"Find all elements with a specific tag.\"\"\"\n        if tag_id not in self.tags:\n            return []\n\n        # Find elements with this tag\n        tagged_elements = []\n        for element_id, element in self.elements.items():\n            if tag_id in element.tags:\n                tagged_elements.append(element)\n\n        return tagged_elements\n\n    def find_elements_by_name(self, name: str) -> List[NavigationElement]:\n        \"\"\"Find elements by name (case-insensitive partial match).\"\"\"\n        name = name.lower()\n\n        matching_elements = []\n        for element_id, element in self.elements.items():\n            if name in element.name.lower():\n                matching_elements.append(element)\n\n        return matching_elements\n\n    def get_path_to_element(self, element_id: str) -> List[str]:\n        \"\"\"Get the path from root to the specified element.\"\"\"\n        if element_id not in self.elements:\n            return []\n\n        # Find view that contains this element\n        view_id = None\n        for view_id, view in self.views.items():\n            if element_id in view.root_elements:\n                break\n\n            # Check if it's a descendant of any root element\n            for root_id in view.root_elements:\n                if self._is_descendant(root_id, element_id):\n                    view_id = view_id\n                    break\n\n            if view_id:\n                break\n\n        if not view_id:\n            return []\n\n        # Find path\n        path = []\n        current_id = element_id\n\n        while current_id:\n            path.insert(0, current_id)\n\n            # Find parent\n            parent_id = None\n            for element_id, element in self.elements.items():\n                if current_id in element.children:\n                    parent_id = element_id\n                    break\n\n            # If no parent, check if it's a root element\n            if not parent_id:\n                # If it's a root element, we've reached the top\n                if current_id in self.views[view_id].root_elements:\n                    break\n\n            current_id = parent_id\n\n        return path\n\n    def _is_descendant(self, ancestor_id: str, descendant_id: str) -> bool:\n        \"\"\"Check if descendant_id is a descendant of ancestor_id.\"\"\"\n        if ancestor_id not in self.elements:\n            return False\n\n        # Check direct children\n        ancestor = self.elements[ancestor_id]\n        if descendant_id in ancestor.children:\n            return True\n\n        # Check descendants recursively\n        for child_id in ancestor.children:\n            if self._is_descendant(child_id, descendant_id):\n                return True\n\n        return False",
                "class NavigationViewType(str, Enum):\n    \"\"\"Types of navigation views.\"\"\"\n\n    LINEAR = \"linear\"  # Traditional linear document view\n    CHAPTER = \"chapter\"  # Organized by chapters/sections\n    CHARACTER = \"character\"  # Organized by character appearances\n    PLOT = \"plot\"  # Organized by plot elements/arcs\n    TIMELINE = \"timeline\"  # Organized by timeline/chronology\n    CUSTOM = \"custom\"",
                "class RevisionManager:\n    \"\"\"Revision management system.\"\"\"\n\n    def __init__(self, document: Document):\n        \"\"\"Initialize the revision manager with the given document.\"\"\"\n        self.document = document\n        self.diffs: Dict[str, RevisionDiff] = {}\n\n    def create_revision(\n        self, name: str, metadata: Optional[Dict[str, Any]] = None\n    ) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        return self.document.create_revision(name=name, metadata=metadata)\n\n    def compare_revisions(\n        self, old_revision_name: str, new_revision_name: str\n    ) -> Optional[RevisionDiff]:\n        \"\"\"Compare two revisions and generate a diff.\"\"\"\n        old_revision = self.document.get_revision(old_revision_name)\n        new_revision = self.document.get_revision(new_revision_name)\n\n        if not old_revision or not new_revision:\n            return None\n\n        # Create a unique ID for this diff\n        diff_id = f\"{old_revision_name}_{new_revision_name}\"\n\n        # Check if we already have this diff\n        if diff_id in self.diffs:\n            return self.diffs[diff_id]\n\n        # Create a new diff\n        revision_diff = RevisionDiff(\n            old_revision_id=old_revision.id,\n            new_revision_id=new_revision.id,\n            old_revision_name=old_revision_name,\n            new_revision_name=new_revision_name,\n        )\n\n        # Compare sections\n        old_sections_by_id = {section.id: section for section in old_revision.sections}\n        new_sections_by_id = {section.id: section for section in new_revision.sections}\n\n        # Find common section IDs\n        common_section_ids = set(old_sections_by_id.keys()) & set(\n            new_sections_by_id.keys()\n        )\n\n        # Find added and removed sections\n        added_section_ids = set(new_sections_by_id.keys()) - set(\n            old_sections_by_id.keys()\n        )\n        removed_section_ids = set(old_sections_by_id.keys()) - set(\n            new_sections_by_id.keys()\n        )\n\n        # Process added sections\n        for section_id in added_section_ids:\n            section = new_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.INSERT,\n                section_id=section_id,\n                new_title=section.title,\n            )\n\n            # Add all segments as inserted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment.id,\n                    new_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            revision_diff.section_diffs.append(section_diff)\n\n        # Process removed sections\n        for section_id in removed_section_ids:\n            section = old_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.DELETE,\n                section_id=section_id,\n                old_title=section.title,\n            )\n\n            # Add all segments as deleted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment.id,\n                    old_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            revision_diff.section_diffs.append(section_diff)\n\n        # Process common sections\n        for section_id in common_section_ids:\n            old_section = old_sections_by_id[section_id]\n            new_section = new_sections_by_id[section_id]\n\n            # Check if title changed\n            if old_section.title != new_section.title:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.REPLACE,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title,\n                )\n            else:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.EQUAL,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title,\n                )\n\n            # Compare segments within the section\n            old_segments_by_id = {\n                segment.id: segment for segment in old_section.segments\n            }\n            new_segments_by_id = {\n                segment.id: segment for segment in new_section.segments\n            }\n\n            # Find common segment IDs\n            common_segment_ids = set(old_segments_by_id.keys()) & set(\n                new_segments_by_id.keys()\n            )\n\n            # Find added and removed segments\n            added_segment_ids = set(new_segments_by_id.keys()) - set(\n                old_segments_by_id.keys()\n            )\n            removed_segment_ids = set(old_segments_by_id.keys()) - set(\n                new_segments_by_id.keys()\n            )\n\n            # Process added segments\n            for segment_id in added_segment_ids:\n                segment = new_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment_id,\n                    new_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            # Process removed segments\n            for segment_id in removed_segment_ids:\n                segment = old_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment_id,\n                    old_content=segment.content,\n                    position=segment.position,\n                )\n                section_diff.segment_diffs.append(segment_diff)\n\n            # Process common segments\n            for segment_id in common_segment_ids:\n                old_segment = old_segments_by_id[segment_id]\n                new_segment = new_segments_by_id[segment_id]\n\n                # Check if content changed\n                if old_segment.content != new_segment.content:\n                    segment_diff = SegmentDiff(\n                        diff_type=DiffType.REPLACE,\n                        segment_id=segment_id,\n                        old_content=old_segment.content,\n                        new_content=new_segment.content,\n                        position=new_segment.position,\n                    )\n                    section_diff.segment_diffs.append(segment_diff)\n\n            # Only add section diff if there are changes\n            if section_diff.diff_type != DiffType.EQUAL or section_diff.segment_diffs:\n                revision_diff.section_diffs.append(section_diff)\n\n        # Store and return the diff\n        self.diffs[diff_id] = revision_diff\n        return revision_diff\n\n    def get_html_diff(self, old_content: str, new_content: str) -> str:\n        \"\"\"Generate an HTML diff of two texts.\"\"\"\n        differ = difflib.HtmlDiff()\n        return differ.make_file(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            context=True,\n        )\n\n    def get_unified_diff(\n        self, old_content: str, new_content: str, context_lines: int = 3\n    ) -> str:\n        \"\"\"Generate a unified diff of two texts.\"\"\"\n        return \"\\n\".join(\n            difflib.unified_diff(\n                old_content.splitlines(),\n                new_content.splitlines(),\n                \"Old Version\",\n                \"New Version\",\n                n=context_lines,\n            )\n        )\n\n    def get_detailed_segment_diff(\n        self, old_content: str, new_content: str\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate a detailed word-level diff of two segment contents.\"\"\"\n        # Split into words\n        old_words = old_content.split()\n        new_words = new_content.split()\n\n        # Get opcodes\n        matcher = difflib.SequenceMatcher(None, old_words, new_words)\n        opcodes = matcher.get_opcodes()\n\n        result = []\n        for tag, i1, i2, j1, j2 in opcodes:\n            if tag == \"equal\":\n                result.append({\"type\": \"equal\", \"content\": \" \".join(old_words[i1:i2])})\n            elif tag == \"replace\":\n                result.append({\"type\": \"delete\", \"content\": \" \".join(old_words[i1:i2])})\n                result.append({\"type\": \"insert\", \"content\": \" \".join(new_words[j1:j2])})\n            elif tag == \"delete\":\n                result.append({\"type\": \"delete\", \"content\": \" \".join(old_words[i1:i2])})\n            elif tag == \"insert\":\n                result.append({\"type\": \"insert\", \"content\": \" \".join(new_words[j1:j2])})\n\n        return result\n\n    def apply_diff(\n        self, diff: RevisionDiff, target_revision_name: Optional[str] = None\n    ) -> Optional[Revision]:\n        \"\"\"Apply a diff to a revision to create a new revision.\"\"\"\n        # If target_revision_name is not provided, create a new revision\n        if not target_revision_name:\n            target_revision_name = (\n                f\"Merged_{diff.old_revision_name}_{diff.new_revision_name}\"\n            )\n\n        # Create a new revision based on the old revision\n        old_revision = self.document.get_revision(diff.old_revision_name)\n        if not old_revision:\n            return None\n\n        # Create a deep copy of the old revision\n        target_revision = self.create_revision(\n            name=target_revision_name,\n            metadata={\"merged_from\": [diff.old_revision_name, diff.new_revision_name]},\n        )\n\n        # Apply section changes\n        for section_diff in diff.section_diffs:\n            section_id = section_diff.section_id\n\n            if section_diff.diff_type == DiffType.INSERT:\n                # Add new section\n                new_section = Section(\n                    id=section_id, title=section_diff.new_title or \"\", segments=[]\n                )\n\n                # Add segment diffs\n                for segment_diff in section_diff.segment_diffs:\n                    if segment_diff.diff_type == DiffType.INSERT:\n                        segment = TextSegment(\n                            id=segment_diff.segment_id or \"\",\n                            content=segment_diff.new_content or \"\",\n                            position=segment_diff.position or 0,\n                        )\n                        new_section.segments.append(segment)\n\n                # Add to target revision\n                target_revision.sections.append(new_section)\n\n            elif section_diff.diff_type == DiffType.DELETE:\n                # Remove section\n                for i, section in enumerate(target_revision.sections):\n                    if section.id == section_id:\n                        target_revision.sections.pop(i)\n                        break\n\n            elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                # Update section title if it changed\n                for section in target_revision.sections:\n                    if section.id == section_id:\n                        if section_diff.new_title:\n                            section.title = section_diff.new_title\n\n                        # Process segment changes\n                        for segment_diff in section_diff.segment_diffs:\n                            segment_id = segment_diff.segment_id\n\n                            if segment_diff.diff_type == DiffType.INSERT:\n                                # Add new segment\n                                segment = TextSegment(\n                                    id=segment_id or \"\",\n                                    content=segment_diff.new_content or \"\",\n                                    position=segment_diff.position or 0,\n                                )\n\n                                # Insert at the right position\n                                if segment_diff.position is not None:\n                                    if segment_diff.position < len(section.segments):\n                                        section.segments.insert(\n                                            segment_diff.position, segment\n                                        )\n                                    else:\n                                        section.segments.append(segment)\n                                else:\n                                    section.segments.append(segment)\n\n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n\n                            elif segment_diff.diff_type == DiffType.DELETE:\n                                # Remove segment\n                                for i, segment in enumerate(section.segments):\n                                    if segment.id == segment_id:\n                                        section.segments.pop(i)\n                                        break\n\n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n\n                            elif segment_diff.diff_type == DiffType.REPLACE:\n                                # Update segment content\n                                for segment in section.segments:\n                                    if (\n                                        segment.id == segment_id\n                                        and segment_diff.new_content\n                                    ):\n                                        segment.content = segment_diff.new_content\n                                        break\n\n                        break\n\n        # Update document's current revision\n        self.document.current_revision = target_revision\n\n        return target_revision\n\n    def merge_revisions(\n        self,\n        base_revision_name: str,\n        revision_names: List[str],\n        merge_strategy: Dict[str, str] = None,\n    ) -> Optional[Revision]:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        # Get base revision\n        base_revision = self.document.get_revision(base_revision_name)\n        if not base_revision:\n            return None\n\n        # Create a new revision based on the base revision\n        merged_revision_name = f\"Merged_{base_revision_name}_{'_'.join(revision_names)}\"\n        merged_revision = self.create_revision(\n            name=merged_revision_name,\n            metadata={\"merged_from\": [base_revision_name] + revision_names},\n        )\n\n        # Default merge strategy: last writer wins\n        if not merge_strategy:\n            merge_strategy = {}\n\n        # Apply diffs from each revision\n        for revision_name in revision_names:\n            # Compare with base revision\n            diff = self.compare_revisions(base_revision_name, revision_name)\n            if not diff:\n                continue\n\n            # Apply changes\n            for section_diff in diff.section_diffs:\n                section_id = section_diff.section_id\n\n                # Check merge strategy for this section\n                section_strategy = merge_strategy.get(section_id, \"last_writer_wins\")\n\n                if section_strategy == \"ignore\":\n                    # Skip this section\n                    continue\n\n                if section_diff.diff_type == DiffType.INSERT:\n                    # Add new section\n                    new_section = Section(\n                        id=section_id, title=section_diff.new_title or \"\", segments=[]\n                    )\n\n                    # Add segment diffs\n                    for segment_diff in section_diff.segment_diffs:\n                        if segment_diff.diff_type == DiffType.INSERT:\n                            segment = TextSegment(\n                                id=segment_diff.segment_id or \"\",\n                                content=segment_diff.new_content or \"\",\n                                position=segment_diff.position or 0,\n                            )\n                            new_section.segments.append(segment)\n\n                    # Add to merged revision\n                    merged_revision.sections.append(new_section)\n\n                elif section_diff.diff_type == DiffType.DELETE:\n                    if section_strategy == \"last_writer_wins\":\n                        # Remove section\n                        for i, section in enumerate(merged_revision.sections):\n                            if section.id == section_id:\n                                merged_revision.sections.pop(i)\n                                break\n\n                elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                    # Update section title if it changed\n                    for section in merged_revision.sections:\n                        if section.id == section_id:\n                            if (\n                                section_diff.new_title\n                                and section_strategy == \"last_writer_wins\"\n                            ):\n                                section.title = section_diff.new_title\n\n                            # Process segment changes\n                            for segment_diff in section_diff.segment_diffs:\n                                segment_id = segment_diff.segment_id\n\n                                # Check merge strategy for this segment\n                                segment_strategy = merge_strategy.get(\n                                    f\"{section_id}_{segment_id}\", section_strategy\n                                )\n\n                                if segment_strategy == \"ignore\":\n                                    # Skip this segment\n                                    continue\n\n                                if segment_diff.diff_type == DiffType.INSERT:\n                                    # Add new segment\n                                    segment = TextSegment(\n                                        id=segment_id or \"\",\n                                        content=segment_diff.new_content or \"\",\n                                        position=segment_diff.position or 0,\n                                    )\n\n                                    # Insert at the right position\n                                    if segment_diff.position is not None:\n                                        if segment_diff.position < len(\n                                            section.segments\n                                        ):\n                                            section.segments.insert(\n                                                segment_diff.position, segment\n                                            )\n                                        else:\n                                            section.segments.append(segment)\n                                    else:\n                                        section.segments.append(segment)\n\n                                    # Update positions\n                                    for i, seg in enumerate(section.segments):\n                                        seg.position = i\n\n                                elif segment_diff.diff_type == DiffType.DELETE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Remove segment\n                                        for i, segment in enumerate(section.segments):\n                                            if segment.id == segment_id:\n                                                section.segments.pop(i)\n                                                break\n\n                                        # Update positions\n                                        for i, seg in enumerate(section.segments):\n                                            seg.position = i\n\n                                elif segment_diff.diff_type == DiffType.REPLACE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Update segment content\n                                        for segment in section.segments:\n                                            if (\n                                                segment.id == segment_id\n                                                and segment_diff.new_content\n                                            ):\n                                                segment.content = (\n                                                    segment_diff.new_content\n                                                )\n                                                break\n\n                            break\n\n        # Update document's current revision\n        self.document.current_revision = merged_revision\n\n        return merged_revision\n\n    def export_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Export the revision history as a structured dictionary.\"\"\"\n        history = {\n            \"current_revision\": self.document.current_revision.name,\n            \"revisions\": {},\n        }\n\n        for name, revision in self.document.revisions.items():\n            history[\"revisions\"][name] = {\n                \"id\": revision.id,\n                \"timestamp\": revision.timestamp.isoformat(),\n                \"metadata\": revision.metadata,\n                \"section_count\": len(revision.sections),\n                \"word_count\": sum(\n                    sum(segment.get_word_count() for segment in section.segments)\n                    for section in revision.sections\n                ),\n            }\n\n        return history\n\n    def get_revision_by_timestamp(self, timestamp: datetime) -> Optional[Revision]:\n        \"\"\"Get the revision closest to the specified timestamp.\"\"\"\n        closest_revision = None\n        min_diff = None\n\n        for revision in self.document.revisions.values():\n            diff = abs((revision.timestamp - timestamp).total_seconds())\n\n            if min_diff is None or diff < min_diff:\n                min_diff = diff\n                closest_revision = revision\n\n        return closest_revision"
            ]
        }
    },
    "unified/text_editor/core/cursor.py": {
        "logprobs": -601.8891151841244,
        "metrics": {
            "loc": 163,
            "sloc": 67,
            "lloc": 83,
            "comments": 8,
            "multi": 51,
            "blank": 33,
            "cyclomatic": 21,
            "internal_imports": [
                "class LineColumnPosition(Position):\n    \"\"\"\n    Position within text content based on line and column coordinates.\n\n    This is a simple positioning system used for line-based text content,\n    where positions are identified by a line number and column number.\n    \"\"\"\n\n    line: int = 0\n    column: int = 0\n    content: Optional[Any] = None  # Field for content reference\n\n    model_config = {\n        \"frozen\": False,  # Allow mutation for compatibility with tests\n        \"arbitrary_types_allowed\": True,\n    }\n\n    def move_up(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position up by the specified number of lines.\n\n        Args:\n            count: Number of lines to move up (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        return LineColumnPosition(line=max(0, self.line - count), column=self.column)\n\n    def move_down(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position down by the specified number of lines.\n\n        Args:\n            count: Number of lines to move down (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line count here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line + count, column=self.column)\n\n    def move_left(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position left by the specified number of columns.\n\n        Args:\n            count: Number of columns to move left (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        if self.column >= count:\n            # We can move left within the current line\n            return LineColumnPosition(line=self.line, column=self.column - count)\n        else:\n            # Note: Moving across line boundaries requires context from the content object\n            # We'll leave it to the caller to handle this special case\n            return LineColumnPosition(line=self.line, column=0)\n\n    def move_right(self, count: int = 1) -> LineColumnPosition:\n        \"\"\"\n        Move the position right by the specified number of columns.\n\n        Args:\n            count: Number of columns to move right (default: 1)\n\n        Returns:\n            A new LineColumnPosition at the new location\n        \"\"\"\n        # Note: We can't validate against line length here because we don't have content object\n        # The caller should validate the position using is_valid after moving\n        return LineColumnPosition(line=self.line, column=self.column + count)\n\n    def is_valid(self, content: TextContent) -> bool:\n        \"\"\"\n        Check if this position is valid within the given content.\n\n        Args:\n            content: The text content to validate against\n\n        Returns:\n            True if the position is valid, False otherwise\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= self.line < content.get_line_count()):\n            return False\n\n        # Check if column is valid\n        line_length = len(content.get_line(self.line))\n        return 0 <= self.column <= line_length\n\n    def compare(self, other: Position) -> int:\n        \"\"\"\n        Compare this position with another position.\n\n        Args:\n            other: Another position to compare with\n\n        Returns:\n            -1 if this position is before other,\n             0 if positions are equal,\n             1 if this position is after other\n        \"\"\"\n        if not isinstance(other, LineColumnPosition):\n            raise TypeError(\"Can only compare with another LineColumnPosition\")\n\n        if self.line < other.line:\n            return -1\n        elif self.line > other.line:\n            return 1\n        else:\n            # Same line, compare columns\n            if self.column < other.column:\n                return -1\n            elif self.column > other.column:\n                return 1\n            else:\n                return 0\n\n    def to_tuple(self) -> Tuple[int, int]:\n        \"\"\"\n        Convert the position to a tuple of (line, column).\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)",
                "class TextBuffer(LineBasedTextContent):\n    \"\"\"\n    A text buffer that stores the content of a file as a list of lines.\n\n    This is the core data structure for the text editor, handling storage,\n    insertion, deletion, and retrieval of text.\n    \"\"\"\n\n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new text buffer with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__(content=content)\n\n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the buffer as a string.\n\n        Returns:\n            The content of the buffer as a string with lines joined by newlines\n        \"\"\"\n        return self.get_text()\n\n    def insert_text(self, line: int, column: int, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position in the buffer.\n\n        Args:\n            line: Line number where text should be inserted (0-indexed)\n            column: Column number where text should be inserted (0-indexed)\n            text: The text to insert\n\n        Raises:\n            IndexError: If the line or column is out of range\n        \"\"\"\n        position = LineColumnPosition(line=line, column=column)\n\n        try:\n            self.insert(position, text)\n        except ValueError as e:\n            # Convert ValueError to IndexError for backward compatibility\n            raise IndexError(str(e))\n\n    def delete_text(\n        self, start_line: int, start_col: int, end_line: int, end_col: int\n    ) -> str:\n        \"\"\"\n        Delete text between the specified positions and return the deleted text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n\n        Returns:\n            The deleted text\n\n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        try:\n            return self.delete(start_position, end_position)\n        except ValueError as e:\n            # Convert ValueError to appropriate error for backward compatibility\n            if \"End position must come after start position\" in str(e):\n                raise ValueError(str(e))\n            else:\n                raise IndexError(str(e))\n\n    def replace_text(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n    ) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n\n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        try:\n            return self.replace(start_position, end_position, new_text)\n        except ValueError as e:\n            # Convert ValueError to appropriate error for backward compatibility\n            if \"End position must come after start position\" in str(e):\n                raise ValueError(str(e))\n            else:\n                raise IndexError(str(e))\n\n    def clear(self) -> None:\n        \"\"\"Clear the buffer, removing all content.\"\"\"\n        super().clear()"
            ]
        }
    },
    "unified/tests/writer/conftest.py": {
        "logprobs": -609.3333910845431,
        "metrics": {
            "loc": 61,
            "sloc": 40,
            "lloc": 39,
            "comments": 6,
            "multi": 0,
            "blank": 12,
            "cyclomatic": 3,
            "internal_imports": []
        }
    },
    "unified/text_editor/customization/__init__.py": {
        "logprobs": -194.28524935263698,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/common/__init__.py": {
        "logprobs": -315.1840924209566,
        "metrics": {
            "loc": 8,
            "sloc": 1,
            "lloc": 2,
            "comments": 0,
            "multi": 5,
            "blank": 2,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "unified/text_editor/customization/playground.py": {
        "logprobs": -1230.9263672331308,
        "metrics": {
            "loc": 314,
            "sloc": 124,
            "lloc": 110,
            "comments": 18,
            "multi": 105,
            "blank": 64,
            "cyclomatic": 30,
            "internal_imports": [
                "class CustomizationManager(BaseModel):\n    \"\"\"\n    Manages the customization system for the text editor.\n\n    This class provides a safe environment for experimenting with\n    different editor behaviors and algorithms.\n    \"\"\"\n\n    components: Dict[str, CustomizableComponent] = Field(default_factory=dict)\n    history: CustomizationHistory = Field(default_factory=CustomizationHistory)\n    environment: Optional[IsolatedEnvironment] = None\n    active_experiment: Optional[ExperimentResults] = None\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the customization manager with default components.\"\"\"\n        super().__init__(**kwargs)\n\n        # Initialize with default components\n        for component in DEFAULT_COMPONENTS:\n            self.components[component.id] = component\n\n        # Initialize the isolated environment\n        self.environment = IsolatedEnvironment()\n\n    def get_component(self, component_id: str) -> Optional[CustomizableComponent]:\n        \"\"\"\n        Get a specific customizable component.\n\n        Args:\n            component_id: ID of the component to retrieve\n\n        Returns:\n            The CustomizableComponent object, or None if not found\n        \"\"\"\n        return self.components.get(component_id)\n\n    def get_all_components(self) -> List[CustomizableComponent]:\n        \"\"\"\n        Get all customizable components.\n\n        Returns:\n            List of all CustomizableComponent objects\n        \"\"\"\n        return list(self.components.values())\n\n    def get_components_by_category(\n        self, category: CustomizationCategory\n    ) -> List[CustomizableComponent]:\n        \"\"\"\n        Get components filtered by category.\n\n        Args:\n            category: Category to filter by\n\n        Returns:\n            List of CustomizableComponent objects in the specified category\n        \"\"\"\n        return [c for c in self.components.values() if c.category == category]\n\n    def get_components_by_difficulty(\n        self, difficulty: CustomizationDifficulty\n    ) -> List[CustomizableComponent]:\n        \"\"\"\n        Get components filtered by difficulty.\n\n        Args:\n            difficulty: Difficulty level to filter by\n\n        Returns:\n            List of CustomizableComponent objects at the specified difficulty\n        \"\"\"\n        return [c for c in self.components.values() if c.difficulty == difficulty]\n\n    def start_experiment(\n        self, component_id: str, implementation_id: str\n    ) -> Optional[ExperimentResults]:\n        \"\"\"\n        Start a customization experiment.\n\n        Args:\n            component_id: ID of the component to customize\n            implementation_id: ID of the implementation to test\n\n        Returns:\n            The ExperimentResults object, or None if the experiment couldn't be started\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return None\n\n        # Check if the implementation exists\n        if (\n            implementation_id != \"default\"\n            and implementation_id not in component.alternative_implementations\n        ):\n            return None\n\n        # Create a new experiment\n        experiment = ExperimentResults(\n            component_id=component_id,\n            implementation_id=implementation_id,\n            start_time=time.time(),\n        )\n\n        # Save the current state\n        snapshot_id = f\"{component_id}_{int(experiment.start_time)}\"\n        self.history.save_snapshot(\n            snapshot_id,\n            {\n                \"component\": component.dict(),\n                \"current_implementation\": component.current_implementation,\n            },\n        )\n\n        # Set the active experiment\n        self.active_experiment = experiment\n\n        # Update the component's current implementation\n        component.current_implementation = implementation_id\n\n        return experiment\n\n    def complete_experiment(\n        self, success: bool, metrics: Dict[str, float] = None, error: str = None\n    ) -> None:\n        \"\"\"\n        Complete the active experiment with results.\n\n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        if not self.active_experiment:\n            return\n\n        # Complete the experiment\n        self.active_experiment.complete(success, metrics, error)\n\n        # Add to history\n        self.history.add_experiment(self.active_experiment)\n\n        # If the experiment failed, revert the component\n        if not success:\n            component_id = self.active_experiment.component_id\n            component = self.get_component(component_id)\n            if component:\n                component.current_implementation = \"default\"\n\n        # Clear the active experiment\n        self.active_experiment = None\n\n    def cancel_experiment(self) -> None:\n        \"\"\"Cancel the active experiment and revert changes.\"\"\"\n        if not self.active_experiment:\n            return\n\n        component_id = self.active_experiment.component_id\n        component = self.get_component(component_id)\n\n        if component:\n            # Revert to the default implementation\n            component.current_implementation = \"default\"\n\n        # Mark as failed and add to history\n        self.active_experiment.complete(False, error=\"Experiment cancelled\")\n        self.history.add_experiment(self.active_experiment)\n\n        # Clear the active experiment\n        self.active_experiment = None\n\n    def run_code_in_sandbox(self, code: str) -> Tuple[bool, Any, str]:\n        \"\"\"\n        Run code in a sandboxed environment to test a customization.\n\n        Args:\n            code: The Python code to execute\n\n        Returns:\n            Tuple of (success, result, error_message)\n        \"\"\"\n        # Execute the code without resetting the environment\n        # This allows us to preserve any variables added to the environment\n        return self.environment.execute(code)\n\n    def get_experiment_history(\n        self, component_id: Optional[str] = None\n    ) -> List[ExperimentResults]:\n        \"\"\"\n        Get the history of experiments.\n\n        Args:\n            component_id: ID of the component to filter by (optional)\n\n        Returns:\n            List of ExperimentResults objects\n        \"\"\"\n        if component_id:\n            return self.history.get_experiments_for_component(component_id)\n        else:\n            return self.history.experiments\n\n    def get_implementation_details(\n        self, component_id: str, implementation_id: str\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get details about a specific implementation.\n\n        Args:\n            component_id: ID of the component\n            implementation_id: ID of the implementation\n\n        Returns:\n            Dictionary with implementation details\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return {}\n\n        if implementation_id == \"default\":\n            description = f\"Default implementation: {component.default_implementation}\"\n            impl_id = component.default_implementation\n        else:\n            description = component.alternative_implementations.get(\n                implementation_id, \"\"\n            )\n            impl_id = implementation_id\n\n        # Get performance history for this implementation\n        experiments = self.history.get_experiments_for_component(component_id)\n        matching_experiments = [\n            e for e in experiments if e.implementation_id == impl_id\n        ]\n\n        # Calculate success rate\n        total = len(matching_experiments)\n        successful = len([e for e in matching_experiments if e.success])\n        success_rate = successful / total if total > 0 else 0\n\n        # Get average performance metrics\n        avg_metrics = {}\n        if successful > 0:\n            for experiment in [e for e in matching_experiments if e.success]:\n                for metric, value in experiment.performance_metrics.items():\n                    if metric not in avg_metrics:\n                        avg_metrics[metric] = []\n                    avg_metrics[metric].append(value)\n\n            avg_metrics = {\n                metric: sum(values) / len(values)\n                for metric, values in avg_metrics.items()\n            }\n\n        return {\n            \"description\": description,\n            \"total_experiments\": total,\n            \"successful_experiments\": successful,\n            \"success_rate\": success_rate,\n            \"average_metrics\": avg_metrics,\n            \"is_current\": component.current_implementation == impl_id,\n        }\n\n    def apply_component_customization(\n        self, component_id: str, implementation_id: str, code: str\n    ) -> Tuple[bool, str]:\n        \"\"\"\n        Apply a customization to a component.\n\n        Args:\n            component_id: ID of the component to customize\n            implementation_id: ID of the implementation to apply\n            code: Custom implementation code\n\n        Returns:\n            Tuple of (success, error_message)\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return False, f\"Component {component_id} not found\"\n\n        # Check if the implementation exists\n        if (\n            implementation_id != \"default\"\n            and implementation_id not in component.alternative_implementations\n        ):\n            return False, f\"Implementation {implementation_id} not found\"\n\n        # Start an experiment\n        experiment = self.start_experiment(component_id, implementation_id)\n        if not experiment:\n            return False, \"Failed to start experiment\"\n\n        # Run the code in the sandbox\n        success, result, error = self.run_code_in_sandbox(code)\n\n        # Get performance metrics\n        metrics = {}\n        if success and isinstance(result, dict):\n            metrics = result.get(\"metrics\", {})\n\n        # Complete the experiment\n        self.complete_experiment(success, metrics, error)\n\n        if not success:\n            return False, error\n\n        return True, \"\"\n\n    def revert_to_default(self, component_id: str) -> bool:\n        \"\"\"\n        Revert a component to its default implementation.\n\n        Args:\n            component_id: ID of the component to revert\n\n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return False\n\n        # Cancel any active experiment for this component\n        if (\n            self.active_experiment\n            and self.active_experiment.component_id == component_id\n        ):\n            self.cancel_experiment()\n\n        # Set to default implementation\n        component.current_implementation = \"default\"\n\n        return True\n\n    def get_current_implementation(self, component_id: str) -> Optional[str]:\n        \"\"\"\n        Get the current implementation for a component.\n\n        Args:\n            component_id: ID of the component to check\n\n        Returns:\n            The implementation ID, or None if the component doesn't exist\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return None\n\n        return component.current_implementation",
                "class CustomizableComponent(BaseModel):\n    \"\"\"\n    Represents a component of the editor that can be customized.\n    \"\"\"\n\n    id: str\n    name: str\n    description: str\n    category: CustomizationCategory\n    difficulty: CustomizationDifficulty\n    default_implementation: str\n    alternative_implementations: Dict[str, str] = Field(default_factory=dict)\n    impact_description: str\n    implementation_hints: List[str] = Field(default_factory=list)\n    current_implementation: str = \"default\"",
                "class CustomizationCategory(Enum):\n    \"\"\"Categories of editor components that can be customized.\"\"\"\n\n    TEXT_STORAGE = \"text_storage\"\n    CURSOR_BEHAVIOR = \"cursor_behavior\"\n    EDITING_OPERATIONS = \"editing_operations\"\n    SEARCH_ALGORITHM = \"search_algorithm\"\n    UNDO_REDO = \"undo_redo\"\n    FILE_HANDLING = \"file_handling\"\n    PERFORMANCE = \"performance\"",
                "class CustomizationDifficulty(Enum):\n    \"\"\"Difficulty levels for customization tasks.\"\"\"\n\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ExperimentResults(BaseModel):\n    \"\"\"\n    Represents the results of a customization experiment.\n    \"\"\"\n\n    component_id: str\n    implementation_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    success: bool = False\n    error_message: Optional[str] = None\n    performance_metrics: Dict[str, float] = Field(default_factory=dict)\n    notes: str = \"\"\n\n    def complete(\n        self, success: bool, metrics: Dict[str, float] = None, error: str = None\n    ) -> None:\n        \"\"\"\n        Mark the experiment as complete with results.\n\n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        self.end_time = time.time()\n        self.success = success\n\n        if metrics:\n            self.performance_metrics = metrics\n\n        if error:\n            self.error_message = error\n\n    def duration(self) -> float:\n        \"\"\"\n        Get the duration of the experiment in seconds.\n\n        Returns:\n            Duration of the experiment, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            return -1\n\n        return self.end_time - self.start_time",
                "class Editor(BaseModel):\n    \"\"\"\n    Core editor class that combines buffer and cursor functionality.\n\n    This class provides the basic editing operations that form the foundation\n    of the text editor, including text insertion, deletion, navigation, and\n    other fundamental operations.\n    \"\"\"\n\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n    cursor: Cursor = None\n    file_manager: FileManager = Field(default_factory=FileManager)\n    history: History = Field(default_factory=History)\n\n    def __init__(self, content: str = \"\", file_path: Optional[str] = None):\n        \"\"\"\n        Initialize a new editor with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n            file_path: Path to the file being edited (optional)\n        \"\"\"\n        super().__init__()\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.file_manager = FileManager(current_path=file_path)\n        self.history = History()\n\n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the editor.\n\n        Returns:\n            The content as a string\n        \"\"\"\n        return self.buffer.get_text()\n\n    def get_cursor_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n\n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return self.cursor.get_position()\n\n    def insert_text(self, text: str) -> None:\n        \"\"\"\n        Insert text at the current cursor position.\n\n        Args:\n            text: The text to insert\n        \"\"\"\n        line, column = self.cursor.get_position()\n        position = LineColumnPosition(line=line, column=column)\n\n        # Insert the text using the buffer\n        self.buffer.insert(position, text)\n\n        # Record the operation in history\n        self.history.record_insert(line, column, text)\n\n        # Update cursor position\n        if \"\\n\" in text:\n            # Move to the end of the inserted text\n            lines = text.split(\"\\n\")\n            new_line = line + len(lines) - 1\n            new_column = len(lines[-1])\n            self.cursor.move_to(new_line, new_column)\n        else:\n            # Move cursor forward by the length of the inserted text\n            self.cursor.move_to(line, column + len(text))\n\n    def delete_char_before_cursor(self) -> None:\n        \"\"\"Delete the character before the cursor (backspace operation).\"\"\"\n        line, column = self.cursor.get_position()\n\n        if column > 0:\n            # Delete character in the current line\n            start_position = LineColumnPosition(line=line, column=column - 1)\n            end_position = LineColumnPosition(line=line, column=column)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, column - 1, line, column, deleted_text)\n            self.cursor.move_to(line, column - 1)\n        elif line > 0:\n            # At the beginning of a line, join with the previous line\n            prev_line_length = len(self.buffer.get_line(line - 1))\n\n            start_position = LineColumnPosition(line=line - 1, column=prev_line_length)\n            end_position = LineColumnPosition(line=line, column=0)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(\n                line - 1, prev_line_length, line, 0, deleted_text\n            )\n            self.cursor.move_to(line - 1, prev_line_length)\n\n    def delete_char_after_cursor(self) -> None:\n        \"\"\"Delete the character after the cursor (delete key operation).\"\"\"\n        line, column = self.cursor.get_position()\n        line_length = len(self.buffer.get_line(line))\n\n        if column < line_length:\n            # Delete character in the current line\n            start_position = LineColumnPosition(line=line, column=column)\n            end_position = LineColumnPosition(line=line, column=column + 1)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, column, line, column + 1, deleted_text)\n        elif line < self.buffer.get_line_count() - 1:\n            # At the end of a line, join with the next line\n            start_position = LineColumnPosition(line=line, column=line_length)\n            end_position = LineColumnPosition(line=line + 1, column=0)\n\n            deleted_text = self.buffer.delete(start_position, end_position)\n            self.history.record_delete(line, line_length, line + 1, 0, deleted_text)\n\n    def new_line(self) -> None:\n        \"\"\"Insert a new line at the cursor position.\"\"\"\n        self.insert_text(\"\\n\")\n\n    def move_cursor(self, direction: str, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor in the specified direction.\n\n        Args:\n            direction: One of \"up\", \"down\", \"left\", \"right\",\n                      \"line_start\", \"line_end\", \"buffer_start\", \"buffer_end\"\n            count: Number of units to move (for up, down, left, right)\n        \"\"\"\n        if direction == \"up\":\n            self.cursor.move_up(count)\n        elif direction == \"down\":\n            self.cursor.move_down(count)\n        elif direction == \"left\":\n            self.cursor.move_left(count)\n        elif direction == \"right\":\n            self.cursor.move_right(count)\n        elif direction == \"line_start\":\n            self.cursor.move_to_line_start()\n        elif direction == \"line_end\":\n            self.cursor.move_to_line_end()\n        elif direction == \"buffer_start\":\n            self.cursor.move_to_buffer_start()\n        elif direction == \"buffer_end\":\n            self.cursor.move_to_buffer_end()\n        else:\n            raise ValueError(f\"Unknown direction: {direction}\")\n\n    def set_cursor_position(self, line: int, column: int) -> None:\n        \"\"\"\n        Set the cursor to the specified position.\n\n        Args:\n            line: Line number (0-indexed)\n            column: Column number (0-indexed)\n        \"\"\"\n        self.cursor.move_to(line, column)\n\n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n\n        Args:\n            line_number: The line number to retrieve (0-indexed)\n\n        Returns:\n            The requested line as a string\n        \"\"\"\n        return self.buffer.get_line(line_number)\n\n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n\n        Returns:\n            The number of lines\n        \"\"\"\n        return self.buffer.get_line_count()\n\n    def replace_text(\n        self,\n        start_line: int,\n        start_col: int,\n        end_line: int,\n        end_col: int,\n        new_text: str,\n    ) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n        \"\"\"\n        start_position = LineColumnPosition(line=start_line, column=start_col)\n        end_position = LineColumnPosition(line=end_line, column=end_col)\n\n        deleted_text = self.buffer.replace(start_position, end_position, new_text)\n        self.history.record_replace(\n            start_line, start_col, end_line, end_col, new_text, deleted_text\n        )\n        return deleted_text\n\n    def clear(self) -> None:\n        \"\"\"Clear the editor, removing all content.\"\"\"\n        content = self.buffer.get_text()\n        if content:\n            line_count = self.buffer.get_line_count()\n            last_line_length = len(self.buffer.get_line(line_count - 1))\n\n            start_position = LineColumnPosition(line=0, column=0)\n            end_position = LineColumnPosition(\n                line=line_count - 1, column=last_line_length\n            )\n\n            self.history.record_delete(0, 0, line_count - 1, last_line_length, content)\n\n        self.buffer.clear()\n        self.cursor.move_to_buffer_start()\n\n    def undo(self) -> bool:\n        \"\"\"\n        Undo the last operation.\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        return self.history.undo(self.buffer)\n\n    def redo(self) -> bool:\n        \"\"\"\n        Redo the last undone operation.\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        return self.history.redo(self.buffer)\n\n    def load_file(self, file_path: str) -> None:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n        \"\"\"\n        content = self.file_manager.load_file(file_path)\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.history.clear()\n\n    def save_file(self, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            file_path: Path to save to (if None, uses current path)\n        \"\"\"\n        content = self.buffer.get_text()\n        self.file_manager.save_file(content, file_path)\n\n    def get_current_file_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.file_manager.get_current_path()\n\n    def is_file_modified(self) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Returns:\n            True if the file has been modified, False otherwise\n        \"\"\"\n        return self.file_manager.is_file_modified()"
            ]
        }
    },
    "unified/setup.py": {
        "logprobs": -282.279631155443,
        "metrics": {
            "loc": 9,
            "sloc": 8,
            "lloc": 2,
            "comments": 0,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "total_loc": 13732,
    "total_sloc": 7916,
    "total_lloc": 5792,
    "total_comments": 862,
    "total_multi": 2315,
    "total_blank": 2506,
    "total_cyclomatic": 1822,
    "total_internal_imports": 270
}