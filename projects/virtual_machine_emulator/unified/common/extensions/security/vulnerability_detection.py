"""
Vulnerability detection for the virtual machine emulator.

This module provides tools for detecting and simulating vulnerabilities:
- Buffer overflow detection
- Format string vulnerabilities
- Code injection detection
- ROP gadget identification
"""

from enum import Enum, auto
from typing import Dict, List, Optional, Set, Tuple, Union, Any, Callable, BinaryIO
import re

from common.core.memory import MemorySystem, MemorySegment, MemoryPermission, MemoryAccessType


class VulnerabilityType(Enum):
    """Types of vulnerabilities that can be detected or simulated."""
    BUFFER_OVERFLOW = auto()    # Buffer overflow
    FORMAT_STRING = auto()      # Format string vulnerability
    CODE_INJECTION = auto()     # Code injection
    USE_AFTER_FREE = auto()     # Use after free
    NULL_DEREFERENCE = auto()   # Null pointer dereference
    INTEGER_OVERFLOW = auto()   # Integer overflow
    DOUBLE_FREE = auto()        # Double free
    ROP = auto()                # Return-oriented programming


class VulnerabilityDetector:
    """Detects security vulnerabilities in the VM."""
    
    def __init__(self, memory: MemorySystem):
        """
        Initialize the vulnerability detector.
        
        Args:
            memory: Memory system to monitor
        """
        self.memory = memory
        self.memory_access_records: Dict[int, List[Dict[str, Any]]] = {}
        self.pattern_matches: Dict[str, List[Tuple[int, Any]]] = {}
        self.buffer_boundaries: Dict[int, int] = {}  # Maps address to size
        self.free_regions: Set[Tuple[int, int]] = set()  # (start, size) of freed regions
    
    def register_buffer(self, address: int, size: int) -> None:
        """
        Register a buffer for overflow monitoring.
        
        Args:
            address: Start address of buffer
            size: Size of buffer in bytes
        """
        self.buffer_boundaries[address] = size
    
    def register_memory_access(
        self,
        address: int,
        access_type: str,
        size: int,
        instruction_pointer: int,
        context: Dict[str, Any] = None
    ) -> None:
        """
        Register a memory access event for vulnerability detection.
        
        Args:
            address: Memory address
            access_type: Type of access (read, write, execute)
            size: Size of access in bytes
            instruction_pointer: Current instruction pointer
            context: Additional context
        """
        if address not in self.memory_access_records:
            self.memory_access_records[address] = []
        
        record = {
            "access_type": access_type,
            "size": size,
            "instruction_pointer": instruction_pointer,
            "context": context or {}
        }
        
        self.memory_access_records[address].append(record)
    
    def register_memory_free(self, address: int, size: int) -> None:
        """
        Register a memory free operation.
        
        Args:
            address: Start address of freed region
            size: Size of freed region in bytes
        """
        self.free_regions.add((address, size))
    
    def detect_buffer_overflows(self) -> List[Dict[str, Any]]:
        """
        Detect potential buffer overflows.
        
        Returns:
            List of detected buffer overflows
        """
        overflows = []
        
        for buffer_addr, buffer_size in self.buffer_boundaries.items():
            # Check writes to buffer boundaries
            buffer_end = buffer_addr + buffer_size
            
            for addr, accesses in self.memory_access_records.items():
                for access in accesses:
                    if access["access_type"] != "write":
                        continue
                    
                    # Check if access extends beyond buffer boundary
                    access_end = addr + access["size"]
                    
                    if addr >= buffer_addr and addr < buffer_end and access_end > buffer_end:
                        overflow = {
                            "type": VulnerabilityType.BUFFER_OVERFLOW.name,
                            "buffer_address": buffer_addr,
                            "buffer_size": buffer_size,
                            "access_address": addr,
                            "access_size": access["size"],
                            "overflow_size": access_end - buffer_end,
                            "instruction_pointer": access["instruction_pointer"],
                            "context": access["context"]
                        }
                        
                        overflows.append(overflow)
        
        return overflows
    
    def detect_format_string_vulnerabilities(self) -> List[Dict[str, Any]]:
        """
        Detect potential format string vulnerabilities.
        
        Returns:
            List of detected format string vulnerabilities
        """
        format_string_vulns = []
        
        # Pattern for common format string sequences
        format_patterns = [
            r"%[0-9]*[diouxXeEfFgGaA]",  # Number formats
            r"%[0-9]*s",                 # String format
            r"%[0-9]*p",                 # Pointer format
            r"%[0-9]*n",                 # Dangerous write format
            r"%[0-9]*%"                  # Format symbol
        ]
        
        # Check write accesses for format strings
        for addr, accesses in self.memory_access_records.items():
            for access in accesses:
                if access["access_type"] != "write":
                    continue
                
                # Try to read the written data at this address
                try:
                    # Skip if we can't read the memory
                    if not hasattr(self.memory, "read_bytes"):
                        continue
                    
                    # Read a reasonable chunk of memory
                    size = min(access["size"], 64)
                    data = self.memory.read_bytes(addr, size, {})
                    
                    # Convert to string and check for format patterns
                    if isinstance(data, (bytes, bytearray)):
                        try:
                            data_str = data.decode('utf-8', errors='ignore')
                            
                            # Count format specifiers
                            format_count = 0
                            for pattern in format_patterns:
                                matches = re.findall(pattern, data_str)
                                format_count += len(matches)
                            
                            # If we have multiple format specifiers, flag as potential vulnerability
                            if format_count >= 2:
                                vulnerability = {
                                    "type": VulnerabilityType.FORMAT_STRING.name,
                                    "address": addr,
                                    "format_specifiers": format_count,
                                    "data": data_str[:32] + "..." if len(data_str) > 32 else data_str,
                                    "instruction_pointer": access["instruction_pointer"],
                                    "context": access["context"]
                                }
                                
                                format_string_vulns.append(vulnerability)
                        except:
                            pass  # Ignore decoding errors
                except:
                    pass  # Ignore memory read errors
        
        return format_string_vulns
    
    def detect_code_injection(self) -> List[Dict[str, Any]]:
        """
        Detect potential code injection vulnerabilities.
        
        Returns:
            List of detected code injection vulnerabilities
        """
        injections = []
        
        # Common shellcode patterns to detect
        shellcode_patterns = [
            # NOP sled (x86)
            bytes([0x90] * 10),
            # Common shellcode instructions
            bytes([0x31, 0xc0, 0x50, 0x68]),  # xor eax,eax; push eax; push ...
            bytes([0xeb, 0x0e, 0x5e, 0x31]),  # jmp short; pop esi; xor ...
        ]
        
        # Check for memory regions that were written to and then executed
        executed_addrs = set()
        written_addrs = {}
        
        for addr, accesses in self.memory_access_records.items():
            for access in accesses:
                if access["access_type"] == "execute":
                    executed_addrs.add(addr)
                elif access["access_type"] == "write":
                    written_addrs[addr] = access
        
        # Look for addresses that were written to and then executed
        for addr in executed_addrs:
            if addr in written_addrs:
                # Check if this memory had a non-executable permission initially
                segment = self.memory.find_segment(addr)
                if segment and not segment.permission & MemoryPermission.EXECUTE:
                    inject = {
                        "type": VulnerabilityType.CODE_INJECTION.name,
                        "address": addr,
                        "segment_name": segment.name if hasattr(segment, 'name') else "unknown",
                        "segment_permission": segment.permission.name if hasattr(segment.permission, 'name') else str(segment.permission),
                        "instruction_pointer": written_addrs[addr]["instruction_pointer"],
                        "context": written_addrs[addr]["context"]
                    }
                    
                    # Check for shellcode patterns
                    try:
                        if hasattr(self.memory, "read_bytes"):
                            data = self.memory.read_bytes(addr, 16, {})
                            
                            for pattern in shellcode_patterns:
                                if pattern in data:
                                    inject["shellcode_pattern"] = "detected"
                                    inject["confidence"] = "high"
                                    break
                    except:
                        pass
                    
                    injections.append(inject)
        
        return injections
    
    def detect_use_after_free(self) -> List[Dict[str, Any]]:
        """
        Detect use-after-free vulnerabilities.
        
        Returns:
            List of detected use-after-free vulnerabilities
        """
        uaf_vulns = []
        
        for addr, accesses in self.memory_access_records.items():
            # Check if this address falls within a freed region
            for free_addr, free_size in self.free_regions:
                if addr >= free_addr and addr < free_addr + free_size:
                    # Found accesses to freed memory
                    for access in accesses:
                        # Only consider accesses after the free
                        if "free_time" in access["context"] and access["context"].get("access_time", float('inf')) > access["context"]["free_time"]:
                            vuln = {
                                "type": VulnerabilityType.USE_AFTER_FREE.name,
                                "address": addr,
                                "freed_region_start": free_addr,
                                "freed_region_size": free_size,
                                "access_type": access["access_type"],
                                "instruction_pointer": access["instruction_pointer"],
                                "context": access["context"]
                            }
                            
                            uaf_vulns.append(vuln)
        
        return uaf_vulns
    
    def find_rop_gadgets(self) -> List[Dict[str, Any]]:
        """
        Find potential ROP gadgets in executable memory.
        
        Returns:
            List of identified ROP gadgets
        """
        gadgets = []
        
        # Common ROP gadget patterns (x86)
        # Each pattern is (byte sequence, description)
        gadget_patterns = [
            (bytes([0xc3]), "ret"),
            (bytes([0x5d, 0xc3]), "pop ebp; ret"),
            (bytes([0x58, 0xc3]), "pop eax; ret"),
            (bytes([0x59, 0xc3]), "pop ecx; ret"),
            (bytes([0x5a, 0xc3]), "pop edx; ret"),
            (bytes([0x5b, 0xc3]), "pop ebx; ret"),
            (bytes([0x5e, 0xc3]), "pop esi; ret"),
            (bytes([0x5f, 0xc3]), "pop edi; ret"),
            (bytes([0x83, 0xc4, 0x04, 0xc3]), "add esp, 4; ret"),
            (bytes([0xff, 0xe4]), "jmp esp"),
        ]
        
        # Scan executable segments for gadget patterns
        for segment in self.memory.segments:
            if not segment.permission & MemoryPermission.EXECUTE:
                continue
            
            try:
                # Read segment data
                for i in range(0, segment.size - 8):
                    addr = segment.base_address + i
                    
                    if hasattr(self.memory, "read_bytes"):
                        # Read enough bytes for the largest pattern
                        data = self.memory.read_bytes(addr, 8, {"operation": "gadget_search"})
                        
                        # Check against gadget patterns
                        for pattern, description in gadget_patterns:
                            pattern_len = len(pattern)
                            
                            if data[:pattern_len] == pattern:
                                gadget = {
                                    "type": "rop_gadget",
                                    "address": addr,
                                    "description": description,
                                    "pattern": pattern.hex(),
                                    "segment_name": segment.name if hasattr(segment, 'name') else "unknown",
                                }
                                
                                gadgets.append(gadget)
            except:
                # Skip segments that can't be read
                pass
        
        return gadgets
    
    def detect_vulnerabilities(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Perform comprehensive vulnerability detection.
        
        Returns:
            Dictionary mapping vulnerability types to detected instances
        """
        results = {
            VulnerabilityType.BUFFER_OVERFLOW.name: self.detect_buffer_overflows(),
            VulnerabilityType.FORMAT_STRING.name: self.detect_format_string_vulnerabilities(),
            VulnerabilityType.CODE_INJECTION.name: self.detect_code_injection(),
            VulnerabilityType.USE_AFTER_FREE.name: self.detect_use_after_free(),
            VulnerabilityType.ROP.name: self.find_rop_gadgets()
        }
        
        return results


class VulnerabilityInjector:
    """Injects controlled vulnerabilities for security testing."""
    
    def __init__(self, memory: MemorySystem):
        """
        Initialize the vulnerability injector.
        
        Args:
            memory: Memory system to inject vulnerabilities into
        """
        self.memory = memory
    
    def inject_buffer_overflow(
        self,
        buffer_address: int,
        overflow_size: int,
        payload: Optional[bytes] = None
    ) -> Dict[str, Any]:
        """
        Inject a buffer overflow vulnerability.
        
        Args:
            buffer_address: Address of the buffer to overflow
            overflow_size: Size of the overflow in bytes
            payload: Optional payload bytes (defaults to 'A's)
            
        Returns:
            Result of the injection operation
        """
        result = {"success": False, "error": None}
        
        try:
            # Find the segment containing this address
            segment = self.memory.find_segment(buffer_address)
            if segment is None:
                result["error"] = f"Address 0x{buffer_address:08x} not in any memory segment"
                return result
            
            # Create default payload if none provided
            data = payload or bytes([0x41] * overflow_size)  # 'A's
            
            # Write the overflow data
            self.memory.write_bytes(
                buffer_address,
                data,
                {"vulnerability": "buffer_overflow"}
            )
            
            result["success"] = True
            result["buffer_address"] = buffer_address
            result["overflow_size"] = overflow_size
            result["payload_size"] = len(data)
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def inject_code_execution(
        self,
        address: int,
        size: int,
        payload: Optional[bytes] = None
    ) -> Dict[str, Any]:
        """
        Inject executable code into memory.
        
        Args:
            address: Address to inject code
            size: Size of the code in bytes
            payload: Optional shellcode payload
            
        Returns:
            Result of the injection operation
        """
        result = {"success": False, "error": None}
        
        try:
            # Find the segment containing this address
            segment = self.memory.find_segment(address)
            if segment is None:
                result["error"] = f"Address 0x{address:08x} not in any memory segment"
                return result
            
            # Default shellcode if none provided (NOP sled + ret)
            shellcode = payload or bytes([0x90] * (size - 1) + [0xc3])
            
            # Save original permission
            original_permission = segment.permission
            
            # Temporarily make segment writable if it isn't
            if not segment.permission & MemoryPermission.WRITE:
                segment.permission |= MemoryPermission.WRITE
            
            # Write the shellcode
            self.memory.write_bytes(
                address,
                shellcode,
                {"vulnerability": "code_execution"}
            )
            
            # Ensure segment is executable
            if not segment.permission & MemoryPermission.EXECUTE:
                segment.permission |= MemoryPermission.EXECUTE
            
            result["success"] = True
            result["address"] = address
            result["size"] = size
            result["original_permission"] = original_permission.name if hasattr(original_permission, 'name') else str(original_permission)
            result["new_permission"] = segment.permission.name if hasattr(segment.permission, 'name') else str(segment.permission)
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def inject_format_string(
        self,
        address: int,
        format_string: Optional[bytes] = None
    ) -> Dict[str, Any]:
        """
        Inject a format string vulnerability.
        
        Args:
            address: Address to inject the format string
            format_string: Optional format string payload
            
        Returns:
            Result of the injection operation
        """
        result = {"success": False, "error": None}
        
        try:
            # Find the segment containing this address
            segment = self.memory.find_segment(address)
            if segment is None:
                result["error"] = f"Address 0x{address:08x} not in any memory segment"
                return result
            
            # Default format string if none provided
            payload = format_string or b"%x%x%x%n"
            
            # Write the format string
            self.memory.write_bytes(
                address,
                payload,
                {"vulnerability": "format_string"}
            )
            
            result["success"] = True
            result["address"] = address
            result["format_string"] = payload.decode('utf-8', errors='ignore')
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def simulate_use_after_free(
        self,
        address: int,
        size: int,
        payload: Optional[bytes] = None
    ) -> Dict[str, Any]:
        """
        Simulate a use-after-free vulnerability.
        
        Args:
            address: Address of the freed memory
            size: Size of the freed region
            payload: Optional payload to write after free
            
        Returns:
            Result of the injection operation
        """
        result = {"success": False, "error": None}
        
        try:
            # Find the segment containing this address
            segment = self.memory.find_segment(address)
            if segment is None:
                result["error"] = f"Address 0x{address:08x} not in any memory segment"
                return result
            
            # Default pattern for freed memory
            data = payload or bytes([0xDD] * size)
            
            # Write the freed memory pattern
            self.memory.write_bytes(
                address,
                data,
                {"vulnerability": "use_after_free", "is_freed": True}
            )
            
            result["success"] = True
            result["address"] = address
            result["size"] = size
        except Exception as e:
            result["error"] = str(e)
        
        return result
    
    def inject_vulnerability(
        self,
        vuln_type: VulnerabilityType,
        address: int,
        size: int,
        payload: Optional[bytes] = None
    ) -> Dict[str, Any]:
        """
        Inject a vulnerability of the specified type.
        
        Args:
            vuln_type: Type of vulnerability to inject
            address: Address for the vulnerability
            size: Size parameter for the vulnerability
            payload: Optional payload data
            
        Returns:
            Result of the injection operation
        """
        if vuln_type == VulnerabilityType.BUFFER_OVERFLOW:
            return self.inject_buffer_overflow(address, size, payload)
        elif vuln_type == VulnerabilityType.CODE_INJECTION:
            return self.inject_code_execution(address, size, payload)
        elif vuln_type == VulnerabilityType.FORMAT_STRING:
            return self.inject_format_string(address, payload)
        elif vuln_type == VulnerabilityType.USE_AFTER_FREE:
            return self.simulate_use_after_free(address, size, payload)
        else:
            return {
                "success": False,
                "error": f"Unsupported vulnerability type: {vuln_type.name}"
            }