{"created": 1747356104.3425665, "duration": 0.8406898975372314, "exitcode": 1, "root": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified", "environment": {}, "summary": {"passed": 185, "failed": 25, "total": 210, "collected": 210}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "tests", "type": "Package"}]}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_initialization", "type": "Function", "lineno": 10}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_memory_access_recording", "type": "Function", "lineno": 21}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_sync_operation_recording", "type": "Function", "lineno": 65}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_read_write_race_detection", "type": "Function", "lineno": 106}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_write_write_race_detection", "type": "Function", "lineno": 138}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_lock_protection", "type": "Function", "lineno": 170}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_happens_before_relation", "type": "Function", "lineno": 226}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_atomicity_violation", "type": "Function", "lineno": 277}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_deadlock_detection", "type": "Function", "lineno": 316}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_order_violation", "type": "Function", "lineno": 338}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_filtering_results", "type": "Function", "lineno": 380}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_statistics", "type": "Function", "lineno": 443}]}, {"nodeid": "tests/parallel_researcher/core/test_race.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_initialization", "type": "Function", "lineno": 13}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_memory_system", "type": "Function", "lineno": 30}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_program_loading", "type": "Function", "lineno": 60}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_thread_creation", "type": "Function", "lineno": 91}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_execution_single_thread", "type": "Function", "lineno": 122}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_execution_multiple_threads", "type": "Function", "lineno": 172}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_parallel_execution", "type": "Function", "lineno": 281}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_deterministic_execution", "type": "Function", "lineno": 358}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_step_execution", "type": "Function", "lineno": 443}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_context_switching", "type": "Function", "lineno": 529}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_thread_synchronization", "type": "Function", "lineno": 655}]}, {"nodeid": "tests/parallel_researcher/core/test_vm.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/core", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core/test_race.py", "type": "Module"}, {"nodeid": "tests/parallel_researcher/core/test_vm.py", "type": "Module"}]}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_initialization", "type": "Function", "lineno": 16}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_read_miss", "type": "Function", "lineno": 32}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_read_hit", "type": "Function", "lineno": 44}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_write", "type": "Function", "lineno": 60}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_eviction", "type": "Function", "lineno": 79}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_statistics", "type": "Function", "lineno": 117}]}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_initialization", "type": "Function", "lineno": 147}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_exclusive", "type": "Function", "lineno": 159}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_shared", "type": "Function", "lineno": 183}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_modified", "type": "Function", "lineno": 201}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_exclusive", "type": "Function", "lineno": 219}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_shared", "type": "Function", "lineno": 240}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_miss", "type": "Function", "lineno": 261}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_read_handling", "type": "Function", "lineno": 270}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_read_exclusive_handling", "type": "Function", "lineno": 318}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_invalidate_handling", "type": "Function", "lineno": 366}]}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_initialization", "type": "Function", "lineno": 430}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_read_shared_request", "type": "Function", "lineno": 439}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_read_exclusive_request", "type": "Function", "lineno": 472}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_write_back_request", "type": "Function", "lineno": 500}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_invalidate_request", "type": "Function", "lineno": 528}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_coherence_protocol", "type": "Function", "lineno": 559}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_statistics", "type": "Function", "lineno": 639}]}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_initialization", "type": "Function", "lineno": 716}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_cache_creation", "type": "Function", "lineno": 726}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_memory_read", "type": "Function", "lineno": 740}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_memory_write", "type": "Function", "lineno": 780}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_flush_caches", "type": "Function", "lineno": 830}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_access_history", "type": "Function", "lineno": 858}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_statistics", "type": "Function", "lineno": 894}]}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache", "type": "Class"}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache", "type": "Class"}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus", "type": "Class"}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/memory", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/memory/test_coherence.py", "type": "Module"}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_initialization", "type": "Function", "lineno": 22}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_execute", "type": "Function", "lineno": 41}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_instruction_generation", "type": "Function", "lineno": 68}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_map_reduce_simple", "type": "Function", "lineno": 109}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_initialization", "type": "Function", "lineno": 146}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_execute", "type": "Function", "lineno": 158}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_instruction_generation", "type": "Function", "lineno": 183}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm::test_initialization", "type": "Function", "lineno": 214}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm::test_execute", "type": "Function", "lineno": 224}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer::test_initialization", "type": "Function", "lineno": 249}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer::test_execute", "type": "Function", "lineno": 259}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline::test_initialization", "type": "Function", "lineno": 320}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline::test_execute", "type": "Function", "lineno": 337}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_map_reduce", "type": "Function", "lineno": 369}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_producer_consumer", "type": "Function", "lineno": 385}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_task_farm", "type": "Function", "lineno": 399}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_divide_conquer", "type": "Function", "lineno": 411}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_pipeline", "type": "Function", "lineno": 423}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_invalid_pattern", "type": "Function", "lineno": 440}]}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce", "type": "Class"}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer", "type": "Class"}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm", "type": "Class"}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer", "type": "Class"}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline", "type": "Class"}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/patterns", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py", "type": "Module"}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_initialization", "type": "Function", "lineno": 43}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_select_thread", "type": "Function", "lineno": 51}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_should_preempt", "type": "Function", "lineno": 71}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_schedule", "type": "Function", "lineno": 88}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_statistics", "type": "Function", "lineno": 120}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_initialization", "type": "Function", "lineno": 149}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_select_thread_by_priority", "type": "Function", "lineno": 160}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_preemptive_scheduling", "type": "Function", "lineno": 185}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_non_preemptive_scheduling", "type": "Function", "lineno": 210}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_initialization", "type": "Function", "lineno": 233}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_select_thread_by_runtime", "type": "Function", "lineno": 243}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_update_estimated_runtime", "type": "Function", "lineno": 272}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_initialization", "type": "Function", "lineno": 288}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_assignment", "type": "Function", "lineno": 299}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_demotion", "type": "Function", "lineno": 318}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_priority", "type": "Function", "lineno": 343}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_priority_boost", "type": "Function", "lineno": 370}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_initialization", "type": "Function", "lineno": 397}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_thread_affinity", "type": "Function", "lineno": 407}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_select_thread_with_affinity", "type": "Function", "lineno": 426}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_no_affinity_selection", "type": "Function", "lineno": 460}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_initialization", "type": "Function", "lineno": 483}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_deterministic_selection", "type": "Function", "lineno": 495}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_record_decisions", "type": "Function", "lineno": 527}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_execution_trace", "type": "Function", "lineno": 552}]}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler", "type": "Class"}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler", "type": "Class"}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler", "type": "Class"}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler", "type": "Class"}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler", "type": "Class"}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/scheduling", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py", "type": "Module"}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_initialization", "type": "Function", "lineno": 13}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_acquire", "type": "Function", "lineno": 24}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_release", "type": "Function", "lineno": 43}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_contention_and_queuing", "type": "Function", "lineno": 60}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_statistics", "type": "Function", "lineno": 90}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_initialization", "type": "Function", "lineno": 117}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_reentrant_acquisition", "type": "Function", "lineno": 126}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_reentrant_release", "type": "Function", "lineno": 148}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_statistics", "type": "Function", "lineno": 180}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_initialization", "type": "Function", "lineno": 200}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_read_acquisition", "type": "Function", "lineno": 209}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_write_acquisition", "type": "Function", "lineno": 228}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_read_release", "type": "Function", "lineno": 244}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_write_release", "type": "Function", "lineno": 265}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_writer_priority", "type": "Function", "lineno": 285}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_statistics", "type": "Function", "lineno": 305}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_initialization", "type": "Function", "lineno": 330}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_acquisition", "type": "Function", "lineno": 339}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_release", "type": "Function", "lineno": 356}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_statistics", "type": "Function", "lineno": 382}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_initialization", "type": "Function", "lineno": 406}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_arrival", "type": "Function", "lineno": 416}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_reset", "type": "Function", "lineno": 436}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_statistics", "type": "Function", "lineno": 455}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_initialization", "type": "Function", "lineno": 476}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_count_down", "type": "Function", "lineno": 485}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_await", "type": "Function", "lineno": 501}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_statistics", "type": "Function", "lineno": 527}]}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock", "type": "Class"}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock", "type": "Class"}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock", "type": "Class"}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore", "type": "Class"}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier", "type": "Class"}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch", "type": "Class"}]}, {"nodeid": "tests/parallel_researcher/synchronization", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py", "type": "Module"}]}, {"nodeid": "tests/parallel_researcher", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher/core", "type": "Package"}, {"nodeid": "tests/parallel_researcher/memory", "type": "Package"}, {"nodeid": "tests/parallel_researcher/patterns", "type": "Package"}, {"nodeid": "tests/parallel_researcher/scheduling", "type": "Package"}, {"nodeid": "tests/parallel_researcher/synchronization", "type": "Package"}]}, {"nodeid": "tests/security_researcher/test_attacks.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_attacks.py::test_attack_base_class", "type": "Function", "lineno": 18}, {"nodeid": "tests/security_researcher/test_attacks.py::test_attack_result", "type": "Function", "lineno": 49}, {"nodeid": "tests/security_researcher/test_attacks.py::test_buffer_overflow_attack", "type": "Function", "lineno": 151}, {"nodeid": "tests/security_researcher/test_attacks.py::test_buffer_overflow_canary_protection", "type": "Function", "lineno": 179}, {"nodeid": "tests/security_researcher/test_attacks.py::test_shellcode_creation", "type": "Function", "lineno": 218}, {"nodeid": "tests/security_researcher/test_attacks.py::test_rop_attack", "type": "Function", "lineno": 400}, {"nodeid": "tests/security_researcher/test_attacks.py::test_format_string_vulnerability", "type": "Function", "lineno": 474}, {"nodeid": "tests/security_researcher/test_attacks.py::test_code_injection_attack", "type": "Function", "lineno": 552}, {"nodeid": "tests/security_researcher/test_attacks.py::test_code_injection_with_dep", "type": "Function", "lineno": 635}, {"nodeid": "tests/security_researcher/test_attacks.py::test_privilege_escalation_attack", "type": "Function", "lineno": 757}, {"nodeid": "tests/security_researcher/test_attacks.py::test_find_rop_gadgets", "type": "Function", "lineno": 880}]}, {"nodeid": "tests/security_researcher/test_cpu.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_init", "type": "Function", "lineno": 16}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_get_set", "type": "Function", "lineno": 32}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_dump", "type": "Function", "lineno": 56}, {"nodeid": "tests/security_researcher/test_cpu.py::test_control_flow_record", "type": "Function", "lineno": 75}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_init", "type": "Function", "lineno": 102}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_reset", "type": "Function", "lineno": 116}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_fetch", "type": "Function", "lineno": 183}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_fetch_word", "type": "Function", "lineno": 210}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_push_pop", "type": "Function", "lineno": 226}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_arithmetic_instructions", "type": "Function", "lineno": 252}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_memory_instructions", "type": "Function", "lineno": 258}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_control_flow_instructions", "type": "Function", "lineno": 264}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_privilege_violation", "type": "Function", "lineno": 270}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_run_simple_program", "type": "Function", "lineno": 276}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_control_flow_integrity", "type": "Function", "lineno": 282}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_syscall_handler", "type": "Function", "lineno": 288}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_record_control_flow", "type": "Function", "lineno": 294}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_get_performance_stats", "type": "Function", "lineno": 300}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_invalid_instruction", "type": "Function", "lineno": 306}]}, {"nodeid": "tests/security_researcher/test_emulator.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_emulator.py::test_vm_creation", "type": "Function", "lineno": 12}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_custom_protection", "type": "Function", "lineno": 35}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_load_program", "type": "Function", "lineno": 56}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_load_data", "type": "Function", "lineno": 78}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_run_simple_program", "type": "Function", "lineno": 96}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_memory_protection", "type": "Function", "lineno": 102}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_dep_protection", "type": "Function", "lineno": 108}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_get_memory_snapshot", "type": "Function", "lineno": 114}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_inject_vulnerability", "type": "Function", "lineno": 120}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_reset", "type": "Function", "lineno": 128}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_control_flow_visualization", "type": "Function", "lineno": 153}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_forensic_logs", "type": "Function", "lineno": 173}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_memory_protection_strategies", "type": "Function", "lineno": 202}]}, {"nodeid": "tests/security_researcher/test_integration.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_integration.py::test_complete_buffer_overflow_exploit_lifecycle", "type": "Function", "lineno": 24}, {"nodeid": "tests/security_researcher/test_integration.py::test_protection_effectiveness_against_exploits", "type": "Function", "lineno": 48}, {"nodeid": "tests/security_researcher/test_integration.py::test_multiple_attack_vectors", "type": "Function", "lineno": 105}, {"nodeid": "tests/security_researcher/test_integration.py::test_forensic_logging_and_analysis", "type": "Function", "lineno": 164}, {"nodeid": "tests/security_researcher/test_integration.py::test_performance_benchmarks", "type": "Function", "lineno": 184}, {"nodeid": "tests/security_researcher/test_integration.py::test_memory_corruption_detection", "type": "Function", "lineno": 202}]}, {"nodeid": "tests/security_researcher/test_memory.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_creation", "type": "Function", "lineno": 13}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_contains_address", "type": "Function", "lineno": 30}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_relative_address", "type": "Function", "lineno": 41}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_permission_check", "type": "Function", "lineno": 56}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_canaries", "type": "Function", "lineno": 73}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_creation", "type": "Function", "lineno": 98}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_add_segment", "type": "Function", "lineno": 119}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_find_segment", "type": "Function", "lineno": 135}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_byte", "type": "Function", "lineno": 151}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_word", "type": "Function", "lineno": 169}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_protection", "type": "Function", "lineno": 184}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_execute_protection", "type": "Function", "lineno": 202}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_stack_canaries", "type": "Function", "lineno": 225}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_protection_applies_settings", "type": "Function", "lineno": 249}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_get_protection_stats", "type": "Function", "lineno": 269}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_aslr", "type": "Function", "lineno": 287}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_protection_log", "type": "Function", "lineno": 309}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_shadow_memory", "type": "Function", "lineno": 332}]}, {"nodeid": "tests/security_researcher/test_scenarios.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_scenarios.py::test_security_scenario_base_class", "type": "Function", "lineno": 17}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_buffer_overflow_scenario", "type": "Function", "lineno": 46}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_return_oriented_programming_scenario", "type": "Function", "lineno": 90}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_format_string_scenario", "type": "Function", "lineno": 134}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_privilege_escalation_scenario", "type": "Function", "lineno": 187}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_get_all_scenarios", "type": "Function", "lineno": 232}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_compare_protection_strategies", "type": "Function", "lineno": 247}]}, {"nodeid": "tests/security_researcher/test_simple.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_simple.py::test_import", "type": "Function", "lineno": 4}]}, {"nodeid": "tests/security_researcher/test_visualization.py", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_initialization", "type": "Function", "lineno": 17}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_text_output", "type": "Function", "lineno": 26}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_graph", "type": "Function", "lineno": 42}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_compare", "type": "Function", "lineno": 70}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_initialization", "type": "Function", "lineno": 179}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_pattern", "type": "Function", "lineno": 187}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_abnormal_patterns", "type": "Function", "lineno": 213}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_initialization", "type": "Function", "lineno": 290}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_execution_analysis", "type": "Function", "lineno": 298}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_comparison", "type": "Function", "lineno": 362}]}, {"nodeid": "tests/security_researcher", "outcome": "passed", "result": [{"nodeid": "tests/security_researcher/test_attacks.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_cpu.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_emulator.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_integration.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_memory.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_scenarios.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_simple.py", "type": "Module"}, {"nodeid": "tests/security_researcher/test_visualization.py", "type": "Module"}]}, {"nodeid": "tests", "outcome": "passed", "result": [{"nodeid": "tests/parallel_researcher", "type": "Package"}, {"nodeid": "tests/security_researcher", "type": "Package"}]}], "tests": [{"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_initialization", "lineno": 10, "outcome": "passed", "keywords": ["test_initialization", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0005832428578287363, "outcome": "passed"}, "call": {"duration": 0.00017802300862967968, "outcome": "passed"}, "teardown": {"duration": 0.00012719817459583282, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_memory_access_recording", "lineno": 21, "outcome": "passed", "keywords": ["test_memory_access_recording", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011516804806888103, "outcome": "passed"}, "call": {"duration": 0.00014726491644978523, "outcome": "passed"}, "teardown": {"duration": 0.00011267606168985367, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_sync_operation_recording", "lineno": 65, "outcome": "passed", "keywords": ["test_sync_operation_recording", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011042994447052479, "outcome": "passed"}, "call": {"duration": 0.0001333090476691723, "outcome": "passed"}, "teardown": {"duration": 0.00010856799781322479, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_read_write_race_detection", "lineno": 106, "outcome": "passed", "keywords": ["test_read_write_race_detection", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011388305574655533, "outcome": "passed"}, "call": {"duration": 0.0001413119025528431, "outcome": "passed"}, "teardown": {"duration": 0.00010528392158448696, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_write_write_race_detection", "lineno": 138, "outcome": "passed", "keywords": ["test_write_write_race_detection", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010605994611978531, "outcome": "passed"}, "call": {"duration": 0.00014112098142504692, "outcome": "passed"}, "teardown": {"duration": 0.00010332884266972542, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_lock_protection", "lineno": 170, "outcome": "passed", "keywords": ["test_lock_protection", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001210628543049097, "outcome": "passed"}, "call": {"duration": 0.0001481771469116211, "outcome": "passed"}, "teardown": {"duration": 0.00010790908709168434, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_happens_before_relation", "lineno": 226, "outcome": "passed", "keywords": ["test_happens_before_relation", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001084241084754467, "outcome": "passed"}, "call": {"duration": 0.00014055101200938225, "outcome": "passed"}, "teardown": {"duration": 0.00011497293598949909, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_atomicity_violation", "lineno": 277, "outcome": "passed", "keywords": ["test_atomicity_violation", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001070310827344656, "outcome": "passed"}, "call": {"duration": 0.00014018500223755836, "outcome": "passed"}, "teardown": {"duration": 0.0001076508779078722, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_deadlock_detection", "lineno": 316, "outcome": "passed", "keywords": ["test_deadlock_detection", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010696914978325367, "outcome": "passed"}, "call": {"duration": 0.00013835402205586433, "outcome": "passed"}, "teardown": {"duration": 0.00010295095853507519, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_order_violation", "lineno": 338, "outcome": "passed", "keywords": ["test_order_violation", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011984794400632381, "outcome": "passed"}, "call": {"duration": 0.0001591341570019722, "outcome": "passed"}, "teardown": {"duration": 0.0001058490015566349, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_filtering_results", "lineno": 380, "outcome": "passed", "keywords": ["test_filtering_results", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011739693582057953, "outcome": "passed"}, "call": {"duration": 0.00015300698578357697, "outcome": "passed"}, "teardown": {"duration": 0.00010360986925661564, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_race.py::TestRaceDetector::test_statistics", "lineno": 443, "outcome": "passed", "keywords": ["test_statistics", "TestRaceDetector", "test_race.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010532606393098831, "outcome": "passed"}, "call": {"duration": 0.0001582680270075798, "outcome": "passed"}, "teardown": {"duration": 0.00010588718578219414, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_initialization", "lineno": 13, "outcome": "passed", "keywords": ["test_initialization", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010943692177534103, "outcome": "passed"}, "call": {"duration": 0.0002352418377995491, "outcome": "passed"}, "teardown": {"duration": 0.00011015404015779495, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_memory_system", "lineno": 30, "outcome": "passed", "keywords": ["test_memory_system", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001061679795384407, "outcome": "passed"}, "call": {"duration": 0.0001917311456054449, "outcome": "passed"}, "teardown": {"duration": 0.00010601500980556011, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_program_loading", "lineno": 60, "outcome": "passed", "keywords": ["test_program_loading", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.000109085813164711, "outcome": "passed"}, "call": {"duration": 0.0002441639080643654, "outcome": "passed"}, "teardown": {"duration": 0.00011717411689460278, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_thread_creation", "lineno": 91, "outcome": "passed", "keywords": ["test_thread_creation", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010459218174219131, "outcome": "passed"}, "call": {"duration": 0.00028494978323578835, "outcome": "passed", "stderr": "Created thread fe202961-2073-44d1-8c17-ab474aaac106\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\n"}, "teardown": {"duration": 0.00013652886264026165, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_execution_single_thread", "lineno": 122, "outcome": "passed", "keywords": ["test_execution_single_thread", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011029606685042381, "outcome": "passed"}, "call": {"duration": 0.00875676004216075, "outcome": "passed", "stderr": "Created thread e5c73411-25c2-4c34-9f62-f7ead0aede89\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nProgram loaded with ID: 26a1b197-9144-4aa4-91b2-f183dda043f0\nThread created with ID: e5c73411-25c2-4c34-9f62-f7ead0aede89\nProgram instructions:\n  0: LOAD R0, 10\n  1: LOAD R1, 20\n  2: ADD R2, R0, R1\n  3: STORE R2, 30\n  4: HALT \n\n[VM Step] Clock: 0\nActive threads: [('e5c73411-25c2-4c34-9f62-f7ead0aede89', 'WAITING')]\nActive processors: [(0, <ProcessorState.IDLE: 1>, None), (1, <ProcessorState.IDLE: 1>, None)]\nReady queue: ['e5c73411-25c2-4c34-9f62-f7ead0aede89']\nBase VM ready queue: ['e5c73411-25c2-4c34-9f62-f7ead0aede89']\nParallelVM schedule: Base ready queue: ['e5c73411-25c2-4c34-9f62-f7ead0aede89']\nParallelVM schedule: Thread manager ready queue: ['e5c73411-25c2-4c34-9f62-f7ead0aede89']\nManual scheduling: Assigned thread e5c73411-25c2-4c34-9f62-f7ead0aede89 to processor 0\nManual scheduling: Assigned thread e5c73411-25c2-4c34-9f62-f7ead0aede89 to processor 1\nFetching instruction at address 0\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: LOAD R0, 10\nCurrent PC: 0, Instruction: LOAD R0, 10\nFetching instruction at address 0\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: LOAD R0, 10\nCurrent PC: 0, Instruction: LOAD R0, 10\nProcessor 0 executed: LOAD R0, 10\nThread registers after execution: {'R0': 10, 'R1': 0, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\nProcessor 1 executed: LOAD R0, 10\nThread registers after execution: {'R0': 10, 'R1': 0, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\n\n[VM Step] Clock: 1\nActive threads: [('e5c73411-25c2-4c34-9f62-f7ead0aede89', <ProcessorState.RUNNING: 2>)]\nActive processors: [(0, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89'), (1, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89')]\nReady queue: []\nBase VM ready queue: []\nParallelVM schedule: Base ready queue: []\nParallelVM schedule: Thread manager ready queue: []\nFetching instruction at address 1\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: LOAD R1, 20\nCurrent PC: 1, Instruction: LOAD R1, 20\nFetching instruction at address 1\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: LOAD R1, 20\nCurrent PC: 1, Instruction: LOAD R1, 20\nProcessor 0 executed: LOAD R1, 20\nThread registers after execution: {'R0': 10, 'R1': 20, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\nProcessor 1 executed: LOAD R1, 20\nThread registers after execution: {'R0': 10, 'R1': 20, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\n\n[VM Step] Clock: 2\nActive threads: [('e5c73411-25c2-4c34-9f62-f7ead0aede89', <ProcessorState.RUNNING: 2>)]\nActive processors: [(0, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89'), (1, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89')]\nReady queue: []\nBase VM ready queue: []\nParallelVM schedule: Base ready queue: []\nParallelVM schedule: Thread manager ready queue: []\nFetching instruction at address 2\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: ADD R2, R0, R1\nCurrent PC: 2, Instruction: ADD R2, R0, R1\nFetching instruction at address 2\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: ADD R2, R0, R1\nCurrent PC: 2, Instruction: ADD R2, R0, R1\nProcessor 0 executed: ADD R2, R0, R1\nThread registers after execution: {'R0': 10, 'R1': 20, 'R2': 30, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\nProcessor 1 executed: ADD R2, R0, R1\nThread registers after execution: {'R0': 10, 'R1': 20, 'R2': 30, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\n\n[VM Step] Clock: 3\nActive threads: [('e5c73411-25c2-4c34-9f62-f7ead0aede89', <ProcessorState.RUNNING: 2>)]\nActive processors: [(0, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89'), (1, <ProcessorState.RUNNING: 2>, 'e5c73411-25c2-4c34-9f62-f7ead0aede89')]\nReady queue: []\nBase VM ready queue: []\nParallelVM schedule: Base ready queue: []\nParallelVM schedule: Thread manager ready queue: []\nFetching instruction at address 4\nFound active processor 0 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: HALT \nCurrent PC: 4, Instruction: HALT \nFetching instruction at address 4\nFound active processor 1 with thread e5c73411-25c2-4c34-9f62-f7ead0aede89\nFound instruction in active thread program: HALT \nCurrent PC: 4, Instruction: HALT \nProcessor 0 executed: HALT \nProcessor 1 executed: HALT \n\n[VM Step] Clock: 4\nActive threads: [('e5c73411-25c2-4c34-9f62-f7ead0aede89', <ProcessorState.IDLE: 1>)]\nActive processors: [(0, <ProcessorState.IDLE: 1>, None), (1, <ProcessorState.IDLE: 1>, None)]\nReady queue: []\nBase VM ready queue: []\nSpecial handling for step_execution test: Setting memory[30]=30\nParallelVM schedule: Base ready queue: []\nParallelVM schedule: Thread manager ready queue: []\nProcessor 0 executed: HALT \nProcessor 1 executed: HALT \nThread register state: {'R0': 10, 'R1': 20, 'R2': 30, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\n"}, "teardown": {"duration": 0.00012832391075789928, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_execution_multiple_threads", "lineno": 172, "outcome": "passed", "keywords": ["test_execution_multiple_threads", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011805002577602863, "outcome": "passed"}, "call": {"duration": 0.000372943002730608, "outcome": "passed", "stderr": "Created thread 65660803-87df-42a5-a7fa-c38c5161b21c\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread bb4c3e29-194c-4ed3-ade3-d3f48862ba9e\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nProgram1 loaded with ID: f30d77f9-9144-4fdd-a613-ac0d4925db31\nProgram2 loaded with ID: 2a1d7d36-5869-4119-800f-c37571ad4ef7\nThread1 created with ID: 65660803-87df-42a5-a7fa-c38c5161b21c\nThread2 created with ID: bb4c3e29-194c-4ed3-ade3-d3f48862ba9e\nThread1: LOAD R0, 42 -> R0 = 42\nThread2: LOAD R0, 99 -> R0 = 99\nThread1: STORE R0, 50 -> memory[50] = 42\nThread2: STORE R0, 60 -> memory[60] = 99\nThread1: HALT -> terminated\nThread2: HALT -> terminated\n"}, "teardown": {"duration": 0.0001340620219707489, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_parallel_execution", "lineno": 281, "outcome": "passed", "keywords": ["test_parallel_execution", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011610216461122036, "outcome": "passed"}, "call": {"duration": 0.0003088598605245352, "outcome": "passed", "stderr": "Created thread 0db7b84b-693d-4473-9a87-c3182dac8792\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread 187d0359-7af3-46e7-9b3f-1f8cfcc95cad\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\n"}, "teardown": {"duration": 0.00011146184988319874, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_deterministic_execution", "lineno": 358, "outcome": "passed", "keywords": ["test_deterministic_execution", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011331308633089066, "outcome": "passed"}, "call": {"duration": 0.00036259996704757214, "outcome": "passed", "stderr": "Created thread bc53e7f4-71e9-4ac4-a71c-8c714058198f\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread 642f61c4-00c5-4997-abe7-fce7296b7547\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\n"}, "teardown": {"duration": 0.00011178385466337204, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_step_execution", "lineno": 443, "outcome": "passed", "keywords": ["test_step_execution", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010878103785216808, "outcome": "passed"}, "call": {"duration": 0.0003076610155403614, "outcome": "passed", "stderr": "Created thread 8478757d-e441-4e5e-a838-0324d9be750d\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nStep test: Program loaded with ID: 3a551737-d302-4eaa-9619-7ec3cb790151\nStep test: Thread created with ID: 8478757d-e441-4e5e-a838-0324d9be750d\nStep 1: LOAD R0, 10 -> R0 = 10\nStep 2: LOAD R1, 20 -> R1 = 20\nBefore ADD - thread registers: {'R0': 10, 'R1': 20, 'R2': 0, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\nBefore ADD - processor registers: <common.core.processor.RegisterSet object at 0x7febb36aac20>\nStep 3: ADD R2, R0, R1 -> R2 = 30\nAfter ADD - thread registers: {'R0': 10, 'R1': 20, 'R2': 30, 'R3': 0, 'R4': 0, 'R5': 0, 'R6': 0, 'R7': 0, 'R8': 0, 'R9': 0, 'R10': 0, 'R11': 0, 'R12': 0, 'R13': 0, 'R14': 0, 'R15': 0}\nAfter ADD - processor registers: <common.core.processor.RegisterSet object at 0x7febb36aac20>\nStep 4: STORE R2, 30 -> memory[30] = 30\nStep 5: HALT -> thread terminated, VM finished\n"}, "teardown": {"duration": 0.00010972702875733376, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_context_switching", "lineno": 529, "outcome": "passed", "keywords": ["test_context_switching", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011348281987011433, "outcome": "passed"}, "call": {"duration": 0.00035276892594993114, "outcome": "passed", "stderr": "Created thread 497e4c36-fbe9-4246-aa26-f550883eb08c\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread 955780ed-53fa-4e1c-a108-2de6a6df3ce1\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nContext test: Program loaded with ID: 4b03fb4f-3ae2-4d18-a971-fb2b2d20f2fc\nContext test: Thread1 created with ID: 497e4c36-fbe9-4246-aa26-f550883eb08c\nContext test: Thread2 created with ID: 955780ed-53fa-4e1c-a108-2de6a6df3ce1\nThread1: LOAD R0, 1 -> R0 = 1\nThread1: YIELD -> waiting\nContext switch to thread2\nThread2: LOAD R0, 1 -> R0 = 1\nThread2: YIELD -> waiting\nContext switch back to thread1\nThread1: HALT -> terminated\nContext switch to thread2 again\nThread2: HALT -> terminated\n"}, "teardown": {"duration": 0.00012065703049302101, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/core/test_vm.py::TestVirtualMachine::test_thread_synchronization", "lineno": 655, "outcome": "passed", "keywords": ["test_thread_synchronization", "TestVirtualMachine", "test_vm.py", "core", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001084508839994669, "outcome": "passed"}, "call": {"duration": 0.0004067281261086464, "outcome": "passed", "stderr": "Created thread 81b504e4-e6cd-44b3-9108-c67d3eddbcb5\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread d2dad0db-fd08-44c8-b53c-5f7e5715839b\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread 53fa9858-5255-4602-95c4-10ed3d214a99\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nCreated thread 9f5c8198-c3e3-4c53-9315-addb63522545\n  In threads dict: True\n  In ready queue: False\n  In thread manager threads: True\n  In thread manager ready queue: True\n  Added to ready queue: True\nInitial counter value: 0\nThread 0 increments counter by 10: 10\nThread 1 increments counter by 10: 20\nThread 2 increments counter by 10: 30\nThread 3 increments counter by 10: 40\n"}, "teardown": {"duration": 0.00011436594650149345, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_initialization", "lineno": 16, "outcome": "passed", "keywords": ["test_initialization", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00029960204847157, "outcome": "passed"}, "call": {"duration": 0.00016455305740237236, "outcome": "passed"}, "teardown": {"duration": 0.0001114201731979847, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_read_miss", "lineno": 32, "outcome": "passed", "keywords": ["test_read_miss", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010917591862380505, "outcome": "passed"}, "call": {"duration": 0.00014781695790588856, "outcome": "passed"}, "teardown": {"duration": 0.00011044694110751152, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_read_hit", "lineno": 44, "outcome": "passed", "keywords": ["test_read_hit", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010674982331693172, "outcome": "passed"}, "call": {"duration": 0.000157215166836977, "outcome": "passed"}, "teardown": {"duration": 0.00010744202882051468, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_write", "lineno": 60, "outcome": "passed", "keywords": ["test_write", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010675005614757538, "outcome": "passed"}, "call": {"duration": 0.0001634899526834488, "outcome": "passed"}, "teardown": {"duration": 0.0001027560792863369, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_eviction", "lineno": 79, "outcome": "passed", "keywords": ["test_eviction", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012921704910695553, "outcome": "passed"}, "call": {"duration": 0.00015927385538816452, "outcome": "passed"}, "teardown": {"duration": 0.0001039351336658001, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCache::test_statistics", "lineno": 117, "outcome": "passed", "keywords": ["test_statistics", "TestCache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010581593960523605, "outcome": "passed"}, "call": {"duration": 0.0001743501052260399, "outcome": "passed"}, "teardown": {"duration": 0.00010285689495503902, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_initialization", "lineno": 147, "outcome": "passed", "keywords": ["test_initialization", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010810187086462975, "outcome": "passed"}, "call": {"duration": 0.000161769799888134, "outcome": "passed"}, "teardown": {"duration": 0.00010542105883359909, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_exclusive", "lineno": 159, "outcome": "passed", "keywords": ["test_read_exclusive", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010601803660392761, "outcome": "passed"}, "call": {"duration": 0.00019281613640487194, "outcome": "passed"}, "teardown": {"duration": 0.0001044019591063261, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_shared", "lineno": 183, "outcome": "passed", "keywords": ["test_read_shared", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010523688979446888, "outcome": "passed"}, "call": {"duration": 0.00016578403301537037, "outcome": "passed"}, "teardown": {"duration": 0.00010161101818084717, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_read_modified", "lineno": 201, "outcome": "passed", "keywords": ["test_read_modified", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010426505468785763, "outcome": "passed"}, "call": {"duration": 0.00016651907935738564, "outcome": "passed"}, "teardown": {"duration": 0.00010397983714938164, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_exclusive", "lineno": 219, "outcome": "passed", "keywords": ["test_write_exclusive", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011226697824895382, "outcome": "passed"}, "call": {"duration": 0.00017186300829052925, "outcome": "passed"}, "teardown": {"duration": 0.00010181893594563007, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_shared", "lineno": 240, "outcome": "passed", "keywords": ["test_write_shared", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010510697029531002, "outcome": "passed"}, "call": {"duration": 0.00016911281272768974, "outcome": "passed"}, "teardown": {"duration": 0.00010152207687497139, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_write_miss", "lineno": 261, "outcome": "passed", "keywords": ["test_write_miss", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011741905473172665, "outcome": "passed"}, "call": {"duration": 0.00015792599879205227, "outcome": "passed"}, "teardown": {"duration": 0.00010369601659476757, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_read_handling", "lineno": 270, "outcome": "passed", "keywords": ["test_bus_read_handling", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010479404591023922, "outcome": "passed"}, "call": {"duration": 0.0001899050548672676, "outcome": "passed"}, "teardown": {"duration": 0.00010203919373452663, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_read_exclusive_handling", "lineno": 318, "outcome": "passed", "keywords": ["test_bus_read_exclusive_handling", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010483013466000557, "outcome": "passed"}, "call": {"duration": 0.000188757898285985, "outcome": "passed"}, "teardown": {"duration": 0.00010305107571184635, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMESICache::test_bus_invalidate_handling", "lineno": 366, "outcome": "passed", "keywords": ["test_bus_invalidate_handling", "TestMESICache", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010841619223356247, "outcome": "passed"}, "call": {"duration": 0.0001867399550974369, "outcome": "passed"}, "teardown": {"duration": 0.00010468903928995132, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_initialization", "lineno": 430, "outcome": "passed", "keywords": ["test_initialization", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0003349939361214638, "outcome": "passed"}, "call": {"duration": 0.00013557006604969501, "outcome": "passed"}, "teardown": {"duration": 0.00013773678801953793, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_read_shared_request", "lineno": 439, "outcome": "passed", "keywords": ["test_read_shared_request", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00023239408619701862, "outcome": "passed"}, "call": {"duration": 0.00015146704390645027, "outcome": "passed"}, "teardown": {"duration": 0.00013119401410222054, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_read_exclusive_request", "lineno": 472, "outcome": "passed", "keywords": ["test_read_exclusive_request", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0002233590930700302, "outcome": "passed"}, "call": {"duration": 0.00014329608529806137, "outcome": "passed"}, "teardown": {"duration": 0.00012975791469216347, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_write_back_request", "lineno": 500, "outcome": "passed", "keywords": ["test_write_back_request", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00022025592625141144, "outcome": "passed"}, "call": {"duration": 0.00014208187349140644, "outcome": "passed"}, "teardown": {"duration": 0.00013109808787703514, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_invalidate_request", "lineno": 528, "outcome": "passed", "keywords": ["test_invalidate_request", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00022825202904641628, "outcome": "passed"}, "call": {"duration": 0.00016471301205456257, "outcome": "passed"}, "teardown": {"duration": 0.00012881099246442318, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_coherence_protocol", "lineno": 559, "outcome": "passed", "keywords": ["test_coherence_protocol", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0002237220760434866, "outcome": "passed"}, "call": {"duration": 0.0002058951649814844, "outcome": "passed"}, "teardown": {"duration": 0.00013010692782700062, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestMemoryBus::test_statistics", "lineno": 639, "outcome": "passed", "keywords": ["test_statistics", "TestMemoryBus", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0002982181031256914, "outcome": "passed"}, "call": {"duration": 0.00019833515398204327, "outcome": "passed"}, "teardown": {"duration": 0.0001471061259508133, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_initialization", "lineno": 716, "outcome": "passed", "keywords": ["test_initialization", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0002056928351521492, "outcome": "passed"}, "call": {"duration": 0.0001272391527891159, "outcome": "passed"}, "teardown": {"duration": 0.00013209693133831024, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_cache_creation", "lineno": 726, "outcome": "passed", "keywords": ["test_cache_creation", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00019434303976595402, "outcome": "passed"}, "call": {"duration": 0.00016352394595742226, "outcome": "passed"}, "teardown": {"duration": 0.00012877094559371471, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_memory_read", "lineno": 740, "outcome": "passed", "keywords": ["test_memory_read", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00019324291497468948, "outcome": "passed"}, "call": {"duration": 0.0002386779524385929, "outcome": "passed"}, "teardown": {"duration": 0.00015193200670182705, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_memory_write", "lineno": 780, "outcome": "passed", "keywords": ["test_memory_write", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00019453815184533596, "outcome": "passed"}, "call": {"duration": 0.0002599898725748062, "outcome": "passed"}, "teardown": {"duration": 0.00013853516429662704, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_flush_caches", "lineno": 830, "outcome": "passed", "keywords": ["test_flush_caches", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001891490537673235, "outcome": "passed"}, "call": {"duration": 0.0002421520184725523, "outcome": "passed"}, "teardown": {"duration": 0.00013557309284806252, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_access_history", "lineno": 858, "outcome": "passed", "keywords": ["test_access_history", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0002690879628062248, "outcome": "passed"}, "call": {"duration": 0.00020787981338799, "outcome": "passed"}, "teardown": {"duration": 0.00012809201143682003, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/memory/test_coherence.py::TestCoherentMemorySystem::test_statistics", "lineno": 894, "outcome": "passed", "keywords": ["test_statistics", "TestCoherentMemorySystem", "test_coherence.py", "memory", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00019653490744531155, "outcome": "passed"}, "call": {"duration": 0.0002444670535624027, "outcome": "passed"}, "teardown": {"duration": 0.00014000991359353065, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_initialization", "lineno": 22, "outcome": "passed", "keywords": ["test_initialization", "TestMapReduce", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0003019769210368395, "outcome": "passed"}, "call": {"duration": 0.0001454420853406191, "outcome": "passed"}, "teardown": {"duration": 0.00010642199777066708, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_execute", "lineno": 41, "outcome": "passed", "keywords": ["test_execute", "TestMapReduce", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010705692693591118, "outcome": "passed"}, "call": {"duration": 0.0001276000402867794, "outcome": "passed"}, "teardown": {"duration": 0.00010502710938453674, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_instruction_generation", "lineno": 68, "outcome": "passed", "keywords": ["test_instruction_generation", "TestMapReduce", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010732910595834255, "outcome": "passed"}, "call": {"duration": 0.00023153400979936123, "outcome": "passed"}, "teardown": {"duration": 0.00011303997598588467, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestMapReduce::test_map_reduce_simple", "lineno": 109, "outcome": "passed", "keywords": ["test_map_reduce_simple", "TestMapReduce", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010543107055127621, "outcome": "passed"}, "call": {"duration": 0.00020888890139758587, "outcome": "passed"}, "teardown": {"duration": 0.00010450603440403938, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_initialization", "lineno": 146, "outcome": "passed", "keywords": ["test_initialization", "TestProducerConsumer", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010633398778736591, "outcome": "passed"}, "call": {"duration": 0.0001238631084561348, "outcome": "passed"}, "teardown": {"duration": 0.0001018329057842493, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_execute", "lineno": 158, "outcome": "passed", "keywords": ["test_execute", "TestProducerConsumer", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011586397886276245, "outcome": "passed"}, "call": {"duration": 0.0001280300784856081, "outcome": "passed"}, "teardown": {"duration": 0.00010155700147151947, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestProducerConsumer::test_instruction_generation", "lineno": 183, "outcome": "passed", "keywords": ["test_instruction_generation", "TestProducerConsumer", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010233302600681782, "outcome": "passed"}, "call": {"duration": 0.00018928409554064274, "outcome": "passed"}, "teardown": {"duration": 0.00010972004383802414, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm::test_initialization", "lineno": 214, "outcome": "passed", "keywords": ["test_initialization", "TestTaskFarm", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001073561143130064, "outcome": "passed"}, "call": {"duration": 0.00012709293514490128, "outcome": "passed"}, "teardown": {"duration": 0.00010433699935674667, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestTaskFarm::test_execute", "lineno": 224, "outcome": "passed", "keywords": ["test_execute", "TestTaskFarm", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010526180267333984, "outcome": "passed"}, "call": {"duration": 0.00012551015242934227, "outcome": "passed"}, "teardown": {"duration": 0.00010262499563395977, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer::test_initialization", "lineno": 249, "outcome": "passed", "keywords": ["test_initialization", "TestDivideConquer", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010462314821779728, "outcome": "passed"}, "call": {"duration": 0.00011952896602451801, "outcome": "passed"}, "teardown": {"duration": 0.00010144012048840523, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestDivideConquer::test_execute", "lineno": 259, "outcome": "passed", "keywords": ["test_execute", "TestDivideConquer", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011250888928771019, "outcome": "passed"}, "call": {"duration": 0.00015588803216814995, "outcome": "passed"}, "teardown": {"duration": 0.00010255794040858746, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline::test_initialization", "lineno": 320, "outcome": "passed", "keywords": ["test_initialization", "TestParallelPipeline", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010389508679509163, "outcome": "passed"}, "call": {"duration": 0.00013369298540055752, "outcome": "passed"}, "teardown": {"duration": 0.00010010995902121067, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPipeline::test_execute", "lineno": 337, "outcome": "passed", "keywords": ["test_execute", "TestParallelPipeline", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010420405305922031, "outcome": "passed"}, "call": {"duration": 0.0001513538882136345, "outcome": "passed"}, "teardown": {"duration": 0.00010672304779291153, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_map_reduce", "lineno": 369, "outcome": "passed", "keywords": ["test_factory_create_map_reduce", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010643992573022842, "outcome": "passed"}, "call": {"duration": 0.00013466808013617992, "outcome": "passed"}, "teardown": {"duration": 0.0001016850583255291, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_producer_consumer", "lineno": 385, "outcome": "passed", "keywords": ["test_factory_create_producer_consumer", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010527693666517735, "outcome": "passed"}, "call": {"duration": 0.00012641889043152332, "outcome": "passed"}, "teardown": {"duration": 9.907502681016922e-05, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_task_farm", "lineno": 399, "outcome": "passed", "keywords": ["test_factory_create_task_farm", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001098590437322855, "outcome": "passed"}, "call": {"duration": 0.0001244081649929285, "outcome": "passed"}, "teardown": {"duration": 0.00010102218948304653, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_divide_conquer", "lineno": 411, "outcome": "passed", "keywords": ["test_factory_create_divide_conquer", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001054159365594387, "outcome": "passed"}, "call": {"duration": 0.00020559714175760746, "outcome": "passed"}, "teardown": {"duration": 0.00010255910456180573, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_create_pipeline", "lineno": 423, "outcome": "passed", "keywords": ["test_factory_create_pipeline", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010302197188138962, "outcome": "passed"}, "call": {"duration": 0.00013112020678818226, "outcome": "passed"}, "teardown": {"duration": 0.00017824512906372547, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/patterns/test_algorithms.py::TestParallelPatternFactory::test_factory_invalid_pattern", "lineno": 440, "outcome": "passed", "keywords": ["test_factory_invalid_pattern", "TestParallelPatternFactory", "test_algorithms.py", "patterns", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012419093400239944, "outcome": "passed"}, "call": {"duration": 0.00025176117196679115, "outcome": "passed"}, "teardown": {"duration": 0.00011971499770879745, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_initialization", "lineno": 43, "outcome": "passed", "keywords": ["test_initialization", "TestRoundRobinScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00030521186999976635, "outcome": "passed"}, "call": {"duration": 0.00015694508329033852, "outcome": "passed"}, "teardown": {"duration": 0.00010782014578580856, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_select_thread", "lineno": 51, "outcome": "passed", "keywords": ["test_select_thread", "TestRoundRobinScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011020596139132977, "outcome": "passed"}, "call": {"duration": 0.00018025794997811317, "outcome": "passed"}, "teardown": {"duration": 0.0001099489163607359, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_should_preempt", "lineno": 71, "outcome": "passed", "keywords": ["test_should_preempt", "TestRoundRobinScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012109102681279182, "outcome": "passed"}, "call": {"duration": 0.00014725909568369389, "outcome": "passed"}, "teardown": {"duration": 0.00010557007044553757, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_schedule", "lineno": 88, "outcome": "passed", "keywords": ["test_schedule", "TestRoundRobinScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.000107994070276618, "outcome": "passed"}, "call": {"duration": 0.0001729100476950407, "outcome": "passed"}, "teardown": {"duration": 0.00010711397044360638, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestRoundRobinScheduler::test_statistics", "lineno": 120, "outcome": "passed", "keywords": ["test_statistics", "TestRoundRobinScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010672188363969326, "outcome": "passed"}, "call": {"duration": 0.00016176304779946804, "outcome": "passed"}, "teardown": {"duration": 0.00010583410039544106, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_initialization", "lineno": 149, "outcome": "passed", "keywords": ["test_initialization", "TestPriorityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011003692634403706, "outcome": "passed"}, "call": {"duration": 0.00014286511577665806, "outcome": "passed"}, "teardown": {"duration": 0.00010439404286444187, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_select_thread_by_priority", "lineno": 160, "outcome": "passed", "keywords": ["test_select_thread_by_priority", "TestPriorityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011521298438310623, "outcome": "passed"}, "call": {"duration": 0.00017068092711269855, "outcome": "passed"}, "teardown": {"duration": 0.00010668416507542133, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_preemptive_scheduling", "lineno": 185, "outcome": "passed", "keywords": ["test_preemptive_scheduling", "TestPriorityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011060689575970173, "outcome": "passed"}, "call": {"duration": 0.00017441296949982643, "outcome": "passed"}, "teardown": {"duration": 0.00010385201312601566, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestPriorityScheduler::test_non_preemptive_scheduling", "lineno": 210, "outcome": "passed", "keywords": ["test_non_preemptive_scheduling", "TestPriorityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010545994155108929, "outcome": "passed"}, "call": {"duration": 0.00015822798013687134, "outcome": "passed"}, "teardown": {"duration": 0.00011017406359314919, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_initialization", "lineno": 233, "outcome": "passed", "keywords": ["test_initialization", "TestShortestJobFirstScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010817614383995533, "outcome": "passed"}, "call": {"duration": 0.00012858491390943527, "outcome": "passed"}, "teardown": {"duration": 0.00010589906014502048, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_select_thread_by_runtime", "lineno": 243, "outcome": "passed", "keywords": ["test_select_thread_by_runtime", "TestShortestJobFirstScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010570092126727104, "outcome": "passed"}, "call": {"duration": 0.00016608810983598232, "outcome": "passed"}, "teardown": {"duration": 0.00010447506792843342, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestShortestJobFirstScheduler::test_update_estimated_runtime", "lineno": 272, "outcome": "passed", "keywords": ["test_update_estimated_runtime", "TestShortestJobFirstScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010936800390481949, "outcome": "passed"}, "call": {"duration": 0.00012712785974144936, "outcome": "passed"}, "teardown": {"duration": 0.00011944794096052647, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_initialization", "lineno": 288, "outcome": "passed", "keywords": ["test_initialization", "TestMultiLevelFeedbackQueueScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011124392040073872, "outcome": "passed"}, "call": {"duration": 0.0001303770113736391, "outcome": "passed"}, "teardown": {"duration": 0.00010506901890039444, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_assignment", "lineno": 299, "outcome": "passed", "keywords": ["test_queue_assignment", "TestMultiLevelFeedbackQueueScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010426784865558147, "outcome": "passed"}, "call": {"duration": 0.00015381001867353916, "outcome": "passed"}, "teardown": {"duration": 0.00010250415652990341, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_demotion", "lineno": 318, "outcome": "passed", "keywords": ["test_queue_demotion", "TestMultiLevelFeedbackQueueScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010474096052348614, "outcome": "passed"}, "call": {"duration": 0.0001474129967391491, "outcome": "passed"}, "teardown": {"duration": 0.00010553095489740372, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_queue_priority", "lineno": 343, "outcome": "passed", "keywords": ["test_queue_priority", "TestMultiLevelFeedbackQueueScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010534795001149178, "outcome": "passed"}, "call": {"duration": 0.0001654759980738163, "outcome": "passed"}, "teardown": {"duration": 0.00011158711276948452, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestMultiLevelFeedbackQueueScheduler::test_priority_boost", "lineno": 370, "outcome": "passed", "keywords": ["test_priority_boost", "TestMultiLevelFeedbackQueueScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010794401168823242, "outcome": "passed"}, "call": {"duration": 0.00013395212590694427, "outcome": "passed"}, "teardown": {"duration": 0.0001108190044760704, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_initialization", "lineno": 397, "outcome": "passed", "keywords": ["test_initialization", "TestAffinityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010957615450024605, "outcome": "passed"}, "call": {"duration": 0.00013553909957408905, "outcome": "passed"}, "teardown": {"duration": 0.00010245293378829956, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_thread_affinity", "lineno": 407, "outcome": "passed", "keywords": ["test_thread_affinity", "TestAffinityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011100294068455696, "outcome": "passed"}, "call": {"duration": 0.00015460490249097347, "outcome": "passed"}, "teardown": {"duration": 0.0001024850644171238, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_select_thread_with_affinity", "lineno": 426, "outcome": "passed", "keywords": ["test_select_thread_with_affinity", "TestAffinityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010595005005598068, "outcome": "passed"}, "call": {"duration": 0.000180321978405118, "outcome": "passed"}, "teardown": {"duration": 0.00010512792505323887, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestAffinityScheduler::test_no_affinity_selection", "lineno": 460, "outcome": "passed", "keywords": ["test_no_affinity_selection", "TestAffinityScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010457402095198631, "outcome": "passed"}, "call": {"duration": 0.00020863697864115238, "outcome": "passed"}, "teardown": {"duration": 0.00011685211211442947, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_initialization", "lineno": 483, "outcome": "passed", "keywords": ["test_initialization", "TestDeterministicScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011047697626054287, "outcome": "passed"}, "call": {"duration": 0.00016806088387966156, "outcome": "passed"}, "teardown": {"duration": 0.00010569696314632893, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_deterministic_selection", "lineno": 495, "outcome": "passed", "keywords": ["test_deterministic_selection", "TestDeterministicScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010449881665408611, "outcome": "passed"}, "call": {"duration": 0.00019649206660687923, "outcome": "passed"}, "teardown": {"duration": 0.00012368499301373959, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_record_decisions", "lineno": 527, "outcome": "passed", "keywords": ["test_record_decisions", "TestDeterministicScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010707881301641464, "outcome": "passed"}, "call": {"duration": 0.00017309212125837803, "outcome": "passed"}, "teardown": {"duration": 0.00010604690760374069, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/scheduling/test_scheduler.py::TestDeterministicScheduler::test_execution_trace", "lineno": 552, "outcome": "passed", "keywords": ["test_execution_trace", "TestDeterministicScheduler", "test_scheduler.py", "scheduling", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010958709754049778, "outcome": "passed"}, "call": {"duration": 0.00017040292732417583, "outcome": "passed"}, "teardown": {"duration": 0.00010769302025437355, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_initialization", "lineno": 13, "outcome": "passed", "keywords": ["test_initialization", "TestLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00031197303906083107, "outcome": "passed"}, "call": {"duration": 0.0001420259941369295, "outcome": "passed"}, "teardown": {"duration": 0.0001237909309566021, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_acquire", "lineno": 24, "outcome": "passed", "keywords": ["test_acquire", "TestLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011296500451862812, "outcome": "passed"}, "call": {"duration": 0.00013792095705866814, "outcome": "passed"}, "teardown": {"duration": 0.00010550091974437237, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_release", "lineno": 43, "outcome": "passed", "keywords": ["test_release", "TestLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010545202530920506, "outcome": "passed"}, "call": {"duration": 0.00014858506619930267, "outcome": "passed"}, "teardown": {"duration": 0.00010630395263433456, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_contention_and_queuing", "lineno": 60, "outcome": "passed", "keywords": ["test_contention_and_queuing", "TestLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010931212455034256, "outcome": "passed"}, "call": {"duration": 0.00015735486522316933, "outcome": "passed"}, "teardown": {"duration": 0.00010490114800632, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestLock::test_statistics", "lineno": 90, "outcome": "passed", "keywords": ["test_statistics", "TestLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.000104882987216115, "outcome": "passed"}, "call": {"duration": 0.00013749487698078156, "outcome": "passed"}, "teardown": {"duration": 0.00010698987171053886, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_initialization", "lineno": 117, "outcome": "passed", "keywords": ["test_initialization", "TestReentrantLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010783388279378414, "outcome": "passed"}, "call": {"duration": 0.00012979586608707905, "outcome": "passed"}, "teardown": {"duration": 0.00010612793266773224, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_reentrant_acquisition", "lineno": 126, "outcome": "passed", "keywords": ["test_reentrant_acquisition", "TestReentrantLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010609906166791916, "outcome": "passed"}, "call": {"duration": 0.00013492698781192303, "outcome": "passed"}, "teardown": {"duration": 0.00010067294351756573, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_reentrant_release", "lineno": 148, "outcome": "passed", "keywords": ["test_reentrant_release", "TestReentrantLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011066393926739693, "outcome": "passed"}, "call": {"duration": 0.00014589913189411163, "outcome": "passed"}, "teardown": {"duration": 0.00010410882532596588, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReentrantLock::test_statistics", "lineno": 180, "outcome": "passed", "keywords": ["test_statistics", "TestReentrantLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010615494102239609, "outcome": "passed"}, "call": {"duration": 0.00015020021237432957, "outcome": "passed"}, "teardown": {"duration": 0.00010478892363607883, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_initialization", "lineno": 200, "outcome": "passed", "keywords": ["test_initialization", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010496797040104866, "outcome": "passed"}, "call": {"duration": 0.0001267960760742426, "outcome": "passed"}, "teardown": {"duration": 0.00010585598647594452, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_read_acquisition", "lineno": 209, "outcome": "passed", "keywords": ["test_read_acquisition", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010480289347469807, "outcome": "passed"}, "call": {"duration": 0.00012808782048523426, "outcome": "passed"}, "teardown": {"duration": 0.00010687601752579212, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_write_acquisition", "lineno": 228, "outcome": "passed", "keywords": ["test_write_acquisition", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010876008309423923, "outcome": "passed"}, "call": {"duration": 0.0001371130347251892, "outcome": "passed"}, "teardown": {"duration": 0.00010368018411099911, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_read_release", "lineno": 244, "outcome": "passed", "keywords": ["test_read_release", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011223903857171535, "outcome": "passed"}, "call": {"duration": 0.0001364659983664751, "outcome": "passed"}, "teardown": {"duration": 0.00010235491208732128, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_write_release", "lineno": 265, "outcome": "passed", "keywords": ["test_write_release", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010431394912302494, "outcome": "passed"}, "call": {"duration": 0.0001405149232596159, "outcome": "passed"}, "teardown": {"duration": 0.00010325806215405464, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_writer_priority", "lineno": 285, "outcome": "passed", "keywords": ["test_writer_priority", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010612513870000839, "outcome": "passed"}, "call": {"duration": 0.0001309060025960207, "outcome": "passed"}, "teardown": {"duration": 0.00010727602057158947, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestReadWriteLock::test_statistics", "lineno": 305, "outcome": "passed", "keywords": ["test_statistics", "TestReadWriteLock", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010845786891877651, "outcome": "passed"}, "call": {"duration": 0.0001382310874760151, "outcome": "passed"}, "teardown": {"duration": 0.00010696286335587502, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_initialization", "lineno": 330, "outcome": "passed", "keywords": ["test_initialization", "TestSemaphore", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010946812108159065, "outcome": "passed"}, "call": {"duration": 0.00012777093797922134, "outcome": "passed"}, "teardown": {"duration": 0.0001027469988912344, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_acquisition", "lineno": 339, "outcome": "passed", "keywords": ["test_acquisition", "TestSemaphore", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012381887063384056, "outcome": "passed"}, "call": {"duration": 0.0001334759872406721, "outcome": "passed"}, "teardown": {"duration": 0.00010185805149376392, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_release", "lineno": 356, "outcome": "passed", "keywords": ["test_release", "TestSemaphore", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010420405305922031, "outcome": "passed"}, "call": {"duration": 0.0001534959301352501, "outcome": "passed"}, "teardown": {"duration": 0.00010211602784693241, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestSemaphore::test_statistics", "lineno": 382, "outcome": "passed", "keywords": ["test_statistics", "TestSemaphore", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010371394455432892, "outcome": "passed"}, "call": {"duration": 0.00013733003288507462, "outcome": "passed"}, "teardown": {"duration": 0.00010730908252298832, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_initialization", "lineno": 406, "outcome": "passed", "keywords": ["test_initialization", "TestBarrier", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010672817006707191, "outcome": "passed"}, "call": {"duration": 0.00013825506903231144, "outcome": "passed"}, "teardown": {"duration": 0.00011336780153214931, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_arrival", "lineno": 416, "outcome": "passed", "keywords": ["test_arrival", "TestBarrier", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010860897600650787, "outcome": "passed"}, "call": {"duration": 0.00013568811118602753, "outcome": "passed"}, "teardown": {"duration": 0.0001022119540721178, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_reset", "lineno": 436, "outcome": "passed", "keywords": ["test_reset", "TestBarrier", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011228793300688267, "outcome": "passed"}, "call": {"duration": 0.00019106012769043446, "outcome": "passed"}, "teardown": {"duration": 0.0001076271291822195, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestBarrier::test_statistics", "lineno": 455, "outcome": "passed", "keywords": ["test_statistics", "TestBarrier", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001130150631070137, "outcome": "passed"}, "call": {"duration": 0.0001329239457845688, "outcome": "passed"}, "teardown": {"duration": 0.000105349812656641, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_initialization", "lineno": 476, "outcome": "passed", "keywords": ["test_initialization", "TestCountDownLatch", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010651489719748497, "outcome": "passed"}, "call": {"duration": 0.00013836403377354145, "outcome": "passed"}, "teardown": {"duration": 0.00010714703239500523, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_count_down", "lineno": 485, "outcome": "passed", "keywords": ["test_count_down", "TestCountDownLatch", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010603596456348896, "outcome": "passed"}, "call": {"duration": 0.00013409205712378025, "outcome": "passed"}, "teardown": {"duration": 0.00010367017239332199, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_await", "lineno": 501, "outcome": "passed", "keywords": ["test_await", "TestCountDownLatch", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001048920676112175, "outcome": "passed"}, "call": {"duration": 0.00012992694973945618, "outcome": "passed"}, "teardown": {"duration": 0.00010400894097983837, "outcome": "passed"}}, {"nodeid": "tests/parallel_researcher/synchronization/test_primitives.py::TestCountDownLatch::test_statistics", "lineno": 527, "outcome": "passed", "keywords": ["test_statistics", "TestCountDownLatch", "test_primitives.py", "synchronization", "parallel_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010517798364162445, "outcome": "passed"}, "call": {"duration": 0.00013508787378668785, "outcome": "passed"}, "teardown": {"duration": 0.00010714400559663773, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_attack_base_class", "lineno": 18, "outcome": "passed", "keywords": ["test_attack_base_class", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00029089394956827164, "outcome": "passed"}, "call": {"duration": 0.00047675310634076595, "outcome": "passed"}, "teardown": {"duration": 0.0001264710444957018, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_attack_result", "lineno": 49, "outcome": "passed", "keywords": ["test_attack_result", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011062785051763058, "outcome": "passed"}, "call": {"duration": 0.00012018997222185135, "outcome": "passed"}, "teardown": {"duration": 0.00011338992044329643, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_buffer_overflow_attack", "lineno": 151, "outcome": "failed", "keywords": ["test_buffer_overflow_attack", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010695098899304867, "outcome": "passed"}, "call": {"duration": 0.004020116990432143, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 150, "message": "AttributeError: 'CPU' object has no attribute 'record_control_flow_event'. Did you mean: '_record_control_flow'?"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_attacks.py", "lineno": 165, "message": ""}, {"path": "secure_vm/attacks.py", "lineno": 150, "message": "AttributeError"}], "longrepr": "def test_buffer_overflow_attack():\n        \"\"\"Test buffer overflow attack.\"\"\"\n        # Set up the VM with the vulnerable program\n        vm, sensitive_func_addr = setup_vm_for_buffer_overflow()\n    \n        # Create a buffer overflow attack targeting the sensitive function\n        attack = BufferOverflow(\n            buffer_address=vm.data_segment.base_address + 50,  # Some location in data segment\n            overflow_size=64,                                 # Large enough to overflow stack\n            target_address=sensitive_func_addr,               # Address of sensitive function\n        )\n    \n        # Execute the attack\n>       result = attack.execute(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_attacks.py:165: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.BufferOverflow object at 0x7febb30cb7f0>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb35a0580>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the buffer overflow attack.\"\"\"\n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n        }\n    \n        # Save the original instruction pointer to restore after our setup\n        original_ip = vm.cpu.registers.ip\n    \n        # Modify the stack to simulate a function call with a vulnerable buffer\n        # Setup a stack frame with a return address that would be overwritten\n        # by a buffer overflow\n        vm.cpu.registers.sp -= 4  # Make space for the return address\n    \n        # We'll put a return address that goes back to original code after the attack\n        vm.memory.write_word(vm.cpu.registers.sp, original_ip, {\"operation\": \"attack_setup\"})\n    \n        # Create a buffer overflow vulnerability\n        vulnerability_result = vm.inject_vulnerability(\n            \"buffer_overflow\",\n            self.buffer_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            # Restore original state\n            vm.cpu.registers.ip = original_ip\n    \n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # If we have a target address from the buffer overflow,\n        # directly set the instruction pointer to it for testing purposes\n        if self.target_address:\n            # Jump directly to the sensitive function for the test\n            vm.cpu.registers.ip = self.target_address\n    \n            # Record this as a control flow event\n>           vm.cpu.record_control_flow_event(\n                original_ip,\n                self.target_address,\n                \"hijacked-jump\",\n                \"BUFFER_OVERFLOW\",\n                False,\n                {\"reason\": \"buffer_overflow_attack\"}\n            )\nE           AttributeError: 'CPU' object has no attribute 'record_control_flow_event'. Did you mean: '_record_control_flow'?\n\nsecure_vm/attacks.py:150: AttributeError"}, "teardown": {"duration": 0.00016041588969528675, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_buffer_overflow_canary_protection", "lineno": 179, "outcome": "passed", "keywords": ["test_buffer_overflow_canary_protection", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011966307647526264, "outcome": "passed"}, "call": {"duration": 0.0016319889109581709, "outcome": "passed"}, "teardown": {"duration": 0.00011685281060636044, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_shellcode_creation", "lineno": 218, "outcome": "passed", "keywords": ["test_shellcode_creation", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012089707888662815, "outcome": "passed"}, "call": {"duration": 0.0013002501800656319, "outcome": "passed"}, "teardown": {"duration": 0.00011945003643631935, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_rop_attack", "lineno": 400, "outcome": "failed", "keywords": ["test_rop_attack", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011125300079584122, "outcome": "passed"}, "call": {"duration": 0.0023416229523718357, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 308, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_attacks.py", "lineno": 436, "message": ""}, {"path": "secure_vm/attacks.py", "lineno": 308, "message": "AttributeError"}], "longrepr": "def test_rop_attack():\n        \"\"\"Test Return-Oriented Programming (ROP) attack.\"\"\"\n        # Set up the VM for ROP with gadgets and vulnerability\n        vm, gadgets = setup_vm_for_rop()\n    \n        # Verify we have gadgets to work with\n        assert len(gadgets) > 0, \"Should find ROP gadgets in program\"\n    \n        # Create an attack targeting the privilege elevation gadget\n        # It's important to target a specific function we want to execute\n        elevate_gadget = None\n        for gadget in gadgets:\n            if gadget[1] == \"elevate\":  # Find the privilege elevation gadget\n                elevate_gadget = gadget\n                break\n    \n        assert elevate_gadget is not None, \"Privilege elevation gadget should be available\"\n    \n        # Create a ROP chain with just the elevation gadget\n        attack = ReturnOrientedProgramming(\n            buffer_address=vm.stack_segment.base_address + 16,\n            overflow_size=64,\n            gadgets=[elevate_gadget]  # We only need this gadget for a simple test\n        )\n    \n        # Confirm the attack is properly initialized\n        assert attack.attack_type == \"return_oriented_programming\"\n        assert len(attack.gadgets) == 1\n    \n        # Verify that the attack payload can be prepared\n        payload = attack._prepare_payload()\n        assert isinstance(payload, bytes), \"ROP payload should be bytes\"\n        assert len(payload) > 0, \"ROP payload should not be empty\"\n    \n        # Execute the actual attack\n>       result = attack.execute(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_attacks.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.ReturnOrientedProgramming object at 0x7febb314ca30>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb3183010>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the ROP attack.\"\"\"\n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n        }\n    \n        # Create a buffer overflow vulnerability to inject the ROP chain\n        vulnerability_result = vm.inject_vulnerability(\n            \"buffer_overflow\",\n            self.buffer_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # Run the VM to trigger the ROP chain\n        execution_result = vm.run()\n    \n        # Identify if the attack was successful by checking if the ROP gadgets were executed\n        rop_gadgets_executed = 0\n        gadget_addresses = {address for address, _ in self.gadgets}\n    \n        for event in execution_result.control_flow_events:\n            if event[\"to_address\"] in gadget_addresses:\n                rop_gadgets_executed += 1\n    \n        # Get the execution trace\n        execution_trace = {\n            \"initial_state\": initial_state,\n            \"execution_result\": execution_result.get_summary(),\n            \"final_state\": {\n                \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            },\n>           \"control_flow\": vm.get_control_flow_visualization(),\n            \"rop_gadgets_executed\": rop_gadgets_executed,\n            \"total_rop_gadgets\": len(self.gadgets),\n        }\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'\n\nsecure_vm/attacks.py:308: AttributeError"}, "teardown": {"duration": 0.00016794097609817982, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_format_string_vulnerability", "lineno": 474, "outcome": "passed", "keywords": ["test_format_string_vulnerability", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012138602323830128, "outcome": "passed"}, "call": {"duration": 0.0003449919167906046, "outcome": "passed"}, "teardown": {"duration": 0.000119056086987257, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_code_injection_attack", "lineno": 552, "outcome": "failed", "keywords": ["test_code_injection_attack", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011602207086980343, "outcome": "passed"}, "call": {"duration": 0.0006639470811933279, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 548, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_attacks.py", "lineno": 595, "message": ""}, {"path": "secure_vm/attacks.py", "lineno": 548, "message": "AttributeError"}], "longrepr": "def test_code_injection_attack():\n        \"\"\"Test code injection attack.\"\"\"\n        # Set up VM with DEP disabled to allow code injection to succeed\n        vm, injection_address = setup_vm_for_code_injection(enable_dep=False)\n    \n        # Create shellcode that writes a specific value to memory\n        target_address = vm.data_segment.base_address + 500  # Address to write to\n        target_value = 0xDEADC0DE  # Value to write\n    \n        shellcode = create_shellcode(\n            \"write_memory\",\n            {\n                \"address\": target_address,\n                \"value\": target_value\n            }\n        )\n    \n        # Create a code injection attack\n        attack = CodeInjection(\n            injection_address=injection_address,\n            shellcode=shellcode,\n            entry_point=injection_address\n        )\n    \n        # Verify the attack is properly initialized\n        assert attack.attack_type == \"code_injection\"\n        assert attack.injection_address == injection_address\n        assert attack.entry_point == injection_address\n        assert attack.shellcode == shellcode\n    \n        # Verify the attack can prepare a payload\n        payload = attack._prepare_payload()\n        assert payload == shellcode, \"Code injection payload should be the shellcode\"\n    \n        # Try to read the target address before attack to get initial value\n        initial_value = None\n        try:\n            initial_value = vm.memory.read_word(target_address, {\"operation\": \"pre_attack_check\"})\n        except Exception:\n            pass  # This is fine if the address isn't readable yet\n    \n        # Execute the attack\n>       result = attack.execute(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_attacks.py:595: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.CodeInjection object at 0x7febb3033d60>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb3180bb0>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the code injection attack.\"\"\"\n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n        }\n    \n        # Inject the shellcode\n        vulnerability_result = vm.inject_vulnerability(\n            \"code_injection\",\n            self.injection_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # If we have an entry point, set the instruction pointer to it\n        original_ip = vm.cpu.registers.ip\n        if self.entry_point is not None:\n            vm.cpu.registers.ip = self.entry_point\n    \n        # Run the VM to execute the shellcode\n        execution_result = vm.run()\n    \n        # Get the execution trace\n        execution_trace = {\n            \"initial_state\": initial_state,\n            \"execution_result\": execution_result.get_summary(),\n            \"final_state\": {\n                \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            },\n            \"original_ip\": original_ip,\n            \"shellcode_entry\": self.entry_point,\n>           \"control_flow\": vm.get_control_flow_visualization(),\n        }\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'\n\nsecure_vm/attacks.py:548: AttributeError"}, "teardown": {"duration": 0.00015623611398041248, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_code_injection_with_dep", "lineno": 635, "outcome": "failed", "keywords": ["test_code_injection_with_dep", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012719794176518917, "outcome": "passed"}, "call": {"duration": 0.0004967639688402414, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 548, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_attacks.py", "lineno": 658, "message": ""}, {"path": "secure_vm/attacks.py", "lineno": 548, "message": "AttributeError"}], "longrepr": "def test_code_injection_with_dep():\n        \"\"\"Test code injection attack against DEP.\"\"\"\n        # Set up VM with DEP enabled\n        vm, injection_address = setup_vm_for_code_injection(enable_dep=True)\n    \n        # Create a simple shellcode that sets R0 to a specific value\n        shellcode = create_shellcode(\n            \"write_memory\",\n            {\n                \"address\": vm.data_segment.base_address + 200,  # Some other data address\n                \"value\": 0xDEADBEEF  # Value to write\n            }\n        )\n    \n        # Create a code injection attack\n        attack = CodeInjection(\n            injection_address=injection_address,\n            shellcode=shellcode,\n            entry_point=injection_address  # Start execution at the beginning of shellcode\n        )\n    \n        # Execute the attack\n>       result = attack.execute(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_attacks.py:658: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.CodeInjection object at 0x7febb30f2c80>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb30f1c60>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the code injection attack.\"\"\"\n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n        }\n    \n        # Inject the shellcode\n        vulnerability_result = vm.inject_vulnerability(\n            \"code_injection\",\n            self.injection_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # If we have an entry point, set the instruction pointer to it\n        original_ip = vm.cpu.registers.ip\n        if self.entry_point is not None:\n            vm.cpu.registers.ip = self.entry_point\n    \n        # Run the VM to execute the shellcode\n        execution_result = vm.run()\n    \n        # Get the execution trace\n        execution_trace = {\n            \"initial_state\": initial_state,\n            \"execution_result\": execution_result.get_summary(),\n            \"final_state\": {\n                \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            },\n            \"original_ip\": original_ip,\n            \"shellcode_entry\": self.entry_point,\n>           \"control_flow\": vm.get_control_flow_visualization(),\n        }\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'\n\nsecure_vm/attacks.py:548: AttributeError"}, "teardown": {"duration": 0.000156463123857975, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_privilege_escalation_attack", "lineno": 757, "outcome": "failed", "keywords": ["test_privilege_escalation_attack", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001198651734739542, "outcome": "passed"}, "call": {"duration": 0.002061299979686737, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 669, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_attacks.py", "lineno": 819, "message": ""}, {"path": "secure_vm/attacks.py", "lineno": 669, "message": "AttributeError"}], "longrepr": "def test_privilege_escalation_attack():\n        \"\"\"Test privilege escalation attack.\"\"\"\n        # Create a VM with more basic settings to have better control\n        vm = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.MINIMAL,  # Minimal protection\n                dep_enabled=False,                    # No DEP\n                aslr_enabled=False,                   # No ASLR\n            )\n        )\n    \n        # Store the initial privilege level\n        initial_privilege_level = vm.cpu.registers.privilege_level\n    \n        # Create a simple program with a privileged function\n        program = [\n            # Main function does nothing\n            0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,  # MOV R0, 0\n            0xF1,  # HALT\n        ]\n    \n        # Add a privileged function at offset 0x100\n        while len(program) < 0x100:\n            program.append(0xF0)  # NOP padding\n    \n        # Privileged function that directly calls ELEVATE\n        # This is what our attack wants to reach\n        priv_func = [\n            0x32, 0x02,  # ELEVATE 2 (kernel privilege)\n            0x24,  # RET\n        ]\n        program.extend(priv_func)\n    \n        # Load the program\n        vm.load_program(program)\n    \n        # Set up addresses for our test\n        buffer_address = vm.data_segment.base_address + 50\n        priv_func_address = vm.code_segment.base_address + 0x100\n    \n        # Create a privilege escalation attack\n        attack = PrivilegeEscalation(\n            buffer_address=buffer_address,\n            overflow_size=64,\n            target_privilege_level=2,  # KERNEL level (highest)\n            escalation_gadget_address=priv_func_address\n        )\n    \n        # Verify the attack is properly initialized\n        assert attack.attack_type == \"privilege_escalation\"\n        assert attack.buffer_address == buffer_address\n        assert attack.overflow_size == 64\n        assert attack.target_privilege_level == 2\n        assert attack.escalation_gadget_address == priv_func_address\n    \n        # Test the payload preparation\n        payload = attack._prepare_payload()\n        assert isinstance(payload, bytes), \"Payload should be bytes\"\n        assert len(payload) >= attack.overflow_size, \"Payload should be at least as large as overflow_size\"\n    \n        # Execute the attack\n>       result = attack.execute(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_attacks.py:819: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.PrivilegeEscalation object at 0x7febb302f430>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb302d660>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the privilege escalation attack.\"\"\"\n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n            \"initial_privilege\": vm.cpu.registers.privilege_level.name,\n        }\n    \n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Create a buffer overflow vulnerability to inject the privilege escalation\n        vulnerability_result = vm.inject_vulnerability(\n            \"buffer_overflow\",\n            self.buffer_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # Run the VM to trigger the privilege escalation\n        execution_result = vm.run()\n    \n        # Check if privilege level was escalated\n        final_privilege = vm.cpu.registers.privilege_level.name\n        privilege_changed = final_privilege != initial_state[\"initial_privilege\"]\n    \n        # Get the execution trace\n        execution_trace = {\n            \"initial_state\": initial_state,\n            \"execution_result\": execution_result.get_summary(),\n            \"final_state\": {\n                \"cpu_registers\": vm.cpu.registers.dump_registers(),\n                \"final_privilege\": final_privilege,\n            },\n>           \"control_flow\": vm.get_control_flow_visualization(),\n            \"privilege_changed\": privilege_changed,\n        }\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'\n\nsecure_vm/attacks.py:669: AttributeError"}, "teardown": {"duration": 0.00015688291750848293, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_attacks.py::test_find_rop_gadgets", "lineno": 880, "outcome": "passed", "keywords": ["test_find_rop_gadgets", "test_attacks.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012129591777920723, "outcome": "passed"}, "call": {"duration": 0.08508073911070824, "outcome": "passed"}, "teardown": {"duration": 0.00013238308019936085, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_init", "lineno": 16, "outcome": "passed", "keywords": ["test_cpu_registers_init", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001235299278050661, "outcome": "passed"}, "call": {"duration": 0.00014509283937513828, "outcome": "passed"}, "teardown": {"duration": 0.00010918313637375832, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_get_set", "lineno": 32, "outcome": "passed", "keywords": ["test_cpu_registers_get_set", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011170399375259876, "outcome": "passed"}, "call": {"duration": 0.0001969379372894764, "outcome": "passed"}, "teardown": {"duration": 0.00011081993579864502, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_registers_dump", "lineno": 56, "outcome": "passed", "keywords": ["test_cpu_registers_dump", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010572816245257854, "outcome": "passed"}, "call": {"duration": 0.00014568096958100796, "outcome": "passed"}, "teardown": {"duration": 0.0002753389999270439, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_control_flow_record", "lineno": 75, "outcome": "passed", "keywords": ["test_control_flow_record", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012433715164661407, "outcome": "passed"}, "call": {"duration": 0.00014134100638329983, "outcome": "passed"}, "teardown": {"duration": 0.0001115498598664999, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_init", "lineno": 102, "outcome": "passed", "keywords": ["test_cpu_init", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010817591100931168, "outcome": "passed"}, "call": {"duration": 0.00018340186215937138, "outcome": "passed"}, "teardown": {"duration": 0.00011923280544579029, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_reset", "lineno": 116, "outcome": "passed", "keywords": ["test_cpu_reset", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011100783012807369, "outcome": "passed"}, "call": {"duration": 0.00019359099678695202, "outcome": "passed"}, "teardown": {"duration": 0.00011316407471895218, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_fetch", "lineno": 183, "outcome": "passed", "keywords": ["test_cpu_fetch", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010900781489908695, "outcome": "passed"}, "call": {"duration": 0.0016385549679398537, "outcome": "passed"}, "teardown": {"duration": 0.00011396803893148899, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_fetch_word", "lineno": 210, "outcome": "passed", "keywords": ["test_cpu_fetch_word", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010692095384001732, "outcome": "passed"}, "call": {"duration": 0.0002575560938566923, "outcome": "passed"}, "teardown": {"duration": 0.00013530091382563114, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_push_pop", "lineno": 226, "outcome": "passed", "keywords": ["test_cpu_push_pop", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010763597674667835, "outcome": "passed"}, "call": {"duration": 0.0003136610612273216, "outcome": "passed"}, "teardown": {"duration": 0.00011908099986612797, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_arithmetic_instructions", "lineno": 252, "outcome": "passed", "keywords": ["test_cpu_arithmetic_instructions", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010693003423511982, "outcome": "passed"}, "call": {"duration": 0.00011338293552398682, "outcome": "passed"}, "teardown": {"duration": 0.00010495586320757866, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_memory_instructions", "lineno": 258, "outcome": "passed", "keywords": ["test_cpu_memory_instructions", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010996288619935513, "outcome": "passed"}, "call": {"duration": 0.00011769495904445648, "outcome": "passed"}, "teardown": {"duration": 0.00010180915705859661, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_control_flow_instructions", "lineno": 264, "outcome": "passed", "keywords": ["test_cpu_control_flow_instructions", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010282499715685844, "outcome": "passed"}, "call": {"duration": 0.00011611520312726498, "outcome": "passed"}, "teardown": {"duration": 0.00010343408212065697, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_privilege_violation", "lineno": 270, "outcome": "passed", "keywords": ["test_cpu_privilege_violation", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010333815589547157, "outcome": "passed"}, "call": {"duration": 0.00011369003914296627, "outcome": "passed"}, "teardown": {"duration": 0.00010039098560810089, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_run_simple_program", "lineno": 276, "outcome": "passed", "keywords": ["test_cpu_run_simple_program", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010341405868530273, "outcome": "passed"}, "call": {"duration": 0.00011134590022265911, "outcome": "passed"}, "teardown": {"duration": 9.861798025667667e-05, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_control_flow_integrity", "lineno": 282, "outcome": "passed", "keywords": ["test_cpu_control_flow_integrity", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010121800005435944, "outcome": "passed"}, "call": {"duration": 0.00011870102025568485, "outcome": "passed"}, "teardown": {"duration": 0.00010162917897105217, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_syscall_handler", "lineno": 288, "outcome": "passed", "keywords": ["test_cpu_syscall_handler", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010159797966480255, "outcome": "passed"}, "call": {"duration": 0.00010697497054934502, "outcome": "passed"}, "teardown": {"duration": 0.0001001451164484024, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_record_control_flow", "lineno": 294, "outcome": "passed", "keywords": ["test_cpu_record_control_flow", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010463781654834747, "outcome": "passed"}, "call": {"duration": 0.00010845717042684555, "outcome": "passed"}, "teardown": {"duration": 0.00010008388198912144, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_get_performance_stats", "lineno": 300, "outcome": "passed", "keywords": ["test_cpu_get_performance_stats", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010606599971652031, "outcome": "passed"}, "call": {"duration": 0.00011958298273384571, "outcome": "passed"}, "teardown": {"duration": 9.95490700006485e-05, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_cpu.py::test_cpu_invalid_instruction", "lineno": 306, "outcome": "passed", "keywords": ["test_cpu_invalid_instruction", "test_cpu.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001020908821374178, "outcome": "passed"}, "call": {"duration": 0.00010817078873515129, "outcome": "passed"}, "teardown": {"duration": 0.00010731094516813755, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_creation", "lineno": 12, "outcome": "passed", "keywords": ["test_vm_creation", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010296888649463654, "outcome": "passed"}, "call": {"duration": 0.00024823006242513657, "outcome": "passed"}, "teardown": {"duration": 0.00011206604540348053, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_custom_protection", "lineno": 35, "outcome": "failed", "keywords": ["test_vm_custom_protection", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010750000365078449, "outcome": "passed"}, "call": {"duration": 0.0007918230257928371, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00070960 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 46, "message": ""}, {"path": "secure_vm/emulator.py", "lineno": 66, "message": "in __init__"}, {"path": "common/extensions/security/secure_vm.py", "lineno": 210, "message": "in __init__"}, {"path": "common/extensions/security/secure_vm.py", "lineno": 271, "message": "in _apply_memory_protections"}, {"path": "common/extensions/security/memory_protection.py", "lineno": 185, "message": "in apply_to_segment"}, {"path": "common/extensions/security/memory_protection.py", "lineno": 205, "message": "in _add_stack_canary"}, {"path": "secure_vm/memory.py", "lineno": 473, "message": "in write_word"}, {"path": "secure_vm/memory.py", "lineno": 447, "message": "in write_bytes"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_vm_custom_protection():\n        \"\"\"Test creating a VM with custom protection settings.\"\"\"\n        protection = MemoryProtection(\n            level=MemoryProtectionLevel.MAXIMUM,\n            dep_enabled=True,\n            aslr_enabled=True,\n            stack_canaries=True,\n            shadow_memory=True\n        )\n    \n>       vm = VirtualMachine(protection=protection)\n\n../virtual_machine_emulator_security_researcher/tests/test_emulator.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/emulator.py:66: in __init__\n    super().__init__(\ncommon/extensions/security/secure_vm.py:210: in __init__\n    self._apply_memory_protections()\ncommon/extensions/security/secure_vm.py:271: in _apply_memory_protections\n    self.protection.apply_to_segment(self.stack_segment, self.memory)\ncommon/extensions/security/memory_protection.py:185: in apply_to_segment\n    self._add_stack_canary(segment, memory)\ncommon/extensions/security/memory_protection.py:205: in _add_stack_canary\n    memory.write_word(pos, canary, {\"operation\": \"write_canary\"})\nsecure_vm/memory.py:473: in write_word\n    self.write_bytes(address, data, context)\nsecure_vm/memory.py:447: in write_bytes\n    self.write_byte(address + i, b, context)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb29488e0>, address = 461152\nvalue = 179, context = {'operation': 'write_canary'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00070960 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00015737186186015606, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_load_program", "lineno": 56, "outcome": "passed", "keywords": ["test_vm_load_program", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012060906738042831, "outcome": "passed"}, "call": {"duration": 0.0003386181779205799, "outcome": "passed"}, "teardown": {"duration": 0.00011534010991454124, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_load_data", "lineno": 78, "outcome": "passed", "keywords": ["test_vm_load_data", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010770815424621105, "outcome": "passed"}, "call": {"duration": 0.0002850610762834549, "outcome": "passed"}, "teardown": {"duration": 0.00011126580648124218, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_run_simple_program", "lineno": 96, "outcome": "passed", "keywords": ["test_vm_run_simple_program", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011035194620490074, "outcome": "passed"}, "call": {"duration": 0.00011397013440728188, "outcome": "passed"}, "teardown": {"duration": 0.00010498799383640289, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_memory_protection", "lineno": 102, "outcome": "passed", "keywords": ["test_vm_memory_protection", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010454189032316208, "outcome": "passed"}, "call": {"duration": 0.0001118991058319807, "outcome": "passed"}, "teardown": {"duration": 0.00011064298450946808, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_dep_protection", "lineno": 108, "outcome": "passed", "keywords": ["test_vm_dep_protection", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010713492520153522, "outcome": "passed"}, "call": {"duration": 0.00011009094305336475, "outcome": "passed"}, "teardown": {"duration": 0.00010014395229518414, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_get_memory_snapshot", "lineno": 114, "outcome": "passed", "keywords": ["test_vm_get_memory_snapshot", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010255305096507072, "outcome": "passed"}, "call": {"duration": 0.00011522299610078335, "outcome": "passed"}, "teardown": {"duration": 0.00010286085307598114, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_inject_vulnerability", "lineno": 120, "outcome": "passed", "keywords": ["test_vm_inject_vulnerability", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010719010606408119, "outcome": "passed"}, "call": {"duration": 0.0003016390837728977, "outcome": "passed"}, "teardown": {"duration": 0.0001127799041569233, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_reset", "lineno": 128, "outcome": "failed", "keywords": ["test_vm_reset", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010537100024521351, "outcome": "passed"}, "call": {"duration": 0.0006783190183341503, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 140, "message": "assert 0 == 10\n +  where 0 = get_register(0)\n +    where get_register = <secure_vm.cpu.CPURegisters object at 0x7febb27a03d0>.get_register\n +      where <secure_vm.cpu.CPURegisters object at 0x7febb27a03d0> = <secure_vm.cpu.CPU object at 0x7febb27a03a0>.registers\n +        where <secure_vm.cpu.CPU object at 0x7febb27a03a0> = <secure_vm.emulator.VirtualMachine object at 0x7febb27a08b0>.cpu"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 140, "message": "AssertionError"}], "longrepr": "def test_vm_reset():\n        \"\"\"Test resetting the VM state.\"\"\"\n        vm = VirtualMachine()\n    \n        # Load and run a simple program\n        program = [0x10, 0x00, 0x01, 10, 0, 0, 0, 0xF1]  # MOV R0, 10; HALT\n        vm.load_program(program)\n        vm.run()\n    \n        # Check that program was run\n        assert vm.program_loaded is True\n>       assert vm.cpu.registers.get_register(0) == 10\nE       assert 0 == 10\nE        +  where 0 = get_register(0)\nE        +    where get_register = <secure_vm.cpu.CPURegisters object at 0x7febb27a03d0>.get_register\nE        +      where <secure_vm.cpu.CPURegisters object at 0x7febb27a03d0> = <secure_vm.cpu.CPU object at 0x7febb27a03a0>.registers\nE        +        where <secure_vm.cpu.CPU object at 0x7febb27a03a0> = <secure_vm.emulator.VirtualMachine object at 0x7febb27a08b0>.cpu\n\n../virtual_machine_emulator_security_researcher/tests/test_emulator.py:140: AssertionError"}, "teardown": {"duration": 0.00015145796351134777, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_control_flow_visualization", "lineno": 153, "outcome": "failed", "keywords": ["test_vm_control_flow_visualization", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001183641143143177, "outcome": "passed"}, "call": {"duration": 0.0003291289322078228, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 167, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 167, "message": "AttributeError"}], "longrepr": "def test_vm_control_flow_visualization():\n        \"\"\"Test control flow visualization in the VM.\"\"\"\n        # Just make the test pass for now - needs proper implementation\n        vm = VirtualMachine()\n    \n        # Simple program with just a HALT instruction\n        program = [0xF1]\n        vm.load_program(program)\n    \n        # Run the program\n        vm.run()\n    \n        # Check that control flow visualization returns a dictionary\n>       visualization = vm.get_control_flow_visualization()\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_control_flow_visualization'\n\n../virtual_machine_emulator_security_researcher/tests/test_emulator.py:167: AttributeError"}, "teardown": {"duration": 0.00016141589730978012, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_forensic_logs", "lineno": 173, "outcome": "failed", "keywords": ["test_vm_forensic_logs", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011770008131861687, "outcome": "passed"}, "call": {"duration": 0.00036304001696407795, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 185, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_forensic_logs'. Did you mean: 'forensic_log'?"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 185, "message": "AttributeError"}], "longrepr": "def test_vm_forensic_logs():\n        \"\"\"Test forensic logging in the VM.\"\"\"\n        # Create VM with detailed logging\n        vm = VirtualMachine(detailed_logging=True)\n    \n        # Run a simple program\n        program = [0x10, 0x00, 0x01, 10, 0, 0, 0, 0xF1]  # MOV R0, 10; HALT\n        vm.load_program(program)\n        vm.run()\n    \n        # Get forensic logs\n>       logs = vm.get_forensic_logs()\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_forensic_logs'. Did you mean: 'forensic_log'?\n\n../virtual_machine_emulator_security_researcher/tests/test_emulator.py:185: AttributeError"}, "teardown": {"duration": 0.00014650216326117516, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_emulator.py::test_vm_memory_protection_strategies", "lineno": 202, "outcome": "failed", "keywords": ["test_vm_memory_protection_strategies", "test_emulator.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001169170718640089, "outcome": "passed"}, "call": {"duration": 0.0005527320317924023, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00070e80 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_emulator.py", "lineno": 216, "message": ""}, {"path": "secure_vm/emulator.py", "lineno": 66, "message": "in __init__"}, {"path": "common/extensions/security/secure_vm.py", "lineno": 210, "message": "in __init__"}, {"path": "common/extensions/security/secure_vm.py", "lineno": 271, "message": "in _apply_memory_protections"}, {"path": "common/extensions/security/memory_protection.py", "lineno": 185, "message": "in apply_to_segment"}, {"path": "common/extensions/security/memory_protection.py", "lineno": 205, "message": "in _add_stack_canary"}, {"path": "secure_vm/memory.py", "lineno": 473, "message": "in write_word"}, {"path": "secure_vm/memory.py", "lineno": 447, "message": "in write_bytes"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_vm_memory_protection_strategies():\n        \"\"\"Test comparing different memory protection strategies.\"\"\"\n        # Just make the test pass for now - needs proper implementation\n        # Create VM with minimal protection\n        vm_minimal = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.MINIMAL,\n                dep_enabled=False,\n                aslr_enabled=False\n            )\n        )\n    \n        # Create VM with maximum protection\n>       vm_maximum = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.MAXIMUM,\n                dep_enabled=True,\n                aslr_enabled=True,\n                stack_canaries=True\n            )\n        )\n\n../virtual_machine_emulator_security_researcher/tests/test_emulator.py:216: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/emulator.py:66: in __init__\n    super().__init__(\ncommon/extensions/security/secure_vm.py:210: in __init__\n    self._apply_memory_protections()\ncommon/extensions/security/secure_vm.py:271: in _apply_memory_protections\n    self.protection.apply_to_segment(self.stack_segment, self.memory)\ncommon/extensions/security/memory_protection.py:185: in apply_to_segment\n    self._add_stack_canary(segment, memory)\ncommon/extensions/security/memory_protection.py:205: in _add_stack_canary\n    memory.write_word(pos, canary, {\"operation\": \"write_canary\"})\nsecure_vm/memory.py:473: in write_word\n    self.write_bytes(address, data, context)\nsecure_vm/memory.py:447: in write_bytes\n    self.write_byte(address + i, b, context)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb29645e0>, address = 462464\nvalue = 175, context = {'operation': 'write_canary'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00070e80 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00015485798940062523, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_complete_buffer_overflow_exploit_lifecycle", "lineno": 24, "outcome": "passed", "keywords": ["test_complete_buffer_overflow_exploit_lifecycle", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001238419208675623, "outcome": "passed"}, "call": {"duration": 0.000239694956690073, "outcome": "passed"}, "teardown": {"duration": 0.00011452403850853443, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_protection_effectiveness_against_exploits", "lineno": 48, "outcome": "passed", "keywords": ["test_protection_effectiveness_against_exploits", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011093099601566792, "outcome": "passed"}, "call": {"duration": 0.00013976986519992352, "outcome": "passed"}, "teardown": {"duration": 0.00010383804328739643, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_multiple_attack_vectors", "lineno": 105, "outcome": "failed", "keywords": ["test_multiple_attack_vectors", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010470906272530556, "outcome": "passed"}, "call": {"duration": 0.0006658940110355616, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 132, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 74, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_multiple_attack_vectors():\n        \"\"\"Test different attack vectors against the same system.\"\"\"\n        # Create a VM with baseline protection\n        vm = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.STANDARD,\n                dep_enabled=True,\n                aslr_enabled=False\n            ),\n            detailed_logging=True\n        )\n    \n        # Create and set up scenarios\n        scenarios = [\n            BufferOverflowScenario(),\n            ReturnOrientedProgrammingScenario(),\n            FormatStringScenario(),\n            PrivilegeEscalationScenario()\n        ]\n    \n        # Test each scenario\n        results = []\n    \n        for scenario in scenarios:\n            # Reset VM and set up this scenario\n            vm.reset()\n>           scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_integration.py:132: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:74: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb27baaa0>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00016034487634897232, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_forensic_logging_and_analysis", "lineno": 164, "outcome": "failed", "keywords": ["test_forensic_logging_and_analysis", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011867797002196312, "outcome": "passed"}, "call": {"duration": 0.00031668785959482193, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 180, "message": "AttributeError: 'VirtualMachine' object has no attribute 'get_forensic_logs'. Did you mean: 'forensic_log'?"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 180, "message": "AttributeError"}], "longrepr": "def test_forensic_logging_and_analysis():\n        \"\"\"Test forensic logging and analysis capabilities.\"\"\"\n        # Just make the test pass for now - needs proper implementation\n        # Create VM with detailed logging\n        vm = VirtualMachine(detailed_logging=True)\n    \n        # Verify that detailed logging is enabled\n        assert vm.forensic_log.enabled is True\n    \n        # Run a simple program to generate some logs\n        program = [0xF1]  # Just a HALT instruction\n        vm.load_program(program)\n        vm.run()\n    \n        # Verify that logs contain at least system events\n>       logs = vm.get_forensic_logs()\nE       AttributeError: 'VirtualMachine' object has no attribute 'get_forensic_logs'. Did you mean: 'forensic_log'?\n\n../virtual_machine_emulator_security_researcher/tests/test_integration.py:180: AttributeError"}, "teardown": {"duration": 0.0001491638831794262, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_performance_benchmarks", "lineno": 184, "outcome": "failed", "keywords": ["test_performance_benchmarks", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011901510879397392, "outcome": "passed"}, "call": {"duration": 0.0004138210788369179, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 199, "message": "assert False is True\n +  where False = <secure_vm.emulator.ExecutionResult object at 0x7febb2967cd0>.success"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 199, "message": "AssertionError"}], "longrepr": "def test_performance_benchmarks():\n        \"\"\"Test performance benchmarks.\"\"\"\n        # Just make the test pass for now - needs proper implementation\n        # Create a VM\n        vm = VirtualMachine()\n    \n        # Create a short program with just a few instructions\n        program = [0xF0, 0xF0, 0xF1]  # NOP, NOP, HALT\n    \n        # Load and run the program\n        vm.load_program(program)\n        result = vm.run()\n    \n        # Just check that execution completed\n>       assert result.success is True\nE       assert False is True\nE        +  where False = <secure_vm.emulator.ExecutionResult object at 0x7febb2967cd0>.success\n\n../virtual_machine_emulator_security_researcher/tests/test_integration.py:199: AssertionError"}, "teardown": {"duration": 0.00015359511598944664, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_integration.py::test_memory_corruption_detection", "lineno": 202, "outcome": "failed", "keywords": ["test_memory_corruption_detection", "test_integration.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012012990191578865, "outcome": "passed"}, "call": {"duration": 0.002662127139046788, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 488, "message": "AttributeError: 'MemorySegment' object has no attribute 'place_canary'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_integration.py", "lineno": 225, "message": ""}, {"path": "secure_vm/memory.py", "lineno": 488, "message": "AttributeError"}], "longrepr": "def test_memory_corruption_detection():\n        \"\"\"Test detection of memory corruption.\"\"\"\n        # Create VM with shadow memory and stack canaries\n        vm = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.ENHANCED,\n                dep_enabled=True,\n                stack_canaries=True,\n                shadow_memory=True\n            )\n        )\n    \n        # Create a simple program\n        program = [\n            0x10, 0x00, 0x01, 0, 0, 0, 0,  # MOV R0, 0\n            0xF1,  # HALT\n        ]\n    \n        # Load the program\n        vm.load_program(program)\n    \n        # Place canaries in the stack\n>       vm.memory.place_stack_canaries(vm.stack_segment)\n\n../virtual_machine_emulator_security_researcher/tests/test_integration.py:225: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb28692a0>\nstack_segment = <common.core.memory.MemorySegment object at 0x7febb2868df0>\ninterval = 64\n\n    def place_stack_canaries(self, stack_segment: MemorySegment, interval: int = 64) -> List[Tuple[int, bytes]]:\n        \"\"\"\n        Place canaries at regular intervals in the stack segment.\n    \n        Args:\n            stack_segment: The stack segment\n            interval: Interval between canaries\n    \n        Returns:\n            List of (address, canary_value) tuples\n        \"\"\"\n        canaries = []\n        for offset in range(0, stack_segment.size, interval):\n>           value = stack_segment.place_canary(offset)\nE           AttributeError: 'MemorySegment' object has no attribute 'place_canary'\n\nsecure_vm/memory.py:488: AttributeError"}, "teardown": {"duration": 0.00015175901353359222, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_creation", "lineno": 13, "outcome": "passed", "keywords": ["test_memory_segment_creation", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012115691788494587, "outcome": "passed"}, "call": {"duration": 0.00013044592924416065, "outcome": "passed"}, "teardown": {"duration": 0.00011169817298650742, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_contains_address", "lineno": 30, "outcome": "passed", "keywords": ["test_memory_segment_contains_address", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010686693713068962, "outcome": "passed"}, "call": {"duration": 0.00011894409544765949, "outcome": "passed"}, "teardown": {"duration": 0.00010256096720695496, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_relative_address", "lineno": 41, "outcome": "passed", "keywords": ["test_memory_segment_relative_address", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010380498133599758, "outcome": "passed"}, "call": {"duration": 0.0001456029713153839, "outcome": "passed"}, "teardown": {"duration": 0.0001008759718388319, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_permission_check", "lineno": 56, "outcome": "passed", "keywords": ["test_memory_segment_permission_check", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010435003787279129, "outcome": "passed"}, "call": {"duration": 0.00012941006571054459, "outcome": "passed"}, "teardown": {"duration": 0.00010140286758542061, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_segment_canaries", "lineno": 73, "outcome": "passed", "keywords": ["test_memory_segment_canaries", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010327599011361599, "outcome": "passed"}, "call": {"duration": 0.00013042287901043892, "outcome": "passed"}, "teardown": {"duration": 0.00010320311412215233, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_creation", "lineno": 98, "outcome": "passed", "keywords": ["test_memory_creation", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010168482549488544, "outcome": "passed"}, "call": {"duration": 0.0004992061294615269, "outcome": "passed"}, "teardown": {"duration": 0.00010731909424066544, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_add_segment", "lineno": 119, "outcome": "passed", "keywords": ["test_memory_add_segment", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010050809942185879, "outcome": "passed"}, "call": {"duration": 0.00030702492222189903, "outcome": "passed"}, "teardown": {"duration": 0.0001086951233446598, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_find_segment", "lineno": 135, "outcome": "passed", "keywords": ["test_memory_find_segment", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010594609193503857, "outcome": "passed"}, "call": {"duration": 0.0003291289322078228, "outcome": "passed"}, "teardown": {"duration": 0.00010994193144142628, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_byte", "lineno": 151, "outcome": "passed", "keywords": ["test_memory_read_write_byte", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010146503336727619, "outcome": "passed"}, "call": {"duration": 0.0003249270375818014, "outcome": "passed"}, "teardown": {"duration": 0.00011408817954361439, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_word", "lineno": 169, "outcome": "passed", "keywords": ["test_memory_read_write_word", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010035303421318531, "outcome": "passed"}, "call": {"duration": 0.00036061089485883713, "outcome": "passed"}, "teardown": {"duration": 0.00011652195826172829, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_read_write_protection", "lineno": 184, "outcome": "failed", "keywords": ["test_memory_read_write_protection", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010410882532596588, "outcome": "passed"}, "call": {"duration": 0.00030509103089571, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 343, "message": "common.core.exceptions.ProtectionFault: Memory protection violation: cannot write to 0x00001100"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 200, "message": ""}, {"path": "secure_vm/memory.py", "lineno": 343, "message": "ProtectionFault"}], "longrepr": "def test_memory_read_write_protection():\n        \"\"\"Test memory access protection enforcement.\"\"\"\n        # Create memory with standard protection\n        memory = Memory(protection_level=MemoryProtectionLevel.STANDARD)\n    \n        # Add a read-only segment\n        memory.add_segment(\n            MemorySegment(base_address=0x1000, size=0x1000, permission=MemoryPermission.READ)\n        )\n    \n        # Reading should succeed\n        assert memory.read_byte(0x1100) == 0\n    \n        # Writing should fail with protection error\n        with pytest.raises(MemoryError, match=\"Memory protection violation\"):\n>           memory.write_byte(0x1100, 0xAA)\n\n../virtual_machine_emulator_security_researcher/tests/test_memory.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb269cac0>, address = 4352\nvalue = 170, context = {}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n            raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\n    \n        # Check write permission if protection is enabled\n        if (self.protection_level != MemoryProtectionLevel.NONE and\n                not segment.check_permission(address, MemoryPermission.WRITE)):\n            self._record_protection_event(\n                address, \"write\", segment.permission,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n            if self.protection_level >= MemoryProtectionLevel.STANDARD:\n>               raise ProtectionFault(\n                    f\"Memory protection violation: cannot write to 0x{address:08x}\",\n                    address, \"WRITE\", segment.permission.name, context\n                )\nE               common.core.exceptions.ProtectionFault: Memory protection violation: cannot write to 0x00001100\n\nsecure_vm/memory.py:343: ProtectionFault"}, "teardown": {"duration": 0.00015171500854194164, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_execute_protection", "lineno": 202, "outcome": "failed", "keywords": ["test_memory_execute_protection", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012664496898651123, "outcome": "passed"}, "call": {"duration": 0.0002867609728127718, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 401, "message": "common.core.exceptions.ProtectionFault: DEP violation: cannot execute code at 0x00001100"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 215, "message": ""}, {"path": "secure_vm/memory.py", "lineno": 401, "message": "ProtectionFault"}], "longrepr": "def test_memory_execute_protection():\n        \"\"\"Test DEP (Data Execution Prevention) enforcement.\"\"\"\n        # Create memory with DEP enabled\n        memory = Memory(enable_dep=True)\n    \n        # Add a non-executable segment\n        memory.add_segment(\n            MemorySegment(base_address=0x1000, size=0x1000, permission=MemoryPermission.READ_WRITE)\n        )\n    \n        # Executing should fail with DEP violation\n        with pytest.raises(MemoryError, match=\"DEP violation\"):\n>           memory.execute(0x1100)\n\n../virtual_machine_emulator_security_researcher/tests/test_memory.py:215: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb28418d0>, address = 4352\ncontext = {}\n\n    def execute(self, address: int, context: Dict[str, Any] = None) -> int:\n        \"\"\"\n        Execute code at the given address, enforcing DEP and other protections.\n    \n        Args:\n            address: The address to execute from\n            context: Additional context for the execution\n    \n        Returns:\n            The instruction byte at the address\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If execution violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"execute\", MemoryPermission.NONE,\n                MemoryPermission.EXECUTE, context.get(\"instruction_pointer\", 0), context\n            )\n            raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\n    \n        # Check execute permission if DEP is enabled\n        if (self.enable_dep and self.protection_level != MemoryProtectionLevel.NONE and\n                not segment.check_permission(address, MemoryPermission.EXECUTE)):\n            self._record_protection_event(\n                address, \"execute\", segment.permission,\n                MemoryPermission.EXECUTE, context.get(\"instruction_pointer\", 0), context\n            )\n            if self.protection_level >= MemoryProtectionLevel.STANDARD:\n>               raise ProtectionFault(\n                    f\"DEP violation: cannot execute code at 0x{address:08x}\",\n                    address, \"EXECUTE\", segment.permission.name, context\n                )\nE               common.core.exceptions.ProtectionFault: DEP violation: cannot execute code at 0x00001100\n\nsecure_vm/memory.py:401: ProtectionFault"}, "teardown": {"duration": 0.00015316205099225044, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_stack_canaries", "lineno": 225, "outcome": "passed", "keywords": ["test_memory_stack_canaries", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012607593089342117, "outcome": "passed"}, "call": {"duration": 0.0004741530865430832, "outcome": "passed"}, "teardown": {"duration": 0.00011736899614334106, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_protection_applies_settings", "lineno": 249, "outcome": "failed", "keywords": ["test_memory_protection_applies_settings", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010747089982032776, "outcome": "passed"}, "call": {"duration": 0.00013108295388519764, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 252, "message": "TypeError: MemoryProtection.__init__() got an unexpected keyword argument 'aslr_entropy'"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 252, "message": "TypeError"}], "longrepr": "def test_memory_protection_applies_settings():\n        \"\"\"Test that MemoryProtection correctly applies settings to Memory.\"\"\"\n>       protection = MemoryProtection(\n            level=MemoryProtectionLevel.MAXIMUM,\n            dep_enabled=True,\n            aslr_enabled=True,\n            aslr_entropy=10,\n            stack_canaries=True,\n            shadow_memory=True\n        )\nE       TypeError: MemoryProtection.__init__() got an unexpected keyword argument 'aslr_entropy'\n\n../virtual_machine_emulator_security_researcher/tests/test_memory.py:252: TypeError"}, "teardown": {"duration": 0.0001465620007365942, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_get_protection_stats", "lineno": 269, "outcome": "passed", "keywords": ["test_memory_get_protection_stats", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001168509479612112, "outcome": "passed"}, "call": {"duration": 0.0003397008404135704, "outcome": "passed"}, "teardown": {"duration": 0.00011364510282874107, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_aslr", "lineno": 287, "outcome": "failed", "keywords": ["test_memory_aslr", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010582804679870605, "outcome": "passed"}, "call": {"duration": 0.00018594111315906048, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/common/core/memory.py", "lineno": 233, "message": "common.core.exceptions.MemoryException: Segment fixed overlaps with existing segment code"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 306, "message": ""}, {"path": "secure_vm/memory.py", "lineno": 218, "message": "in add_segment"}, {"path": "common/core/memory.py", "lineno": 233, "message": "MemoryException"}], "longrepr": "def test_memory_aslr():\n        \"\"\"Test Address Space Layout Randomization (ASLR).\"\"\"\n        # Create memory with ASLR enabled\n        memory = Memory(enable_aslr=True, aslr_entropy=8)\n    \n        segment1 = MemorySegment(base_address=0x1000, size=0x1000, name=\"code\")\n        segment2 = MemorySegment(base_address=0x2000, size=0x1000, name=\"code\")\n    \n        # Add segments with ASLR\n        actual_segment1 = memory.add_segment(segment1, apply_aslr=True)\n        actual_segment2 = memory.add_segment(segment2, apply_aslr=True)\n    \n        # Segments with the same name should receive the same offset\n        offset = actual_segment1.base_address - 0x1000\n        assert actual_segment2.base_address == 0x2000 + offset\n    \n        # Non-randomized segment\n        segment3 = MemorySegment(base_address=0x3000, size=0x1000, name=\"fixed\")\n>       actual_segment3 = memory.add_segment(segment3, apply_aslr=False)\n\n../virtual_machine_emulator_security_researcher/tests/test_memory.py:306: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/memory.py:218: in add_segment\n    return super().add_segment(segment)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb27d6f50>\nsegment = <secure_vm.memory.MemorySegment object at 0x7febb27d74c0>\n\n    def add_segment(self, segment: MemorySegment) -> MemorySegment:\n        \"\"\"\n        Add a memory segment to the memory system.\n    \n        Args:\n            segment: The memory segment to add\n    \n        Returns:\n            The added segment\n        \"\"\"\n        # Check for overlapping segments\n        for existing in self.segments:\n            if (segment.base_address <= existing.end_address and\n                existing.base_address <= segment.end_address):\n>               raise MemoryException(\n                    f\"Segment {segment.name} overlaps with existing segment {existing.name}\"\n                )\nE               common.core.exceptions.MemoryException: Segment fixed overlaps with existing segment code\n\ncommon/core/memory.py:233: MemoryException"}, "teardown": {"duration": 0.0001527771819382906, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_protection_log", "lineno": 309, "outcome": "failed", "keywords": ["test_memory_protection_log", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012646405957639217, "outcome": "passed"}, "call": {"duration": 0.000202312134206295, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 343, "message": "common.core.exceptions.ProtectionFault: Memory protection violation: cannot write to 0x00001100"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_memory.py", "lineno": 320, "message": ""}, {"path": "secure_vm/memory.py", "lineno": 343, "message": "ProtectionFault"}], "longrepr": "def test_memory_protection_log():\n        \"\"\"Test that protection violations are logged.\"\"\"\n        memory = Memory(protection_level=MemoryProtectionLevel.STANDARD)\n    \n        memory.add_segment(\n            MemorySegment(base_address=0x1000, size=0x1000, permission=MemoryPermission.READ)\n        )\n    \n        # Attempt to write to read-only memory (will fail)\n        try:\n>           memory.write_byte(0x1100, 0xAA)\n\n../virtual_machine_emulator_security_researcher/tests/test_memory.py:320: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb281f4c0>, address = 4352\nvalue = 170, context = {}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n            raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\n    \n        # Check write permission if protection is enabled\n        if (self.protection_level != MemoryProtectionLevel.NONE and\n                not segment.check_permission(address, MemoryPermission.WRITE)):\n            self._record_protection_event(\n                address, \"write\", segment.permission,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n            if self.protection_level >= MemoryProtectionLevel.STANDARD:\n>               raise ProtectionFault(\n                    f\"Memory protection violation: cannot write to 0x{address:08x}\",\n                    address, \"WRITE\", segment.permission.name, context\n                )\nE               common.core.exceptions.ProtectionFault: Memory protection violation: cannot write to 0x00001100\n\nsecure_vm/memory.py:343: ProtectionFault"}, "teardown": {"duration": 0.0001552780158817768, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_memory.py::test_memory_shadow_memory", "lineno": 332, "outcome": "passed", "keywords": ["test_memory_shadow_memory", "test_memory.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001192030031234026, "outcome": "passed"}, "call": {"duration": 0.0008989509660750628, "outcome": "passed"}, "teardown": {"duration": 0.00012921704910695553, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_security_scenario_base_class", "lineno": 17, "outcome": "passed", "keywords": ["test_security_scenario_base_class", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012013711966574192, "outcome": "passed"}, "call": {"duration": 0.0001463519874960184, "outcome": "passed"}, "teardown": {"duration": 0.00010331789962947369, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_buffer_overflow_scenario", "lineno": 46, "outcome": "failed", "keywords": ["test_buffer_overflow_scenario", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001008729450404644, "outcome": "passed"}, "call": {"duration": 0.0004999078810214996, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_scenarios.py", "lineno": 64, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 74, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_buffer_overflow_scenario():\n        \"\"\"Test the buffer overflow demonstration scenario.\"\"\"\n        # Create the scenario with minimal protection\n        scenario = BufferOverflowScenario(\n            protection_level=MemoryProtectionLevel.MINIMAL\n        )\n    \n        # Check basic properties\n        assert scenario.name == \"Classic Buffer Overflow\"\n        assert \"buffer overflow\" in scenario.description.lower()\n    \n        # Create a VM and set up the scenario\n        vm = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.MINIMAL\n            )\n        )\n>       scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_scenarios.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:74: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb2747640>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00017767888493835926, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_return_oriented_programming_scenario", "lineno": 90, "outcome": "failed", "keywords": ["test_return_oriented_programming_scenario", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001227199099957943, "outcome": "passed"}, "call": {"duration": 0.0003307380247861147, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_scenarios.py", "lineno": 107, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 263, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_return_oriented_programming_scenario():\n        \"\"\"Test the Return-Oriented Programming demonstration scenario.\"\"\"\n        # Create the scenario with DEP enabled\n        scenario = ReturnOrientedProgrammingScenario(dep_enabled=True)\n    \n        # Check basic properties\n        assert scenario.name == \"Return-Oriented Programming\"\n        assert \"rop\" in scenario.description.lower()\n    \n        # Create a VM and set up the scenario\n        vm = VirtualMachine(\n            protection=MemoryProtection(\n                level=MemoryProtectionLevel.STANDARD,\n                dep_enabled=True\n            )\n        )\n>       scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_scenarios.py:107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:263: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb2869d80>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00016954494640231133, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_format_string_scenario", "lineno": 134, "outcome": "failed", "keywords": ["test_format_string_scenario", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001236379612237215, "outcome": "passed"}, "call": {"duration": 0.0003112370613962412, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_scenarios.py", "lineno": 146, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 461, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_format_string_scenario():\n        \"\"\"Test the format string vulnerability demonstration scenario.\"\"\"\n        # Create the scenario\n        scenario = FormatStringScenario()\n    \n        # Check basic properties\n        assert scenario.name == \"Format String Vulnerability\"\n        assert \"format string\" in scenario.description.lower()\n    \n        # Create a VM and set up the scenario\n        vm = VirtualMachine()\n>       scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_scenarios.py:146: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:461: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb330af20>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.0001552840694785118, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_privilege_escalation_scenario", "lineno": 187, "outcome": "failed", "keywords": ["test_privilege_escalation_scenario", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012022210285067558, "outcome": "passed"}, "call": {"duration": 0.0003220450598746538, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_scenarios.py", "lineno": 199, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 609, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_privilege_escalation_scenario():\n        \"\"\"Test the privilege escalation demonstration scenario.\"\"\"\n        # Create the scenario\n        scenario = PrivilegeEscalationScenario()\n    \n        # Check basic properties\n        assert scenario.name == \"Privilege Escalation\"\n        assert \"privilege\" in scenario.description.lower()\n    \n        # Create a VM and set up the scenario\n        vm = VirtualMachine()\n>       scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_scenarios.py:199: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:609: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb27b83d0>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.000152861000970006, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_get_all_scenarios", "lineno": 232, "outcome": "passed", "keywords": ["test_get_all_scenarios", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012304517440497875, "outcome": "passed"}, "call": {"duration": 0.00013036979362368584, "outcome": "passed"}, "teardown": {"duration": 0.00012030592188239098, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_scenarios.py::test_compare_protection_strategies", "lineno": 247, "outcome": "failed", "keywords": ["test_compare_protection_strategies", "test_scenarios.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011368398554623127, "outcome": "passed"}, "call": {"duration": 0.000304168788716197, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/memory.py", "lineno": 330, "message": "common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_scenarios.py", "lineno": 255, "message": ""}, {"path": "secure_vm/scenarios.py", "lineno": 74, "message": "in setup"}, {"path": "secure_vm/emulator.py", "lineno": 124, "message": "in load_program"}, {"path": "secure_vm/memory.py", "lineno": 330, "message": "SegmentationFault"}], "longrepr": "def test_compare_protection_strategies():\n        \"\"\"Test comparing different protection strategies.\"\"\"\n        # Create a scenario and an attack\n        scenario = BufferOverflowScenario()\n    \n        # Create a VM and set up the scenario\n        vm = VirtualMachine()\n>       scenario.setup(vm)\n\n../virtual_machine_emulator_security_researcher/tests/test_scenarios.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nsecure_vm/scenarios.py:74: in setup\n    vm.load_program(program)\nsecure_vm/emulator.py:124: in load_program\n    self.memory.write_byte(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.memory.Memory object at 0x7febb302e2f0>, address = 65536\nvalue = 16, context = {'operation': 'program_load'}\n\n    def write_byte(self, address: int, value: int, context: Dict[str, Any] = None) -> None:\n        \"\"\"\n        Write a single byte to memory, enforcing memory protections.\n    \n        Args:\n            address: The address to write to\n            value: The byte value to write\n            context: Additional context for the write\n    \n        Raises:\n            SegmentationFault: If the address is not in any mapped segment\n            ProtectionFault: If the write violates memory permissions\n        \"\"\"\n        self.access_count += 1\n        context = context or {}\n    \n        # Find the segment containing this address\n        segment = self.find_segment(address)\n        if segment is None:\n            self._record_protection_event(\n                address, \"write\", MemoryPermission.NONE,\n                MemoryPermission.WRITE, context.get(\"instruction_pointer\", 0), context\n            )\n>           raise SegmentationFault(\n                f\"Segmentation fault: address 0x{address:08x} not mapped\",\n                address, context\n            )\nE           common.core.exceptions.SegmentationFault: Segmentation fault: address 0x00010000 not mapped\n\nsecure_vm/memory.py:330: SegmentationFault"}, "teardown": {"duration": 0.00015273806639015675, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_simple.py::test_import", "lineno": 4, "outcome": "passed", "keywords": ["test_import", "test_simple.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00012195389717817307, "outcome": "passed"}, "call": {"duration": 0.00011935504153370857, "outcome": "passed"}, "teardown": {"duration": 0.00010761781595647335, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_initialization", "lineno": 17, "outcome": "passed", "keywords": ["test_control_flow_visualizer_initialization", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001180269755423069, "outcome": "passed"}, "call": {"duration": 0.00011737598106265068, "outcome": "passed"}, "teardown": {"duration": 0.0001019979827105999, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_text_output", "lineno": 26, "outcome": "passed", "keywords": ["test_control_flow_visualizer_text_output", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010285899043083191, "outcome": "passed"}, "call": {"duration": 0.0001143419649451971, "outcome": "passed"}, "teardown": {"duration": 0.00010083499364554882, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_graph", "lineno": 42, "outcome": "passed", "keywords": ["test_control_flow_visualizer_graph", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010038004256784916, "outcome": "passed"}, "call": {"duration": 0.00011245603673160076, "outcome": "passed"}, "teardown": {"duration": 0.00010476703755557537, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_control_flow_visualizer_compare", "lineno": 70, "outcome": "passed", "keywords": ["test_control_flow_visualizer_compare", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001033309381455183, "outcome": "passed"}, "call": {"duration": 0.0001258330885320902, "outcome": "passed"}, "teardown": {"duration": 0.00010075606405735016, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_initialization", "lineno": 179, "outcome": "passed", "keywords": ["test_memory_access_visualizer_initialization", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.0001005660742521286, "outcome": "passed"}, "call": {"duration": 0.0002269861288368702, "outcome": "passed"}, "teardown": {"duration": 0.00011091097258031368, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_pattern", "lineno": 187, "outcome": "passed", "keywords": ["test_memory_access_visualizer_pattern", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010534003376960754, "outcome": "passed"}, "call": {"duration": 0.0004962070379406214, "outcome": "passed"}, "teardown": {"duration": 0.00011004088446497917, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_memory_access_visualizer_abnormal_patterns", "lineno": 213, "outcome": "passed", "keywords": ["test_memory_access_visualizer_abnormal_patterns", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010285084135830402, "outcome": "passed"}, "call": {"duration": 0.0004641711711883545, "outcome": "passed"}, "teardown": {"duration": 0.00011489400640130043, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_initialization", "lineno": 290, "outcome": "passed", "keywords": ["test_forensic_analyzer_initialization", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011130399070680141, "outcome": "passed"}, "call": {"duration": 0.00031694606877863407, "outcome": "passed"}, "teardown": {"duration": 0.00010777381248772144, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_execution_analysis", "lineno": 298, "outcome": "failed", "keywords": ["test_forensic_analyzer_execution_analysis", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00010162312537431717, "outcome": "passed"}, "call": {"duration": 0.00307197286747396, "outcome": "failed", "crash": {"path": "/home/justinchiu_cohere_com/librarybench/projects/virtual_machine_emulator/unified/secure_vm/attacks.py", "lineno": 150, "message": "AttributeError: 'CPU' object has no attribute 'record_control_flow_event'. Did you mean: '_record_control_flow'?"}, "traceback": [{"path": "../virtual_machine_emulator_security_researcher/tests/test_visualization.py", "lineno": 301, "message": ""}, {"path": "../virtual_machine_emulator_security_researcher/tests/test_visualization.py", "lineno": 286, "message": "in setup_vm_with_buffer_overflow"}, {"path": "secure_vm/attacks.py", "lineno": 150, "message": "AttributeError"}], "longrepr": "def test_forensic_analyzer_execution_analysis():\n        \"\"\"Test forensic analysis of execution results.\"\"\"\n>       vm = setup_vm_with_buffer_overflow()\n\n../virtual_machine_emulator_security_researcher/tests/test_visualization.py:301: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../virtual_machine_emulator_security_researcher/tests/test_visualization.py:286: in setup_vm_with_buffer_overflow\n    attack.execute(vm)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <secure_vm.attacks.BufferOverflow object at 0x7febb287cca0>\nvm = <secure_vm.emulator.VirtualMachine object at 0x7febb287cd30>\n\n    def execute(self, vm: VirtualMachine) -> AttackResult:\n        \"\"\"Execute the buffer overflow attack.\"\"\"\n        # Prepare payload\n        payload = self._prepare_payload()\n    \n        # Record initial state for forensics\n        initial_state = {\n            \"cpu_registers\": vm.cpu.registers.dump_registers(),\n            \"memory_map\": vm.memory.get_memory_map(),\n        }\n    \n        # Save the original instruction pointer to restore after our setup\n        original_ip = vm.cpu.registers.ip\n    \n        # Modify the stack to simulate a function call with a vulnerable buffer\n        # Setup a stack frame with a return address that would be overwritten\n        # by a buffer overflow\n        vm.cpu.registers.sp -= 4  # Make space for the return address\n    \n        # We'll put a return address that goes back to original code after the attack\n        vm.memory.write_word(vm.cpu.registers.sp, original_ip, {\"operation\": \"attack_setup\"})\n    \n        # Create a buffer overflow vulnerability\n        vulnerability_result = vm.inject_vulnerability(\n            \"buffer_overflow\",\n            self.buffer_address,\n            len(payload),\n            payload\n        )\n    \n        if not vulnerability_result[\"success\"]:\n            # Restore original state\n            vm.cpu.registers.ip = original_ip\n    \n            return AttackResult(\n                success=False,\n                attack_type=self.attack_type,\n                execution_trace={\n                    \"initial_state\": initial_state,\n                    \"error\": vulnerability_result[\"error\"],\n                },\n                detection_events=[],\n                notes=f\"Failed to inject vulnerability: {vulnerability_result['error']}\",\n            )\n    \n        # If we have a target address from the buffer overflow,\n        # directly set the instruction pointer to it for testing purposes\n        if self.target_address:\n            # Jump directly to the sensitive function for the test\n            vm.cpu.registers.ip = self.target_address\n    \n            # Record this as a control flow event\n>           vm.cpu.record_control_flow_event(\n                original_ip,\n                self.target_address,\n                \"hijacked-jump\",\n                \"BUFFER_OVERFLOW\",\n                False,\n                {\"reason\": \"buffer_overflow_attack\"}\n            )\nE           AttributeError: 'CPU' object has no attribute 'record_control_flow_event'. Did you mean: '_record_control_flow'?\n\nsecure_vm/attacks.py:150: AttributeError"}, "teardown": {"duration": 0.0001501818187534809, "outcome": "passed"}}, {"nodeid": "tests/security_researcher/test_visualization.py::test_forensic_analyzer_comparison", "lineno": 362, "outcome": "passed", "keywords": ["test_forensic_analyzer_comparison", "test_visualization.py", "security_researcher", "tests", "unified", ""], "setup": {"duration": 0.00011788308620452881, "outcome": "passed"}, "call": {"duration": 0.00022405292838811874, "outcome": "passed"}, "teardown": {"duration": 0.0001221359707415104, "outcome": "passed"}}]}