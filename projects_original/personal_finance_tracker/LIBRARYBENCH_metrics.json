{
    "total_logprobs": -43395.12184965351,
    "total_tokens": 72962,
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/test_values_budgeting/__init__.py": {
        "logprobs": -196.681849484544,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/income/__init__.py": {
        "logprobs": -185.68769836905,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/ethical_screening/screening.py": {
        "logprobs": -1717.0404434418645,
        "metrics": {
            "loc": 460,
            "sloc": 260,
            "lloc": 206,
            "comments": 46,
            "multi": 63,
            "blank": 90,
            "cyclomatic": 73,
            "internal_imports": [
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")",
                "class EthicalCriteria:\n    \"\"\"Customizable ethical screening criteria for investments.\"\"\"\n    \n    criteria_id: str\n    name: str\n    environmental: Dict[str, Any]\n    social: Dict[str, Any]\n    governance: Dict[str, Any]\n    min_overall_score: float\n    exclusions: List[str] = field(default_factory=list)\n    inclusions: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Validate that criteria weights are included and sum approximately to 1.\"\"\"\n        # Check that each criteria includes a weight\n        for field_name in ['environmental', 'social', 'governance']:\n            field_value = getattr(self, field_name)\n            if 'weight' not in field_value:\n                raise ValueError(f\"{field_name} criteria must include a weight\")\n            \n            # Ensure weight is between 0 and 1\n            if field_value['weight'] < 0 or field_value['weight'] > 1:\n                raise ValueError(f\"{field_name} weight must be between 0 and 1\")\n        \n        # Check that weights sum to approximately 1\n        weights_sum = (\n            self.environmental.get('weight', 0) + \n            self.social.get('weight', 0) + \n            self.governance.get('weight', 0)\n        )\n        if abs(weights_sum - 1.0) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Criteria weights sum to {weights_sum}, expected 1.0\")"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/tax/tax_manager.py": {
        "logprobs": -2925.0177195257797,
        "metrics": {
            "loc": 810,
            "sloc": 467,
            "lloc": 229,
            "comments": 90,
            "multi": 132,
            "blank": 132,
            "cyclomatic": 90,
            "internal_imports": [
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class TaxPayment(BaseModel):\n    \"\"\"Tax payment model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    tax_year: int\n    quarter: int\n    payment_method: str\n    confirmation_number: Optional[str] = None\n    notes: Optional[str] = None",
                "class TaxRate(BaseModel):\n    \"\"\"Tax rate for a specific income bracket.\"\"\"\n\n    bracket_min: float\n    bracket_max: Optional[float] = None\n    rate: float  # Percentage (0-100)\n    tax_year: int\n    jurisdiction: str = \"federal\"",
                "class TaxDeduction(BaseModel):\n    \"\"\"Tax deduction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    amount: float\n    tax_year: int\n    category: str\n    description: Optional[str] = None\n    receipt_path: Optional[str] = None",
                "class FilingStatus(str, Enum):\n    \"\"\"Tax filing status.\"\"\"\n\n    SINGLE = \"single\"\n    MARRIED_JOINT = \"married_filing_jointly\"\n    MARRIED_SEPARATE = \"married_filing_separately\"\n    HEAD_OF_HOUSEHOLD = \"head_of_household\"",
                "class TaxJurisdiction(str, Enum):\n    \"\"\"Tax jurisdiction types.\"\"\"\n\n    FEDERAL = \"federal\"\n    STATE = \"state\"\n    LOCAL = \"local\"",
                "class QuarterInfo(BaseModel):\n    \"\"\"Information about a tax quarter.\"\"\"\n\n    year: int\n    quarter: int\n    start_date: datetime\n    end_date: datetime\n    due_date: datetime\n    description: str",
                "class TaxBracket(BaseModel):\n    \"\"\"Tax bracket for a specific jurisdiction and filing status.\"\"\"\n\n    jurisdiction: TaxJurisdiction\n    filing_status: FilingStatus\n    tax_year: int\n    income_thresholds: List[float]  # Lower bounds of each bracket\n    rates: List[float]  # Rates for each bracket (as percentage: 10 = 10%)\n\n    @validator(\"rates\")\n    def validate_rates(cls, v, values):\n        \"\"\"Validate that rates are between 0 and 100 and match income thresholds.\"\"\"\n        if any(r < 0 or r > 100 for r in v):\n            raise ValueError(\"Rates must be between 0 and 100\")\n\n        if \"income_thresholds\" in values and len(v) != len(values[\"income_thresholds\"]):\n            raise ValueError(\"Number of rates must match number of income thresholds\")\n\n        return v",
                "class TaxLiability(BaseModel):\n    \"\"\"Calculated tax liability for a jurisdiction and period.\"\"\"\n\n    jurisdiction: TaxJurisdiction\n    tax_year: int\n    income: float\n    deductions: float\n    taxable_income: float\n    tax_amount: float\n    effective_rate: float  # As percentage\n    marginal_rate: float  # As percentage\n    filing_status: FilingStatus\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    breakdown: Dict[str, float] = Field(default_factory=dict)  # Detailed breakdown\n\n    @validator(\"effective_rate\", \"marginal_rate\")\n    def validate_rates(cls, v):\n        \"\"\"Validate that rates are between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Rates must be between 0 and 100\")\n        return v",
                "class EstimatedPayment(BaseModel):\n    \"\"\"Estimated tax payment calculation.\"\"\"\n\n    tax_year: int\n    quarter: int\n    jurisdiction: TaxJurisdiction\n    due_date: datetime\n    payment_amount: float  # Use this field instead of suggested_amount\n    suggested_amount: Optional[float] = None  # Keep for backwards compatibility\n    minimum_required: float\n    safe_harbor_amount: Optional[float] = None\n    year_to_date_liability: float\n    previous_payments: float\n    federal_tax: Optional[float] = None  # Added for test compatibility\n    self_employment_tax: Optional[float] = None  # Added for test compatibility\n    state_tax: Optional[float] = None  # Added for test compatibility\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None",
                "class TaxYearSummary(BaseModel):\n    \"\"\"Summary of tax obligations for a tax year.\"\"\"\n\n    tax_year: int\n    total_income: float\n    total_expenses: float\n    total_deductions: float\n    taxable_income: float\n    total_tax: float\n    effective_tax_rate: float\n    federal_tax: float\n    state_tax: float\n    self_employment_tax: float\n    total_paid: float\n    balance_due: float\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    deductions: List[TaxDeduction] = Field(default_factory=list)\n    payments: List[TaxPayment] = Field(default_factory=list)\n\n    @validator(\"effective_tax_rate\")\n    def validate_rate(cls, v):\n        \"\"\"Validate that rate is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Rate must be between 0 and 100\")\n        return v"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/tax/_test_tax_manager_full.py": {
        "logprobs": -1951.9394837885898,
        "metrics": {
            "loc": 498,
            "sloc": 328,
            "lloc": 193,
            "comments": 66,
            "multi": 0,
            "blank": 91,
            "cyclomatic": 106,
            "internal_imports": [
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class TaxPayment(BaseModel):\n    \"\"\"Tax payment model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    tax_year: int\n    quarter: int\n    payment_method: str\n    confirmation_number: Optional[str] = None\n    notes: Optional[str] = None",
                "class TaxDeduction(BaseModel):\n    \"\"\"Tax deduction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    amount: float\n    tax_year: int\n    category: str\n    description: Optional[str] = None\n    receipt_path: Optional[str] = None",
                "class FilingStatus(str, Enum):\n    \"\"\"Tax filing status.\"\"\"\n\n    SINGLE = \"single\"\n    MARRIED_JOINT = \"married_filing_jointly\"\n    MARRIED_SEPARATE = \"married_filing_separately\"\n    HEAD_OF_HOUSEHOLD = \"head_of_household\"",
                "class TaxJurisdiction(str, Enum):\n    \"\"\"Tax jurisdiction types.\"\"\"\n\n    FEDERAL = \"federal\"\n    STATE = \"state\"\n    LOCAL = \"local\"",
                "class TaxBracket(BaseModel):\n    \"\"\"Tax bracket for a specific jurisdiction and filing status.\"\"\"\n\n    jurisdiction: TaxJurisdiction\n    filing_status: FilingStatus\n    tax_year: int\n    income_thresholds: List[float]  # Lower bounds of each bracket\n    rates: List[float]  # Rates for each bracket (as percentage: 10 = 10%)\n\n    @validator(\"rates\")\n    def validate_rates(cls, v, values):\n        \"\"\"Validate that rates are between 0 and 100 and match income thresholds.\"\"\"\n        if any(r < 0 or r > 100 for r in v):\n            raise ValueError(\"Rates must be between 0 and 100\")\n\n        if \"income_thresholds\" in values and len(v) != len(values[\"income_thresholds\"]):\n            raise ValueError(\"Number of rates must match number of income thresholds\")\n\n        return v",
                "class TaxManager:\n    \"\"\"\n    Tax management engine for freelancers.\n\n    This class handles tax calculations, estimated payment scheduling,\n    and tax optimization for freelancers.\n    \"\"\"\n\n    def __init__(self, filing_status: FilingStatus = FilingStatus.SINGLE):\n        \"\"\"\n        Initialize the tax manager.\n\n        Args:\n            filing_status: Tax filing status\n        \"\"\"\n        self.filing_status = filing_status\n        self._tax_brackets = {}  # Cache for tax brackets\n        self._se_tax_rate = 15.3  # Self-employment tax rate (percentage)\n        self._se_tax_income_limit = 147000  # For 2022 (Social Security wage base)\n        self._standard_deduction = {\n            2022: {\n                FilingStatus.SINGLE: 12950,\n                FilingStatus.MARRIED_JOINT: 25900,\n                FilingStatus.MARRIED_SEPARATE: 12950,\n                FilingStatus.HEAD_OF_HOUSEHOLD: 19400,\n            }\n        }\n\n    def set_tax_brackets(self, brackets: List[TaxBracket]) -> None:\n        \"\"\"\n        Set tax brackets for calculations.\n\n        Args:\n            brackets: List of tax brackets\n        \"\"\"\n        # Index brackets by jurisdiction, year, and filing status\n        for bracket in brackets:\n            key = (bracket.jurisdiction, bracket.tax_year, bracket.filing_status)\n            self._tax_brackets[key] = bracket\n\n    def get_tax_brackets(\n        self,\n        jurisdiction: TaxJurisdiction,\n        tax_year: int,\n        filing_status: Optional[FilingStatus] = None,\n    ) -> Optional[TaxBracket]:\n        \"\"\"\n        Get tax brackets for a specific jurisdiction and year.\n\n        Args:\n            jurisdiction: Tax jurisdiction\n            tax_year: Tax year\n            filing_status: Filing status (defaults to instance filing status)\n\n        Returns:\n            Tax bracket if found, None otherwise\n        \"\"\"\n        status = filing_status or self.filing_status\n        key = (jurisdiction, tax_year, status)\n        return self._tax_brackets.get(key)\n\n    def load_default_brackets(self) -> None:\n        \"\"\"Load default tax brackets for common jurisdictions.\"\"\"\n        # 2022 federal tax brackets (simplified example)\n        federal_single = TaxBracket(\n            jurisdiction=TaxJurisdiction.FEDERAL,\n            filing_status=FilingStatus.SINGLE,\n            tax_year=2022,\n            income_thresholds=[0, 10275, 41775, 89075, 170050, 215950, 539900],\n            rates=[10, 12, 22, 24, 32, 35, 37],\n        )\n\n        federal_married_joint = TaxBracket(\n            jurisdiction=TaxJurisdiction.FEDERAL,\n            filing_status=FilingStatus.MARRIED_JOINT,\n            tax_year=2022,\n            income_thresholds=[0, 20550, 83550, 178150, 340100, 431900, 647850],\n            rates=[10, 12, 22, 24, 32, 35, 37],\n        )\n\n        self.set_tax_brackets([federal_single, federal_married_joint])\n\n    def calculate_tax_quarters(self, tax_year: int) -> List[QuarterInfo]:\n        \"\"\"\n        Calculate tax quarter information for a specific year.\n\n        Args:\n            tax_year: Tax year\n\n        Returns:\n            List of tax quarter information\n        \"\"\"\n        quarters = []\n\n        # First quarter: January 1 - March 31, due April 15\n        q1_start = datetime(tax_year, 1, 1)\n        q1_end = datetime(tax_year, 3, 31)\n        q1_due = datetime(tax_year, 4, 15)\n\n        # Second quarter: April 1 - May 31, due June 15\n        q2_start = datetime(tax_year, 4, 1)\n        q2_end = datetime(tax_year, 5, 31)\n        q2_due = datetime(tax_year, 6, 15)\n\n        # Third quarter: June 1 - August 31, due September 15\n        q3_start = datetime(tax_year, 6, 1)\n        q3_end = datetime(tax_year, 8, 31)\n        q3_due = datetime(tax_year, 9, 15)\n\n        # Fourth quarter: September 1 - December 31, due January 15 of next year\n        q4_start = datetime(tax_year, 9, 1)\n        q4_end = datetime(tax_year, 12, 31)\n        q4_due = datetime(tax_year + 1, 1, 15)\n\n        quarters = [\n            QuarterInfo(\n                year=tax_year,\n                quarter=1,\n                start_date=q1_start,\n                end_date=q1_end,\n                due_date=q1_due,\n                description=f\"Q1 {tax_year} (Jan-Mar)\",\n            ),\n            QuarterInfo(\n                year=tax_year,\n                quarter=2,\n                start_date=q2_start,\n                end_date=q2_end,\n                due_date=q2_due,\n                description=f\"Q2 {tax_year} (Apr-May)\",\n            ),\n            QuarterInfo(\n                year=tax_year,\n                quarter=3,\n                start_date=q3_start,\n                end_date=q3_end,\n                due_date=q3_due,\n                description=f\"Q3 {tax_year} (Jun-Aug)\",\n            ),\n            QuarterInfo(\n                year=tax_year,\n                quarter=4,\n                start_date=q4_start,\n                end_date=q4_end,\n                due_date=q4_due,\n                description=f\"Q4 {tax_year} (Sep-Dec)\",\n            ),\n        ]\n\n        return quarters\n\n    def get_current_quarter(self) -> QuarterInfo:\n        \"\"\"\n        Get the current tax quarter information.\n\n        Returns:\n            Information about the current tax quarter\n        \"\"\"\n        today = datetime.now()\n        year = today.year\n\n        quarters = self.calculate_tax_quarters(year)\n\n        # Find the current quarter\n        for quarter in quarters:\n            if quarter.start_date <= today <= quarter.end_date:\n                return quarter\n\n        # If not found (shouldn't happen), return the last quarter of the year\n        return quarters[-1]\n\n    def calculate_taxable_income(\n        self,\n        transactions: List[Transaction],\n        tax_year: int,\n        deductions: List[TaxDeduction] = None,\n    ) -> Tuple[float, float, float]:\n        \"\"\"\n        Calculate taxable income for a tax year.\n\n        Args:\n            transactions: List of all transactions\n            tax_year: Tax year to calculate for\n            deductions: List of tax deductions\n\n        Returns:\n            Tuple of (total income, total deductions, taxable income)\n        \"\"\"\n        # Filter transactions to the tax year\n        year_start = datetime(tax_year, 1, 1)\n        year_end = datetime(tax_year, 12, 31, 23, 59, 59)\n\n        year_transactions = [\n            t for t in transactions if year_start <= t.date <= year_end\n        ]\n\n        # Calculate total income\n        income_transactions = [\n            t for t in year_transactions if t.transaction_type == TransactionType.INCOME\n        ]\n        total_income = sum(t.amount for t in income_transactions)\n\n        # Calculate business expenses\n        expense_transactions = [\n            t\n            for t in year_transactions\n            if (\n                t.transaction_type == TransactionType.EXPENSE\n                and t.category is not None\n                and t.category.name != \"PERSONAL\"\n                and t.business_use_percentage is not None\n            )\n        ]\n\n        total_expenses = sum(\n            t.amount * (t.business_use_percentage / 100) for t in expense_transactions\n        )\n\n        # Add additional deductions\n        additional_deductions = 0.0\n        if deductions:\n            additional_deductions = sum(d.amount for d in deductions)\n\n        # Get standard deduction\n        std_deduction = self._standard_deduction.get(tax_year, {}).get(\n            self.filing_status,\n            12950,  # Default to 2022 single\n        )\n\n        # Calculate total deductions (greater of itemized or standard)\n        total_deductions = max(total_expenses + additional_deductions, std_deduction)\n\n        # Calculate taxable income\n        taxable_income = max(0, total_income - total_deductions)\n\n        return total_income, total_deductions, taxable_income\n\n    def calculate_federal_tax(\n        self,\n        taxable_income: float,\n        tax_year: int,\n        filing_status: Optional[FilingStatus] = None,\n    ) -> float:\n        \"\"\"\n        Calculate federal income tax.\n\n        Args:\n            taxable_income: Taxable income amount\n            tax_year: Tax year\n            filing_status: Filing status (defaults to instance filing status)\n\n        Returns:\n            Federal tax amount\n        \"\"\"\n        # Get tax brackets\n        status = filing_status or self.filing_status\n        brackets = self.get_tax_brackets(TaxJurisdiction.FEDERAL, tax_year, status)\n\n        if not brackets:\n            raise ValueError(f\"No federal tax brackets for {tax_year} and {status}\")\n\n        # Calculate tax\n        tax = 0.0\n        prev_threshold = 0.0\n\n        for i, threshold in enumerate(brackets.income_thresholds):\n            rate = brackets.rates[i] / 100  # Convert percentage to decimal\n\n            if taxable_income <= threshold:\n                tax += (taxable_income - prev_threshold) * rate\n                break\n            else:\n                tax += (threshold - prev_threshold) * rate\n\n            prev_threshold = threshold\n\n            # If this is the last bracket, calculate tax on remaining income\n            if i == len(brackets.income_thresholds) - 1:\n                tax += (taxable_income - threshold) * rate\n\n        return tax\n\n    def calculate_self_employment_tax(self, net_business_income: float) -> float:\n        \"\"\"\n        Calculate self-employment tax.\n\n        Args:\n            net_business_income: Net business income\n\n        Returns:\n            Self-employment tax amount\n        \"\"\"\n        # SE tax is calculated on 92.35% of net business income\n        taxable_income = net_business_income * 0.9235\n\n        # Social Security portion (12.4%) is subject to wage base limit\n        social_security_portion = min(taxable_income, self._se_tax_income_limit) * 0.124\n\n        # Medicare portion (2.9%) applies to all income\n        medicare_portion = taxable_income * 0.029\n\n        # Additional Medicare Tax (0.9%) on income above threshold\n        # (simplified - would normally depend on filing status)\n        additional_medicare = max(0, taxable_income - 200000) * 0.009\n\n        return social_security_portion + medicare_portion + additional_medicare\n\n    def calculate_tax_liability(\n        self,\n        income: Optional[float] = None,\n        transactions: Optional[List[Transaction]] = None,\n        tax_year: int = datetime.now().year,\n        deductions: List[TaxDeduction] = None,\n        include_state: bool = True,\n        jurisdiction: TaxJurisdiction = TaxJurisdiction.FEDERAL,\n    ) -> TaxLiability:\n        \"\"\"\n        Calculate total tax liability.\n\n        Args:\n            transactions: List of all transactions\n            tax_year: Tax year to calculate for\n            deductions: List of tax deductions\n            include_state: Whether to include state tax calculations\n\n        Returns:\n            TaxLiability object with detailed tax information\n        \"\"\"\n        # Performance measurement\n        start_time = time.time()\n\n        # Calculate taxable income\n        if income is not None:\n            # Direct income provided\n            total_income = income\n            # Use standard deduction as default\n            std_deduction = self._standard_deduction.get(tax_year, {}).get(\n                self.filing_status,\n                12950,  # Default to 2022 single\n            )\n            total_deductions = std_deduction\n            taxable_income = max(0, total_income - total_deductions)\n        elif transactions is not None:\n            # Calculate from transactions\n            total_income, total_deductions, taxable_income = self.calculate_taxable_income(\n                transactions, tax_year, deductions\n            )\n        else:\n            raise ValueError(\"Either income or transactions must be provided\")\n\n        # Calculate federal income tax\n        federal_tax = self.calculate_federal_tax(taxable_income, tax_year)\n\n        # Calculate self-employment tax\n        # For this example, assume all income is business income\n        self_employment_tax = self.calculate_self_employment_tax(\n            total_income - total_deductions\n        )\n\n        # Calculate state tax (simplified example)\n        state_tax = 0.0\n        if include_state:\n            # Simplified: assume 5% flat state tax\n            state_tax = taxable_income * 0.05\n\n        # Calculate total tax\n        total_tax = federal_tax + self_employment_tax + state_tax\n\n        # Calculate effective and marginal rates\n        effective_rate = 0.0\n        if total_income > 0:\n            effective_rate = (total_tax / total_income) * 100\n\n        # Get federal brackets to determine marginal rate\n        brackets = self.get_tax_brackets(\n            TaxJurisdiction.FEDERAL, tax_year, self.filing_status\n        )\n        marginal_rate = 0.0\n\n        if brackets:\n            for i, threshold in enumerate(brackets.income_thresholds):\n                if i < len(brackets.income_thresholds) - 1:\n                    if taxable_income < brackets.income_thresholds[i + 1]:\n                        marginal_rate = brackets.rates[i]\n                        break\n                else:\n                    marginal_rate = brackets.rates[i]\n\n        # Create detailed breakdown\n        breakdown = {\n            \"federal_income_tax\": federal_tax,\n            \"self_employment_tax\": self_employment_tax,\n            \"state_tax\": state_tax,\n            \"total_tax\": total_tax,\n        }\n\n        # Create tax liability object\n        liability = TaxLiability(\n            jurisdiction=TaxJurisdiction.FEDERAL,  # Primary jurisdiction\n            tax_year=tax_year,\n            income=total_income,\n            deductions=total_deductions,\n            taxable_income=taxable_income,\n            tax_amount=total_tax,\n            effective_rate=effective_rate,\n            marginal_rate=marginal_rate,\n            filing_status=self.filing_status,\n            breakdown=breakdown,\n        )\n\n        # Verify performance requirement\n        elapsed_time = time.time() - start_time\n        if elapsed_time > 1.0:\n            print(\n                f\"Warning: Tax liability calculation took {elapsed_time:.2f} seconds, which exceeds the 1 second requirement\"\n            )\n\n        return liability\n\n    def calculate_quarterly_tax_payment(\n        self,\n        quarterly_taxable_income: float,\n        ytd_taxable_income: float,\n        tax_year: int,\n        quarter: int,\n        prior_payments: float = 0.0,\n    ) -> EstimatedPayment:\n        \"\"\"\n        Calculate estimated quarterly tax payment.\n\n        Args:\n            quarterly_taxable_income: Taxable income for the quarter\n            ytd_taxable_income: Year-to-date taxable income\n            tax_year: Tax year\n            quarter: Quarter number (1-4)\n            prior_payments: Sum of prior payments made this year\n\n        Returns:\n            EstimatedPayment object with payment details\n        \"\"\"\n        # Get quarter information\n        quarters = self.calculate_tax_quarters(tax_year)\n        quarter_info = next((q for q in quarters if q.quarter == quarter), None)\n        \n        if not quarter_info:\n            raise ValueError(f\"Invalid quarter: {quarter}\")\n            \n        # Calculate federal tax on YTD income\n        ytd_federal_tax = self.calculate_federal_tax(ytd_taxable_income, tax_year)\n        \n        # Calculate self-employment tax on YTD income (simplified)\n        ytd_se_tax = ytd_taxable_income * 0.15  # Approximate SE tax rate\n        \n        # Total YTD liability\n        ytd_liability = ytd_federal_tax + ytd_se_tax\n        \n        # Calculate payment based on quarter\n        if quarter == 1:\n            # First quarter - pay 25% of projected annual tax\n            payment_amount = ytd_liability * 0.25\n        else:\n            # For later quarters, adjust for prior payments\n            remaining_liability = ytd_liability - prior_payments\n            remaining_quarters = 5 - quarter  # Quarters remaining including current\n            \n            if remaining_quarters <= 0:\n                # Last quarter or past end of year\n                payment_amount = remaining_liability\n            else:\n                payment_amount = remaining_liability / remaining_quarters\n                \n        # Calculate safe harbor amount (simplified)\n        safe_harbor = ytd_liability * 0.225  # 90% of annual tax / 4\n        \n        # Create estimated payment object with federal tax component for test compatibility\n        payment = EstimatedPayment(\n            tax_year=tax_year,\n            quarter=quarter,\n            jurisdiction=TaxJurisdiction.FEDERAL,\n            due_date=quarter_info.due_date,\n            payment_amount=max(0, payment_amount),\n            minimum_required=max(0, min(payment_amount, safe_harbor)),\n            safe_harbor_amount=safe_harbor,\n            year_to_date_liability=ytd_liability,\n            previous_payments=prior_payments,\n            federal_tax=ytd_federal_tax * (quarter/4),\n            self_employment_tax=ytd_se_tax * (quarter/4),\n            notes=f\"Estimated Q{quarter} tax payment for {tax_year}\",\n        )\n        \n        return payment\n    \n    def calculate_estimated_payment(\n        self,\n        transactions: List[Transaction],\n        payments: List[TaxPayment],\n        tax_year: int,\n        quarter: int,\n        deductions: List[TaxDeduction] = None,\n    ) -> EstimatedPayment:\n        \"\"\"\n        Calculate estimated quarterly tax payment.\n\n        Args:\n            transactions: List of all transactions\n            payments: Previous tax payments\n            tax_year: Tax year\n            quarter: Quarter number (1-4)\n            deductions: List of tax deductions\n\n        Returns:\n            EstimatedPayment object with payment details\n        \"\"\"\n        # Get quarter information\n        quarters = self.calculate_tax_quarters(tax_year)\n        quarter_info = next((q for q in quarters if q.quarter == quarter), None)\n\n        if not quarter_info:\n            raise ValueError(f\"Invalid quarter: {quarter}\")\n\n        # Calculate year-to-date liability\n        ytd_transactions = [\n            t\n            for t in transactions\n            if t.date.year == tax_year and t.date <= quarter_info.end_date\n        ]\n\n        liability = self.calculate_tax_liability(ytd_transactions, tax_year, deductions)\n\n        # Get previous payments for this year\n        previous_payments_total = sum(\n            p.amount for p in payments if p.tax_year == tax_year and p.quarter < quarter\n        )\n\n        # Calculate required payment\n        # Basic rule: Pay 25% of annual liability each quarter\n        annual_projection = liability.tax_amount * (4 / quarter)  # Simple extrapolation\n\n        # Simplistic approach for safe harbor (for illustration)\n        # Safe harbor is typically 100% of previous year tax or 90% of current year\n        safe_harbor = (\n            annual_projection * 0.9 / 4\n        )  # 90% of projected annual tax divided by 4\n\n        # Required payment is remaining liability divided by remaining quarters\n        remaining_liability = liability.tax_amount - previous_payments_total\n        remaining_quarters = 5 - quarter  # Quarters remaining including current\n\n        if remaining_quarters <= 0:\n            # Last quarter or past end of year\n            suggested_amount = remaining_liability\n        else:\n            suggested_amount = remaining_liability / remaining_quarters\n\n        # Create estimated payment object\n        payment = EstimatedPayment(\n            tax_year=tax_year,\n            quarter=quarter,\n            jurisdiction=TaxJurisdiction.FEDERAL,\n            due_date=quarter_info.due_date,\n            suggested_amount=max(0, suggested_amount),\n            minimum_required=max(0, min(suggested_amount, safe_harbor)),\n            safe_harbor_amount=safe_harbor,\n            year_to_date_liability=liability.tax_amount,\n            previous_payments=previous_payments_total,\n            notes=f\"Estimated Q{quarter} tax payment for {tax_year}\",\n        )\n\n        return payment\n\n    def record_tax_payment(self, payment: TaxPayment) -> TaxPayment:\n        \"\"\"\n        Record a tax payment.\n\n        Args:\n            payment: Tax payment to record\n\n        Returns:\n            The recorded payment\n        \"\"\"\n        # In a real implementation, this would store the payment in a database\n        # For this example, we just return the payment\n        return payment\n\n    def get_tax_summary(\n        self,\n        transactions: List[Transaction],\n        payments: List[TaxPayment],\n        tax_year: int,\n        deductions: List[TaxDeduction] = None,\n    ) -> TaxYearSummary:\n        \"\"\"\n        Generate a summary of tax obligations for a year.\n\n        Args:\n            transactions: List of all transactions\n            payments: List of tax payments\n            tax_year: Tax year\n            deductions: List of tax deductions\n\n        Returns:\n            TaxYearSummary object with detailed tax information\n        \"\"\"\n        # Calculate liability\n        liability = self.calculate_tax_liability(transactions, tax_year, deductions)\n\n        # Filter to business transactions for the year\n        year_start = datetime(tax_year, 1, 1)\n        year_end = datetime(tax_year, 12, 31, 23, 59, 59)\n\n        year_transactions = [\n            t for t in transactions if year_start <= t.date <= year_end\n        ]\n\n        # Calculate income and expenses\n        income_transactions = [\n            t for t in year_transactions if t.transaction_type == TransactionType.INCOME\n        ]\n        total_income = sum(t.amount for t in income_transactions)\n\n        expense_transactions = [\n            t\n            for t in year_transactions\n            if (\n                t.transaction_type == TransactionType.EXPENSE\n                and t.category is not None\n                and t.category.name != \"PERSONAL\"\n                and t.business_use_percentage is not None\n            )\n        ]\n        total_expenses = sum(\n            t.amount * (t.business_use_percentage / 100) for t in expense_transactions\n        )\n\n        # Get total payments\n        year_payments = [p for p in payments if p.tax_year == tax_year]\n        total_paid = sum(p.amount for p in year_payments)\n\n        # Create summary\n        summary = TaxYearSummary(\n            tax_year=tax_year,\n            total_income=total_income,\n            total_expenses=total_expenses,\n            total_deductions=liability.deductions,\n            taxable_income=liability.taxable_income,\n            total_tax=liability.tax_amount,\n            effective_tax_rate=liability.effective_rate,\n            federal_tax=liability.breakdown[\"federal_income_tax\"],\n            state_tax=liability.breakdown.get(\"state_tax\", 0.0),\n            self_employment_tax=liability.breakdown[\"self_employment_tax\"],\n            total_paid=total_paid,\n            balance_due=max(0, liability.tax_amount - total_paid),\n            deductions=deductions or [],\n            payments=year_payments,\n        )\n\n        return summary\n\n    def compare_tax_years(\n        self,\n        transactions: List[Transaction],\n        payments: List[TaxPayment],\n        tax_year1: int,\n        tax_year2: int,\n        deductions1: List[TaxDeduction] = None,\n        deductions2: List[TaxDeduction] = None,\n    ) -> Dict[str, float]:\n        \"\"\"\n        Compare tax obligations between two years.\n\n        Args:\n            transactions: List of all transactions\n            payments: List of all payments\n            tax_year1: First tax year\n            tax_year2: Second tax year\n            deductions1: Deductions for first year\n            deductions2: Deductions for second year\n\n        Returns:\n            Dictionary with comparison metrics\n        \"\"\"\n        # Get summaries for both years\n        summary1 = self.get_tax_summary(transactions, payments, tax_year1, deductions1)\n        summary2 = self.get_tax_summary(transactions, payments, tax_year2, deductions2)\n\n        # Calculate differences\n        income_change = summary2.total_income - summary1.total_income\n        income_change_pct = (\n            (income_change / summary1.total_income * 100)\n            if summary1.total_income > 0\n            else 0\n        )\n\n        expense_change = summary2.total_expenses - summary1.total_expenses\n        expense_change_pct = (\n            (expense_change / summary1.total_expenses * 100)\n            if summary1.total_expenses > 0\n            else 0\n        )\n\n        tax_change = summary2.total_tax - summary1.total_tax\n        tax_change_pct = (\n            (tax_change / summary1.total_tax * 100) if summary1.total_tax > 0 else 0\n        )\n\n        effective_rate_change = (\n            summary2.effective_tax_rate - summary1.effective_tax_rate\n        )\n\n        # Create comparison result\n        comparison = {\n            \"income_change\": income_change,\n            \"income_change_pct\": income_change_pct,\n            \"expense_change\": expense_change,\n            \"expense_change_pct\": expense_change_pct,\n            \"tax_change\": tax_change,\n            \"tax_change_pct\": tax_change_pct,\n            \"effective_rate_change\": effective_rate_change,\n            \"year1\": summary1.tax_year,\n            \"year2\": summary2.tax_year,\n            \"year1_tax\": summary1.total_tax,\n            \"year2_tax\": summary2.total_tax,\n        }\n\n        return comparison\n\n    def optimize_deductions(\n        self,\n        transactions: List[Transaction],\n        potential_deductions: List[TaxDeduction],\n        tax_year: int,\n        target_liability: Optional[float] = None,\n    ) -> List[TaxDeduction]:\n        \"\"\"\n        Optimize tax deductions to minimize tax liability.\n\n        Args:\n            transactions: List of all transactions\n            potential_deductions: List of potential deductions to consider\n            tax_year: Tax year\n            target_liability: Optional target tax liability\n\n        Returns:\n            List of optimized deductions\n        \"\"\"\n        # Start with base liability without extra deductions\n        base_liability = self.calculate_tax_liability(transactions, tax_year)\n\n        # If no target, simply use all deductions\n        if target_liability is None:\n            return potential_deductions\n\n        # Sort deductions by amount (largest first)\n        sorted_deductions = sorted(\n            potential_deductions, key=lambda d: d.amount, reverse=True\n        )\n\n        # Start with no deductions\n        selected_deductions = []\n        current_liability = base_liability.tax_amount\n\n        # Add deductions until target is reached\n        for deduction in sorted_deductions:\n            # Calculate liability with this deduction\n            test_deductions = selected_deductions + [deduction]\n            test_liability = self.calculate_tax_liability(\n                transactions, tax_year, test_deductions\n            )\n\n            # If this reduces liability closer to target, add it\n            if abs(test_liability.tax_amount - target_liability) < abs(\n                current_liability - target_liability\n            ):\n                selected_deductions.append(deduction)\n                current_liability = test_liability.tax_amount\n\n            # If we've reached or gone below target, stop\n            if current_liability <= target_liability:\n                break\n\n        return selected_deductions"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/models.py": {
        "logprobs": -1275.1725551693646,
        "metrics": {
            "loc": 211,
            "sloc": 143,
            "lloc": 221,
            "comments": 13,
            "multi": 0,
            "blank": 41,
            "cyclomatic": 55,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/conftest.py": {
        "logprobs": -1464.8893444073685,
        "metrics": {
            "loc": 363,
            "sloc": 296,
            "lloc": 109,
            "comments": 22,
            "multi": 0,
            "blank": 46,
            "cyclomatic": 36,
            "internal_imports": [
                "class AccountType(str, Enum):\n    \"\"\"Account type enum.\"\"\"\n\n    CHECKING = \"checking\"\n    SAVINGS = \"savings\"\n    CREDIT_CARD = \"credit_card\"\n    INVESTMENT = \"investment\"\n    CASH = \"cash\"",
                "class Client(BaseModel):\n    \"\"\"Client model.\"\"\"\n\n    id: str\n    name: str\n    contact_email: Optional[str] = None\n    contact_phone: Optional[str] = None\n    address: Optional[str] = None\n    notes: Optional[str] = None\n    active: bool = True",
                "class ExpenseCategory(str, Enum):\n    \"\"\"Expense category enum.\"\"\"\n\n    BUSINESS_SUPPLIES = \"business_supplies\"\n    SOFTWARE = \"software\"\n    MARKETING = \"marketing\"\n    OFFICE_RENT = \"office_rent\"\n    UTILITIES = \"utilities\"\n    TRAVEL = \"travel\"\n    MEALS = \"meals\"\n    EQUIPMENT = \"equipment\"\n    PROFESSIONAL_DEVELOPMENT = \"professional_development\"\n    PROFESSIONAL_SERVICES = \"professional_services\"\n    HEALTH_INSURANCE = \"health_insurance\"\n    RETIREMENT = \"retirement\"\n    PHONE = \"phone\"\n    INTERNET = \"internet\"\n    CAR = \"car\"\n    HOME_OFFICE = \"home_office\"\n    PERSONAL = \"personal\"\n    OTHER = \"other\"",
                "class Invoice(BaseModel):\n    \"\"\"Invoice model.\"\"\"\n\n    id: str\n    client_id: str\n    project_id: Optional[str] = None\n    issue_date: datetime\n    due_date: datetime\n    amount: float\n    status: str  # e.g., \"draft\", \"sent\", \"paid\", \"overdue\"\n    payment_date: Optional[datetime] = None\n    description: Optional[str] = None\n    line_items: List[Dict] = Field(default_factory=list)",
                "class Project(BaseModel):\n    \"\"\"Project model.\"\"\"\n\n    id: str\n    name: str\n    client_id: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    status: str  # e.g., \"active\", \"completed\", \"on_hold\"\n    hourly_rate: Optional[float] = None\n    fixed_price: Optional[float] = None\n    estimated_hours: Optional[float] = None\n    description: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)",
                "class TimeEntry(BaseModel):\n    \"\"\"Time entry model for tracking hours worked on projects.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    project_id: str\n    start_time: datetime\n    end_time: Optional[datetime] = None\n    duration_minutes: Optional[float] = None\n    description: str\n    billable: bool = True\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"duration_minutes\", always=True)\n    def calculate_duration(cls, v, values):\n        \"\"\"Calculate duration from start and end time if not provided.\"\"\"\n        if v is not None:\n            return v\n        if (\n            \"start_time\" in values\n            and \"end_time\" in values\n            and values[\"end_time\"] is not None\n        ):\n            delta = values[\"end_time\"] - values[\"start_time\"]\n            return delta.total_seconds() / 60\n        return None",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\""
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/income/models.py": {
        "logprobs": -623.6031708249651,
        "metrics": {
            "loc": 95,
            "sloc": 65,
            "lloc": 100,
            "comments": 11,
            "multi": 0,
            "blank": 20,
            "cyclomatic": 19,
            "internal_imports": [
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/impact_measurement/impact.py": {
        "logprobs": -2929.8934773887913,
        "metrics": {
            "loc": 710,
            "sloc": 441,
            "lloc": 281,
            "comments": 90,
            "multi": 76,
            "blank": 123,
            "cyclomatic": 96,
            "internal_imports": [
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactMetric:\n    \"\"\"Model for defining and tracking impact metrics.\"\"\"\n    \n    metric_id: str\n    name: str\n    category: str\n    unit: str\n    description: str\n    higher_is_better: bool\n    data_source: str",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]",
                "class ImpactData:\n    \"\"\"Impact data for a specific investment in a specific year.\"\"\"\n    \n    investment_id: str\n    year: int\n    metrics: Dict[str, float]"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/test_impact_measurement/__init__.py": {
        "logprobs": -183.86320114615998,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/income/__init__.py": {
        "logprobs": -241.6657962841,
        "metrics": {
            "loc": 5,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 4,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/projection/financial_projector.py": {
        "logprobs": -2510.08247054267,
        "metrics": {
            "loc": 674,
            "sloc": 452,
            "lloc": 251,
            "comments": 84,
            "multi": 62,
            "blank": 85,
            "cyclomatic": 95,
            "internal_imports": [
                "class AccountBalance(BaseModel):\n    \"\"\"Account balance model.\"\"\"\n\n    account_id: str\n    account_name: str\n    account_type: AccountType\n    balance: float\n    as_of_date: datetime",
                "class ExpenseCategory(str, Enum):\n    \"\"\"Expense category enum.\"\"\"\n\n    BUSINESS_SUPPLIES = \"business_supplies\"\n    SOFTWARE = \"software\"\n    MARKETING = \"marketing\"\n    OFFICE_RENT = \"office_rent\"\n    UTILITIES = \"utilities\"\n    TRAVEL = \"travel\"\n    MEALS = \"meals\"\n    EQUIPMENT = \"equipment\"\n    PROFESSIONAL_DEVELOPMENT = \"professional_development\"\n    PROFESSIONAL_SERVICES = \"professional_services\"\n    HEALTH_INSURANCE = \"health_insurance\"\n    RETIREMENT = \"retirement\"\n    PHONE = \"phone\"\n    INTERNET = \"internet\"\n    CAR = \"car\"\n    HOME_OFFICE = \"home_office\"\n    PERSONAL = \"personal\"\n    OTHER = \"other\"",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class CashFlowProjection(BaseModel):\n    \"\"\"Cash flow projection for a specific timeframe.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    start_date: datetime\n    end_date: datetime\n    scenario: ProjectionScenario = ProjectionScenario.EXPECTED\n    starting_balance: float\n    ending_balance: float\n    total_income: float\n    total_expenses: float\n    net_cash_flow: float\n    monthly_breakdown: Dict[str, Dict[str, float]] = Field(default_factory=dict)\n    confidence_interval: float = 0.8  # 80% confidence interval by default\n    notes: Optional[str] = None\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class CashFlowProjection(BaseModel):\n    \"\"\"Cash flow projection for a specific timeframe.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    start_date: datetime\n    end_date: datetime\n    scenario: ProjectionScenario = ProjectionScenario.EXPECTED\n    starting_balance: float\n    ending_balance: float\n    total_income: float\n    total_expenses: float\n    net_cash_flow: float\n    monthly_breakdown: Dict[str, Dict[str, float]] = Field(default_factory=dict)\n    confidence_interval: float = 0.8  # 80% confidence interval by default\n    notes: Optional[str] = None\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class CashFlowProjection(BaseModel):\n    \"\"\"Cash flow projection for a specific timeframe.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    start_date: datetime\n    end_date: datetime\n    scenario: ProjectionScenario = ProjectionScenario.EXPECTED\n    starting_balance: float\n    ending_balance: float\n    total_income: float\n    total_expenses: float\n    net_cash_flow: float\n    monthly_breakdown: Dict[str, Dict[str, float]] = Field(default_factory=dict)\n    confidence_interval: float = 0.8  # 80% confidence interval by default\n    notes: Optional[str] = None\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class CashFlowProjection(BaseModel):\n    \"\"\"Cash flow projection for a specific timeframe.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    start_date: datetime\n    end_date: datetime\n    scenario: ProjectionScenario = ProjectionScenario.EXPECTED\n    starting_balance: float\n    ending_balance: float\n    total_income: float\n    total_expenses: float\n    net_cash_flow: float\n    monthly_breakdown: Dict[str, Dict[str, float]] = Field(default_factory=dict)\n    confidence_interval: float = 0.8  # 80% confidence interval by default\n    notes: Optional[str] = None\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class RunwayProjection(BaseModel):\n    \"\"\"Cash runway projection showing how long funds will last.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    starting_balance: float\n    spending_level: SpendingLevel\n    monthly_expense_rate: float\n    expected_income: Dict[str, float] = Field(default_factory=dict)  # Month -> amount\n    runway_months: float\n    depletion_date: Optional[datetime] = None\n    confidence_level: float = 0.8\n    notes: Optional[str] = None\n\n    @validator(\"confidence_level\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence level is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence level must be between 0 and 1\")\n        return v",
                "class RunwayProjection(BaseModel):\n    \"\"\"Cash runway projection showing how long funds will last.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    starting_balance: float\n    spending_level: SpendingLevel\n    monthly_expense_rate: float\n    expected_income: Dict[str, float] = Field(default_factory=dict)  # Month -> amount\n    runway_months: float\n    depletion_date: Optional[datetime] = None\n    confidence_level: float = 0.8\n    notes: Optional[str] = None\n\n    @validator(\"confidence_level\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence level is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence level must be between 0 and 1\")\n        return v",
                "class RunwayProjection(BaseModel):\n    \"\"\"Cash runway projection showing how long funds will last.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    starting_balance: float\n    spending_level: SpendingLevel\n    monthly_expense_rate: float\n    expected_income: Dict[str, float] = Field(default_factory=dict)  # Month -> amount\n    runway_months: float\n    depletion_date: Optional[datetime] = None\n    confidence_level: float = 0.8\n    notes: Optional[str] = None\n\n    @validator(\"confidence_level\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence level is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence level must be between 0 and 1\")\n        return v",
                "class RunwayProjection(BaseModel):\n    \"\"\"Cash runway projection showing how long funds will last.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    starting_balance: float\n    spending_level: SpendingLevel\n    monthly_expense_rate: float\n    expected_income: Dict[str, float] = Field(default_factory=dict)  # Month -> amount\n    runway_months: float\n    depletion_date: Optional[datetime] = None\n    confidence_level: float = 0.8\n    notes: Optional[str] = None\n\n    @validator(\"confidence_level\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence level is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence level must be between 0 and 1\")\n        return v",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class WhatIfScenario(BaseModel):\n    \"\"\"What-if scenario for financial planning.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    description: Optional[str] = None\n    base_scenario: ProjectionScenario\n    parameters: List[ScenarioParameter] = Field(default_factory=list)\n    result_metrics: Dict[str, float] = Field(default_factory=dict)\n    creation_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None",
                "class WhatIfScenario(BaseModel):\n    \"\"\"What-if scenario for financial planning.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    description: Optional[str] = None\n    base_scenario: ProjectionScenario\n    parameters: List[ScenarioParameter] = Field(default_factory=list)\n    result_metrics: Dict[str, float] = Field(default_factory=dict)\n    creation_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None",
                "class WhatIfScenario(BaseModel):\n    \"\"\"What-if scenario for financial planning.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    description: Optional[str] = None\n    base_scenario: ProjectionScenario\n    parameters: List[ScenarioParameter] = Field(default_factory=list)\n    result_metrics: Dict[str, float] = Field(default_factory=dict)\n    creation_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None",
                "class WhatIfScenario(BaseModel):\n    \"\"\"What-if scenario for financial planning.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    description: Optional[str] = None\n    base_scenario: ProjectionScenario\n    parameters: List[ScenarioParameter] = Field(default_factory=list)\n    result_metrics: Dict[str, float] = Field(default_factory=dict)\n    creation_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None",
                "class EmergencyFundAssessment(BaseModel):\n    \"\"\"Assessment of emergency fund adequacy.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    assessment_date: datetime = Field(default_factory=datetime.now)\n    current_fund_balance: float\n    monthly_essential_expenses: float\n    recommended_months_coverage: float = 6.0\n    recommended_fund_size: float\n    current_coverage_months: float\n    adequacy_level: str  # e.g., \"inadequate\", \"minimal\", \"adequate\", \"excellent\"\n    funding_plan: Optional[str] = None\n    notes: Optional[str] = None",
                "class EmergencyFundAssessment(BaseModel):\n    \"\"\"Assessment of emergency fund adequacy.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    assessment_date: datetime = Field(default_factory=datetime.now)\n    current_fund_balance: float\n    monthly_essential_expenses: float\n    recommended_months_coverage: float = 6.0\n    recommended_fund_size: float\n    current_coverage_months: float\n    adequacy_level: str  # e.g., \"inadequate\", \"minimal\", \"adequate\", \"excellent\"\n    funding_plan: Optional[str] = None\n    notes: Optional[str] = None",
                "class EmergencyFundAssessment(BaseModel):\n    \"\"\"Assessment of emergency fund adequacy.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    assessment_date: datetime = Field(default_factory=datetime.now)\n    current_fund_balance: float\n    monthly_essential_expenses: float\n    recommended_months_coverage: float = 6.0\n    recommended_fund_size: float\n    current_coverage_months: float\n    adequacy_level: str  # e.g., \"inadequate\", \"minimal\", \"adequate\", \"excellent\"\n    funding_plan: Optional[str] = None\n    notes: Optional[str] = None",
                "class EmergencyFundAssessment(BaseModel):\n    \"\"\"Assessment of emergency fund adequacy.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    assessment_date: datetime = Field(default_factory=datetime.now)\n    current_fund_balance: float\n    monthly_essential_expenses: float\n    recommended_months_coverage: float = 6.0\n    recommended_fund_size: float\n    current_coverage_months: float\n    adequacy_level: str  # e.g., \"inadequate\", \"minimal\", \"adequate\", \"excellent\"\n    funding_plan: Optional[str] = None\n    notes: Optional[str] = None"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/__init__.py": {
        "logprobs": -253.5306998395016,
        "metrics": {
            "loc": 7,
            "sloc": 1,
            "lloc": 2,
            "comments": 0,
            "multi": 4,
            "blank": 2,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/setup.py": {
        "logprobs": -190.4994605767017,
        "metrics": {
            "loc": 14,
            "sloc": 13,
            "lloc": 2,
            "comments": 0,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/tax/__init__.py": {
        "logprobs": -189.00018263343998,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/projection/__init__.py": {
        "logprobs": -191.0744433451,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/__init__.py": {
        "logprobs": -188.087841629733,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/shareholder_advocacy/__init__.py": {
        "logprobs": -197.83749044584496,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/portfolio_analysis/analysis.py": {
        "logprobs": -4100.516108936571,
        "metrics": {
            "loc": 1051,
            "sloc": 664,
            "lloc": 457,
            "comments": 144,
            "multi": 82,
            "blank": 179,
            "cyclomatic": 147,
            "internal_imports": [
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class InvestmentHolding:\n    \"\"\"A specific holding of an investment in a portfolio.\"\"\"\n    \n    investment_id: str\n    shares: float\n    purchase_price: float\n    purchase_date: date\n    current_price: float\n    current_value: float\n    \n    def __post_init__(self):\n        \"\"\"Validate that current_value = shares * current_price.\"\"\"\n        expected_value = self.shares * self.current_price\n        if abs(self.current_value - expected_value) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Current value {self.current_value} does not match shares * price {expected_value}\")\n    \n    @property\n    def return_percentage(self) -> float:\n        \"\"\"Calculate the percentage return on this holding.\"\"\"\n        return (self.current_price / self.purchase_price - 1) * 100",
                "class EthicalScreener:\n    \"\"\"Evaluates investments against customizable ethical criteria.\"\"\"\n    \n    def __init__(self, criteria: EthicalCriteria):\n        \"\"\"Initialize with the given ethical criteria.\n        \n        Args:\n            criteria: The ethical criteria to use for screening\n        \"\"\"\n        self.criteria = criteria\n        \n    @staticmethod\n    def generate_criteria_from_survey(survey_responses: Dict[str, Any]) -> EthicalCriteria:\n        \"\"\"Generate ethical criteria from user survey responses.\n        \n        Args:\n            survey_responses: Dictionary containing survey responses with keys:\n                - top_concerns: List of user's top ethical concerns\n                - industries_to_avoid: List of industries to exclude\n                - industries_to_support: List of industries to prioritize\n                - relative_importance: Dict with weights for environmental, social, governance\n                - environmental_priorities: List of environmental priorities\n                - social_priorities: List of social priorities  \n                - governance_priorities: List of governance priorities\n                \n        Returns:\n            EthicalCriteria object based on survey responses\n        \"\"\"\n        # Calculate weights based on relative importance\n        total_importance = sum(survey_responses[\"relative_importance\"].values())\n        env_weight = survey_responses[\"relative_importance\"][\"environmental\"] / total_importance\n        social_weight = survey_responses[\"relative_importance\"][\"social\"] / total_importance\n        gov_weight = survey_responses[\"relative_importance\"][\"governance\"] / total_importance\n        \n        # Create environmental criteria\n        environmental = {\n            \"weight\": env_weight,\n            \"min_environmental_score\": 60\n        }\n        \n        if \"carbon_reduction\" in survey_responses[\"environmental_priorities\"]:\n            environmental[\"max_carbon_footprint\"] = 50000000\n            \n        if \"renewable_energy\" in survey_responses[\"environmental_priorities\"]:\n            environmental[\"min_renewable_energy_use\"] = 0.5\n            \n        if \"fossil_fuels\" in survey_responses[\"industries_to_avoid\"]:\n            environmental[\"exclude_fossil_fuel_production\"] = True\n            \n        # Create social criteria\n        social = {\n            \"weight\": social_weight,\n            \"min_social_score\": 60\n        }\n        \n        if \"diversity\" in survey_responses[\"social_priorities\"]:\n            social[\"min_diversity_score\"] = 0.65\n            \n        if \"human_rights\" in survey_responses[\"top_concerns\"]:\n            social[\"exclude_human_rights_violations\"] = True\n            \n        if \"weapons\" in survey_responses[\"industries_to_avoid\"]:\n            social[\"exclude_weapons_manufacturing\"] = True\n            \n        # Create governance criteria\n        governance = {\n            \"weight\": gov_weight,\n            \"min_governance_score\": 60\n        }\n        \n        if \"board_diversity\" in survey_responses[\"governance_priorities\"]:\n            governance[\"min_board_independence\"] = 0.65\n            \n        if \"executive_compensation\" in survey_responses[\"governance_priorities\"]:\n            governance[\"exclude_excessive_executive_compensation\"] = True\n            \n        # Create the criteria\n        return EthicalCriteria(\n            criteria_id=\"user-personalized\",\n            name=\"User Personalized Criteria\",\n            environmental=environmental,\n            social=social,\n            governance=governance,\n            min_overall_score=65,\n            exclusions=survey_responses[\"industries_to_avoid\"],\n            inclusions=survey_responses[\"industries_to_support\"]\n        )\n    \n    def screen_investment(self, investment: Investment) -> ScreeningResult:\n        \"\"\"Screen a single investment against the ethical criteria.\n        \n        Args:\n            investment: The investment to screen\n            \n        Returns:\n            A ScreeningResult with the screening outcome\n        \"\"\"\n        # Start timing for performance benchmarking\n        start_time = time.time()\n        \n        # Check for exclusions (immediate disqualification)\n        exclusion_flags = self._check_exclusions(investment)\n        \n        # Check for inclusions (positive attributes)\n        inclusion_flags = self._check_inclusions(investment)\n        \n        # Evaluate environmental criteria\n        env_score, env_details = self._evaluate_environmental_criteria(investment)\n        \n        # Evaluate social criteria\n        social_score, social_details = self._evaluate_social_criteria(investment)\n        \n        # Evaluate governance criteria\n        gov_score, gov_details = self._evaluate_governance_criteria(investment)\n        \n        # Calculate weighted overall score\n        overall_score = (\n            env_score * self.criteria.environmental[\"weight\"] +\n            social_score * self.criteria.social[\"weight\"] +\n            gov_score * self.criteria.governance[\"weight\"]\n        )\n        \n        # Determine if the investment passes the screening\n        passes = (\n            len(exclusion_flags) == 0 and  # No exclusion criteria violated\n            overall_score >= self.criteria.min_overall_score\n        )\n        \n        # Compile detailed results\n        details = {\n            \"environmental\": env_details,\n            \"social\": social_details,\n            \"governance\": gov_details,\n            \"processing_time_ms\": (time.time() - start_time) * 1000\n        }\n        \n        return ScreeningResult(\n            investment_id=investment.id,\n            passed=passes,\n            overall_score=overall_score,\n            environmental_score=env_score,\n            social_score=social_score,\n            governance_score=gov_score,\n            exclusion_flags=exclusion_flags,\n            inclusion_flags=inclusion_flags,\n            details=details\n        )\n    \n    def screen_investments(self, investments: List[Investment]) -> Dict[str, ScreeningResult]:\n        \"\"\"Screen multiple investments against the ethical criteria.\n        \n        Args:\n            investments: List of investments to screen\n            \n        Returns:\n            Dict mapping investment IDs to their screening results\n        \"\"\"\n        start_time = time.time()\n        results = {}\n        \n        for investment in investments:\n            results[investment.id] = self.screen_investment(investment)\n        \n        total_time = time.time() - start_time\n        print(f\"Screened {len(investments)} investments in {total_time:.2f} seconds\")\n        \n        return results\n    \n    def _check_exclusions(self, investment: Investment) -> List[str]:\n        \"\"\"Check if the investment violates any exclusion criteria.\n        \n        Args:\n            investment: The investment to check\n            \n        Returns:\n            List of exclusion flags that apply to this investment\n        \"\"\"\n        exclusion_flags = []\n        \n        # Check industry exclusions (from the top-level exclusions list)\n        for exclusion in self.criteria.exclusions:\n            # Direct match on industry\n            if investment.industry.lower() == exclusion.lower():\n                exclusion_flags.append(f\"excluded_industry:{investment.industry}\")\n            \n            # Direct match on sector\n            if investment.sector.lower() == exclusion.lower():\n                exclusion_flags.append(f\"excluded_sector:{investment.sector}\")\n                \n            # Partial match on industry name (handles cases like \"fossil_fuels\" vs \"Oil & Gas\")\n            if exclusion.lower() in [\"fossil_fuels\", \"fossil_fuel\"] and \"oil\" in investment.industry.lower():\n                exclusion_flags.append(f\"excluded_fossil_fuels_industry:{investment.industry}\")\n                \n            # Check for related terms in industry or sector\n            for term in exclusion.lower().split(\"_\"):\n                if len(term) > 3:  # Only use meaningful words, not short ones\n                    if term in investment.industry.lower() or term in investment.sector.lower():\n                        exclusion_flags.append(f\"excluded_term:{term}\")\n        \n        # Check environmental exclusions\n        if (self.criteria.environmental.get(\"exclude_fossil_fuel_production\", False) and\n                (\"fossil_fuel_production\" in [p.lower() for p in investment.positive_practices + investment.controversies] \n                 or \"oil\" in investment.industry.lower())):\n            exclusion_flags.append(\"fossil_fuel_production\")\n        \n        # Check social exclusions\n        if (self.criteria.social.get(\"exclude_human_rights_violations\", False) and\n                any(\"human_rights\" in c.lower() for c in investment.controversies)):\n            exclusion_flags.append(\"human_rights_violations\")\n            \n        if (self.criteria.social.get(\"exclude_weapons_manufacturing\", False) and\n                \"weapons_manufacturing\" in [p.lower() for p in investment.positive_practices + investment.controversies]):\n            exclusion_flags.append(\"weapons_manufacturing\")\n        \n        # Check governance exclusions\n        if (self.criteria.governance.get(\"exclude_excessive_executive_compensation\", False) and\n                any(\"compensation\" in c.lower() for c in investment.controversies)):\n            exclusion_flags.append(\"excessive_executive_compensation\")\n        \n        return exclusion_flags\n    \n    def _check_inclusions(self, investment: Investment) -> List[str]:\n        \"\"\"Check if the investment matches any inclusion criteria.\n        \n        Args:\n            investment: The investment to check\n            \n        Returns:\n            List of inclusion flags that apply to this investment\n        \"\"\"\n        inclusion_flags = []\n        \n        # Check industry inclusions\n        if investment.industry.lower() in [i.lower() for i in self.criteria.inclusions]:\n            inclusion_flags.append(f\"preferred_industry:{investment.industry}\")\n        \n        # Check sector inclusions\n        if investment.sector.lower() in [i.lower() for i in self.criteria.inclusions]:\n            inclusion_flags.append(f\"preferred_sector:{investment.sector}\")\n        \n        # Check positive practices\n        for practice in investment.positive_practices:\n            if practice.lower() in [i.lower() for i in self.criteria.inclusions]:\n                inclusion_flags.append(f\"positive_practice:{practice}\")\n        \n        return inclusion_flags\n    \n    def _evaluate_environmental_criteria(self, investment: Investment) -> Tuple[float, Dict[str, Any]]:\n        \"\"\"Evaluate the investment against environmental criteria.\n        \n        Args:\n            investment: The investment to evaluate\n            \n        Returns:\n            Tuple of (score, details) where score is 0-100 and details contains the reasoning\n        \"\"\"\n        env_criteria = self.criteria.environmental\n        details = {}\n        \n        # Start with the ESG environmental score\n        base_score = investment.esg_ratings.environmental\n        details[\"base_score\"] = base_score\n        \n        # Adjust for carbon footprint\n        if \"max_carbon_footprint\" in env_criteria:\n            max_carbon = env_criteria[\"max_carbon_footprint\"]\n            if investment.carbon_footprint <= max_carbon:\n                carbon_ratio = investment.carbon_footprint / max_carbon\n                carbon_score = 100 - (carbon_ratio * 100)\n                details[\"carbon_footprint_score\"] = carbon_score\n            else:\n                # Exceeds maximum carbon footprint\n                carbon_penalty = min(30, (investment.carbon_footprint / max_carbon - 1) * 20)\n                base_score -= carbon_penalty\n                details[\"carbon_footprint_penalty\"] = carbon_penalty\n        \n        # Adjust for renewable energy use\n        if \"min_renewable_energy_use\" in env_criteria:\n            min_renewable = env_criteria[\"min_renewable_energy_use\"]\n            if investment.renewable_energy_use >= min_renewable:\n                renewable_bonus = (investment.renewable_energy_use - min_renewable) * 50\n                base_score += renewable_bonus\n                details[\"renewable_energy_bonus\"] = renewable_bonus\n            else:\n                # Below minimum renewable energy use\n                renewable_penalty = min(20, (min_renewable - investment.renewable_energy_use) * 40)\n                base_score -= renewable_penalty\n                details[\"renewable_energy_penalty\"] = renewable_penalty\n        \n        # Apply minimum environmental score threshold\n        if \"min_environmental_score\" in env_criteria:\n            min_score = env_criteria[\"min_environmental_score\"]\n            if base_score < min_score:\n                details[\"below_min_threshold\"] = True\n        \n        # Cap the final score at 100\n        final_score = max(0, min(100, base_score))\n        details[\"final_score\"] = final_score\n        \n        return final_score, details\n    \n    def _evaluate_social_criteria(self, investment: Investment) -> Tuple[float, Dict[str, Any]]:\n        \"\"\"Evaluate the investment against social criteria.\n        \n        Args:\n            investment: The investment to evaluate\n            \n        Returns:\n            Tuple of (score, details) where score is 0-100 and details contains the reasoning\n        \"\"\"\n        social_criteria = self.criteria.social\n        details = {}\n        \n        # Start with the ESG social score\n        base_score = investment.esg_ratings.social\n        details[\"base_score\"] = base_score\n        \n        # Adjust for diversity score\n        if \"min_diversity_score\" in social_criteria:\n            min_diversity = social_criteria[\"min_diversity_score\"]\n            if investment.diversity_score >= min_diversity:\n                diversity_bonus = (investment.diversity_score - min_diversity) * 50\n                base_score += diversity_bonus\n                details[\"diversity_bonus\"] = diversity_bonus\n            else:\n                # Below minimum diversity score\n                diversity_penalty = min(20, (min_diversity - investment.diversity_score) * 40)\n                base_score -= diversity_penalty\n                details[\"diversity_penalty\"] = diversity_penalty\n        \n        # Adjust for controversies\n        controversy_count = len(investment.controversies)\n        if controversy_count > 0:\n            # More controversies means a larger penalty\n            controversy_penalty = min(30, controversy_count * 10)\n            base_score -= controversy_penalty\n            details[\"controversy_penalty\"] = controversy_penalty\n            details[\"controversies\"] = investment.controversies\n        \n        # Apply minimum social score threshold\n        if \"min_social_score\" in social_criteria:\n            min_score = social_criteria[\"min_social_score\"]\n            if base_score < min_score:\n                details[\"below_min_threshold\"] = True\n        \n        # Cap the final score at 100\n        final_score = max(0, min(100, base_score))\n        details[\"final_score\"] = final_score\n        \n        return final_score, details\n    \n    def _evaluate_governance_criteria(self, investment: Investment) -> Tuple[float, Dict[str, Any]]:\n        \"\"\"Evaluate the investment against governance criteria.\n        \n        Args:\n            investment: The investment to evaluate\n            \n        Returns:\n            Tuple of (score, details) where score is 0-100 and details contains the reasoning\n        \"\"\"\n        gov_criteria = self.criteria.governance\n        details = {}\n        \n        # Start with the ESG governance score\n        base_score = investment.esg_ratings.governance\n        details[\"base_score\"] = base_score\n        \n        # Adjust for board independence\n        if \"min_board_independence\" in gov_criteria:\n            min_independence = gov_criteria[\"min_board_independence\"]\n            if investment.board_independence >= min_independence:\n                independence_bonus = (investment.board_independence - min_independence) * 50\n                base_score += independence_bonus\n                details[\"board_independence_bonus\"] = independence_bonus\n            else:\n                # Below minimum board independence\n                independence_penalty = min(20, (min_independence - investment.board_independence) * 40)\n                base_score -= independence_penalty\n                details[\"board_independence_penalty\"] = independence_penalty\n        \n        # Apply minimum governance score threshold\n        if \"min_governance_score\" in gov_criteria:\n            min_score = gov_criteria[\"min_governance_score\"]\n            if base_score < min_score:\n                details[\"below_min_threshold\"] = True\n        \n        # Cap the final score at 100\n        final_score = max(0, min(100, base_score))\n        details[\"final_score\"] = final_score\n        \n        return final_score, details",
                "class ScreeningResult:\n    \"\"\"Result of screening an investment against ethical criteria.\"\"\"\n    \n    investment_id: str\n    passed: bool\n    overall_score: float\n    environmental_score: float\n    social_score: float\n    governance_score: float\n    exclusion_flags: List[str]\n    inclusion_flags: List[str]\n    details: Dict[str, Any]"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/test_shareholder_advocacy/__init__.py": {
        "logprobs": -193.60925484185,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/projection/models.py": {
        "logprobs": -859.7642620738305,
        "metrics": {
            "loc": 144,
            "sloc": 99,
            "lloc": 174,
            "comments": 12,
            "multi": 0,
            "blank": 32,
            "cyclomatic": 27,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/values_budgeting/__init__.py": {
        "logprobs": -204.57784938808697,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/shareholder_advocacy/advocacy.py": {
        "logprobs": -2254.573697560327,
        "metrics": {
            "loc": 547,
            "sloc": 350,
            "lloc": 275,
            "comments": 61,
            "multi": 52,
            "blank": 93,
            "cyclomatic": 131,
            "internal_imports": [
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Investment:\n    \"\"\"Model representing an investment opportunity with ESG attributes.\"\"\"\n    \n    id: str\n    name: str\n    sector: str\n    industry: str\n    market_cap: float\n    price: float\n    esg_ratings: Union[ESGRating, Dict[str, Any]]\n    carbon_footprint: float\n    renewable_energy_use: float\n    diversity_score: float\n    board_independence: float\n    controversies: List[str] = field(default_factory=list)\n    positive_practices: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        \"\"\"Convert dictionary esg_ratings to ESGRating object if necessary.\"\"\"\n        if isinstance(self.esg_ratings, dict):\n            self.esg_ratings = ESGRating(\n                environmental=self.esg_ratings[\"environmental\"],\n                social=self.esg_ratings[\"social\"],\n                governance=self.esg_ratings[\"governance\"],\n                overall=self.esg_ratings[\"overall\"]\n            )\n    \n    @property\n    def has_major_controversies(self) -> bool:\n        \"\"\"Check if the investment has major controversies.\"\"\"\n        major_issues = [\"human_rights\", \"fraud\", \"corruption\", \"environmental_disaster\"]\n        return any(issue in self.controversies for issue in major_issues)",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class Portfolio:\n    \"\"\"A collection of investment holdings.\"\"\"\n    \n    portfolio_id: str\n    name: str\n    holdings: List[Union[InvestmentHolding, Dict[str, Any]]]\n    total_value: float\n    cash_balance: float\n    creation_date: date\n    last_updated: date\n    \n    def __post_init__(self):\n        \"\"\"Validate that total_value equals the sum of all holdings' values and convert dict holdings to InvestmentHolding objects.\"\"\"\n        # Convert dictionary holdings to InvestmentHolding objects\n        for i, holding in enumerate(self.holdings):\n            if isinstance(holding, dict):\n                # Convert any string dates to date objects\n                if isinstance(holding.get(\"purchase_date\"), str):\n                    holding[\"purchase_date\"] = date.fromisoformat(holding[\"purchase_date\"])\n                \n                self.holdings[i] = InvestmentHolding(**holding)\n        \n        # Now validate total value\n        holdings_sum = sum(holding.current_value for holding in self.holdings)\n        if abs(self.total_value - holdings_sum) > 0.01:  # Allow for small rounding errors\n            raise ValueError(f\"Total value {self.total_value} does not match holdings sum {holdings_sum}\")\n    \n    @property\n    def total_assets(self) -> float:\n        \"\"\"Calculate total assets including cash.\"\"\"\n        return self.total_value + self.cash_balance",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")",
                "class ShareholderResolution:\n    \"\"\"Model representing a shareholder resolution with voting results.\"\"\"\n    \n    company_id: str\n    resolution_id: str\n    year: int\n    title: str\n    category: str\n    subcategory: str\n    proposed_by: str\n    status: str\n    votes_for: Optional[float] = None\n    votes_against: Optional[float] = None\n    abstentions: Optional[float] = None\n    company_recommendation: Optional[str] = None\n    outcome: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"Validate that vote percentages sum to approximately 1.\"\"\"\n        if all(val is not None for val in [self.votes_for, self.votes_against, self.abstentions]):\n            vote_sum = self.votes_for + self.votes_against + self.abstentions\n            if abs(vote_sum - 1.0) > 0.01:  # Allow for small rounding errors\n                raise ValueError(f\"Vote percentages sum to {vote_sum}, expected 1.0\")"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/projection/__init__.py": {
        "logprobs": -250.401945474615,
        "metrics": {
            "loc": 5,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 4,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/test_portfolio_analysis/__init__.py": {
        "logprobs": -175.684480669426,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/expense/__init__.py": {
        "logprobs": -190.97974777655,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/conftest.py": {
        "logprobs": -1881.462511947117,
        "metrics": {
            "loc": 385,
            "sloc": 366,
            "lloc": 53,
            "comments": 12,
            "multi": 0,
            "blank": 11,
            "cyclomatic": 9,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/values_budgeting/budgeting.py": {
        "logprobs": -4822.577230425842,
        "metrics": {
            "loc": 1141,
            "sloc": 772,
            "lloc": 514,
            "comments": 133,
            "multi": 68,
            "blank": 179,
            "cyclomatic": 218,
            "internal_imports": [
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)",
                "class Transaction:\n    \"\"\"Model representing a personal financial transaction.\"\"\"\n    \n    id: str\n    date: date\n    amount: float\n    vendor: str\n    category: str\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/models/common.py": {
        "logprobs": -744.0887529819041,
        "metrics": {
            "loc": 191,
            "sloc": 136,
            "lloc": 222,
            "comments": 4,
            "multi": 0,
            "blank": 40,
            "cyclomatic": 30,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/project/__init__.py": {
        "logprobs": -192.86347389700998,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/project/models.py": {
        "logprobs": -644.5963382322752,
        "metrics": {
            "loc": 114,
            "sloc": 78,
            "lloc": 125,
            "comments": 6,
            "multi": 0,
            "blank": 27,
            "cyclomatic": 22,
            "internal_imports": [
                "class Project(BaseModel):\n    \"\"\"Project model.\"\"\"\n\n    id: str\n    name: str\n    client_id: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    status: str  # e.g., \"active\", \"completed\", \"on_hold\"\n    hourly_rate: Optional[float] = None\n    fixed_price: Optional[float] = None\n    estimated_hours: Optional[float] = None\n    description: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)",
                "class TimeEntry(BaseModel):\n    \"\"\"Time entry model for tracking hours worked on projects.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    project_id: str\n    start_time: datetime\n    end_time: Optional[datetime] = None\n    duration_minutes: Optional[float] = None\n    description: str\n    billable: bool = True\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"duration_minutes\", always=True)\n    def calculate_duration(cls, v, values):\n        \"\"\"Calculate duration from start and end time if not provided.\"\"\"\n        if v is not None:\n            return v\n        if (\n            \"start_time\" in values\n            and \"end_time\" in values\n            and values[\"end_time\"] is not None\n        ):\n            delta = values[\"end_time\"] - values[\"start_time\"]\n            return delta.total_seconds() / 60\n        return None",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/portfolio_analysis/__init__.py": {
        "logprobs": -187.22582435622002,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/tests/projection/_test_financial_projector_simple.py": {
        "logprobs": -709.9074704493456,
        "metrics": {
            "loc": 107,
            "sloc": 78,
            "lloc": 38,
            "comments": 6,
            "multi": 0,
            "blank": 18,
            "cyclomatic": 20,
            "internal_imports": [
                "class ExpenseCategory(str, Enum):\n    \"\"\"Expense category enum.\"\"\"\n\n    BUSINESS_SUPPLIES = \"business_supplies\"\n    SOFTWARE = \"software\"\n    MARKETING = \"marketing\"\n    OFFICE_RENT = \"office_rent\"\n    UTILITIES = \"utilities\"\n    TRAVEL = \"travel\"\n    MEALS = \"meals\"\n    EQUIPMENT = \"equipment\"\n    PROFESSIONAL_DEVELOPMENT = \"professional_development\"\n    PROFESSIONAL_SERVICES = \"professional_services\"\n    HEALTH_INSURANCE = \"health_insurance\"\n    RETIREMENT = \"retirement\"\n    PHONE = \"phone\"\n    INTERNET = \"internet\"\n    CAR = \"car\"\n    HOME_OFFICE = \"home_office\"\n    PERSONAL = \"personal\"\n    OTHER = \"other\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class SpendingLevel(str, Enum):\n    \"\"\"Spending level for cash runway projections.\"\"\"\n\n    MINIMAL = \"minimal\"  # Essential expenses only\n    REDUCED = \"reduced\"  # Reduced discretionary spending\n    NORMAL = \"normal\"  # Normal spending patterns\n    INCREASED = \"increased\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class ProjectionScenario(str, Enum):\n    \"\"\"Scenario types for financial projections.\"\"\"\n\n    PESSIMISTIC = \"pessimistic\"\n    CONSERVATIVE = \"conservative\"\n    EXPECTED = \"expected\"\n    OPTIMISTIC = \"optimistic\"",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class RevenueSource(BaseModel):\n    \"\"\"Revenue source for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    probability: float = 100.0  # Percentage probability of receiving this income\n    expected_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    notes: Optional[str] = None\n\n    @validator(\"probability\")\n    def validate_probability(cls, v):\n        \"\"\"Validate probability is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Probability must be between 0 and 100\")\n        return v",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ExpenseItem(BaseModel):\n    \"\"\"Expense item for cash flow projections.\"\"\"\n\n    name: str\n    amount: float\n    category: str\n    due_date: Optional[datetime] = None\n    recurring: bool = False\n    recurrence_frequency: Optional[str] = None  # e.g., \"monthly\", \"quarterly\"\n    essential: bool = False  # Whether this is an essential expense\n    notes: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class ScenarioParameter(BaseModel):\n    \"\"\"Parameter for what-if scenario analysis.\"\"\"\n\n    name: str\n    description: Optional[str] = None\n    current_value: float\n    min_value: float\n    max_value: float\n    step_size: float = 1.0\n    unit: Optional[str] = None",
                "class FinancialProjector:\n    \"\"\"\n    Financial projection model for freelancers.\n\n    This class provides cash flow forecasting, runway calculations,\n    what-if analysis, and emergency fund assessment.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the financial projector.\"\"\"\n        self._projection_cache = {}\n\n    def project_cash_flow(\n        self,\n        starting_balance: float,\n        current_date: datetime,\n        months_ahead: int,\n        revenue_sources: List[RevenueSource],\n        expense_items: List[ExpenseItem],\n        scenario: ProjectionScenario = ProjectionScenario.EXPECTED,\n        historical_transactions: Optional[List[Transaction]] = None,\n        confidence_interval: float = 0.8,\n    ) -> CashFlowProjection:\n        \"\"\"\n        Project cash flow for a specific timeframe.\n\n        Args:\n            starting_balance: Current cash balance\n            current_date: Start date for projection\n            months_ahead: Number of months to project\n            revenue_sources: Expected revenue sources\n            expense_items: Expected expenses\n            scenario: Projection scenario\n            historical_transactions: Optional historical transactions for trend analysis\n            confidence_interval: Confidence interval for projections\n\n        Returns:\n            CashFlowProjection object with detailed cash flow projection\n        \"\"\"\n        # Performance measurement\n        start_time = time.time()\n\n        # Calculate dates\n        start_date = datetime(current_date.year, current_date.month, 1)\n        end_month = current_date.month + months_ahead\n        end_year = current_date.year + (end_month - 1) // 12\n        end_month = ((end_month - 1) % 12) + 1\n        end_date = datetime(\n            end_year, end_month, calendar.monthrange(end_year, end_month)[1]\n        )\n\n        # Generate month strings for the projection period\n        months = []\n        current_month = start_date\n        while current_month <= end_date:\n            months.append(current_month.strftime(\"%Y-%m\"))\n\n            # Move to next month\n            month = current_month.month + 1\n            year = current_month.year + (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n            current_month = datetime(year, month, 1)\n\n        # Initialize monthly breakdown\n        monthly_breakdown = {\n            month: {\"income\": 0.0, \"expenses\": 0.0, \"balance\": 0.0} for month in months\n        }\n\n        # Apply scenario adjustments\n        income_multiplier = self._get_scenario_income_multiplier(scenario)\n        expense_multiplier = self._get_scenario_expense_multiplier(scenario)\n\n        # Process revenue sources\n        for revenue in revenue_sources:\n            if revenue.recurring:\n                # Add recurring revenue to each month\n                self._add_recurring_item(\n                    monthly_breakdown,\n                    revenue,\n                    start_date,\n                    end_date,\n                    \"income\",\n                    income_multiplier,\n                )\n            elif revenue.expected_date:\n                # Add one-time revenue\n                month_key = revenue.expected_date.strftime(\"%Y-%m\")\n                if month_key in monthly_breakdown:\n                    # Apply probability and scenario adjustment\n                    adjusted_amount = (\n                        revenue.amount * (revenue.probability / 100) * income_multiplier\n                    )\n                    monthly_breakdown[month_key][\"income\"] += adjusted_amount\n\n        # Process expenses\n        for expense in expense_items:\n            if expense.recurring:\n                # Add recurring expense to each month\n                self._add_recurring_item(\n                    monthly_breakdown,\n                    expense,\n                    start_date,\n                    end_date,\n                    \"expenses\",\n                    expense_multiplier,\n                )\n            elif expense.due_date:\n                # Add one-time expense\n                month_key = expense.due_date.strftime(\"%Y-%m\")\n                if month_key in monthly_breakdown:\n                    # Apply scenario adjustment\n                    adjusted_amount = expense.amount * expense_multiplier\n                    monthly_breakdown[month_key][\"expenses\"] += adjusted_amount\n\n        # Calculate balances for each month\n        running_balance = starting_balance\n\n        for month in months:\n            income = monthly_breakdown[month][\"income\"]\n            expenses = monthly_breakdown[month][\"expenses\"]\n            net = income - expenses\n            running_balance += net\n            monthly_breakdown[month][\"balance\"] = running_balance\n\n        # Calculate totals\n        total_income = sum(monthly_breakdown[month][\"income\"] for month in months)\n        total_expenses = sum(monthly_breakdown[month][\"expenses\"] for month in months)\n        net_cash_flow = total_income - total_expenses\n        ending_balance = starting_balance + net_cash_flow\n\n        # Create projection\n        projection = CashFlowProjection(\n            start_date=start_date,\n            end_date=end_date,\n            scenario=scenario,\n            starting_balance=starting_balance,\n            ending_balance=ending_balance,\n            total_income=total_income,\n            total_expenses=total_expenses,\n            net_cash_flow=net_cash_flow,\n            monthly_breakdown=monthly_breakdown,\n            confidence_interval=confidence_interval,\n        )\n\n        # Verify performance\n        elapsed_time = time.time() - start_time\n\n        return projection\n\n    def _add_recurring_item(\n        self,\n        monthly_breakdown: Dict[str, Dict[str, float]],\n        item: Union[RevenueSource, ExpenseItem],\n        start_date: datetime,\n        end_date: datetime,\n        item_type: str,  # \"income\" or \"expenses\"\n        multiplier: float = 1.0,\n    ) -> None:\n        \"\"\"Add a recurring item to monthly breakdown.\"\"\"\n        # Handle different recurrence frequencies\n        months_interval = 1  # Default to monthly\n\n        if item.recurrence_frequency == \"quarterly\":\n            months_interval = 3\n        elif item.recurrence_frequency == \"biannual\":\n            months_interval = 6\n        elif item.recurrence_frequency == \"annual\":\n            months_interval = 12\n        elif item.recurrence_frequency == \"biweekly\":\n            # Approximate biweekly as 2.17 payments per month\n            months_interval = 1\n            multiplier *= 2.17\n        elif item.recurrence_frequency == \"weekly\":\n            # Approximate weekly as 4.33 payments per month\n            months_interval = 1\n            multiplier *= 4.33\n\n        # Determine start month (use expected_date if available)\n        if hasattr(item, \"expected_date\") and item.expected_date:\n            current_month = item.expected_date\n        else:\n            current_month = start_date\n\n        # Add to each applicable month\n        while current_month <= end_date:\n            month_key = current_month.strftime(\"%Y-%m\")\n\n            if month_key in monthly_breakdown:\n                # Apply probability adjustment for revenue\n                if item_type == \"income\" and hasattr(item, \"probability\"):\n                    adjusted_amount = (\n                        item.amount * (item.probability / 100) * multiplier\n                    )\n                else:\n                    adjusted_amount = item.amount * multiplier\n\n                monthly_breakdown[month_key][item_type] += adjusted_amount\n\n            # Move to next applicable month\n            month = current_month.month + months_interval\n            year = current_month.year + (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n            current_month = datetime(year, month, 1)\n\n    def _get_scenario_income_multiplier(self, scenario: ProjectionScenario) -> float:\n        \"\"\"Get income multiplier based on scenario.\"\"\"\n        if scenario == ProjectionScenario.PESSIMISTIC:\n            return 0.7  # 70% of expected income\n        elif scenario == ProjectionScenario.CONSERVATIVE:\n            return 0.85  # 85% of expected income\n        elif scenario == ProjectionScenario.EXPECTED:\n            return 1.0  # 100% of expected income\n        elif scenario == ProjectionScenario.OPTIMISTIC:\n            return 1.15  # 115% of expected income\n        return 1.0\n\n    def _get_scenario_expense_multiplier(self, scenario: ProjectionScenario) -> float:\n        \"\"\"Get expense multiplier based on scenario.\"\"\"\n        if scenario == ProjectionScenario.PESSIMISTIC:\n            return 1.15  # 115% of expected expenses\n        elif scenario == ProjectionScenario.CONSERVATIVE:\n            return 1.05  # 105% of expected expenses\n        elif scenario == ProjectionScenario.EXPECTED:\n            return 1.0  # 100% of expected expenses\n        elif scenario == ProjectionScenario.OPTIMISTIC:\n            return 0.95  # 95% of expected expenses\n        return 1.0\n\n    def calculate_runway(\n        self,\n        current_balance: float,\n        spending_level: SpendingLevel,\n        monthly_expenses: Optional[float] = None,\n        historical_transactions: Optional[List[Transaction]] = None,\n        expected_revenue: Optional[Dict[str, float]] = None,\n        confidence_level: float = 0.8,\n    ) -> RunwayProjection:\n        \"\"\"\n        Calculate how long current funds will last at different spending levels.\n\n        Args:\n            current_balance: Current cash balance\n            spending_level: Level of spending to project\n            monthly_expenses: Optional override for monthly expense rate\n            historical_transactions: Optional historical transactions for expense analysis\n            expected_revenue: Optional expected future revenue by month\n            confidence_level: Confidence level for projection\n\n        Returns:\n            RunwayProjection with detailed runway information\n        \"\"\"\n        # Performance measurement\n        start_time = time.time()\n\n        # Determine monthly expense rate\n        monthly_expense_rate = 0.0\n\n        if monthly_expenses is not None:\n            # Use provided expense rate\n            monthly_expense_rate = monthly_expenses\n        elif historical_transactions:\n            # Calculate from historical data (last 3 months)\n            now = datetime.now()\n            three_months_ago = datetime(now.year, now.month, 1) - timedelta(days=90)\n\n            # Filter to expenses in the last 3 months\n            recent_expenses = [\n                t\n                for t in historical_transactions\n                if (\n                    t.transaction_type == TransactionType.EXPENSE\n                    and t.date >= three_months_ago\n                )\n            ]\n\n            # Group by month and calculate average\n            expenses_by_month = {}\n            for expense in recent_expenses:\n                month_key = expense.date.strftime(\"%Y-%m\")\n                if month_key not in expenses_by_month:\n                    expenses_by_month[month_key] = 0\n                expenses_by_month[month_key] += expense.amount\n\n            if expenses_by_month:\n                monthly_expense_rate = sum(expenses_by_month.values()) / len(\n                    expenses_by_month\n                )\n            else:\n                raise ValueError(\"No historical expense data available\")\n        else:\n            raise ValueError(\n                \"Either monthly_expenses or historical_transactions must be provided\"\n            )\n\n        # Apply spending level adjustment\n        adjusted_expense_rate = self._adjust_for_spending_level(\n            monthly_expense_rate, spending_level\n        )\n\n        # Calculate runway without expected revenue\n        bare_runway_months = (\n            current_balance / adjusted_expense_rate\n            if adjusted_expense_rate > 0\n            else float(\"inf\")\n        )\n\n        # Include expected revenue if provided\n        if expected_revenue:\n            # Get expected revenue by month\n            sorted_months = sorted(expected_revenue.keys())\n\n            # Calculate runway with revenue\n            balance = current_balance\n            months = 0\n            depletion_date = None\n\n            while balance > 0 and months < 60:  # Cap at 5 years\n                # Current month index\n                current_month_idx = months % len(sorted_months)\n                current_month = sorted_months[current_month_idx]\n\n                # Subtract expenses and add revenue\n                balance -= adjusted_expense_rate\n                if current_month in expected_revenue:\n                    balance += expected_revenue[current_month]\n\n                months += 1\n\n                # Calculate depletion date\n                if balance <= 0:\n                    now = datetime.now()\n                    depletion_date = datetime(\n                        now.year + (now.month + months - 1) // 12,\n                        ((now.month + months - 1) % 12) + 1,\n                        1,\n                    )\n                    break\n\n            # If we reached the cap without depleting, set to infinity\n            runway_months = months if months < 60 else float(\"inf\")\n        else:\n            # Without expected revenue, use simple calculation\n            runway_months = bare_runway_months\n\n            # Calculate depletion date\n            if runway_months < float(\"inf\"):\n                now = datetime.now()\n                months_to_add = math.floor(runway_months)\n                depletion_date = datetime(\n                    now.year + (now.month + months_to_add - 1) // 12,\n                    ((now.month + months_to_add - 1) % 12) + 1,\n                    1,\n                )\n            else:\n                depletion_date = None\n\n        # Create result\n        result = RunwayProjection(\n            calculation_date=datetime.now(),\n            starting_balance=current_balance,\n            spending_level=spending_level,\n            monthly_expense_rate=adjusted_expense_rate,\n            expected_income=expected_revenue or {},\n            runway_months=runway_months,\n            depletion_date=depletion_date,\n            confidence_level=confidence_level,\n        )\n\n        # Verify performance\n        elapsed_time = time.time() - start_time\n\n        return result\n\n    def _adjust_for_spending_level(\n        self, base_expense_rate: float, spending_level: SpendingLevel\n    ) -> float:\n        \"\"\"Adjust expense rate based on spending level.\"\"\"\n        if spending_level == SpendingLevel.MINIMAL:\n            return base_expense_rate * 0.6  # 60% of normal expenses\n        elif spending_level == SpendingLevel.REDUCED:\n            return base_expense_rate * 0.8  # 80% of normal expenses\n        elif spending_level == SpendingLevel.NORMAL:\n            return base_expense_rate  # 100% of normal expenses\n        elif spending_level == SpendingLevel.INCREASED:\n            return base_expense_rate * 1.2  # 120% of normal expenses\n        return base_expense_rate\n\n    def create_what_if_scenario(\n        self,\n        name: str,\n        base_scenario: ProjectionScenario,\n        parameters: List[ScenarioParameter],\n        description: Optional[str] = None,\n    ) -> WhatIfScenario:\n        \"\"\"\n        Create a what-if scenario for financial planning.\n\n        Args:\n            name: Name for the scenario\n            base_scenario: Base projection scenario\n            parameters: Parameters for the scenario\n            description: Optional description\n\n        Returns:\n            WhatIfScenario object\n        \"\"\"\n        # Create the scenario\n        scenario = WhatIfScenario(\n            name=name,\n            description=description,\n            base_scenario=base_scenario,\n            parameters=parameters,\n            creation_date=datetime.now(),\n        )\n\n        return scenario\n\n    def evaluate_what_if_scenario(\n        self,\n        scenario: WhatIfScenario,\n        starting_balance: float,\n        revenue_sources: List[RevenueSource],\n        expense_items: List[ExpenseItem],\n        months_ahead: int = 12,\n    ) -> Tuple[WhatIfScenario, CashFlowProjection]:\n        \"\"\"\n        Evaluate a what-if scenario and calculate its impact.\n\n        Args:\n            scenario: What-if scenario to evaluate\n            starting_balance: Current cash balance\n            revenue_sources: Expected revenue sources\n            expense_items: Expected expenses\n            months_ahead: Number of months to project\n\n        Returns:\n            Tuple of (updated scenario with results, cash flow projection)\n        \"\"\"\n        # Apply parameter adjustments to revenue and expenses\n        adjusted_revenue = list(revenue_sources)\n        adjusted_expenses = list(expense_items)\n\n        # Track adjustments made for each parameter\n        adjustments = {}\n\n        for param in scenario.parameters:\n            # Store original value\n            adjustments[param.name] = param.current_value\n\n            # Apply parameter adjustments based on name patterns\n            if \"hourly_rate\" in param.name.lower():\n                # Adjust revenue based on hourly rate change\n                for i, revenue in enumerate(adjusted_revenue):\n                    if \"hourly\" in revenue.name.lower():\n                        # Create a new object with updated amount\n                        new_revenue = RevenueSource(\n                            name=revenue.name,\n                            amount=param.current_value,\n                            probability=revenue.probability,\n                            expected_date=revenue.expected_date,\n                            recurring=revenue.recurring,\n                            recurrence_frequency=revenue.recurrence_frequency,\n                            notes=revenue.notes,\n                        )\n                        adjusted_revenue[i] = new_revenue\n\n            elif \"monthly_income\" in param.name.lower():\n                # Adjust monthly income\n                for i, revenue in enumerate(adjusted_revenue):\n                    if revenue.recurring and revenue.recurrence_frequency == \"monthly\":\n                        # Create a new object with updated amount\n                        new_revenue = RevenueSource(\n                            name=revenue.name,\n                            amount=param.current_value,\n                            probability=revenue.probability,\n                            expected_date=revenue.expected_date,\n                            recurring=revenue.recurring,\n                            recurrence_frequency=revenue.recurrence_frequency,\n                            notes=revenue.notes,\n                        )\n                        adjusted_revenue[i] = new_revenue\n\n            elif \"expense_reduction\" in param.name.lower():\n                # Apply expense reduction percentage\n                reduction_factor = 1.0 - (param.current_value / 100)\n                for i, expense in enumerate(adjusted_expenses):\n                    # Create a new object with updated amount\n                    new_expense = ExpenseItem(\n                        name=expense.name,\n                        amount=expense.amount * reduction_factor,\n                        category=expense.category,\n                        due_date=expense.due_date,\n                        recurring=expense.recurring,\n                        recurrence_frequency=expense.recurrence_frequency,\n                        essential=expense.essential,\n                        notes=expense.notes,\n                    )\n                    adjusted_expenses[i] = new_expense\n\n            # Add more parameter handling as needed\n\n        # Run projection with adjusted values\n        projection = self.project_cash_flow(\n            starting_balance=starting_balance,\n            current_date=datetime.now(),\n            months_ahead=months_ahead,\n            revenue_sources=adjusted_revenue,\n            expense_items=adjusted_expenses,\n            scenario=scenario.base_scenario,\n        )\n\n        # Calculate result metrics\n        result_metrics = {\n            \"ending_balance\": projection.ending_balance,\n            \"net_cash_flow\": projection.net_cash_flow,\n            \"total_income\": projection.total_income,\n            \"total_expenses\": projection.total_expenses,\n        }\n\n        # Update scenario with results\n        # Create a new scenario with updated result metrics\n        updated_scenario = WhatIfScenario(\n            id=scenario.id,\n            name=scenario.name,\n            description=scenario.description,\n            base_scenario=scenario.base_scenario,\n            parameters=scenario.parameters,\n            result_metrics=result_metrics,\n            creation_date=scenario.creation_date,\n            notes=scenario.notes,\n        )\n\n        return updated_scenario, projection\n\n    def assess_emergency_fund(\n        self,\n        current_fund_balance: float,\n        monthly_expenses: Optional[float] = None,\n        historical_transactions: Optional[List[Transaction]] = None,\n        recommended_months: float = 6.0,\n    ) -> EmergencyFundAssessment:\n        \"\"\"\n        Assess the adequacy of an emergency fund.\n\n        Args:\n            current_fund_balance: Current emergency fund balance\n            monthly_expenses: Optional override for monthly expenses\n            historical_transactions: Optional historical transactions for expense analysis\n            recommended_months: Recommended number of months coverage\n\n        Returns:\n            EmergencyFundAssessment with detailed assessment\n        \"\"\"\n        # Determine monthly essential expenses\n        monthly_essential = 0.0\n\n        if monthly_expenses is not None:\n            # Use provided expense amount\n            monthly_essential = monthly_expenses\n        elif historical_transactions:\n            # Calculate from historical data (last 3 months)\n            now = datetime.now()\n            three_months_ago = datetime(now.year, now.month, 1) - timedelta(days=90)\n\n            # Filter to essential expenses in the last 3 months\n            essential_expenses = [\n                t\n                for t in historical_transactions\n                if (\n                    t.transaction_type == TransactionType.EXPENSE\n                    and t.date >= three_months_ago\n                    and t.category\n                    in [\n                        ExpenseCategory.UTILITIES,\n                        ExpenseCategory.HEALTH_INSURANCE,\n                        ExpenseCategory.OFFICE_RENT,\n                        ExpenseCategory.INTERNET,\n                        ExpenseCategory.PHONE,\n                    ]\n                )\n            ]\n\n            # Group by month and calculate average\n            expenses_by_month = {}\n            for expense in essential_expenses:\n                month_key = expense.date.strftime(\"%Y-%m\")\n                if month_key not in expenses_by_month:\n                    expenses_by_month[month_key] = 0\n                expenses_by_month[month_key] += expense.amount\n\n            if expenses_by_month:\n                monthly_essential = sum(expenses_by_month.values()) / len(\n                    expenses_by_month\n                )\n            else:\n                raise ValueError(\"No historical essential expense data available\")\n        else:\n            raise ValueError(\n                \"Either monthly_expenses or historical_transactions must be provided\"\n            )\n\n        # Calculate recommended fund size\n        recommended_fund_size = monthly_essential * recommended_months\n\n        # Calculate current coverage\n        current_coverage_months = (\n            current_fund_balance / monthly_essential if monthly_essential > 0 else 0\n        )\n\n        # Determine adequacy level\n        if current_coverage_months < 1:\n            adequacy_level = \"inadequate\"\n            funding_plan = (\n                \"Immediate action needed: Build to 1 month coverage as soon as possible\"\n            )\n        elif current_coverage_months < 3:\n            adequacy_level = \"minimal\"\n            funding_plan = \"Continue building: Aim for 3 months coverage\"\n        elif current_coverage_months < recommended_months:\n            adequacy_level = \"adequate\"\n            funding_plan = f\"Good progress: Continue building toward {recommended_months} months coverage\"\n        else:\n            adequacy_level = \"excellent\"\n            funding_plan = (\n                \"Well funded: Maintain current level or consider other financial goals\"\n            )\n\n        # Create assessment\n        assessment = EmergencyFundAssessment(\n            assessment_date=datetime.now(),\n            current_fund_balance=current_fund_balance,\n            monthly_essential_expenses=monthly_essential,\n            recommended_months_coverage=recommended_months,\n            recommended_fund_size=recommended_fund_size,\n            current_coverage_months=current_coverage_months,\n            adequacy_level=adequacy_level,\n            funding_plan=funding_plan,\n        )\n\n        return assessment"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/test_ethical_screening/__init__.py": {
        "logprobs": -176.29193783537,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/project/profitability_analyzer.py": {
        "logprobs": -1472.1901983189437,
        "metrics": {
            "loc": 512,
            "sloc": 321,
            "lloc": 143,
            "comments": 43,
            "multi": 71,
            "blank": 76,
            "cyclomatic": 96,
            "internal_imports": [
                "class Client(BaseModel):\n    \"\"\"Client model.\"\"\"\n\n    id: str\n    name: str\n    contact_email: Optional[str] = None\n    contact_phone: Optional[str] = None\n    address: Optional[str] = None\n    notes: Optional[str] = None\n    active: bool = True",
                "class Project(BaseModel):\n    \"\"\"Project model.\"\"\"\n\n    id: str\n    name: str\n    client_id: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    status: str  # e.g., \"active\", \"completed\", \"on_hold\"\n    hourly_rate: Optional[float] = None\n    fixed_price: Optional[float] = None\n    estimated_hours: Optional[float] = None\n    description: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)",
                "class TimeEntry(BaseModel):\n    \"\"\"Time entry model for tracking hours worked on projects.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    project_id: str\n    start_time: datetime\n    end_time: Optional[datetime] = None\n    duration_minutes: Optional[float] = None\n    description: str\n    billable: bool = True\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"duration_minutes\", always=True)\n    def calculate_duration(cls, v, values):\n        \"\"\"Calculate duration from start and end time if not provided.\"\"\"\n        if v is not None:\n            return v\n        if (\n            \"start_time\" in values\n            and \"end_time\" in values\n            and values[\"end_time\"] is not None\n        ):\n            delta = values[\"end_time\"] - values[\"start_time\"]\n            return delta.total_seconds() / 60\n        return None",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class Invoice(BaseModel):\n    \"\"\"Invoice model.\"\"\"\n\n    id: str\n    client_id: str\n    project_id: Optional[str] = None\n    issue_date: datetime\n    due_date: datetime\n    amount: float\n    status: str  # e.g., \"draft\", \"sent\", \"paid\", \"overdue\"\n    payment_date: Optional[datetime] = None\n    description: Optional[str] = None\n    line_items: List[Dict] = Field(default_factory=list)",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class ProjectMetricType(str, Enum):\n    \"\"\"Types of project profitability metrics.\"\"\"\n\n    HOURLY_RATE = \"hourly_rate\"\n    TOTAL_PROFIT = \"total_profit\"\n    PROFIT_MARGIN = \"profit_margin\"\n    ROI = \"roi\"",
                "class ProjectMetricType(str, Enum):\n    \"\"\"Types of project profitability metrics.\"\"\"\n\n    HOURLY_RATE = \"hourly_rate\"\n    TOTAL_PROFIT = \"total_profit\"\n    PROFIT_MARGIN = \"profit_margin\"\n    ROI = \"roi\"",
                "class ProfitabilityMetric(BaseModel):\n    \"\"\"Profitability metric for a project.\"\"\"\n\n    project_id: str\n    metric_type: ProjectMetricType\n    value: float\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    description: Optional[str] = None",
                "class ProfitabilityMetric(BaseModel):\n    \"\"\"Profitability metric for a project.\"\"\"\n\n    project_id: str\n    metric_type: ProjectMetricType\n    value: float\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    description: Optional[str] = None",
                "class ProjectProfitability(BaseModel):\n    \"\"\"Project profitability analysis result.\"\"\"\n\n    project_id: str\n    project_name: str\n    client_id: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    total_hours: float\n    total_revenue: float\n    total_expenses: float\n    total_profit: float\n    effective_hourly_rate: float\n    profit_margin: float  # Percentage\n    roi: float  # Return on investment\n    is_completed: bool\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    metrics: List[ProfitabilityMetric] = Field(default_factory=list)\n\n    @validator(\"effective_hourly_rate\", \"profit_margin\", \"roi\", pre=True, always=True)\n    def validate_rates(cls, v, values):\n        \"\"\"Ensure rates are calculated correctly.\"\"\"\n        if v is not None:\n            return v\n\n        # If we have all required values, calculate the field\n        if (\n            \"total_hours\" in values\n            and \"total_revenue\" in values\n            and \"total_expenses\" in values\n        ):\n            hours = values[\"total_hours\"]\n            revenue = values[\"total_revenue\"]\n            expenses = values[\"total_expenses\"]\n\n            if values[\"current_field_name\"] == \"effective_hourly_rate\":\n                return revenue / max(hours, 0.01)  # Avoid division by zero\n\n            if values[\"current_field_name\"] == \"profit_margin\":\n                return 100 * (revenue - expenses) / max(revenue, 0.01)\n\n            if values[\"current_field_name\"] == \"roi\":\n                return (revenue - expenses) / max(expenses, 0.01)\n\n        return 0.0",
                "class ProjectProfitability(BaseModel):\n    \"\"\"Project profitability analysis result.\"\"\"\n\n    project_id: str\n    project_name: str\n    client_id: str\n    start_date: datetime\n    end_date: Optional[datetime] = None\n    total_hours: float\n    total_revenue: float\n    total_expenses: float\n    total_profit: float\n    effective_hourly_rate: float\n    profit_margin: float  # Percentage\n    roi: float  # Return on investment\n    is_completed: bool\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    metrics: List[ProfitabilityMetric] = Field(default_factory=list)\n\n    @validator(\"effective_hourly_rate\", \"profit_margin\", \"roi\", pre=True, always=True)\n    def validate_rates(cls, v, values):\n        \"\"\"Ensure rates are calculated correctly.\"\"\"\n        if v is not None:\n            return v\n\n        # If we have all required values, calculate the field\n        if (\n            \"total_hours\" in values\n            and \"total_revenue\" in values\n            and \"total_expenses\" in values\n        ):\n            hours = values[\"total_hours\"]\n            revenue = values[\"total_revenue\"]\n            expenses = values[\"total_expenses\"]\n\n            if values[\"current_field_name\"] == \"effective_hourly_rate\":\n                return revenue / max(hours, 0.01)  # Avoid division by zero\n\n            if values[\"current_field_name\"] == \"profit_margin\":\n                return 100 * (revenue - expenses) / max(revenue, 0.01)\n\n            if values[\"current_field_name\"] == \"roi\":\n                return (revenue - expenses) / max(expenses, 0.01)\n\n        return 0.0",
                "class ClientProfitability(BaseModel):\n    \"\"\"Client profitability analysis result.\"\"\"\n\n    client_id: str\n    client_name: str\n    number_of_projects: int\n    total_hours: float\n    total_revenue: float\n    total_expenses: float\n    total_profit: float\n    average_hourly_rate: float\n    average_profit_margin: float\n    average_invoice_payment_days: Optional[float] = None\n    projects: List[ProjectProfitability] = Field(default_factory=list)\n    calculation_date: datetime = Field(default_factory=datetime.now)",
                "class ClientProfitability(BaseModel):\n    \"\"\"Client profitability analysis result.\"\"\"\n\n    client_id: str\n    client_name: str\n    number_of_projects: int\n    total_hours: float\n    total_revenue: float\n    total_expenses: float\n    total_profit: float\n    average_hourly_rate: float\n    average_profit_margin: float\n    average_invoice_payment_days: Optional[float] = None\n    projects: List[ProjectProfitability] = Field(default_factory=list)\n    calculation_date: datetime = Field(default_factory=datetime.now)",
                "class TrendPoint(BaseModel):\n    \"\"\"Point in a trend analysis.\"\"\"\n\n    date: datetime\n    value: float",
                "class TrendPoint(BaseModel):\n    \"\"\"Point in a trend analysis.\"\"\"\n\n    date: datetime\n    value: float",
                "class TrendAnalysis(BaseModel):\n    \"\"\"Trend analysis for project profitability over time.\"\"\"\n\n    metric_type: ProjectMetricType\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    period: str  # \"weekly\", \"monthly\", \"quarterly\", \"yearly\"\n    start_date: datetime\n    end_date: datetime\n    data_points: List[TrendPoint] = Field(default_factory=list)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    description: Optional[str] = None",
                "class TrendAnalysis(BaseModel):\n    \"\"\"Trend analysis for project profitability over time.\"\"\"\n\n    metric_type: ProjectMetricType\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    period: str  # \"weekly\", \"monthly\", \"quarterly\", \"yearly\"\n    start_date: datetime\n    end_date: datetime\n    data_points: List[TrendPoint] = Field(default_factory=list)\n    calculation_date: datetime = Field(default_factory=datetime.now)\n    description: Optional[str] = None"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/tests/__init__.py": {
        "logprobs": -178.16894245577998,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/__init__.py": {
        "logprobs": -214.787088875916,
        "metrics": {
            "loc": 3,
            "sloc": 1,
            "lloc": 2,
            "comments": 0,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/project/__init__.py": {
        "logprobs": -253.16112137134996,
        "metrics": {
            "loc": 5,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 4,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/expense/models.py": {
        "logprobs": -809.7660564287498,
        "metrics": {
            "loc": 160,
            "sloc": 106,
            "lloc": 160,
            "comments": 13,
            "multi": 0,
            "blank": 34,
            "cyclomatic": 51,
            "internal_imports": [
                "class ExpenseCategory(str, Enum):\n    \"\"\"Expense category enum.\"\"\"\n\n    BUSINESS_SUPPLIES = \"business_supplies\"\n    SOFTWARE = \"software\"\n    MARKETING = \"marketing\"\n    OFFICE_RENT = \"office_rent\"\n    UTILITIES = \"utilities\"\n    TRAVEL = \"travel\"\n    MEALS = \"meals\"\n    EQUIPMENT = \"equipment\"\n    PROFESSIONAL_DEVELOPMENT = \"professional_development\"\n    PROFESSIONAL_SERVICES = \"professional_services\"\n    HEALTH_INSURANCE = \"health_insurance\"\n    RETIREMENT = \"retirement\"\n    PHONE = \"phone\"\n    INTERNET = \"internet\"\n    CAR = \"car\"\n    HOME_OFFICE = \"home_office\"\n    PERSONAL = \"personal\"\n    OTHER = \"other\"",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/tax/models.py": {
        "logprobs": -792.4039055071767,
        "metrics": {
            "loc": 129,
            "sloc": 89,
            "lloc": 152,
            "comments": 10,
            "multi": 0,
            "blank": 29,
            "cyclomatic": 31,
            "internal_imports": [
                "class TaxRate(BaseModel):\n    \"\"\"Tax rate for a specific income bracket.\"\"\"\n\n    bracket_min: float\n    bracket_max: Optional[float] = None\n    rate: float  # Percentage (0-100)\n    tax_year: int\n    jurisdiction: str = \"federal\"",
                "class TaxPayment(BaseModel):\n    \"\"\"Tax payment model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    tax_year: int\n    quarter: int\n    payment_method: str\n    confirmation_number: Optional[str] = None\n    notes: Optional[str] = None",
                "class TaxDeduction(BaseModel):\n    \"\"\"Tax deduction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    amount: float\n    tax_year: int\n    category: str\n    description: Optional[str] = None\n    receipt_path: Optional[str] = None"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/impact_measurement/__init__.py": {
        "logprobs": -208.64693653849997,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/income/income_manager.py": {
        "logprobs": -1961.1253806730592,
        "metrics": {
            "loc": 460,
            "sloc": 260,
            "lloc": 176,
            "comments": 53,
            "multi": 62,
            "blank": 80,
            "cyclomatic": 71,
            "internal_imports": [
                "class Invoice(BaseModel):\n    \"\"\"Invoice model.\"\"\"\n\n    id: str\n    client_id: str\n    project_id: Optional[str] = None\n    issue_date: datetime\n    due_date: datetime\n    amount: float\n    status: str  # e.g., \"draft\", \"sent\", \"paid\", \"overdue\"\n    payment_date: Optional[datetime] = None\n    description: Optional[str] = None\n    line_items: List[Dict] = Field(default_factory=list)",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class SmoothingConfig(BaseModel):\n    \"\"\"Configuration for income smoothing algorithms.\"\"\"\n\n    method: SmoothingMethod = SmoothingMethod.MOVING_AVERAGE\n    window_size: int = 3  # Number of months for moving average\n    alpha: float = 0.3  # For exponential smoothing\n    seasonal_periods: int = 12  # For seasonal adjustment\n    percentile: float = 25.0  # Percentile for percentile-based method\n    min_history_months: int = 3  # Minimum months of data required\n    target_monthly_income: Optional[float] = None  # Override calculated smoothed income\n    emergency_buffer_months: float = 2.0  # Buffer for lean months\n    confidence_interval: float = 0.8  # For prediction intervals\n\n    @validator(\"window_size\")\n    def validate_window_size(cls, v):\n        \"\"\"Validate window size is positive.\"\"\"\n        if v <= 0:\n            raise ValueError(\"Window size must be positive\")\n        return v\n\n    @validator(\"alpha\")\n    def validate_alpha(cls, v):\n        \"\"\"Validate alpha is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Alpha must be between 0 and 1\")\n        return v\n\n    @validator(\"percentile\")\n    def validate_percentile(cls, v):\n        \"\"\"Validate percentile is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Percentile must be between 0 and 100\")\n        return v\n\n    @validator(\"emergency_buffer_months\")\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer is non-negative.\"\"\"\n        if v < 0:\n            raise ValueError(\"Emergency buffer months must be non-negative\")\n        return v\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class SmoothingConfig(BaseModel):\n    \"\"\"Configuration for income smoothing algorithms.\"\"\"\n\n    method: SmoothingMethod = SmoothingMethod.MOVING_AVERAGE\n    window_size: int = 3  # Number of months for moving average\n    alpha: float = 0.3  # For exponential smoothing\n    seasonal_periods: int = 12  # For seasonal adjustment\n    percentile: float = 25.0  # Percentile for percentile-based method\n    min_history_months: int = 3  # Minimum months of data required\n    target_monthly_income: Optional[float] = None  # Override calculated smoothed income\n    emergency_buffer_months: float = 2.0  # Buffer for lean months\n    confidence_interval: float = 0.8  # For prediction intervals\n\n    @validator(\"window_size\")\n    def validate_window_size(cls, v):\n        \"\"\"Validate window size is positive.\"\"\"\n        if v <= 0:\n            raise ValueError(\"Window size must be positive\")\n        return v\n\n    @validator(\"alpha\")\n    def validate_alpha(cls, v):\n        \"\"\"Validate alpha is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Alpha must be between 0 and 1\")\n        return v\n\n    @validator(\"percentile\")\n    def validate_percentile(cls, v):\n        \"\"\"Validate percentile is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Percentile must be between 0 and 100\")\n        return v\n\n    @validator(\"emergency_buffer_months\")\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer is non-negative.\"\"\"\n        if v < 0:\n            raise ValueError(\"Emergency buffer months must be non-negative\")\n        return v\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class SmoothingConfig(BaseModel):\n    \"\"\"Configuration for income smoothing algorithms.\"\"\"\n\n    method: SmoothingMethod = SmoothingMethod.MOVING_AVERAGE\n    window_size: int = 3  # Number of months for moving average\n    alpha: float = 0.3  # For exponential smoothing\n    seasonal_periods: int = 12  # For seasonal adjustment\n    percentile: float = 25.0  # Percentile for percentile-based method\n    min_history_months: int = 3  # Minimum months of data required\n    target_monthly_income: Optional[float] = None  # Override calculated smoothed income\n    emergency_buffer_months: float = 2.0  # Buffer for lean months\n    confidence_interval: float = 0.8  # For prediction intervals\n\n    @validator(\"window_size\")\n    def validate_window_size(cls, v):\n        \"\"\"Validate window size is positive.\"\"\"\n        if v <= 0:\n            raise ValueError(\"Window size must be positive\")\n        return v\n\n    @validator(\"alpha\")\n    def validate_alpha(cls, v):\n        \"\"\"Validate alpha is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Alpha must be between 0 and 1\")\n        return v\n\n    @validator(\"percentile\")\n    def validate_percentile(cls, v):\n        \"\"\"Validate percentile is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Percentile must be between 0 and 100\")\n        return v\n\n    @validator(\"emergency_buffer_months\")\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer is non-negative.\"\"\"\n        if v < 0:\n            raise ValueError(\"Emergency buffer months must be non-negative\")\n        return v\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class SmoothingConfig(BaseModel):\n    \"\"\"Configuration for income smoothing algorithms.\"\"\"\n\n    method: SmoothingMethod = SmoothingMethod.MOVING_AVERAGE\n    window_size: int = 3  # Number of months for moving average\n    alpha: float = 0.3  # For exponential smoothing\n    seasonal_periods: int = 12  # For seasonal adjustment\n    percentile: float = 25.0  # Percentile for percentile-based method\n    min_history_months: int = 3  # Minimum months of data required\n    target_monthly_income: Optional[float] = None  # Override calculated smoothed income\n    emergency_buffer_months: float = 2.0  # Buffer for lean months\n    confidence_interval: float = 0.8  # For prediction intervals\n\n    @validator(\"window_size\")\n    def validate_window_size(cls, v):\n        \"\"\"Validate window size is positive.\"\"\"\n        if v <= 0:\n            raise ValueError(\"Window size must be positive\")\n        return v\n\n    @validator(\"alpha\")\n    def validate_alpha(cls, v):\n        \"\"\"Validate alpha is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Alpha must be between 0 and 1\")\n        return v\n\n    @validator(\"percentile\")\n    def validate_percentile(cls, v):\n        \"\"\"Validate percentile is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Percentile must be between 0 and 100\")\n        return v\n\n    @validator(\"emergency_buffer_months\")\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer is non-negative.\"\"\"\n        if v < 0:\n            raise ValueError(\"Emergency buffer months must be non-negative\")\n        return v\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class SmoothingConfig(BaseModel):\n    \"\"\"Configuration for income smoothing algorithms.\"\"\"\n\n    method: SmoothingMethod = SmoothingMethod.MOVING_AVERAGE\n    window_size: int = 3  # Number of months for moving average\n    alpha: float = 0.3  # For exponential smoothing\n    seasonal_periods: int = 12  # For seasonal adjustment\n    percentile: float = 25.0  # Percentile for percentile-based method\n    min_history_months: int = 3  # Minimum months of data required\n    target_monthly_income: Optional[float] = None  # Override calculated smoothed income\n    emergency_buffer_months: float = 2.0  # Buffer for lean months\n    confidence_interval: float = 0.8  # For prediction intervals\n\n    @validator(\"window_size\")\n    def validate_window_size(cls, v):\n        \"\"\"Validate window size is positive.\"\"\"\n        if v <= 0:\n            raise ValueError(\"Window size must be positive\")\n        return v\n\n    @validator(\"alpha\")\n    def validate_alpha(cls, v):\n        \"\"\"Validate alpha is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Alpha must be between 0 and 1\")\n        return v\n\n    @validator(\"percentile\")\n    def validate_percentile(cls, v):\n        \"\"\"Validate percentile is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Percentile must be between 0 and 100\")\n        return v\n\n    @validator(\"emergency_buffer_months\")\n    def validate_buffer(cls, v):\n        \"\"\"Validate buffer is non-negative.\"\"\"\n        if v < 0:\n            raise ValueError(\"Emergency buffer months must be non-negative\")\n        return v\n\n    @validator(\"confidence_interval\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence interval is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence interval must be between 0 and 1\")\n        return v",
                "class SmoothingMethod(str, Enum):\n    \"\"\"Income smoothing method enum.\"\"\"\n\n    MOVING_AVERAGE = \"moving_average\"\n    EXPONENTIAL_SMOOTHING = \"exponential_smoothing\"\n    SEASONAL_ADJUSTMENT = \"seasonal_adjustment\"\n    PERCENTILE_BASED = \"percentile_based\"\n    ROLLING_MEDIAN = \"rolling_median\"",
                "class SmoothingMethod(str, Enum):\n    \"\"\"Income smoothing method enum.\"\"\"\n\n    MOVING_AVERAGE = \"moving_average\"\n    EXPONENTIAL_SMOOTHING = \"exponential_smoothing\"\n    SEASONAL_ADJUSTMENT = \"seasonal_adjustment\"\n    PERCENTILE_BASED = \"percentile_based\"\n    ROLLING_MEDIAN = \"rolling_median\"",
                "class SmoothingMethod(str, Enum):\n    \"\"\"Income smoothing method enum.\"\"\"\n\n    MOVING_AVERAGE = \"moving_average\"\n    EXPONENTIAL_SMOOTHING = \"exponential_smoothing\"\n    SEASONAL_ADJUSTMENT = \"seasonal_adjustment\"\n    PERCENTILE_BASED = \"percentile_based\"\n    ROLLING_MEDIAN = \"rolling_median\"",
                "class SmoothingMethod(str, Enum):\n    \"\"\"Income smoothing method enum.\"\"\"\n\n    MOVING_AVERAGE = \"moving_average\"\n    EXPONENTIAL_SMOOTHING = \"exponential_smoothing\"\n    SEASONAL_ADJUSTMENT = \"seasonal_adjustment\"\n    PERCENTILE_BASED = \"percentile_based\"\n    ROLLING_MEDIAN = \"rolling_median\"",
                "class SmoothingMethod(str, Enum):\n    \"\"\"Income smoothing method enum.\"\"\"\n\n    MOVING_AVERAGE = \"moving_average\"\n    EXPONENTIAL_SMOOTHING = \"exponential_smoothing\"\n    SEASONAL_ADJUSTMENT = \"seasonal_adjustment\"\n    PERCENTILE_BASED = \"percentile_based\"\n    ROLLING_MEDIAN = \"rolling_median\"",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class SmoothedIncome(BaseModel):\n    \"\"\"Smoothed income calculation result.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    actual_income: float\n    smoothed_income: float\n    method: SmoothingMethod\n    configuration: SmoothingConfig\n    income_deficit: float = 0.0  # Negative when actual < smoothed\n    income_surplus: float = 0.0  # Positive when actual > smoothed\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None",
                "class RevenueForecast(BaseModel):\n    \"\"\"Revenue forecast model.\"\"\"\n\n    month: datetime\n    expected_income: float\n    lower_bound: float\n    upper_bound: float\n    confidence_interval: float\n    sources: Dict[str, float] = Field(default_factory=dict)  # Client/project breakdown\n    notes: Optional[str] = None"
            ]
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/ethical_finance/ethical_screening/__init__.py": {
        "logprobs": -184.54253339285737,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_socially_responsible_investor/setup.py": {
        "logprobs": -214.97548820367044,
        "metrics": {
            "loc": 15,
            "sloc": 14,
            "lloc": 2,
            "comments": 0,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/expense/__init__.py": {
        "logprobs": -261.55025721372,
        "metrics": {
            "loc": 5,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 4,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/models/__init__.py": {
        "logprobs": -199.827398541279,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/tax/__init__.py": {
        "logprobs": -249.09740424265797,
        "metrics": {
            "loc": 5,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 4,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "personal_finance_tracker/personal_finance_tracker_freelancer/personal_finance_tracker/expense/categorizer.py": {
        "logprobs": -1390.1909221999176,
        "metrics": {
            "loc": 500,
            "sloc": 268,
            "lloc": 179,
            "comments": 51,
            "multi": 91,
            "blank": 89,
            "cyclomatic": 59,
            "internal_imports": [
                "class ExpenseCategory(str, Enum):\n    \"\"\"Expense category enum.\"\"\"\n\n    BUSINESS_SUPPLIES = \"business_supplies\"\n    SOFTWARE = \"software\"\n    MARKETING = \"marketing\"\n    OFFICE_RENT = \"office_rent\"\n    UTILITIES = \"utilities\"\n    TRAVEL = \"travel\"\n    MEALS = \"meals\"\n    EQUIPMENT = \"equipment\"\n    PROFESSIONAL_DEVELOPMENT = \"professional_development\"\n    PROFESSIONAL_SERVICES = \"professional_services\"\n    HEALTH_INSURANCE = \"health_insurance\"\n    RETIREMENT = \"retirement\"\n    PHONE = \"phone\"\n    INTERNET = \"internet\"\n    CAR = \"car\"\n    HOME_OFFICE = \"home_office\"\n    PERSONAL = \"personal\"\n    OTHER = \"other\"",
                "class Transaction(BaseModel):\n    \"\"\"Transaction model.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    date: datetime\n    amount: float\n    description: str\n    transaction_type: TransactionType\n    account_id: str\n    category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    project_id: Optional[str] = None\n    client_id: Optional[str] = None\n    invoice_id: Optional[str] = None\n    receipt_path: Optional[str] = None\n    notes: Optional[str] = None\n    tags: List[str] = Field(default_factory=list)\n\n    @validator(\"business_use_percentage\")\n    def validate_business_percentage(cls, v):\n        \"\"\"Validate that business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class TransactionType(str, Enum):\n    \"\"\"Transaction type enum.\"\"\"\n\n    INCOME = \"income\"\n    EXPENSE = \"expense\"\n    TAX_PAYMENT = \"tax_payment\"\n    TRANSFER = \"transfer\"",
                "class CategorizationRule(BaseModel):\n    \"\"\"Rule for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n\n    # Rule conditions (at least one must be provided)\n    keyword_patterns: List[str] = Field(default_factory=list)\n    merchant_patterns: List[str] = Field(default_factory=list)\n    amount_min: Optional[float] = None\n    amount_max: Optional[float] = None\n\n    # Business use percentage\n    business_use_percentage: float = 100.0\n\n    # Rule priority (higher has precedence)\n    priority: int = 0\n\n    # Rule activation\n    is_active: bool = True\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: Optional[datetime] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v\n\n    def matches(self, transaction: Transaction) -> bool:\n        \"\"\"Check if transaction matches this rule.\"\"\"\n        # Skip if rule is inactive\n        if not self.is_active:\n            return False\n\n        # Check amount range if specified\n        if self.amount_min is not None and transaction.amount < self.amount_min:\n            return False\n\n        if self.amount_max is not None and transaction.amount > self.amount_max:\n            return False\n\n        # Check description against keyword patterns\n        description_match = False\n        if not self.keyword_patterns:\n            description_match = True  # No patterns means automatic match\n        else:\n            for pattern in self.keyword_patterns:\n                if re.search(pattern, transaction.description, re.IGNORECASE):\n                    description_match = True\n                    break\n\n        if not description_match:\n            return False\n\n        # Check merchant name if available (assumed to be in tags)\n        merchant_match = False\n        if not self.merchant_patterns:\n            merchant_match = True  # No patterns means automatic match\n        else:\n            for tag in transaction.tags:\n                for pattern in self.merchant_patterns:\n                    if re.search(pattern, tag, re.IGNORECASE):\n                        merchant_match = True\n                        break\n                if merchant_match:\n                    break\n\n        if not merchant_match:\n            return False\n\n        # All conditions matched\n        return True",
                "class CategorizationRule(BaseModel):\n    \"\"\"Rule for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n\n    # Rule conditions (at least one must be provided)\n    keyword_patterns: List[str] = Field(default_factory=list)\n    merchant_patterns: List[str] = Field(default_factory=list)\n    amount_min: Optional[float] = None\n    amount_max: Optional[float] = None\n\n    # Business use percentage\n    business_use_percentage: float = 100.0\n\n    # Rule priority (higher has precedence)\n    priority: int = 0\n\n    # Rule activation\n    is_active: bool = True\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: Optional[datetime] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v\n\n    def matches(self, transaction: Transaction) -> bool:\n        \"\"\"Check if transaction matches this rule.\"\"\"\n        # Skip if rule is inactive\n        if not self.is_active:\n            return False\n\n        # Check amount range if specified\n        if self.amount_min is not None and transaction.amount < self.amount_min:\n            return False\n\n        if self.amount_max is not None and transaction.amount > self.amount_max:\n            return False\n\n        # Check description against keyword patterns\n        description_match = False\n        if not self.keyword_patterns:\n            description_match = True  # No patterns means automatic match\n        else:\n            for pattern in self.keyword_patterns:\n                if re.search(pattern, transaction.description, re.IGNORECASE):\n                    description_match = True\n                    break\n\n        if not description_match:\n            return False\n\n        # Check merchant name if available (assumed to be in tags)\n        merchant_match = False\n        if not self.merchant_patterns:\n            merchant_match = True  # No patterns means automatic match\n        else:\n            for tag in transaction.tags:\n                for pattern in self.merchant_patterns:\n                    if re.search(pattern, tag, re.IGNORECASE):\n                        merchant_match = True\n                        break\n                if merchant_match:\n                    break\n\n        if not merchant_match:\n            return False\n\n        # All conditions matched\n        return True",
                "class CategorizationRule(BaseModel):\n    \"\"\"Rule for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n\n    # Rule conditions (at least one must be provided)\n    keyword_patterns: List[str] = Field(default_factory=list)\n    merchant_patterns: List[str] = Field(default_factory=list)\n    amount_min: Optional[float] = None\n    amount_max: Optional[float] = None\n\n    # Business use percentage\n    business_use_percentage: float = 100.0\n\n    # Rule priority (higher has precedence)\n    priority: int = 0\n\n    # Rule activation\n    is_active: bool = True\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: Optional[datetime] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v\n\n    def matches(self, transaction: Transaction) -> bool:\n        \"\"\"Check if transaction matches this rule.\"\"\"\n        # Skip if rule is inactive\n        if not self.is_active:\n            return False\n\n        # Check amount range if specified\n        if self.amount_min is not None and transaction.amount < self.amount_min:\n            return False\n\n        if self.amount_max is not None and transaction.amount > self.amount_max:\n            return False\n\n        # Check description against keyword patterns\n        description_match = False\n        if not self.keyword_patterns:\n            description_match = True  # No patterns means automatic match\n        else:\n            for pattern in self.keyword_patterns:\n                if re.search(pattern, transaction.description, re.IGNORECASE):\n                    description_match = True\n                    break\n\n        if not description_match:\n            return False\n\n        # Check merchant name if available (assumed to be in tags)\n        merchant_match = False\n        if not self.merchant_patterns:\n            merchant_match = True  # No patterns means automatic match\n        else:\n            for tag in transaction.tags:\n                for pattern in self.merchant_patterns:\n                    if re.search(pattern, tag, re.IGNORECASE):\n                        merchant_match = True\n                        break\n                if merchant_match:\n                    break\n\n        if not merchant_match:\n            return False\n\n        # All conditions matched\n        return True",
                "class MixedUseItem(BaseModel):\n    \"\"\"Item with mixed business and personal use.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n    business_use_percentage: float\n    documentation: Optional[str] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class MixedUseItem(BaseModel):\n    \"\"\"Item with mixed business and personal use.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n    business_use_percentage: float\n    documentation: Optional[str] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class MixedUseItem(BaseModel):\n    \"\"\"Item with mixed business and personal use.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    name: str\n    category: ExpenseCategory\n    description: Optional[str] = None\n    business_use_percentage: float\n    documentation: Optional[str] = None\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v < 0 or v > 100:\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class CategorizationResult(BaseModel):\n    \"\"\"Result of an expense categorization.\"\"\"\n\n    transaction_id: UUID\n    original_transaction: Transaction\n    matched_rule: Optional[CategorizationRule] = None\n    assigned_category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    confidence_score: float = 0.0  # 0-1 confidence in categorization\n    is_mixed_use: bool = False\n    categorization_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None\n\n    @validator(\"confidence_score\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence score is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence score must be between 0 and 1\")\n        return v\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class CategorizationResult(BaseModel):\n    \"\"\"Result of an expense categorization.\"\"\"\n\n    transaction_id: UUID\n    original_transaction: Transaction\n    matched_rule: Optional[CategorizationRule] = None\n    assigned_category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    confidence_score: float = 0.0  # 0-1 confidence in categorization\n    is_mixed_use: bool = False\n    categorization_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None\n\n    @validator(\"confidence_score\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence score is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence score must be between 0 and 1\")\n        return v\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class CategorizationResult(BaseModel):\n    \"\"\"Result of an expense categorization.\"\"\"\n\n    transaction_id: UUID\n    original_transaction: Transaction\n    matched_rule: Optional[CategorizationRule] = None\n    assigned_category: Optional[ExpenseCategory] = None\n    business_use_percentage: Optional[float] = None\n    confidence_score: float = 0.0  # 0-1 confidence in categorization\n    is_mixed_use: bool = False\n    categorization_date: datetime = Field(default_factory=datetime.now)\n    notes: Optional[str] = None\n\n    @validator(\"confidence_score\")\n    def validate_confidence(cls, v):\n        \"\"\"Validate confidence score is between 0 and 1.\"\"\"\n        if v < 0 or v > 1:\n            raise ValueError(\"Confidence score must be between 0 and 1\")\n        return v\n\n    @validator(\"business_use_percentage\")\n    def validate_percentage(cls, v):\n        \"\"\"Validate business use percentage is between 0 and 100.\"\"\"\n        if v is not None and (v < 0 or v > 100):\n            raise ValueError(\"Business use percentage must be between 0 and 100\")\n        return v",
                "class ExpenseSummary(BaseModel):\n    \"\"\"Summary of expenses by category.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    total_expenses: float\n    business_expenses: float\n    personal_expenses: float\n    by_category: Dict[ExpenseCategory, float] = Field(default_factory=dict)\n    generation_date: datetime = Field(default_factory=datetime.now)",
                "class ExpenseSummary(BaseModel):\n    \"\"\"Summary of expenses by category.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    total_expenses: float\n    business_expenses: float\n    personal_expenses: float\n    by_category: Dict[ExpenseCategory, float] = Field(default_factory=dict)\n    generation_date: datetime = Field(default_factory=datetime.now)",
                "class ExpenseSummary(BaseModel):\n    \"\"\"Summary of expenses by category.\"\"\"\n\n    period_start: datetime\n    period_end: datetime\n    total_expenses: float\n    business_expenses: float\n    personal_expenses: float\n    by_category: Dict[ExpenseCategory, float] = Field(default_factory=dict)\n    generation_date: datetime = Field(default_factory=datetime.now)",
                "class AuditRecord(BaseModel):\n    \"\"\"Audit record for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    transaction_id: UUID\n    timestamp: datetime = Field(default_factory=datetime.now)\n    action: str  # e.g., \"categorize\", \"recategorize\", \"mark_business\", \"mark_personal\"\n    previous_state: Optional[Dict] = None\n    new_state: Dict\n    user_id: Optional[str] = None\n    notes: Optional[str] = None",
                "class AuditRecord(BaseModel):\n    \"\"\"Audit record for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    transaction_id: UUID\n    timestamp: datetime = Field(default_factory=datetime.now)\n    action: str  # e.g., \"categorize\", \"recategorize\", \"mark_business\", \"mark_personal\"\n    previous_state: Optional[Dict] = None\n    new_state: Dict\n    user_id: Optional[str] = None\n    notes: Optional[str] = None",
                "class AuditRecord(BaseModel):\n    \"\"\"Audit record for expense categorization.\"\"\"\n\n    id: UUID = Field(default_factory=uuid4)\n    transaction_id: UUID\n    timestamp: datetime = Field(default_factory=datetime.now)\n    action: str  # e.g., \"categorize\", \"recategorize\", \"mark_business\", \"mark_personal\"\n    previous_state: Optional[Dict] = None\n    new_state: Dict\n    user_id: Optional[str] = None\n    notes: Optional[str] = None"
            ]
        }
    },
    "total_loc": 9344,
    "total_sloc": 6068,
    "total_lloc": 4289,
    "total_comments": 970,
    "total_multi": 783,
    "total_blank": 1525,
    "total_cyclomatic": 1482,
    "total_internal_imports": 274
}