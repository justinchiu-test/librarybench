"""Grant proposal export functionality for ResearchBrain."""

import os
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import yaml
from jinja2 import Environment, FileSystemLoader, Template

from researchbrain.core.models import (
    Experiment, GrantProposal, Note, ResearchQuestion
)


def export_proposal(grant: GrantProposal, notes: List[Note], 
                   experiments: List[Experiment], 
                   questions: List[ResearchQuestion],
                   output_path: Union[str, Path]) -> bool:
    """Export a grant proposal to a structured document.
    
    Args:
        grant: The grant proposal to export.
        notes: List of notes related to the grant.
        experiments: List of experiments related to the grant.
        questions: List of research questions related to the grant.
        output_path: Path where the proposal will be saved.
        
    Returns:
        True if the export was successful, False otherwise.
    """
    output_path = Path(output_path)
    
    # Determine output format based on file extension
    if output_path.suffix.lower() == '.md':
        return _export_markdown(grant, notes, experiments, questions, output_path)
    elif output_path.suffix.lower() == '.yaml' or output_path.suffix.lower() == '.yml':
        return _export_yaml(grant, notes, experiments, questions, output_path)
    else:
        # Default to markdown if extension not recognized
        return _export_markdown(grant, notes, experiments, questions, output_path)


def _export_markdown(grant: GrantProposal, notes: List[Note], 
                    experiments: List[Experiment], 
                    questions: List[ResearchQuestion],
                    output_path: Path) -> bool:
    """Export a grant proposal to a Markdown document.
    
    Args:
        grant: The grant proposal to export.
        notes: List of notes related to the grant.
        experiments: List of experiments related to the grant.
        questions: List of research questions related to the grant.
        output_path: Path where the Markdown file will be saved.
        
    Returns:
        True if the export was successful, False otherwise.
    """
    try:
        # Basic template for markdown export
        template_str = """# {{ grant.title }}

## Grant Proposal for {{ grant.funding_agency }}

**Status:** {{ grant.status }}
{% if grant.deadline %}**Deadline:** {{ grant.deadline.strftime('%B %d, %Y') }}{% endif %}
{% if grant.amount %}**Requested Amount:** ${{ '{:,.2f}'.format(grant.amount) }}{% endif %}

## Project Description

{{ grant.description }}

{% if grant.budget_items %}
## Budget

{% for category, items in grant.budget_items.items() %}
### {{ category|title }}
{% for item, amount in items.items() %}
- {{ item }}: ${{ '{:,.2f}'.format(amount) }}
{% endfor %}
{% endfor %}
{% endif %}

{% if grant.timeline %}
## Timeline

{% for period, milestones in grant.timeline.items() %}
### {{ period|title }}
{% for phase, description in milestones.items() %}
- {{ phase|upper }}: {{ description }}
{% endfor %}
{% endfor %}
{% endif %}

{% if questions %}
## Research Questions

{% for question in questions %}
### {{ question.question }}
{% if question.description %}
{{ question.description }}
{% endif %}

**Status:** {{ question.status }} | **Priority:** {{ question.priority }}/10

{% if question.evidence %}
#### Evidence
{% for evidence in question.evidence %}
- **{{ evidence.evidence_type|title }} ({{ evidence.strength|title }}):** {% if evidence.description %}{{ evidence.description }}{% else %}See note attached to this evidence{% endif %}
{% endfor %}
{% endif %}

{% endfor %}
{% endif %}

{% if experiments %}
## Proposed Experiments

{% for experiment in experiments %}
### {{ experiment.title }}
**Status:** {{ experiment.status }}

**Hypothesis:** {{ experiment.hypothesis }}

#### Methodology
{{ experiment.methodology }}

{% if experiment.results %}
#### Results
{{ experiment.results }}
{% endif %}

{% if experiment.conclusion %}
#### Conclusion
{{ experiment.conclusion }}
{% endif %}

{% endfor %}
{% endif %}

{% if notes %}
## Supporting Notes

{% for note in notes %}
### {{ note.title }}
{{ note.content }}

{% if note.tags %}**Tags:** {{ note.tags|join(', ') }}{% endif %}

{% endfor %}
{% endif %}

---

*Generated by ResearchBrain on {{ now.strftime('%Y-%m-%d at %H:%M:%S') }}*
"""
        
        # Create Jinja2 template
        template = Template(template_str)
        
        # Render the template
        output = template.render(
            grant=grant,
            notes=notes,
            experiments=experiments,
            questions=questions,
            now=datetime.now()
        )
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(output)
        
        return True
    except Exception as e:
        return False


def _export_yaml(grant: GrantProposal, notes: List[Note],
                experiments: List[Experiment],
                questions: List[ResearchQuestion],
                output_path: Path) -> bool:
    """Export a grant proposal to a YAML document.

    Args:
        grant: The grant proposal to export.
        notes: List of notes related to the grant.
        experiments: List of experiments related to the grant.
        questions: List of research questions related to the grant.
        output_path: Path where the YAML file will be saved.

    Returns:
        True if the export was successful, False otherwise.
    """
    try:
        # Prepare data structure
        grant_data = grant.model_dump()

        # Convert UUID objects to strings for JSON serialization
        # but preserve numeric values as numbers rather than strings
        grant_data = _convert_uuids_to_strings(grant_data)

        # Add related items
        grant_data['notes_data'] = [_convert_uuids_to_strings(note.model_dump()) for note in notes]
        grant_data['experiments_data'] = [_convert_uuids_to_strings(exp.model_dump()) for exp in experiments]
        grant_data['questions_data'] = [_convert_uuids_to_strings(q.model_dump()) for q in questions]

        # Add export metadata
        grant_data['export_metadata'] = {
            'generated_at': datetime.now().isoformat(),
            'format_version': '1.0'
        }

        # Ensure amount is treated as a float, not a string
        if 'amount' in grant_data and grant_data['amount'] is not None:
            grant_data['amount'] = float(grant_data['amount'])

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            yaml.dump(grant_data, f, default_flow_style=False, sort_keys=False, Dumper=yaml.SafeDumper)

        return True
    except Exception as e:
        print(f"YAML export error: {e}")
        return False


def _convert_uuids_to_strings(data: Dict[str, Any]) -> Dict[str, Any]:
    """Convert UUID objects and Enum types to strings in a dictionary.

    Args:
        data: Dictionary that may contain UUID objects or Enum values.

    Returns:
        Dictionary with UUID objects and Enum values converted to strings.
    """
    from enum import Enum

    for key, value in list(data.items()):
        if isinstance(value, dict):
            data[key] = _convert_uuids_to_strings(value)
        elif isinstance(value, list):
            new_list = []
            for item in value:
                if isinstance(item, dict):
                    new_list.append(_convert_uuids_to_strings(item))
                elif hasattr(item, 'hex'):  # UUID object
                    new_list.append(str(item))
                elif isinstance(item, Enum):
                    new_list.append(item.value)
                else:
                    new_list.append(item)
            data[key] = new_list
        elif hasattr(value, 'hex'):  # UUID object
            data[key] = str(value)
        elif isinstance(value, Enum):
            data[key] = value.value
        elif isinstance(value, datetime):
            # Handle datetime objects
            data[key] = value.isoformat()
        # Don't convert numeric values to strings - keep them as numbers
        # The SafeDumper should handle them correctly

    return data