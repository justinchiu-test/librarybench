{
    "total_logprobs": -37619.83164294212,
    "total_tokens": 69973,
    "text_editor/text_editor_student/text_editor/core/buffer.py": {
        "logprobs": -762.3179839003866,
        "metrics": {
            "loc": 197,
            "sloc": 66,
            "lloc": 87,
            "comments": 19,
            "multi": 68,
            "blank": 43,
            "cyclomatic": 25,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/customization/manager.py": {
        "logprobs": -2384.0117469513643,
        "metrics": {
            "loc": 504,
            "sloc": 285,
            "lloc": 165,
            "comments": 29,
            "multi": 104,
            "blank": 82,
            "cyclomatic": 63,
            "internal_imports": [
                "class CustomizableComponent(BaseModel):\n    \"\"\"\n    Represents a component of the editor that can be customized.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: CustomizationCategory\n    difficulty: CustomizationDifficulty\n    default_implementation: str\n    alternative_implementations: Dict[str, str] = Field(default_factory=dict)\n    impact_description: str\n    implementation_hints: List[str] = Field(default_factory=list)\n    current_implementation: str = \"default\"",
                "class CustomizationCategory(Enum):\n    \"\"\"Categories of editor components that can be customized.\"\"\"\n    TEXT_STORAGE = \"text_storage\"\n    CURSOR_BEHAVIOR = \"cursor_behavior\"\n    EDITING_OPERATIONS = \"editing_operations\"\n    SEARCH_ALGORITHM = \"search_algorithm\"\n    UNDO_REDO = \"undo_redo\"\n    FILE_HANDLING = \"file_handling\"\n    PERFORMANCE = \"performance\"",
                "class CustomizationDifficulty(Enum):\n    \"\"\"Difficulty levels for customization tasks.\"\"\"\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ExperimentResults(BaseModel):\n    \"\"\"\n    Represents the results of a customization experiment.\n    \"\"\"\n    component_id: str\n    implementation_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    success: bool = False\n    error_message: Optional[str] = None\n    performance_metrics: Dict[str, float] = Field(default_factory=dict)\n    notes: str = \"\"\n    \n    def complete(self, success: bool, metrics: Dict[str, float] = None, error: str = None) -> None:\n        \"\"\"\n        Mark the experiment as complete with results.\n        \n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        self.end_time = time.time()\n        self.success = success\n        \n        if metrics:\n            self.performance_metrics = metrics\n            \n        if error:\n            self.error_message = error\n    \n    def duration(self) -> float:\n        \"\"\"\n        Get the duration of the experiment in seconds.\n        \n        Returns:\n            Duration of the experiment, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            return -1\n        \n        return self.end_time - self.start_time",
                "class CustomizationHistory(BaseModel):\n    \"\"\"\n    Tracks the history of customization experiments.\n    \"\"\"\n    experiments: List[ExperimentResults] = Field(default_factory=list)\n    snapshots: Dict[str, Any] = Field(default_factory=dict)\n    \n    def add_experiment(self, experiment: ExperimentResults) -> None:\n        \"\"\"\n        Add an experiment to the history.\n        \n        Args:\n            experiment: The experiment to add\n        \"\"\"\n        self.experiments.append(experiment)\n    \n    def get_experiments_for_component(self, component_id: str) -> List[ExperimentResults]:\n        \"\"\"\n        Get all experiments for a specific component.\n        \n        Args:\n            component_id: ID of the component to get experiments for\n            \n        Returns:\n            List of experiments for the component\n        \"\"\"\n        return [e for e in self.experiments if e.component_id == component_id]\n    \n    def get_last_successful_experiment(self, component_id: str) -> Optional[ExperimentResults]:\n        \"\"\"\n        Get the last successful experiment for a component.\n        \n        Args:\n            component_id: ID of the component to check\n            \n        Returns:\n            The last successful experiment, or None if none found\n        \"\"\"\n        experiments = self.get_experiments_for_component(component_id)\n        successful = [e for e in experiments if e.success]\n        \n        if successful:\n            return successful[-1]\n        \n        return None\n    \n    def save_snapshot(self, snapshot_id: str, snapshot_data: Any) -> None:\n        \"\"\"\n        Save a snapshot of the editor state.\n        \n        Args:\n            snapshot_id: ID for the snapshot\n            snapshot_data: Data to save\n        \"\"\"\n        self.snapshots[snapshot_id] = snapshot_data\n    \n    def get_snapshot(self, snapshot_id: str) -> Optional[Any]:\n        \"\"\"\n        Get a saved snapshot.\n        \n        Args:\n            snapshot_id: ID of the snapshot to retrieve\n            \n        Returns:\n            The snapshot data, or None if not found\n        \"\"\"\n        return self.snapshots.get(snapshot_id)"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/features/manager.py": {
        "logprobs": -1583.1474339517406,
        "metrics": {
            "loc": 389,
            "sloc": 250,
            "lloc": 104,
            "comments": 20,
            "multi": 68,
            "blank": 54,
            "cyclomatic": 41,
            "internal_imports": [
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n    \n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n        \n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n        \n        self.feature_usage_count[feature_id] += count\n        \n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if feature_id in self.feature_usage_count and self.feature_usage_count[feature_id] <= 10:\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n    \n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n        \n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n        \n        # Check if the user should level up based on experience points\n        if (self.skill_level == SkillLevel.BEGINNER and \n            self.experience_points >= 100):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.INTERMEDIATE and \n              self.experience_points >= 300):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.ADVANCED and \n              self.experience_points >= 600):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n    \n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n        \n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n        \n        # Record this event in progress history\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"feature_unlocked\",\n            \"feature_id\": feature_id\n        })\n    \n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n        \n        Args:\n            feature_id: The ID of the feature to check\n            \n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n    \n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"level_up\",\n            \"new_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points\n        })\n    \n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n        \n        # Simple assessment: count number of different features used\n        unique_features_used = len([k for k, v in self.feature_usage_count.items() if v > 5])\n        \n        # Update skill level based on unique features used\n        if unique_features_used >= 15 and self.skill_level.value < SkillLevel.EXPERT.value:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif unique_features_used >= 10 and self.skill_level.value < SkillLevel.ADVANCED.value:\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif unique_features_used >= 5 and self.skill_level.value < SkillLevel.INTERMEDIATE.value:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n    \n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n        \n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), \n                key=lambda x: x[1], \n                reverse=True\n            )[:5] if self.feature_usage_count else []\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n    \n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n        \n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n        \n        self.feature_usage_count[feature_id] += count\n        \n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if feature_id in self.feature_usage_count and self.feature_usage_count[feature_id] <= 10:\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n    \n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n        \n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n        \n        # Check if the user should level up based on experience points\n        if (self.skill_level == SkillLevel.BEGINNER and \n            self.experience_points >= 100):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.INTERMEDIATE and \n              self.experience_points >= 300):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.ADVANCED and \n              self.experience_points >= 600):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n    \n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n        \n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n        \n        # Record this event in progress history\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"feature_unlocked\",\n            \"feature_id\": feature_id\n        })\n    \n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n        \n        Args:\n            feature_id: The ID of the feature to check\n            \n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n    \n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"level_up\",\n            \"new_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points\n        })\n    \n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n        \n        # Simple assessment: count number of different features used\n        unique_features_used = len([k for k, v in self.feature_usage_count.items() if v > 5])\n        \n        # Update skill level based on unique features used\n        if unique_features_used >= 15 and self.skill_level.value < SkillLevel.EXPERT.value:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif unique_features_used >= 10 and self.skill_level.value < SkillLevel.ADVANCED.value:\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif unique_features_used >= 5 and self.skill_level.value < SkillLevel.INTERMEDIATE.value:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n    \n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n        \n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), \n                key=lambda x: x[1], \n                reverse=True\n            )[:5] if self.feature_usage_count else []\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n    \n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n        \n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n        \n        self.feature_usage_count[feature_id] += count\n        \n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if feature_id in self.feature_usage_count and self.feature_usage_count[feature_id] <= 10:\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n    \n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n        \n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n        \n        # Check if the user should level up based on experience points\n        if (self.skill_level == SkillLevel.BEGINNER and \n            self.experience_points >= 100):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.INTERMEDIATE and \n              self.experience_points >= 300):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.ADVANCED and \n              self.experience_points >= 600):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n    \n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n        \n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n        \n        # Record this event in progress history\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"feature_unlocked\",\n            \"feature_id\": feature_id\n        })\n    \n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n        \n        Args:\n            feature_id: The ID of the feature to check\n            \n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n    \n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"level_up\",\n            \"new_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points\n        })\n    \n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n        \n        # Simple assessment: count number of different features used\n        unique_features_used = len([k for k, v in self.feature_usage_count.items() if v > 5])\n        \n        # Update skill level based on unique features used\n        if unique_features_used >= 15 and self.skill_level.value < SkillLevel.EXPERT.value:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif unique_features_used >= 10 and self.skill_level.value < SkillLevel.ADVANCED.value:\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif unique_features_used >= 5 and self.skill_level.value < SkillLevel.INTERMEDIATE.value:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n    \n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n        \n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), \n                key=lambda x: x[1], \n                reverse=True\n            )[:5] if self.feature_usage_count else []\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n    \n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n        \n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n        \n        self.feature_usage_count[feature_id] += count\n        \n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if feature_id in self.feature_usage_count and self.feature_usage_count[feature_id] <= 10:\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n    \n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n        \n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n        \n        # Check if the user should level up based on experience points\n        if (self.skill_level == SkillLevel.BEGINNER and \n            self.experience_points >= 100):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.INTERMEDIATE and \n              self.experience_points >= 300):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.ADVANCED and \n              self.experience_points >= 600):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n    \n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n        \n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n        \n        # Record this event in progress history\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"feature_unlocked\",\n            \"feature_id\": feature_id\n        })\n    \n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n        \n        Args:\n            feature_id: The ID of the feature to check\n            \n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n    \n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"level_up\",\n            \"new_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points\n        })\n    \n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n        \n        # Simple assessment: count number of different features used\n        unique_features_used = len([k for k, v in self.feature_usage_count.items() if v > 5])\n        \n        # Update skill level based on unique features used\n        if unique_features_used >= 15 and self.skill_level.value < SkillLevel.EXPERT.value:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif unique_features_used >= 10 and self.skill_level.value < SkillLevel.ADVANCED.value:\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif unique_features_used >= 5 and self.skill_level.value < SkillLevel.INTERMEDIATE.value:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n    \n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n        \n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), \n                key=lambda x: x[1], \n                reverse=True\n            )[:5] if self.feature_usage_count else []\n        }",
                "class UserProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress and skill level for the progressive feature system.\n    \"\"\"\n    skill_level: SkillLevel = SkillLevel.BEGINNER\n    experience_points: int = 0\n    feature_usage_count: Dict[str, int] = Field(default_factory=dict)\n    unlocked_features: Set[str] = Field(default_factory=set)\n    last_assessment_time: Optional[float] = None\n    progress_history: List[Dict[str, Any]] = Field(default_factory=list)\n    \n    def record_feature_usage(self, feature_id: str, count: int = 1) -> None:\n        \"\"\"\n        Record that a feature was used by the user.\n        \n        Args:\n            feature_id: The ID of the feature that was used\n            count: How many times the feature was used (default: 1)\n        \"\"\"\n        if feature_id not in self.feature_usage_count:\n            self.feature_usage_count[feature_id] = 0\n        \n        self.feature_usage_count[feature_id] += count\n        \n        # Award experience points for using features\n        # More points for using advanced features less frequently\n        if feature_id in self.feature_usage_count and self.feature_usage_count[feature_id] <= 10:\n            self.add_experience(2)\n        else:\n            self.add_experience(1)\n    \n    def add_experience(self, points: int) -> None:\n        \"\"\"\n        Add experience points to the user's progress.\n        \n        Args:\n            points: The number of experience points to add\n        \"\"\"\n        self.experience_points += points\n        \n        # Check if the user should level up based on experience points\n        if (self.skill_level == SkillLevel.BEGINNER and \n            self.experience_points >= 100):\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.INTERMEDIATE and \n              self.experience_points >= 300):\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif (self.skill_level == SkillLevel.ADVANCED and \n              self.experience_points >= 600):\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n    \n    def unlock_feature(self, feature_id: str) -> None:\n        \"\"\"\n        Unlock a feature for the user.\n        \n        Args:\n            feature_id: The ID of the feature to unlock\n        \"\"\"\n        self.unlocked_features.add(feature_id)\n        \n        # Record this event in progress history\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"feature_unlocked\",\n            \"feature_id\": feature_id\n        })\n    \n    def is_feature_unlocked(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is unlocked for the user.\n        \n        Args:\n            feature_id: The ID of the feature to check\n            \n        Returns:\n            True if the feature is unlocked, False otherwise\n        \"\"\"\n        return feature_id in self.unlocked_features\n    \n    def _record_level_up(self) -> None:\n        \"\"\"Record a level-up event in the progress history.\"\"\"\n        self.progress_history.append({\n            \"timestamp\": time.time(),\n            \"event\": \"level_up\",\n            \"new_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points\n        })\n    \n    def assess_skill(self) -> None:\n        \"\"\"\n        Assess the user's skill level based on feature usage patterns.\n        This would use a more sophisticated algorithm in a real implementation.\n        \"\"\"\n        # Record that an assessment was performed\n        self.last_assessment_time = time.time()\n        \n        # Simple assessment: count number of different features used\n        unique_features_used = len([k for k, v in self.feature_usage_count.items() if v > 5])\n        \n        # Update skill level based on unique features used\n        if unique_features_used >= 15 and self.skill_level.value < SkillLevel.EXPERT.value:\n            self.skill_level = SkillLevel.EXPERT\n            self._record_level_up()\n        elif unique_features_used >= 10 and self.skill_level.value < SkillLevel.ADVANCED.value:\n            self.skill_level = SkillLevel.ADVANCED\n            self._record_level_up()\n        elif unique_features_used >= 5 and self.skill_level.value < SkillLevel.INTERMEDIATE.value:\n            self.skill_level = SkillLevel.INTERMEDIATE\n            self._record_level_up()\n    \n    def get_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate a report of the user's progress.\n        \n        Returns:\n            A dictionary containing progress information\n        \"\"\"\n        return {\n            \"skill_level\": self.skill_level.name,\n            \"experience_points\": self.experience_points,\n            \"features_used\": len(self.feature_usage_count),\n            \"unlocked_features\": len(self.unlocked_features),\n            \"most_used_features\": sorted(\n                self.feature_usage_count.items(), \n                key=lambda x: x[1], \n                reverse=True\n            )[:5] if self.feature_usage_count else []\n        }",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\""
            ]
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/__init__.py": {
        "logprobs": -436.0953564987754,
        "metrics": {
            "loc": 21,
            "sloc": 17,
            "lloc": 10,
            "comments": 0,
            "multi": 0,
            "blank": 3,
            "cyclomatic": 0,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))",
                "class Revision(BaseModel):\n    \"\"\"A revision of a document.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n    sections: List[Section] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)",
                "class FocusMode:\n    \"\"\"The focus mode system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the focus mode system with the given document.\"\"\"\n        self.document = document\n        self.active_focus: Optional[FocusContext] = None\n        self.focus_history: List[FocusContext] = []\n    \n    def is_active(self) -> bool:\n        \"\"\"Check if focus mode is currently active.\"\"\"\n        return self.active_focus is not None\n    \n    def get_focus_context(self) -> Optional[FocusContext]:\n        \"\"\"Get the current focus context if focus mode is active.\"\"\"\n        return self.active_focus\n    \n    def enter_focus(\n        self, \n        section_index: int, \n        segment_index: int, \n        level: FocusLevel = FocusLevel.PARAGRAPH\n    ) -> Optional[FocusContext]:\n        \"\"\"Enter focus mode for the specified section and segment.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n        \n        segment = section.get_segment(segment_index)\n        if not segment:\n            return None\n        \n        self.active_focus = FocusContext(\n            document=self.document,\n            section=section,\n            segment=segment,\n            level=level\n        )\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n    \n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        if self.active_focus:\n            self.active_focus = None\n            return True\n        return False\n    \n    def move_focus(self, direction: int = 1) -> Optional[FocusContext]:\n        \"\"\"Move the focus to the next or previous segment.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        current_segment = self.active_focus.segment\n        current_section = self.active_focus.section\n        \n        # Find the next segment within the current section\n        next_position = current_segment.position + direction\n        next_segment = current_section.get_segment(next_position)\n        \n        if next_segment:\n            # Move focus within the same section\n            self.active_focus = FocusContext(\n                document=self.document,\n                section=current_section,\n                segment=next_segment,\n                level=self.active_focus.level\n            )\n            self.focus_history.append(self.active_focus)\n            return self.active_focus\n        \n        # Try to move to a different section\n        current_section_idx = self.document.current_revision.sections.index(current_section)\n        next_section_idx = current_section_idx + direction\n        \n        if 0 <= next_section_idx < len(self.document.current_revision.sections):\n            next_section = self.document.current_revision.sections[next_section_idx]\n            \n            # Get the first or last segment of the next section depending on direction\n            target_position = 0 if direction > 0 else len(next_section.segments) - 1\n            if 0 <= target_position < len(next_section.segments):\n                next_segment = next_section.segments[target_position]\n                \n                self.active_focus = FocusContext(\n                    document=self.document,\n                    section=next_section,\n                    segment=next_segment,\n                    level=self.active_focus.level\n                )\n                self.focus_history.append(self.active_focus)\n                return self.active_focus\n        \n        return None\n    \n    def change_focus_level(self, level: FocusLevel) -> Optional[FocusContext]:\n        \"\"\"Change the level of focus.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        self.active_focus.level = level\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n    \n    def edit_focused_content(self, new_content: str) -> Optional[TextSegment]:\n        \"\"\"Edit the content of the focused segment.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        self.active_focus.segment.content = new_content\n        self.document.updated_at = time.time()\n        return self.active_focus.segment\n    \n    def get_focus_time(self) -> float:\n        \"\"\"Get the time spent in the current focus session in seconds.\"\"\"\n        if not self.active_focus:\n            return 0.0\n        \n        return time.time() - self.active_focus.start_time\n    \n    def get_surrounding_context(self, context_size: int = 2) -> List[TextSegment]:\n        \"\"\"Get the surrounding segments around the focused segment.\"\"\"\n        if not self.active_focus:\n            return []\n        \n        section = self.active_focus.section\n        position = self.active_focus.segment.position\n        \n        start = max(0, position - context_size)\n        end = min(len(section.segments), position + context_size + 1)\n        \n        return section.segments[start:end]",
                "class FocusLevel(str, Enum):\n    \"\"\"The level of focus.\"\"\"\n    \n    PARAGRAPH = \"paragraph\"\n    SENTENCE = \"sentence\"\n    SECTION = \"section\"",
                "class FocusContext(BaseModel):\n    \"\"\"Context information about the focused element.\"\"\"\n    \n    document: Document\n    section: Section\n    segment: TextSegment\n    level: FocusLevel\n    start_time: float = Field(default_factory=time.time)\n    \n    class Config:\n        arbitrary_types_allowed = True",
                "class WritingStatistics:\n    \"\"\"Writing statistics tracking system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the writing statistics system with the given document.\"\"\"\n        self.document = document\n        self.stats_history: List[DocumentStats] = []\n        self.pace_history: List[WritingPace] = []\n        self.progress_trackers: Dict[str, ProgressTracker] = {}\n        self._last_word_count: int = 0\n        self._last_check_time: float = time.time()\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n    \n    def _count_sentences(self, text: str) -> int:\n        \"\"\"Count the number of sentences in the text.\"\"\"\n        # Simple sentence counting - this could be improved with NLP\n        return len(re.findall(r'[.!?]+\\s+', text)) + 1\n    \n    def _identify_sentence_type(self, sentence: str) -> str:\n        \"\"\"Identify the type of a sentence.\"\"\"\n        sentence = sentence.strip()\n        if not sentence:\n            return \"unknown\"\n        \n        if sentence.endswith('?'):\n            return \"interrogative\"\n        elif sentence.endswith('!'):\n            return \"exclamatory\"\n        elif ',' in sentence and ('but' in sentence.lower() or 'however' in sentence.lower()):\n            return \"complex\"\n        else:\n            return \"declarative\"\n    \n    def _is_complex_sentence(self, sentence: str) -> bool:\n        \"\"\"Check if a sentence is complex (has multiple clauses).\"\"\"\n        # Simple check for coordinating conjunctions and subordinating conjunctions\n        coordinating_conjunctions = [\n            ' and ', ' but ', ' or ', ' nor ', ' so ', ' for ', ' yet '\n        ]\n\n        subordinating_conjunctions = [\n            ' because ', ' although ', ' though ', ' since ', ' unless ',\n            ' if ', ' when ', ' where ', ' while '\n        ]\n\n        # Check for conjunction at beginning of sentence too\n        sentence_starts = [\n            'when ', 'if ', 'while ', 'because ', 'although ', 'though ',\n            'since ', 'unless ', 'where '\n        ]\n\n        sentence = sentence.lower()\n\n        # Check for any coordinating conjunctions within the sentence\n        has_coordinating = any(conj in sentence for conj in coordinating_conjunctions)\n\n        # Check for any subordinating conjunctions within the sentence\n        has_subordinating = any(conj in sentence for conj in subordinating_conjunctions)\n\n        # Check if the sentence starts with a subordinating conjunction\n        starts_with_subordinating = any(sentence.startswith(start) for start in sentence_starts)\n\n        return has_coordinating or has_subordinating or starts_with_subordinating\n    \n    def _calculate_vocabulary_richness(self, total_words: int, unique_words: int) -> float:\n        \"\"\"Calculate vocabulary richness (Type-Token Ratio).\"\"\"\n        if total_words == 0:\n            return 0.0\n        return unique_words / total_words\n    \n    def calculate_stats(self) -> DocumentStats:\n        \"\"\"Calculate the current document statistics.\"\"\"\n        text = self.document.get_content()\n        \n        # Basic counts\n        word_count = len(re.findall(r'\\b\\w+\\b', text))\n        character_count = len(text)\n        paragraph_count = len(re.findall(r'\\n\\s*\\n', text)) + 1\n        \n        # Split into sentences for sentence analysis\n        sentences = re.split(r'[.!?]+\\s+', text)\n        sentence_count = len(sentences)\n        \n        # Analyze sentence structure\n        sentence_lengths = [len(re.findall(r'\\b\\w+\\b', s)) for s in sentences if s.strip()]\n        avg_sentence_length = statistics.mean(sentence_lengths) if sentence_lengths else 0\n        sentence_length_variance = statistics.variance(sentence_lengths) if len(sentence_lengths) > 1 else 0\n        \n        complex_sentences = sum(1 for s in sentences if self._is_complex_sentence(s))\n        \n        sentence_types = {}\n        for s in sentences:\n            if not s.strip():\n                continue\n            sent_type = self._identify_sentence_type(s)\n            sentence_types[sent_type] = sentence_types.get(sent_type, 0) + 1\n        \n        # Analyze word usage\n        words = re.findall(r'\\b\\w+\\b', text.lower())\n        unique_words = len(set(words))\n        \n        word_lengths = [len(w) for w in words]\n        avg_word_length = statistics.mean(word_lengths) if word_lengths else 0\n        \n        # Count word frequencies\n        word_frequencies = {}\n        for word in words:\n            if len(word) > 3:  # Ignore very short words\n                word_frequencies[word] = word_frequencies.get(word, 0) + 1\n        \n        # Get most common words (top 20)\n        most_common = dict(sorted(word_frequencies.items(), key=lambda x: x[1], reverse=True)[:20])\n        \n        # Calculate reading level metrics\n        reading_level = {\n            ReadingLevel.FLESCH_KINCAID_GRADE.value: textstat.flesch_kincaid_grade(text),\n            ReadingLevel.FLESCH_READING_EASE.value: textstat.flesch_reading_ease(text),\n            ReadingLevel.GUNNING_FOG.value: textstat.gunning_fog(text),\n            ReadingLevel.SMOG_INDEX.value: textstat.smog_index(text),\n            ReadingLevel.AUTOMATED_READABILITY_INDEX.value: textstat.automated_readability_index(text),\n            ReadingLevel.COLEMAN_LIAU_INDEX.value: textstat.coleman_liau_index(text)\n        }\n        \n        # Create stats objects\n        word_stats = WordStats(\n            total_words=word_count,\n            unique_words=unique_words,\n            average_word_length=avg_word_length,\n            most_common_words=most_common,\n            vocabulary_richness=self._calculate_vocabulary_richness(word_count, unique_words)\n        )\n        \n        sentence_stats = SentenceStats(\n            total_sentences=sentence_count,\n            average_sentence_length=avg_sentence_length,\n            sentence_length_variance=sentence_length_variance,\n            complex_sentences=complex_sentences,\n            sentence_types=sentence_types\n        )\n        \n        document_stats = DocumentStats(\n            word_count=word_count,\n            character_count=character_count,\n            paragraph_count=paragraph_count,\n            sentence_count=sentence_count,\n            reading_level=reading_level,\n            word_stats=word_stats,\n            sentence_stats=sentence_stats\n        )\n        \n        # Update history\n        self.stats_history.append(document_stats)\n        \n        # Update last word count for pace tracking\n        self._last_word_count = word_count\n        \n        return document_stats\n    \n    def calculate_writing_pace(self) -> WritingPace:\n        \"\"\"Calculate the current writing pace.\"\"\"\n        current_time = time.time()\n        current_word_count = self.document.get_word_count()\n        \n        time_diff_seconds = current_time - self._last_check_time\n        word_diff = current_word_count - self._last_word_count\n        \n        if time_diff_seconds <= 0:\n            words_per_minute = 0.0\n        else:\n            # Calculate words per minute\n            words_per_minute = (word_diff / time_diff_seconds) * 60\n        \n        # Update for next calculation\n        self._last_check_time = current_time\n        self._last_word_count = current_word_count\n        \n        # Create pace object\n        pace = WritingPace(\n            words_per_minute=words_per_minute,\n            words_per_hour=words_per_minute * 60,\n            words_per_day=words_per_minute * 60 * 24\n        )\n        \n        # Update history\n        self.pace_history.append(pace)\n        \n        return pace\n    \n    def set_progress_goal(\n        self, \n        goal_id: str,\n        goal_type: str, \n        target: int, \n        deadline: Optional[datetime] = None\n    ) -> ProgressTracker:\n        \"\"\"Set a new progress goal.\"\"\"\n        tracker = ProgressTracker(\n            start_date=datetime.now(),\n            goal_type=goal_type,\n            goal_target=target,\n            goal_deadline=deadline\n        )\n        \n        self.progress_trackers[goal_id] = tracker\n        return tracker\n    \n    def update_progress(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Update the progress for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n        \n        tracker = self.progress_trackers[goal_id]\n        current_stats = self.calculate_stats()\n        \n        progress_entry = {\n            \"timestamp\": datetime.now(),\n            \"word_count\": current_stats.word_count,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target\n        }\n        \n        if tracker.goal_type == \"word_count\":\n            progress_entry[\"progress_percentage\"] = (current_stats.word_count / tracker.goal_target) * 100\n            progress_entry[\"remaining\"] = max(0, tracker.goal_target - current_stats.word_count)\n        \n        if tracker.goal_deadline:\n            now = datetime.now()\n            if now < tracker.goal_deadline:\n                time_remaining = tracker.goal_deadline - now\n                progress_entry[\"time_remaining_days\"] = time_remaining.days\n                \n                # Estimate completion date based on current pace\n                if self.pace_history and tracker.goal_type == \"word_count\":\n                    latest_pace = self.pace_history[-1]\n                    words_remaining = max(0, tracker.goal_target - current_stats.word_count)\n                    \n                    if latest_pace.words_per_day > 0:\n                        days_needed = words_remaining / latest_pace.words_per_day\n                        progress_entry[\"estimated_completion_date\"] = now + timedelta(days=days_needed)\n        \n        tracker.progress_history.append(progress_entry)\n        return progress_entry\n    \n    def get_progress_report(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a detailed progress report for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n        \n        tracker = self.progress_trackers[goal_id]\n        current_progress = self.update_progress(goal_id)\n        \n        if not current_progress or not tracker.progress_history:\n            return None\n        \n        report = {\n            \"goal_id\": goal_id,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n            \"start_date\": tracker.start_date,\n            \"deadline\": tracker.goal_deadline,\n            \"current_progress\": current_progress,\n            \"history_summary\": {\n                \"start_value\": tracker.progress_history[0].get(\"word_count\", 0),\n                \"current_value\": current_progress.get(\"word_count\", 0),\n                \"total_progress\": current_progress.get(\"word_count\", 0) - tracker.progress_history[0].get(\"word_count\", 0)\n            }\n        }\n        \n        # Calculate average daily progress\n        if len(tracker.progress_history) > 1:\n            first_entry = tracker.progress_history[0]\n            last_entry = tracker.progress_history[-1]\n            \n            first_time = first_entry[\"timestamp\"]\n            last_time = last_entry[\"timestamp\"]\n            \n            time_diff_days = (last_time - first_time).days or 1  # Avoid division by zero\n            progress_diff = last_entry.get(\"word_count\", 0) - first_entry.get(\"word_count\", 0)\n            \n            report[\"average_daily_progress\"] = progress_diff / time_diff_days\n        \n        return report\n    \n    def start_background_tracking(self, interval_seconds: int = 60) -> None:\n        \"\"\"Start tracking statistics in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n        \n        self._stop_background_thread = False\n        \n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.calculate_stats()\n                    self.calculate_writing_pace()\n                    \n                    # Update all progress trackers\n                    for goal_id in self.progress_trackers:\n                        self.update_progress(goal_id)\n                except Exception as e:\n                    print(f\"Error in background tracking: {e}\")\n                \n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n        \n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n    \n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)\n    \n    def get_trend_analysis(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"Analyze trends in writing statistics over the specified number of days.\"\"\"\n        now = datetime.now()\n        cutoff_date = now - timedelta(days=days)\n        \n        # Filter history to the specified time range\n        recent_stats = [s for s in self.stats_history if s.timestamp >= cutoff_date]\n        recent_pace = [p for p in self.pace_history if p.timestamp >= cutoff_date]\n        \n        if not recent_stats:\n            return {\"error\": \"Not enough data for trend analysis\"}\n        \n        # Calculate daily word counts\n        daily_word_counts = {}\n        for stats in recent_stats:\n            day_key = stats.timestamp.strftime(\"%Y-%m-%d\")\n            if day_key not in daily_word_counts:\n                daily_word_counts[day_key] = []\n            daily_word_counts[day_key].append(stats.word_count)\n        \n        # Get the last word count for each day\n        daily_progress = {\n            day: counts[-1] for day, counts in daily_word_counts.items()\n        }\n        \n        # Calculate daily difference\n        days_sorted = sorted(daily_progress.keys())\n        daily_change = {}\n        for i in range(1, len(days_sorted)):\n            prev_day = days_sorted[i-1]\n            curr_day = days_sorted[i]\n            daily_change[curr_day] = daily_progress[curr_day] - daily_progress[prev_day]\n        \n        # Calculate reading level trends\n        reading_level_trends = {}\n        for level_type in ReadingLevel:\n            level_values = [s.reading_level.get(level_type.value, 0) for s in recent_stats]\n            if level_values:\n                reading_level_trends[level_type.value] = {\n                    \"start\": level_values[0],\n                    \"end\": level_values[-1],\n                    \"change\": level_values[-1] - level_values[0],\n                    \"average\": sum(level_values) / len(level_values)\n                }\n        \n        # Calculate pace trends\n        pace_trends = {}\n        if recent_pace:\n            wpm_values = [p.words_per_minute for p in recent_pace]\n            pace_trends[\"words_per_minute\"] = {\n                \"start\": wpm_values[0],\n                \"end\": wpm_values[-1],\n                \"change\": wpm_values[-1] - wpm_values[0],\n                \"average\": sum(wpm_values) / len(wpm_values)\n            }\n        \n        return {\n            \"period_days\": days,\n            \"total_word_count_change\": recent_stats[-1].word_count - recent_stats[0].word_count,\n            \"daily_progress\": daily_progress,\n            \"daily_change\": daily_change,\n            \"average_daily_change\": sum(daily_change.values()) / len(daily_change) if daily_change else 0,\n            \"reading_level_trends\": reading_level_trends,\n            \"pace_trends\": pace_trends,\n            \"vocabulary_richness_change\": (\n                recent_stats[-1].word_stats.vocabulary_richness - \n                recent_stats[0].word_stats.vocabulary_richness\n            )\n        }",
                "class ReadingLevel(str, Enum):\n    \"\"\"Different reading level metrics.\"\"\"\n    \n    FLESCH_KINCAID_GRADE = \"flesch_kincaid_grade\"\n    FLESCH_READING_EASE = \"flesch_reading_ease\"\n    GUNNING_FOG = \"gunning_fog\"\n    SMOG_INDEX = \"smog_index\"\n    AUTOMATED_READABILITY_INDEX = \"automated_readability_index\"\n    COLEMAN_LIAU_INDEX = \"coleman_liau_index\"\n    DALE_CHALL_READABILITY_SCORE = \"dale_chall_readability_score\"\n    LINSEAR_WRITE_FORMULA = \"linsear_write_formula\"\n    SPACHE_READABILITY = \"spache_readability\"",
                "class DocumentStats(BaseModel):\n    \"\"\"Overall document statistics.\"\"\"\n    \n    word_count: int\n    character_count: int\n    paragraph_count: int\n    sentence_count: int\n    reading_level: Dict[str, float]\n    word_stats: WordStats\n    sentence_stats: SentenceStats\n    timestamp: datetime = Field(default_factory=datetime.now)",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n    \n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n    \n    def _find_element_occurrences(\n        self, \n        element_name: str, \n        aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n        \n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = r'\\b(' + '|'.join(re.escape(name) for name in names_to_search) + r')\\b'\n        regex = re.compile(pattern, re.IGNORECASE)\n        \n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n                    \n                    results.append((section, segment, match.start(), context))\n        \n        return results\n    \n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n        \n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set()\n        }\n        \n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n        \n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n        \n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n        \n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(re.findall(r'\\b' + re.escape(element) + r'\\b', text, re.IGNORECASE))\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element in [e.name for e in self.elements.values()]\n                    }\n        \n        return results\n    \n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n        \n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n            \n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n            \n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n                \n                co_occurrences = 0\n                for context in contexts:\n                    pattern = r'\\b(' + '|'.join(\n                        [re.escape(other_element.name)] + \n                        [re.escape(alias) for alias in other_element.aliases]\n                    ) + r')\\b'\n                    \n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n                \n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n        \n        return connections\n    \n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n        \n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n        \n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n            \n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n        \n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n        \n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(char_timeline_sections, key=lambda s: timeline_sections[s])\n                    \n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n                            \n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(ConsistencyIssue(\n                                        id=str(len(issues) + 1),\n                                        issue_type=\"timeline\",\n                                        elements_involved=[char_id],\n                                        description=(\n                                            f\"Character appears in non-sequential timeline points: \"\n                                            f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[k]]}\"\n                                        ),\n                                        locations=[\n                                            (sorted_sections[i], \"\"),\n                                            (sorted_sections[j], \"\"),\n                                            (sorted_sections[k], \"\")\n                                        ],\n                                        severity=3\n                                    ))\n        \n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n            \n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n                \n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name):]\n                    \n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r'\\s+was\\s+(\\w+)',\n                        r'\\s+had\\s+(\\w+)',\n                        r'\\s+with\\s+(\\w+)',\n                        r',\\s+a\\s+(\\w+)',\n                        r',\\s+the\\s+(\\w+)'\n                    ]\n                    \n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append((\n                                occurrence.section_id,\n                                occurrence.segment_id,\n                                match.group(1),\n                                context\n                            ))\n            \n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n                \n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\")\n                ]\n                \n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(ConsistencyIssue(\n                            id=str(len(issues) + 1),\n                            issue_type=\"contradiction\",\n                            elements_involved=[element_id],\n                            description=(\n                                f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                            ),\n                            locations=[\n                                (descriptions[word1][0][0], descriptions[word1][0][1]),\n                                (descriptions[word2][0][0], descriptions[word2][0][1])\n                            ],\n                            severity=4\n                        ))\n        \n        return issues\n    \n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n        \n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(name, aliases):\n            occurrences.append(ElementOccurrence(\n                element_id=element_id,\n                section_id=section.id,\n                segment_id=segment.id,\n                position=position,\n                context=context\n            ))\n        \n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None\n        )\n        \n        self.elements[element_id] = element\n        return element\n    \n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n        \n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: []\n        }\n        \n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name,\n                        element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n        \n        # Update element relationships\n        self.update_element_relationships()\n        \n        # Detect consistency issues\n        self.check_consistency()\n        \n        return tracked_elements\n    \n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n        \n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n    \n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n    \n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n        \n        element = self.elements[element_id]\n        appearances = []\n        \n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n            \n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n            \n            if section and segment:\n                appearances.append({\n                    \"section_title\": section.title,\n                    \"section_id\": section.id,\n                    \"segment_id\": segment.id,\n                    \"segment_position\": segment.position,\n                    \"context\": occurrence.context,\n                    \"mentioned_with\": [\n                        self.elements[e_id].name \n                        for e_id in occurrence.mentioned_with \n                        if e_id in self.elements\n                    ]\n                })\n        \n        return appearances\n    \n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n        \n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": []\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n        \n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append({\n                    \"section_id\": section.id,\n                    \"section_title\": sections[section.id][\"section_title\"],\n                    \"appearances\": sorted(\n                        sections[section.id][\"appearances\"],\n                        key=lambda a: a[\"segment_position\"]\n                    )\n                })\n        \n        return ordered_sections\n    \n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n    \n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n        \n        self._stop_background_thread = False\n        \n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n                \n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n        \n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n    \n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n    \n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class NarrativeElement(BaseModel):\n    \"\"\"A tracked narrative element such as a character or plot element.\"\"\"\n    \n    id: str\n    name: str\n    element_type: ElementType\n    aliases: List[str] = Field(default_factory=list)\n    description: str = \"\"\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    occurrences: List[ElementOccurrence] = Field(default_factory=list)\n    related_elements: Dict[str, float] = Field(default_factory=dict)  # Element ID to relationship strength\n    first_appearance: Optional[datetime] = None\n    last_appearance: Optional[datetime] = None",
                "class DocumentNavigator:\n    \"\"\"Non-linear document navigation system.\"\"\"\n    \n    def __init__(self, document: Document, narrative_tracker: Optional[NarrativeTracker] = None):\n        \"\"\"Initialize the navigation system with the given document.\"\"\"\n        self.document = document\n        self.narrative_tracker = narrative_tracker\n        self.elements: Dict[str, NavigationElement] = {}\n        self.views: Dict[str, NavigationView] = {}\n        self.tags: Dict[str, NavigationTag] = {}\n        self.links: Dict[str, NavigationLink] = {}\n        self.current_position: Optional[NavigationPosition] = None\n        \n        # Initialize with default linear view\n        self._initialize_linear_view()\n    \n    def _initialize_linear_view(self) -> None:\n        \"\"\"Initialize the default linear view of the document.\"\"\"\n        # Create view\n        view_id = \"view_linear\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Linear View\",\n            view_type=NavigationViewType.LINEAR\n        )\n        \n        # Create elements for sections and segments\n        root_elements = []\n        \n        for section_idx, section in enumerate(self.document.current_revision.sections):\n            # Create element for the section\n            section_element_id = f\"element_section_{section.id}\"\n            section_element = NavigationElement(\n                id=section_element_id,\n                element_type=\"section\",\n                name=section.title,\n                original_id=section.id\n            )\n            \n            # Add to elements\n            self.elements[section_element_id] = section_element\n            root_elements.append(section_element_id)\n            \n            # Create elements for segments\n            for segment_idx, segment in enumerate(section.segments):\n                segment_element_id = f\"element_segment_{segment.id}\"\n                segment_element = NavigationElement(\n                    id=segment_element_id,\n                    element_type=\"segment\",\n                    name=f\"Paragraph {segment_idx + 1}\",\n                    original_id=segment.id\n                )\n                \n                # Add to elements\n                self.elements[segment_element_id] = segment_element\n                \n                # Add to section's children\n                section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        # Set current position to the first section if available\n        if root_elements:\n            self.current_position = NavigationPosition(\n                view_id=view_id,\n                element_id=root_elements[0]\n            )\n    \n    def _create_character_view(self) -> str:\n        \"\"\"Create a view organized by characters.\"\"\"\n        if not self.narrative_tracker:\n            return \"\"\n        \n        # Create view\n        view_id = \"view_character\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Character View\",\n            view_type=NavigationViewType.CHARACTER\n        )\n        \n        # Get character elements from the narrative tracker\n        character_elements = [\n            element for element in self.narrative_tracker.elements.values()\n            if element.element_type == ElementType.CHARACTER\n        ]\n        \n        # Create elements for each character\n        root_elements = []\n        \n        for character in character_elements:\n            # Create element for the character\n            character_element_id = f\"element_character_{character.id}\"\n            character_element = NavigationElement(\n                id=character_element_id,\n                element_type=\"character\",\n                name=character.name,\n                original_id=character.id,\n                metadata={\"description\": character.description}\n            )\n            \n            # Add to elements\n            self.elements[character_element_id] = character_element\n            root_elements.append(character_element_id)\n            \n            # Get appearances of this character\n            appearances = self.narrative_tracker.get_element_appearances(character.id)\n            \n            # Group by section\n            section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n            for appearance in appearances:\n                section_id = appearance[\"section_id\"]\n                if section_id not in section_appearances:\n                    section_appearances[section_id] = []\n                section_appearances[section_id].append(appearance)\n            \n            # Create elements for each section with appearances\n            for section_id, section_apps in section_appearances.items():\n                # Get the section\n                section = None\n                for s in self.document.current_revision.sections:\n                    if s.id == section_id:\n                        section = s\n                        break\n                \n                if not section:\n                    continue\n                \n                # Create element for the section\n                section_element_id = f\"element_character_section_{character.id}_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                \n                # Add to character's children\n                character_element.children.append(section_element_id)\n                \n                # Create elements for each appearance\n                for appearance in section_apps:\n                    segment_id = appearance[\"segment_id\"]\n                    \n                    # Get the segment\n                    segment = None\n                    for seg in section.segments:\n                        if seg.id == segment_id:\n                            segment = seg\n                            break\n                    \n                    if not segment:\n                        continue\n                    \n                    # Create element for the segment\n                    segment_element_id = f\"element_character_segment_{character.id}_{segment.id}\"\n                    \n                    # Skip if already added\n                    if segment_element_id in self.elements:\n                        continue\n                    \n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Appearance {len(section_element.children) + 1}\",\n                        original_id=segment.id,\n                        metadata={\"context\": appearance[\"context\"]}\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def _create_plot_view(self) -> str:\n        \"\"\"Create a view organized by plot elements.\"\"\"\n        # Create view\n        view_id = \"view_plot\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Plot View\",\n            view_type=NavigationViewType.PLOT\n        )\n        \n        # First, look for plot-related metadata in the document\n        plot_elements = []\n        \n        # Check for plot tags\n        plot_tags = [tag for tag in self.tags.values() if \"plot\" in tag.name.lower()]\n        \n        if plot_tags:\n            # Organize by plot tags\n            for tag in plot_tags:\n                # Create element for the tag\n                tag_element_id = f\"element_plot_tag_{tag.id}\"\n                tag_element = NavigationElement(\n                    id=tag_element_id,\n                    element_type=\"tag\",\n                    name=tag.name,\n                    original_id=tag.id\n                )\n                \n                # Add to elements\n                self.elements[tag_element_id] = tag_element\n                plot_elements.append(tag_element_id)\n                \n                # Find elements with this tag\n                for element_id, element in self.elements.items():\n                    if tag.id in element.tags:\n                        # Create a reference element\n                        ref_element_id = f\"element_plot_ref_{tag.id}_{element.id}\"\n                        ref_element = NavigationElement(\n                            id=ref_element_id,\n                            element_type=element.element_type,\n                            name=element.name,\n                            original_id=element.original_id\n                        )\n                        \n                        # Add to elements\n                        self.elements[ref_element_id] = ref_element\n                        \n                        # Add to tag's children\n                        tag_element.children.append(ref_element_id)\n        \n        # If we have a narrative tracker, use plot elements from there\n        elif self.narrative_tracker:\n            # Get plot elements from the narrative tracker\n            plot_narrative_elements = [\n                element for element in self.narrative_tracker.elements.values()\n                if element.element_type in (ElementType.EVENT, ElementType.ITEM, ElementType.TERM)\n            ]\n            \n            for plot_element in plot_narrative_elements:\n                # Create element for the plot element\n                plot_element_id = f\"element_plot_{plot_element.id}\"\n                plot_nav_element = NavigationElement(\n                    id=plot_element_id,\n                    element_type=\"plot\",\n                    name=plot_element.name,\n                    original_id=plot_element.id,\n                    metadata={\"description\": plot_element.description}\n                )\n                \n                # Add to elements\n                self.elements[plot_element_id] = plot_nav_element\n                plot_elements.append(plot_element_id)\n                \n                # Get appearances of this plot element\n                appearances = self.narrative_tracker.get_element_appearances(plot_element.id)\n                \n                # Group by section\n                section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n                for appearance in appearances:\n                    section_id = appearance[\"section_id\"]\n                    if section_id not in section_appearances:\n                        section_appearances[section_id] = []\n                    section_appearances[section_id].append(appearance)\n                \n                # Create elements for each section with appearances\n                for section_id, section_apps in section_appearances.items():\n                    # Get the section\n                    section = None\n                    for s in self.document.current_revision.sections:\n                        if s.id == section_id:\n                            section = s\n                            break\n                    \n                    if not section:\n                        continue\n                    \n                    # Create element for the section\n                    section_element_id = f\"element_plot_section_{plot_element.id}_{section.id}\"\n                    section_element = NavigationElement(\n                        id=section_element_id,\n                        element_type=\"section\",\n                        name=section.title,\n                        original_id=section.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[section_element_id] = section_element\n                    \n                    # Add to plot element's children\n                    plot_nav_element.children.append(section_element_id)\n                    \n                    # Create elements for each appearance\n                    for appearance in section_apps:\n                        segment_id = appearance[\"segment_id\"]\n                        \n                        # Get the segment\n                        segment = None\n                        for seg in section.segments:\n                            if seg.id == segment_id:\n                                segment = seg\n                                break\n                        \n                        if not segment:\n                            continue\n                        \n                        # Create element for the segment\n                        segment_element_id = f\"element_plot_segment_{plot_element.id}_{segment.id}\"\n                        \n                        # Skip if already added\n                        if segment_element_id in self.elements:\n                            continue\n                        \n                        segment_element = NavigationElement(\n                            id=segment_element_id,\n                            element_type=\"segment\",\n                            name=f\"Reference {len(section_element.children) + 1}\",\n                            original_id=segment.id,\n                            metadata={\"context\": appearance[\"context\"]}\n                        )\n                        \n                        # Add to elements\n                        self.elements[segment_element_id] = segment_element\n                        \n                        # Add to section's children\n                        section_element.children.append(segment_element_id)\n        \n        # If we don't have plot tags or narrative tracker, create a dummy structure\n        if not plot_elements:\n            # Create a default \"plot\" element\n            plot_element_id = \"element_plot_default\"\n            plot_element = NavigationElement(\n                id=plot_element_id,\n                element_type=\"plot\",\n                name=\"Main Plot\"\n            )\n            \n            # Add to elements\n            self.elements[plot_element_id] = plot_element\n            plot_elements.append(plot_element_id)\n            \n            # Add all sections as children\n            for section in self.document.current_revision.sections:\n                # Create element for the section\n                section_element_id = f\"element_plot_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                \n                # Add to plot's children\n                plot_element.children.append(section_element_id)\n        \n        # Update view\n        view.root_elements = plot_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def _create_timeline_view(self) -> str:\n        \"\"\"Create a view organized by timeline/chronology.\"\"\"\n        # Create view\n        view_id = \"view_timeline\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Timeline View\",\n            view_type=NavigationViewType.TIMELINE\n        )\n        \n        # Check for timeline metadata in sections\n        timeline_sections = []\n        \n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections.append((section, section.metadata[\"timeline\"]))\n        \n        # If we have timeline metadata, use it to organize the view\n        if timeline_sections:\n            # Sort sections by timeline value\n            timeline_sections.sort(key=lambda x: x[1])\n            \n            # Create elements for each section in chronological order\n            root_elements = []\n            \n            for section, timeline in timeline_sections:\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=f\"{timeline}: {section.title}\",\n                    original_id=section.id,\n                    metadata={\"timeline\": timeline}\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n                \n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        else:\n            # Create a simple chronological view (same as linear)\n            root_elements = []\n            \n            for section_idx, section in enumerate(self.document.current_revision.sections):\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                    metadata={\"position\": section_idx}\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n                \n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def create_view(self, name: str, view_type: NavigationViewType) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        if view_type == NavigationViewType.CHARACTER:\n            return self._create_character_view()\n        elif view_type == NavigationViewType.PLOT:\n            return self._create_plot_view()\n        elif view_type == NavigationViewType.TIMELINE:\n            return self._create_timeline_view()\n        elif view_type == NavigationViewType.CUSTOM:\n            # Create a custom view\n            view_id = f\"view_custom_{len(self.views) + 1}\"\n            view = NavigationView(\n                id=view_id,\n                name=name,\n                view_type=view_type\n            )\n            \n            self.views[view_id] = view\n            return view_id\n        else:\n            # Linear view already exists\n            return \"view_linear\"\n    \n    def create_tag(self, name: str, color: str = \"#CCCCCC\") -> str:\n        \"\"\"Create a new tag for navigation elements.\"\"\"\n        tag_id = f\"tag_{len(self.tags) + 1}\"\n        tag = NavigationTag(\n            id=tag_id,\n            name=name,\n            color=color\n        )\n        \n        self.tags[tag_id] = tag\n        return tag_id\n    \n    def add_tag_to_element(self, element_id: str, tag_id: str) -> bool:\n        \"\"\"Add a tag to a navigation element.\"\"\"\n        if element_id not in self.elements or tag_id not in self.tags:\n            return False\n        \n        element = self.elements[element_id]\n        if tag_id not in element.tags:\n            element.tags.append(tag_id)\n        \n        return True\n    \n    def create_link(\n        self, \n        source_type: str, \n        source_id: str, \n        target_type: str, \n        target_id: str, \n        link_type: str\n    ) -> str:\n        \"\"\"Create a link between two navigation elements.\"\"\"\n        link_id = f\"link_{len(self.links) + 1}\"\n        link = NavigationLink(\n            id=link_id,\n            source_type=source_type,\n            source_id=source_id,\n            target_type=target_type,\n            target_id=target_id,\n            link_type=link_type\n        )\n        \n        self.links[link_id] = link\n        return link_id\n    \n    def add_element_to_view(self, view_id: str, element_id: str, parent_id: Optional[str] = None) -> bool:\n        \"\"\"Add an element to a view, optionally as a child of another element.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n        \n        view = self.views[view_id]\n        \n        if parent_id:\n            if parent_id not in self.elements:\n                return False\n            \n            parent = self.elements[parent_id]\n            if element_id not in parent.children:\n                parent.children.append(element_id)\n        else:\n            if element_id not in view.root_elements:\n                view.root_elements.append(element_id)\n        \n        return True\n    \n    def get_current_element(self) -> Optional[NavigationElement]:\n        \"\"\"Get the current navigation element.\"\"\"\n        if not self.current_position:\n            return None\n        \n        element_id = self.current_position.element_id\n        return self.elements.get(element_id)\n    \n    def get_element_content(self, element_id: str) -> Optional[str]:\n        \"\"\"Get the content of a navigation element.\"\"\"\n        if element_id not in self.elements:\n            return None\n        \n        element = self.elements[element_id]\n        original_id = element.original_id\n        \n        if not original_id:\n            return None\n        \n        if element.element_type == \"section\":\n            # Find the section\n            for section in self.document.current_revision.sections:\n                if section.id == original_id:\n                    return section.get_content()\n        \n        elif element.element_type == \"segment\":\n            # Find the segment\n            for section in self.document.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == original_id:\n                        return segment.content\n        \n        return None\n    \n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n        \n        self.current_position = NavigationPosition(\n            view_id=view_id,\n            element_id=element_id\n        )\n        \n        return True\n    \n    def navigate_to_related(self, link_type: Optional[str] = None) -> List[NavigationElement]:\n        \"\"\"Navigate to elements related to the current element.\"\"\"\n        if not self.current_position:\n            return []\n        \n        current_element_id = self.current_position.element_id\n        \n        # Find links with this element as source\n        related_links = []\n        for link in self.links.values():\n            if link.source_id == current_element_id:\n                if not link_type or link.link_type == link_type:\n                    related_links.append(link)\n        \n        # Get related elements\n        related_elements = []\n        for link in related_links:\n            target_id = link.target_id\n            if target_id in self.elements:\n                related_elements.append(self.elements[target_id])\n        \n        return related_elements\n    \n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Find parent element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Navigate to parent\n            self.current_position = NavigationPosition(\n                view_id=view_id,\n                element_id=parent_id\n            )\n            return True\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Already at top level\n            return False\n        \n        return False\n    \n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Check if this element is a child of another element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n            \n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n                \n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(siblings):\n                    next_id = siblings[current_index + 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=next_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n                \n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(view.root_elements):\n                    next_id = view.root_elements[current_index + 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=next_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        return False\n    \n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Check if this element is a child of another element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n            \n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n                \n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = siblings[current_index - 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=prev_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n                \n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = view.root_elements[current_index - 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=prev_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        return False\n    \n    def navigate_children(self) -> List[NavigationElement]:\n        \"\"\"Get the children of the current element.\"\"\"\n        if not self.current_position:\n            return []\n        \n        current_element_id = self.current_position.element_id\n        \n        # Get element\n        element = self.elements.get(current_element_id)\n        if not element:\n            return []\n        \n        # Get children\n        children = []\n        for child_id in element.children:\n            if child_id in self.elements:\n                children.append(self.elements[child_id])\n        \n        return children\n    \n    def find_elements_by_tag(self, tag_id: str) -> List[NavigationElement]:\n        \"\"\"Find all elements with a specific tag.\"\"\"\n        if tag_id not in self.tags:\n            return []\n        \n        # Find elements with this tag\n        tagged_elements = []\n        for element_id, element in self.elements.items():\n            if tag_id in element.tags:\n                tagged_elements.append(element)\n        \n        return tagged_elements\n    \n    def find_elements_by_name(self, name: str) -> List[NavigationElement]:\n        \"\"\"Find elements by name (case-insensitive partial match).\"\"\"\n        name = name.lower()\n        \n        matching_elements = []\n        for element_id, element in self.elements.items():\n            if name in element.name.lower():\n                matching_elements.append(element)\n        \n        return matching_elements\n    \n    def get_path_to_element(self, element_id: str) -> List[str]:\n        \"\"\"Get the path from root to the specified element.\"\"\"\n        if element_id not in self.elements:\n            return []\n        \n        # Find view that contains this element\n        view_id = None\n        for view_id, view in self.views.items():\n            if element_id in view.root_elements:\n                break\n            \n            # Check if it's a descendant of any root element\n            for root_id in view.root_elements:\n                if self._is_descendant(root_id, element_id):\n                    view_id = view_id\n                    break\n            \n            if view_id:\n                break\n        \n        if not view_id:\n            return []\n        \n        # Find path\n        path = []\n        current_id = element_id\n        \n        while current_id:\n            path.insert(0, current_id)\n            \n            # Find parent\n            parent_id = None\n            for element_id, element in self.elements.items():\n                if current_id in element.children:\n                    parent_id = element_id\n                    break\n            \n            # If no parent, check if it's a root element\n            if not parent_id:\n                # If it's a root element, we've reached the top\n                if current_id in self.views[view_id].root_elements:\n                    break\n            \n            current_id = parent_id\n        \n        return path\n    \n    def _is_descendant(self, ancestor_id: str, descendant_id: str) -> bool:\n        \"\"\"Check if descendant_id is a descendant of ancestor_id.\"\"\"\n        if ancestor_id not in self.elements:\n            return False\n        \n        # Check direct children\n        ancestor = self.elements[ancestor_id]\n        if descendant_id in ancestor.children:\n            return True\n        \n        # Check descendants recursively\n        for child_id in ancestor.children:\n            if self._is_descendant(child_id, descendant_id):\n                return True\n        \n        return False",
                "class NavigationViewType(str, Enum):\n    \"\"\"Types of navigation views.\"\"\"\n    \n    LINEAR = \"linear\"  # Traditional linear document view\n    CHAPTER = \"chapter\"  # Organized by chapters/sections\n    CHARACTER = \"character\"  # Organized by character appearances\n    PLOT = \"plot\"  # Organized by plot elements/arcs\n    TIMELINE = \"timeline\"  # Organized by timeline/chronology\n    CUSTOM = \"custom\"",
                "class RevisionManager:\n    \"\"\"Revision management system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the revision manager with the given document.\"\"\"\n        self.document = document\n        self.diffs: Dict[str, RevisionDiff] = {}\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        return self.document.create_revision(name=name, metadata=metadata)\n    \n    def compare_revisions(self, old_revision_name: str, new_revision_name: str) -> Optional[RevisionDiff]:\n        \"\"\"Compare two revisions and generate a diff.\"\"\"\n        old_revision = self.document.get_revision(old_revision_name)\n        new_revision = self.document.get_revision(new_revision_name)\n        \n        if not old_revision or not new_revision:\n            return None\n        \n        # Create a unique ID for this diff\n        diff_id = f\"{old_revision_name}_{new_revision_name}\"\n        \n        # Check if we already have this diff\n        if diff_id in self.diffs:\n            return self.diffs[diff_id]\n        \n        # Create a new diff\n        revision_diff = RevisionDiff(\n            old_revision_id=old_revision.id,\n            new_revision_id=new_revision.id,\n            old_revision_name=old_revision_name,\n            new_revision_name=new_revision_name\n        )\n        \n        # Compare sections\n        old_sections_by_id = {section.id: section for section in old_revision.sections}\n        new_sections_by_id = {section.id: section for section in new_revision.sections}\n        \n        # Find common section IDs\n        common_section_ids = set(old_sections_by_id.keys()) & set(new_sections_by_id.keys())\n        \n        # Find added and removed sections\n        added_section_ids = set(new_sections_by_id.keys()) - set(old_sections_by_id.keys())\n        removed_section_ids = set(old_sections_by_id.keys()) - set(new_sections_by_id.keys())\n        \n        # Process added sections\n        for section_id in added_section_ids:\n            section = new_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.INSERT,\n                section_id=section_id,\n                new_title=section.title\n            )\n            \n            # Add all segments as inserted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment.id,\n                    new_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            revision_diff.section_diffs.append(section_diff)\n        \n        # Process removed sections\n        for section_id in removed_section_ids:\n            section = old_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.DELETE,\n                section_id=section_id,\n                old_title=section.title\n            )\n            \n            # Add all segments as deleted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment.id,\n                    old_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            revision_diff.section_diffs.append(section_diff)\n        \n        # Process common sections\n        for section_id in common_section_ids:\n            old_section = old_sections_by_id[section_id]\n            new_section = new_sections_by_id[section_id]\n            \n            # Check if title changed\n            if old_section.title != new_section.title:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.REPLACE,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title\n                )\n            else:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.EQUAL,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title\n                )\n            \n            # Compare segments within the section\n            old_segments_by_id = {segment.id: segment for segment in old_section.segments}\n            new_segments_by_id = {segment.id: segment for segment in new_section.segments}\n            \n            # Find common segment IDs\n            common_segment_ids = set(old_segments_by_id.keys()) & set(new_segments_by_id.keys())\n            \n            # Find added and removed segments\n            added_segment_ids = set(new_segments_by_id.keys()) - set(old_segments_by_id.keys())\n            removed_segment_ids = set(old_segments_by_id.keys()) - set(new_segments_by_id.keys())\n            \n            # Process added segments\n            for segment_id in added_segment_ids:\n                segment = new_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment_id,\n                    new_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            # Process removed segments\n            for segment_id in removed_segment_ids:\n                segment = old_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment_id,\n                    old_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            # Process common segments\n            for segment_id in common_segment_ids:\n                old_segment = old_segments_by_id[segment_id]\n                new_segment = new_segments_by_id[segment_id]\n                \n                # Check if content changed\n                if old_segment.content != new_segment.content:\n                    segment_diff = SegmentDiff(\n                        diff_type=DiffType.REPLACE,\n                        segment_id=segment_id,\n                        old_content=old_segment.content,\n                        new_content=new_segment.content,\n                        position=new_segment.position\n                    )\n                    section_diff.segment_diffs.append(segment_diff)\n            \n            # Only add section diff if there are changes\n            if section_diff.diff_type != DiffType.EQUAL or section_diff.segment_diffs:\n                revision_diff.section_diffs.append(section_diff)\n        \n        # Store and return the diff\n        self.diffs[diff_id] = revision_diff\n        return revision_diff\n    \n    def get_html_diff(self, old_content: str, new_content: str) -> str:\n        \"\"\"Generate an HTML diff of two texts.\"\"\"\n        differ = difflib.HtmlDiff()\n        return differ.make_file(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            context=True\n        )\n    \n    def get_unified_diff(self, old_content: str, new_content: str, context_lines: int = 3) -> str:\n        \"\"\"Generate a unified diff of two texts.\"\"\"\n        return \"\\n\".join(difflib.unified_diff(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            n=context_lines\n        ))\n    \n    def get_detailed_segment_diff(self, old_content: str, new_content: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate a detailed word-level diff of two segment contents.\"\"\"\n        # Split into words\n        old_words = old_content.split()\n        new_words = new_content.split()\n        \n        # Get opcodes\n        matcher = difflib.SequenceMatcher(None, old_words, new_words)\n        opcodes = matcher.get_opcodes()\n        \n        result = []\n        for tag, i1, i2, j1, j2 in opcodes:\n            if tag == 'equal':\n                result.append({\n                    'type': 'equal',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n            elif tag == 'replace':\n                result.append({\n                    'type': 'delete',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n                result.append({\n                    'type': 'insert',\n                    'content': ' '.join(new_words[j1:j2])\n                })\n            elif tag == 'delete':\n                result.append({\n                    'type': 'delete',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n            elif tag == 'insert':\n                result.append({\n                    'type': 'insert',\n                    'content': ' '.join(new_words[j1:j2])\n                })\n        \n        return result\n    \n    def apply_diff(self, diff: RevisionDiff, target_revision_name: Optional[str] = None) -> Optional[Revision]:\n        \"\"\"Apply a diff to a revision to create a new revision.\"\"\"\n        # If target_revision_name is not provided, create a new revision\n        if not target_revision_name:\n            target_revision_name = f\"Merged_{diff.old_revision_name}_{diff.new_revision_name}\"\n        \n        # Create a new revision based on the old revision\n        old_revision = self.document.get_revision(diff.old_revision_name)\n        if not old_revision:\n            return None\n        \n        # Create a deep copy of the old revision\n        target_revision = self.create_revision(\n            name=target_revision_name,\n            metadata={\"merged_from\": [diff.old_revision_name, diff.new_revision_name]}\n        )\n        \n        # Apply section changes\n        for section_diff in diff.section_diffs:\n            section_id = section_diff.section_id\n            \n            if section_diff.diff_type == DiffType.INSERT:\n                # Add new section\n                new_section = Section(\n                    id=section_id,\n                    title=section_diff.new_title or \"\",\n                    segments=[]\n                )\n                \n                # Add segment diffs\n                for segment_diff in section_diff.segment_diffs:\n                    if segment_diff.diff_type == DiffType.INSERT:\n                        segment = TextSegment(\n                            id=segment_diff.segment_id or \"\",\n                            content=segment_diff.new_content or \"\",\n                            position=segment_diff.position or 0\n                        )\n                        new_section.segments.append(segment)\n                \n                # Add to target revision\n                target_revision.sections.append(new_section)\n            \n            elif section_diff.diff_type == DiffType.DELETE:\n                # Remove section\n                for i, section in enumerate(target_revision.sections):\n                    if section.id == section_id:\n                        target_revision.sections.pop(i)\n                        break\n            \n            elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                # Update section title if it changed\n                for section in target_revision.sections:\n                    if section.id == section_id:\n                        if section_diff.new_title:\n                            section.title = section_diff.new_title\n                        \n                        # Process segment changes\n                        for segment_diff in section_diff.segment_diffs:\n                            segment_id = segment_diff.segment_id\n                            \n                            if segment_diff.diff_type == DiffType.INSERT:\n                                # Add new segment\n                                segment = TextSegment(\n                                    id=segment_id or \"\",\n                                    content=segment_diff.new_content or \"\",\n                                    position=segment_diff.position or 0\n                                )\n                                \n                                # Insert at the right position\n                                if segment_diff.position is not None:\n                                    if segment_diff.position < len(section.segments):\n                                        section.segments.insert(segment_diff.position, segment)\n                                    else:\n                                        section.segments.append(segment)\n                                else:\n                                    section.segments.append(segment)\n                                \n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n                            \n                            elif segment_diff.diff_type == DiffType.DELETE:\n                                # Remove segment\n                                for i, segment in enumerate(section.segments):\n                                    if segment.id == segment_id:\n                                        section.segments.pop(i)\n                                        break\n                                \n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n                            \n                            elif segment_diff.diff_type == DiffType.REPLACE:\n                                # Update segment content\n                                for segment in section.segments:\n                                    if segment.id == segment_id and segment_diff.new_content:\n                                        segment.content = segment_diff.new_content\n                                        break\n                        \n                        break\n        \n        # Update document's current revision\n        self.document.current_revision = target_revision\n        \n        return target_revision\n    \n    def merge_revisions(\n        self, \n        base_revision_name: str, \n        revision_names: List[str], \n        merge_strategy: Dict[str, str] = None\n    ) -> Optional[Revision]:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        # Get base revision\n        base_revision = self.document.get_revision(base_revision_name)\n        if not base_revision:\n            return None\n        \n        # Create a new revision based on the base revision\n        merged_revision_name = f\"Merged_{base_revision_name}_{'_'.join(revision_names)}\"\n        merged_revision = self.create_revision(\n            name=merged_revision_name,\n            metadata={\"merged_from\": [base_revision_name] + revision_names}\n        )\n        \n        # Default merge strategy: last writer wins\n        if not merge_strategy:\n            merge_strategy = {}\n        \n        # Apply diffs from each revision\n        for revision_name in revision_names:\n            # Compare with base revision\n            diff = self.compare_revisions(base_revision_name, revision_name)\n            if not diff:\n                continue\n            \n            # Apply changes\n            for section_diff in diff.section_diffs:\n                section_id = section_diff.section_id\n                \n                # Check merge strategy for this section\n                section_strategy = merge_strategy.get(section_id, \"last_writer_wins\")\n                \n                if section_strategy == \"ignore\":\n                    # Skip this section\n                    continue\n                \n                if section_diff.diff_type == DiffType.INSERT:\n                    # Add new section\n                    new_section = Section(\n                        id=section_id,\n                        title=section_diff.new_title or \"\",\n                        segments=[]\n                    )\n                    \n                    # Add segment diffs\n                    for segment_diff in section_diff.segment_diffs:\n                        if segment_diff.diff_type == DiffType.INSERT:\n                            segment = TextSegment(\n                                id=segment_diff.segment_id or \"\",\n                                content=segment_diff.new_content or \"\",\n                                position=segment_diff.position or 0\n                            )\n                            new_section.segments.append(segment)\n                    \n                    # Add to merged revision\n                    merged_revision.sections.append(new_section)\n                \n                elif section_diff.diff_type == DiffType.DELETE:\n                    if section_strategy == \"last_writer_wins\":\n                        # Remove section\n                        for i, section in enumerate(merged_revision.sections):\n                            if section.id == section_id:\n                                merged_revision.sections.pop(i)\n                                break\n                \n                elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                    # Update section title if it changed\n                    for section in merged_revision.sections:\n                        if section.id == section_id:\n                            if section_diff.new_title and section_strategy == \"last_writer_wins\":\n                                section.title = section_diff.new_title\n                            \n                            # Process segment changes\n                            for segment_diff in section_diff.segment_diffs:\n                                segment_id = segment_diff.segment_id\n                                \n                                # Check merge strategy for this segment\n                                segment_strategy = merge_strategy.get(f\"{section_id}_{segment_id}\", section_strategy)\n                                \n                                if segment_strategy == \"ignore\":\n                                    # Skip this segment\n                                    continue\n                                \n                                if segment_diff.diff_type == DiffType.INSERT:\n                                    # Add new segment\n                                    segment = TextSegment(\n                                        id=segment_id or \"\",\n                                        content=segment_diff.new_content or \"\",\n                                        position=segment_diff.position or 0\n                                    )\n                                    \n                                    # Insert at the right position\n                                    if segment_diff.position is not None:\n                                        if segment_diff.position < len(section.segments):\n                                            section.segments.insert(segment_diff.position, segment)\n                                        else:\n                                            section.segments.append(segment)\n                                    else:\n                                        section.segments.append(segment)\n                                    \n                                    # Update positions\n                                    for i, seg in enumerate(section.segments):\n                                        seg.position = i\n                                \n                                elif segment_diff.diff_type == DiffType.DELETE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Remove segment\n                                        for i, segment in enumerate(section.segments):\n                                            if segment.id == segment_id:\n                                                section.segments.pop(i)\n                                                break\n                                        \n                                        # Update positions\n                                        for i, seg in enumerate(section.segments):\n                                            seg.position = i\n                                \n                                elif segment_diff.diff_type == DiffType.REPLACE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Update segment content\n                                        for segment in section.segments:\n                                            if segment.id == segment_id and segment_diff.new_content:\n                                                segment.content = segment_diff.new_content\n                                                break\n                            \n                            break\n        \n        # Update document's current revision\n        self.document.current_revision = merged_revision\n        \n        return merged_revision\n    \n    def export_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Export the revision history as a structured dictionary.\"\"\"\n        history = {\n            \"current_revision\": self.document.current_revision.name,\n            \"revisions\": {}\n        }\n        \n        for name, revision in self.document.revisions.items():\n            history[\"revisions\"][name] = {\n                \"id\": revision.id,\n                \"timestamp\": revision.timestamp.isoformat(),\n                \"metadata\": revision.metadata,\n                \"section_count\": len(revision.sections),\n                \"word_count\": sum(\n                    sum(segment.get_word_count() for segment in section.segments)\n                    for section in revision.sections\n                )\n            }\n        \n        return history\n    \n    def get_revision_by_timestamp(self, timestamp: datetime) -> Optional[Revision]:\n        \"\"\"Get the revision closest to the specified timestamp.\"\"\"\n        closest_revision = None\n        min_diff = None\n        \n        for revision in self.document.revisions.values():\n            diff = abs((revision.timestamp - timestamp).total_seconds())\n            \n            if min_diff is None or diff < min_diff:\n                min_diff = diff\n                closest_revision = revision\n        \n        return closest_revision",
                "class DiffType(str, Enum):\n    \"\"\"Types of differences.\"\"\"\n    \n    EQUAL = \"equal\"\n    INSERT = \"insert\"\n    DELETE = \"delete\"\n    REPLACE = \"replace\"",
                "class WriterTextEditor:\n    \"\"\"Main client class for the writer text editor.\"\"\"\n    \n    def __init__(self, document_title: str = \"Untitled Document\"):\n        \"\"\"Initialize the text editor with a new document.\"\"\"\n        self.document = Document(title=document_title)\n        self.focus_mode = FocusMode(self.document)\n        self.statistics = WritingStatistics(self.document)\n        self.narrative_tracker = NarrativeTracker(self.document)\n        self.navigator = DocumentNavigator(self.document, self.narrative_tracker)\n        self.revision_manager = RevisionManager(self.document)\n        \n        # Start the background tracking\n        self.statistics.start_background_tracking()\n        self.narrative_tracker.start_background_tracking()\n    \n    def close(self):\n        \"\"\"Clean up resources when closing the editor.\"\"\"\n        self.statistics.stop_background_tracking()\n        self.narrative_tracker.stop_background_tracking()\n    \n    # Document operations\n    \n    def get_document(self) -> Document:\n        \"\"\"Get the current document.\"\"\"\n        return self.document\n    \n    def add_section(self, title: str) -> str:\n        \"\"\"Add a new section to the document and return its ID.\"\"\"\n        section = self.document.add_section(title)\n        return section.id\n    \n    def add_paragraph(self, section_index: int, content: str) -> Optional[str]:\n        \"\"\"Add a paragraph to a section and return its ID.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n        \n        segment = section.add_segment(content)\n        return segment.id\n    \n    def get_document_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return self.document.get_content()\n    \n    # Focus mode operations\n    \n    def enter_focus(self, section_index: int, paragraph_index: int, \n                   level: FocusLevel = FocusLevel.PARAGRAPH) -> bool:\n        \"\"\"Enter focus mode for a specific paragraph.\"\"\"\n        focus_context = self.focus_mode.enter_focus(\n            section_index=section_index,\n            segment_index=paragraph_index,\n            level=level\n        )\n        return focus_context is not None\n    \n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        return self.focus_mode.exit_focus()\n    \n    def edit_in_focus(self, new_content: str) -> bool:\n        \"\"\"Edit the content in focus mode.\"\"\"\n        result = self.focus_mode.edit_focused_content(new_content)\n        return result is not None\n    \n    def move_focus(self, direction: int = 1) -> bool:\n        \"\"\"Move focus to the next or previous paragraph.\"\"\"\n        result = self.focus_mode.move_focus(direction)\n        return result is not None\n    \n    def get_focus_context(self) -> Dict[str, Any]:\n        \"\"\"Get information about the current focus context.\"\"\"\n        context = self.focus_mode.get_focus_context()\n        if not context:\n            return {\"active\": False}\n        \n        return {\n            \"active\": True,\n            \"section_title\": context.section.title,\n            \"content\": context.segment.content,\n            \"level\": context.level.value,\n            \"focus_time\": self.focus_mode.get_focus_time()\n        }\n    \n    # Statistics operations\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get the current document statistics.\"\"\"\n        stats = self.statistics.calculate_stats()\n        \n        return {\n            \"word_count\": stats.word_count,\n            \"character_count\": stats.character_count,\n            \"paragraph_count\": stats.paragraph_count,\n            \"sentence_count\": stats.sentence_count,\n            \"reading_level\": stats.reading_level,\n            \"vocabulary_richness\": stats.word_stats.vocabulary_richness,\n            \"avg_sentence_length\": stats.sentence_stats.average_sentence_length\n        }\n    \n    def get_writing_pace(self) -> Dict[str, float]:\n        \"\"\"Get the current writing pace.\"\"\"\n        pace = self.statistics.calculate_writing_pace()\n        \n        return {\n            \"words_per_minute\": pace.words_per_minute,\n            \"words_per_hour\": pace.words_per_hour,\n            \"words_per_day\": pace.words_per_day\n        }\n    \n    def set_writing_goal(self, goal_id: str, target: int, days: int = 30) -> Dict[str, Any]:\n        \"\"\"Set a writing goal for word count.\"\"\"\n        from datetime import datetime, timedelta\n        \n        deadline = datetime.now() + timedelta(days=days)\n        tracker = self.statistics.set_progress_goal(\n            goal_id=goal_id,\n            goal_type=\"word_count\",\n            target=target,\n            deadline=deadline\n        )\n        \n        progress = self.statistics.update_progress(goal_id)\n        \n        return {\n            \"goal_id\": goal_id,\n            \"target\": target,\n            \"deadline_days\": days,\n            \"current_word_count\": progress[\"word_count\"],\n            \"progress_percentage\": progress[\"progress_percentage\"],\n            \"remaining\": progress[\"remaining\"]\n        }\n    \n    def get_goal_progress(self, goal_id: str) -> Dict[str, Any]:\n        \"\"\"Get progress for a specific goal.\"\"\"\n        report = self.statistics.get_progress_report(goal_id)\n        if not report:\n            return {\"error\": f\"Goal {goal_id} not found\"}\n        \n        return report\n    \n    # Narrative element operations\n    \n    def detect_characters(self) -> List[Dict[str, Any]]:\n        \"\"\"Detect and track characters in the document.\"\"\"\n        elements = self.narrative_tracker.detect_elements()\n        characters = elements.get(ElementType.CHARACTER.value, [])\n        \n        return [\n            {\n                \"id\": char.id,\n                \"name\": char.name,\n                \"occurrences\": len(char.occurrences)\n            }\n            for char in characters\n        ]\n    \n    def get_character_timeline(self, character_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of a character's appearances.\"\"\"\n        timeline = self.narrative_tracker.get_element_timeline(character_id)\n        \n        return timeline\n    \n    def check_narrative_consistency(self) -> List[Dict[str, Any]]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        issues = self.narrative_tracker.check_consistency()\n        \n        return [\n            {\n                \"id\": issue.id,\n                \"type\": issue.issue_type,\n                \"description\": issue.description,\n                \"severity\": issue.severity,\n                \"resolved\": issue.resolved\n            }\n            for issue in issues\n        ]\n    \n    # Navigation operations\n    \n    def create_navigation_view(self, name: str, view_type: str) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        nav_type = NavigationViewType(view_type)\n        view_id = self.navigator.create_view(name, nav_type)\n        \n        return view_id\n    \n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        return self.navigator.navigate_to(view_id, element_id)\n    \n    def get_current_location(self) -> Dict[str, Any]:\n        \"\"\"Get information about the current navigation location.\"\"\"\n        element = self.navigator.get_current_element()\n        if not element:\n            return {\"error\": \"No current position\"}\n        \n        content = self.navigator.get_element_content(element.id)\n        \n        return {\n            \"view_id\": self.navigator.current_position.view_id,\n            \"element_id\": element.id,\n            \"element_type\": element.element_type,\n            \"name\": element.name,\n            \"content\": content\n        }\n    \n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        return self.navigator.navigate_next()\n    \n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        return self.navigator.navigate_previous()\n    \n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        return self.navigator.navigate_parent()\n    \n    def get_navigation_children(self) -> List[Dict[str, Any]]:\n        \"\"\"Get the children of the current element.\"\"\"\n        children = self.navigator.navigate_children()\n        \n        return [\n            {\n                \"id\": child.id,\n                \"type\": child.element_type,\n                \"name\": child.name\n            }\n            for child in children\n        ]\n    \n    # Revision operations\n    \n    def create_revision(self, name: str) -> str:\n        \"\"\"Create a new revision of the document.\"\"\"\n        revision = self.revision_manager.create_revision(name)\n        return revision.id\n    \n    def compare_revisions(self, old_revision: str, new_revision: str) -> Dict[str, Any]:\n        \"\"\"Compare two revisions and return the differences.\"\"\"\n        diff = self.revision_manager.compare_revisions(old_revision, new_revision)\n        if not diff:\n            return {\"error\": \"Could not compare revisions\"}\n        \n        # Convert diff to a simplified format\n        result = {\n            \"old_revision\": old_revision,\n            \"new_revision\": new_revision,\n            \"timestamp\": diff.timestamp.isoformat(),\n            \"sections\": []\n        }\n        \n        for section_diff in diff.section_diffs:\n            section_info = {\n                \"id\": section_diff.section_id,\n                \"type\": section_diff.diff_type.value,\n                \"old_title\": section_diff.old_title,\n                \"new_title\": section_diff.new_title,\n                \"segments\": []\n            }\n            \n            for segment_diff in section_diff.segment_diffs:\n                segment_info = {\n                    \"id\": segment_diff.segment_id,\n                    \"type\": segment_diff.diff_type.value,\n                    \"position\": segment_diff.position,\n                    \"has_content_change\": segment_diff.old_content != segment_diff.new_content\n                }\n                section_info[\"segments\"].append(segment_info)\n            \n            result[\"sections\"].append(section_info)\n        \n        return result\n    \n    def switch_revision(self, revision_name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        return self.document.switch_to_revision(revision_name)\n    \n    def get_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Get the revision history.\"\"\"\n        return self.revision_manager.export_revision_history()\n    \n    def merge_revisions(self, base_revision: str, revisions: List[str]) -> str:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        merged = self.revision_manager.merge_revisions(base_revision, revisions)\n        if not merged:\n            return \"\"\n        \n        return merged.name"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/interview/__init__.py": {
        "logprobs": -194.660500765034,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/narrative.py": {
        "logprobs": -2431.093749539517,
        "metrics": {
            "loc": 523,
            "sloc": 371,
            "lloc": 313,
            "comments": 56,
            "multi": 0,
            "blank": 85,
            "cyclomatic": 113,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))"
            ]
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/utils/__init__.py": {
        "logprobs": -194.08857965925,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/core/file_manager.py": {
        "logprobs": -527.4651400945448,
        "metrics": {
            "loc": 119,
            "sloc": 43,
            "lloc": 51,
            "comments": 4,
            "multi": 41,
            "blank": 31,
            "cyclomatic": 15,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/learning/manager.py": {
        "logprobs": -2771.8724176044375,
        "metrics": {
            "loc": 825,
            "sloc": 579,
            "lloc": 139,
            "comments": 35,
            "multi": 100,
            "blank": 119,
            "cyclomatic": 54,
            "internal_imports": [
                "class Concept(BaseModel):\n    \"\"\"\n    Represents a computer science concept that can be learned.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: ConceptCategory\n    difficulty: ConceptDifficulty\n    prerequisites: List[str] = Field(default_factory=list)\n    related_concepts: List[str] = Field(default_factory=list)\n    resources: List[Dict[str, str]] = Field(default_factory=list)\n    examples: List[str] = Field(default_factory=list)\n    module_path: Optional[str] = None",
                "class Concept(BaseModel):\n    \"\"\"\n    Represents a computer science concept that can be learned.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: ConceptCategory\n    difficulty: ConceptDifficulty\n    prerequisites: List[str] = Field(default_factory=list)\n    related_concepts: List[str] = Field(default_factory=list)\n    resources: List[Dict[str, str]] = Field(default_factory=list)\n    examples: List[str] = Field(default_factory=list)\n    module_path: Optional[str] = None",
                "class ConceptCategory(Enum):\n    \"\"\"Categories of computer science concepts.\"\"\"\n    DATA_STRUCTURES = \"data_structures\"\n    ALGORITHMS = \"algorithms\"\n    DESIGN_PATTERNS = \"design_patterns\"\n    EDITOR_INTERNALS = \"editor_internals\"\n    PERFORMANCE = \"performance\"\n    PROGRAMMING_LANGUAGES = \"programming_languages\"\n    SOFTWARE_ARCHITECTURE = \"software_architecture\"\n    USER_INTERFACE = \"user_interface\"",
                "class ConceptCategory(Enum):\n    \"\"\"Categories of computer science concepts.\"\"\"\n    DATA_STRUCTURES = \"data_structures\"\n    ALGORITHMS = \"algorithms\"\n    DESIGN_PATTERNS = \"design_patterns\"\n    EDITOR_INTERNALS = \"editor_internals\"\n    PERFORMANCE = \"performance\"\n    PROGRAMMING_LANGUAGES = \"programming_languages\"\n    SOFTWARE_ARCHITECTURE = \"software_architecture\"\n    USER_INTERFACE = \"user_interface\"",
                "class ConceptDifficulty(Enum):\n    \"\"\"Difficulty levels for computer science concepts.\"\"\"\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ConceptDifficulty(Enum):\n    \"\"\"Difficulty levels for computer science concepts.\"\"\"\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class Annotation(BaseModel):\n    \"\"\"\n    Represents an annotation on source code that explains a concept.\n    \"\"\"\n    concept_id: str\n    start_line: int\n    end_line: int\n    text: str\n    code_snippet: str",
                "class Annotation(BaseModel):\n    \"\"\"\n    Represents an annotation on source code that explains a concept.\n    \"\"\"\n    concept_id: str\n    start_line: int\n    end_line: int\n    text: str\n    code_snippet: str",
                "class ExtensionProject(BaseModel):\n    \"\"\"\n    Represents a guided extension project for learning.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    difficulty: ConceptDifficulty\n    concepts: List[str]  # List of concept IDs\n    requirements: List[str]\n    starter_code: Optional[str] = None\n    solution_code: Optional[str] = None\n    tests: List[str] = Field(default_factory=list)\n    hints: List[str] = Field(default_factory=list)\n    estimated_time_minutes: int = 60",
                "class ExtensionProject(BaseModel):\n    \"\"\"\n    Represents a guided extension project for learning.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    difficulty: ConceptDifficulty\n    concepts: List[str]  # List of concept IDs\n    requirements: List[str]\n    starter_code: Optional[str] = None\n    solution_code: Optional[str] = None\n    tests: List[str] = Field(default_factory=list)\n    hints: List[str] = Field(default_factory=list)\n    estimated_time_minutes: int = 60",
                "class LearningProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress in learning concepts.\n    \"\"\"\n    completed_concepts: Set[str] = Field(default_factory=set)\n    concept_mastery: Dict[str, float] = Field(default_factory=dict)  # 0.0 to 1.0\n    completed_projects: Set[str] = Field(default_factory=set)\n    viewed_annotations: Dict[str, int] = Field(default_factory=dict)  # concept_id -> count\n    current_project: Optional[str] = None\n    \n    def mark_concept_viewed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as having been viewed.\n        \n        Args:\n            concept_id: ID of the concept that was viewed\n        \"\"\"\n        if concept_id not in self.viewed_annotations:\n            self.viewed_annotations[concept_id] = 0\n        \n        self.viewed_annotations[concept_id] += 1\n        \n        # Update mastery based on view count\n        views = self.viewed_annotations[concept_id]\n        if views >= 5:\n            self.concept_mastery[concept_id] = 1.0\n        else:\n            self.concept_mastery[concept_id] = views / 5.0\n    \n    def mark_concept_completed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as completed/mastered.\n        \n        Args:\n            concept_id: ID of the concept that was completed\n        \"\"\"\n        self.completed_concepts.add(concept_id)\n        self.concept_mastery[concept_id] = 1.0\n    \n    def mark_project_completed(self, project_id: str) -> None:\n        \"\"\"\n        Mark an extension project as completed.\n        \n        Args:\n            project_id: ID of the project that was completed\n        \"\"\"\n        self.completed_projects.add(project_id)\n        self.current_project = None\n    \n    def set_current_project(self, project_id: str) -> None:\n        \"\"\"\n        Set the current extension project.\n        \n        Args:\n            project_id: ID of the project to set as current\n        \"\"\"\n        self.current_project = project_id\n    \n    def get_mastery_level(self, concept_id: str) -> float:\n        \"\"\"\n        Get the mastery level for a concept.\n        \n        Args:\n            concept_id: ID of the concept to check\n            \n        Returns:\n            Mastery level from 0.0 to 1.0\n        \"\"\"\n        return self.concept_mastery.get(concept_id, 0.0)\n    \n    def is_concept_completed(self, concept_id: str) -> bool:\n        \"\"\"\n        Check if a concept is completed.\n        \n        Args:\n            concept_id: ID of the concept to check\n            \n        Returns:\n            True if the concept is completed, False otherwise\n        \"\"\"\n        return concept_id in self.completed_concepts\n    \n    def is_project_completed(self, project_id: str) -> bool:\n        \"\"\"\n        Check if a project is completed.\n        \n        Args:\n            project_id: ID of the project to check\n            \n        Returns:\n            True if the project is completed, False otherwise\n        \"\"\"\n        return project_id in self.completed_projects",
                "class LearningProgress(BaseModel):\n    \"\"\"\n    Tracks a user's progress in learning concepts.\n    \"\"\"\n    completed_concepts: Set[str] = Field(default_factory=set)\n    concept_mastery: Dict[str, float] = Field(default_factory=dict)  # 0.0 to 1.0\n    completed_projects: Set[str] = Field(default_factory=set)\n    viewed_annotations: Dict[str, int] = Field(default_factory=dict)  # concept_id -> count\n    current_project: Optional[str] = None\n    \n    def mark_concept_viewed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as having been viewed.\n        \n        Args:\n            concept_id: ID of the concept that was viewed\n        \"\"\"\n        if concept_id not in self.viewed_annotations:\n            self.viewed_annotations[concept_id] = 0\n        \n        self.viewed_annotations[concept_id] += 1\n        \n        # Update mastery based on view count\n        views = self.viewed_annotations[concept_id]\n        if views >= 5:\n            self.concept_mastery[concept_id] = 1.0\n        else:\n            self.concept_mastery[concept_id] = views / 5.0\n    \n    def mark_concept_completed(self, concept_id: str) -> None:\n        \"\"\"\n        Mark a concept as completed/mastered.\n        \n        Args:\n            concept_id: ID of the concept that was completed\n        \"\"\"\n        self.completed_concepts.add(concept_id)\n        self.concept_mastery[concept_id] = 1.0\n    \n    def mark_project_completed(self, project_id: str) -> None:\n        \"\"\"\n        Mark an extension project as completed.\n        \n        Args:\n            project_id: ID of the project that was completed\n        \"\"\"\n        self.completed_projects.add(project_id)\n        self.current_project = None\n    \n    def set_current_project(self, project_id: str) -> None:\n        \"\"\"\n        Set the current extension project.\n        \n        Args:\n            project_id: ID of the project to set as current\n        \"\"\"\n        self.current_project = project_id\n    \n    def get_mastery_level(self, concept_id: str) -> float:\n        \"\"\"\n        Get the mastery level for a concept.\n        \n        Args:\n            concept_id: ID of the concept to check\n            \n        Returns:\n            Mastery level from 0.0 to 1.0\n        \"\"\"\n        return self.concept_mastery.get(concept_id, 0.0)\n    \n    def is_concept_completed(self, concept_id: str) -> bool:\n        \"\"\"\n        Check if a concept is completed.\n        \n        Args:\n            concept_id: ID of the concept to check\n            \n        Returns:\n            True if the concept is completed, False otherwise\n        \"\"\"\n        return concept_id in self.completed_concepts\n    \n    def is_project_completed(self, project_id: str) -> bool:\n        \"\"\"\n        Check if a project is completed.\n        \n        Args:\n            project_id: ID of the project to check\n            \n        Returns:\n            True if the project is completed, False otherwise\n        \"\"\"\n        return project_id in self.completed_projects"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/features/__init__.py": {
        "logprobs": -207.91082549111397,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/tests/__init__.py": {
        "logprobs": -172.2433837649065,
        "metrics": {
            "loc": 3,
            "sloc": 0,
            "lloc": 1,
            "comments": 0,
            "multi": 3,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/navigation.py": {
        "logprobs": -2062.491424238359,
        "metrics": {
            "loc": 947,
            "sloc": 612,
            "lloc": 532,
            "comments": 130,
            "multi": 0,
            "blank": 189,
            "cyclomatic": 167,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n    \n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n    \n    def _find_element_occurrences(\n        self, \n        element_name: str, \n        aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n        \n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = r'\\b(' + '|'.join(re.escape(name) for name in names_to_search) + r')\\b'\n        regex = re.compile(pattern, re.IGNORECASE)\n        \n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n                    \n                    results.append((section, segment, match.start(), context))\n        \n        return results\n    \n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n        \n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set()\n        }\n        \n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n        \n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n        \n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n        \n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(re.findall(r'\\b' + re.escape(element) + r'\\b', text, re.IGNORECASE))\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element in [e.name for e in self.elements.values()]\n                    }\n        \n        return results\n    \n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n        \n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n            \n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n            \n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n                \n                co_occurrences = 0\n                for context in contexts:\n                    pattern = r'\\b(' + '|'.join(\n                        [re.escape(other_element.name)] + \n                        [re.escape(alias) for alias in other_element.aliases]\n                    ) + r')\\b'\n                    \n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n                \n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n        \n        return connections\n    \n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n        \n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n        \n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n            \n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n        \n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n        \n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(char_timeline_sections, key=lambda s: timeline_sections[s])\n                    \n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n                            \n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(ConsistencyIssue(\n                                        id=str(len(issues) + 1),\n                                        issue_type=\"timeline\",\n                                        elements_involved=[char_id],\n                                        description=(\n                                            f\"Character appears in non-sequential timeline points: \"\n                                            f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[k]]}\"\n                                        ),\n                                        locations=[\n                                            (sorted_sections[i], \"\"),\n                                            (sorted_sections[j], \"\"),\n                                            (sorted_sections[k], \"\")\n                                        ],\n                                        severity=3\n                                    ))\n        \n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n            \n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n                \n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name):]\n                    \n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r'\\s+was\\s+(\\w+)',\n                        r'\\s+had\\s+(\\w+)',\n                        r'\\s+with\\s+(\\w+)',\n                        r',\\s+a\\s+(\\w+)',\n                        r',\\s+the\\s+(\\w+)'\n                    ]\n                    \n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append((\n                                occurrence.section_id,\n                                occurrence.segment_id,\n                                match.group(1),\n                                context\n                            ))\n            \n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n                \n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\")\n                ]\n                \n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(ConsistencyIssue(\n                            id=str(len(issues) + 1),\n                            issue_type=\"contradiction\",\n                            elements_involved=[element_id],\n                            description=(\n                                f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                            ),\n                            locations=[\n                                (descriptions[word1][0][0], descriptions[word1][0][1]),\n                                (descriptions[word2][0][0], descriptions[word2][0][1])\n                            ],\n                            severity=4\n                        ))\n        \n        return issues\n    \n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n        \n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(name, aliases):\n            occurrences.append(ElementOccurrence(\n                element_id=element_id,\n                section_id=section.id,\n                segment_id=segment.id,\n                position=position,\n                context=context\n            ))\n        \n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None\n        )\n        \n        self.elements[element_id] = element\n        return element\n    \n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n        \n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: []\n        }\n        \n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name,\n                        element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n        \n        # Update element relationships\n        self.update_element_relationships()\n        \n        # Detect consistency issues\n        self.check_consistency()\n        \n        return tracked_elements\n    \n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n        \n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n    \n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n    \n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n        \n        element = self.elements[element_id]\n        appearances = []\n        \n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n            \n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n            \n            if section and segment:\n                appearances.append({\n                    \"section_title\": section.title,\n                    \"section_id\": section.id,\n                    \"segment_id\": segment.id,\n                    \"segment_position\": segment.position,\n                    \"context\": occurrence.context,\n                    \"mentioned_with\": [\n                        self.elements[e_id].name \n                        for e_id in occurrence.mentioned_with \n                        if e_id in self.elements\n                    ]\n                })\n        \n        return appearances\n    \n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n        \n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": []\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n        \n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append({\n                    \"section_id\": section.id,\n                    \"section_title\": sections[section.id][\"section_title\"],\n                    \"appearances\": sorted(\n                        sections[section.id][\"appearances\"],\n                        key=lambda a: a[\"segment_position\"]\n                    )\n                })\n        \n        return ordered_sections\n    \n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n    \n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n        \n        self._stop_background_thread = False\n        \n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n                \n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n        \n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n    \n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n    \n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class NarrativeElement(BaseModel):\n    \"\"\"A tracked narrative element such as a character or plot element.\"\"\"\n    \n    id: str\n    name: str\n    element_type: ElementType\n    aliases: List[str] = Field(default_factory=list)\n    description: str = \"\"\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    occurrences: List[ElementOccurrence] = Field(default_factory=list)\n    related_elements: Dict[str, float] = Field(default_factory=dict)  # Element ID to relationship strength\n    first_appearance: Optional[datetime] = None\n    last_appearance: Optional[datetime] = None"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/interview/manager.py": {
        "logprobs": -2071.9528748802163,
        "metrics": {
            "loc": 549,
            "sloc": 283,
            "lloc": 188,
            "comments": 51,
            "multi": 106,
            "blank": 113,
            "cyclomatic": 60,
            "internal_imports": [
                "\"\"\"Profile the memory usage of a Python program\"\"\"\n\n# .. we'll use this to pass it to the child script ..\n_CLEAN_GLOBALS = globals().copy()\n\n__version__ = '0.61.0'\n\n_CMD_USAGE = \"python -m memory_profiler script_file.py\"\n\nfrom asyncio import iscoroutinefunction\nfrom contextlib import contextmanager\nfrom functools import partial, wraps\nfrom types import coroutine\nimport builtins\nimport inspect\nimport linecache\nimport logging\nimport os\nimport io\nimport pdb\nimport subprocess\nimport sys\nimport time\nimport traceback\nimport warnings\n\nif sys.platform == \"win32\":\n    # any value except signal.CTRL_C_EVENT and signal.CTRL_BREAK_EVENT\n    # can be used to kill a process unconditionally in Windows\n    SIGKILL = -1\nelse:\n    from signal import SIGKILL\nimport psutil\n\n\n# TODO: provide alternative when multiprocessing is not available\ntry:\n    from multiprocessing import Process, Pipe\nexcept ImportError:\n    from multiprocessing.dummy import Process, Pipe\n\ntry:\n    from IPython.core.magic import Magics, line_cell_magic, magics_class\nexcept ImportError:\n    # ipython_version < '0.13'\n    Magics = object\n    line_cell_magic = lambda func: func\n    magics_class = lambda cls: cls\n\n_TWO_20 = float(2 ** 20)\n\n\n# .. get available packages ..\ntry:\n    import tracemalloc\n\n    has_tracemalloc = True\nexcept ImportError:\n    has_tracemalloc = False\n\n\nclass MemitResult(object):\n    \"\"\"memit magic run details.\n\n    Object based on IPython's TimeitResult\n    \"\"\"\n\n    def __init__(self, mem_usage, baseline, repeat, timeout, interval,\n                 include_children):\n        self.mem_usage = mem_usage\n        self.baseline = baseline\n        self.repeat = repeat\n        self.timeout = timeout\n        self.interval = interval\n        self.include_children = include_children\n\n    def __str__(self):\n        max_mem = max(self.mem_usage)\n        inc = max_mem - self.baseline\n        return 'peak memory: %.02f MiB, increment: %.02f MiB' % (max_mem, inc)\n\n    def _repr_pretty_(self, p, cycle):\n        msg = str(self)\n        p.text(u'<MemitResult : ' + msg + u'>')\n\n\ndef _get_child_memory(process, meminfo_attr=None, memory_metric=0):\n    \"\"\"\n    Returns a generator that yields memory for all child processes.\n    \"\"\"\n    # Convert a pid to a process\n    if isinstance(process, int):\n        if process == -1: process = os.getpid()\n        process = psutil.Process(process)\n\n    if not meminfo_attr:\n        # Use the psutil 2.0 attr if the older version isn't passed in.\n        meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') else 'get_memory_info'\n\n    # Select the psutil function get the children similar to how we selected\n    # the memory_info attr (a change from excepting the AttributeError).\n    children_attr = 'children' if hasattr(process, 'children') else 'get_children'\n\n    # Loop over the child processes and yield their memory\n    try:\n        for child in getattr(process, children_attr)(recursive=True):\n            if isinstance(memory_metric, str):\n                meminfo = getattr(child, meminfo_attr)()\n                yield child.pid, getattr(meminfo, memory_metric) / _TWO_20\n            else:\n                yield child.pid, getattr(child, meminfo_attr)()[memory_metric] / _TWO_20\n    except (psutil.NoSuchProcess, psutil.AccessDenied):\n        # https://github.com/fabianp/memory_profiler/issues/71\n        yield (0, 0.0)\n\n\ndef _get_memory(pid, backend, timestamps=False, include_children=False, filename=None):\n    # .. low function to get memory consumption ..\n    if pid == -1:\n        pid = os.getpid()\n\n    def tracemalloc_tool():\n        # .. cross-platform but but requires Python 3.4 or higher ..\n        stat = next(filter(lambda item: str(item).startswith(filename),\n                           tracemalloc.take_snapshot().statistics('filename')))\n        mem = stat.size / _TWO_20\n        if timestamps:\n            return mem, time.time()\n        else:\n            return mem\n\n    def ps_util_tool():\n        # .. cross-platform but but requires psutil ..\n        process = psutil.Process(pid)\n        try:\n            # avoid using get_memory_info since it does not exists\n            # in psutil > 2.0 and accessing it will cause exception.\n            meminfo_attr = 'memory_info' if hasattr(process, 'memory_info') \\\n                else 'get_memory_info'\n            mem = getattr(process, meminfo_attr)()[0] / _TWO_20\n            if include_children:\n                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr)])\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        except psutil.AccessDenied:\n            pass\n            # continue and try to get this from ps\n\n    def _ps_util_full_tool(memory_metric):\n\n        # .. cross-platform but requires psutil > 4.0.0 ..\n        process = psutil.Process(pid)\n        try:\n            if not hasattr(process, 'memory_full_info'):\n                raise NotImplementedError(\"Backend `{}` requires psutil > 4.0.0\".format(memory_metric))\n\n            meminfo_attr = 'memory_full_info'\n            meminfo = getattr(process, meminfo_attr)()\n\n            if not hasattr(meminfo, memory_metric):\n                raise NotImplementedError(\n                    \"Metric `{}` not available. For details, see:\".format(memory_metric) +\n                    \"https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info\")\n            mem = getattr(meminfo, memory_metric) / _TWO_20\n\n            if include_children:\n                mem +=  sum([mem for (pid, mem) in _get_child_memory(process, meminfo_attr, memory_metric)])\n\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        \n        except psutil.AccessDenied:\n            pass\n            # continue and try to get this from ps\n\n    def posix_tool():\n        # .. scary stuff ..\n        if include_children:\n            raise NotImplementedError((\n                \"The psutil module is required to monitor the \"\n                \"memory usage of child processes.\"\n            ))\n\n        warnings.warn(\"psutil module not found. memory_profiler will be slow\")\n        # ..\n        # .. memory usage in MiB ..\n        # .. this should work on both Mac and Linux ..\n        # .. subprocess.check_output appeared in 2.7, using Popen ..\n        # .. for backwards compatibility ..\n        out = subprocess.Popen(['ps', 'v', '-p', str(pid)],\n                               stdout=subprocess.PIPE\n                               ).communicate()[0].split(b'\\n')\n        try:\n            vsz_index = out[0].split().index(b'RSS')\n            mem = float(out[1].split()[vsz_index]) / 1024\n            if timestamps:\n                return mem, time.time()\n            else:\n                return mem\n        except:\n            if timestamps:\n                return -1, time.time()\n            else:\n                return -1\n\n    if backend == 'tracemalloc' and \\\n            (filename is None or filename == '<unknown>'):\n        raise RuntimeError(\n            'There is no access to source file of the profiled function'\n        )\n\n    tools = {'tracemalloc': tracemalloc_tool,\n             'psutil': ps_util_tool,\n             'psutil_pss': lambda: _ps_util_full_tool(memory_metric=\"pss\"),\n             'psutil_uss': lambda: _ps_util_full_tool(memory_metric=\"uss\"),\n             'posix': posix_tool}\n    return tools[backend]()\n\n\nclass MemTimer(Process):\n    \"\"\"\n    Fetch memory consumption from over a time interval\n    \"\"\"\n\n    def __init__(self, monitor_pid, interval, pipe, backend, max_usage=False,\n                 *args, **kw):\n        self.monitor_pid = monitor_pid\n        self.interval = interval\n        self.pipe = pipe\n        self.cont = True\n        self.backend = backend\n        self.max_usage = max_usage\n        self.n_measurements = 1\n\n        self.timestamps = kw.pop(\"timestamps\", False)\n        self.include_children = kw.pop(\"include_children\", False)\n\n        # get baseline memory usage\n        self.mem_usage = [\n            _get_memory(self.monitor_pid, self.backend, timestamps=self.timestamps,\n                        include_children=self.include_children)]\n        super(MemTimer, self).__init__(*args, **kw)\n\n    def run(self):\n        self.pipe.send(0)  # we're ready\n        stop = False\n        while True:\n            cur_mem = _get_memory(\n                self.monitor_pid, self.backend, timestamps=self.timestamps,\n                include_children=self.include_children,)\n            if not self.max_usage:\n                self.mem_usage.append(cur_mem)\n            else:\n                self.mem_usage[0] = max(cur_mem, self.mem_usage[0])\n            self.n_measurements += 1\n            if stop:\n                break\n            stop = self.pipe.poll(self.interval)\n            # do one more iteration\n\n        self.pipe.send(self.mem_usage)\n        self.pipe.send(self.n_measurements)\n\n\ndef memory_usage(proc=-1, interval=.1, timeout=None, timestamps=False,\n                 include_children=False, multiprocess=False, max_usage=False,\n                 retval=False, stream=None, backend=None, max_iterations=None):\n    \"\"\"\n    Return the memory usage of a process or piece of code\n\n    Parameters\n    ----------\n    proc : {int, string, tuple, subprocess.Popen}, optional\n        The process to monitor. Can be given by an integer/string\n        representing a PID, by a Popen object or by a tuple\n        representing a Python function. The tuple contains three\n        values (f, args, kw) and specifies to run the function\n        f(*args, **kw).\n        Set to -1 (default) for current process.\n\n    interval : float, optional\n        Interval at which measurements are collected.\n\n    timeout : float, optional\n        Maximum amount of time (in seconds) to wait before returning.\n\n    max_usage : bool, optional\n        Only return the maximum memory usage (default False)\n\n    retval : bool, optional\n        For profiling python functions. Save the return value of the profiled\n        function. Return value of memory_usage becomes a tuple:\n        (mem_usage, retval)\n\n    timestamps : bool, optional\n        if True, timestamps of memory usage measurement are collected as well.\n\n    include_children : bool, optional\n        if True, sum the memory of all forked processes as well\n\n    multiprocess : bool, optional\n        if True, track the memory usage of all forked processes.\n\n    stream : File\n        if stream is a File opened with write access, then results are written\n        to this file instead of stored in memory and returned at the end of\n        the subprocess. Useful for long-running processes.\n        Implies timestamps=True.\n\n    backend : str, optional\n        Current supported backends: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'\n        If `backend=None` the default is \"psutil\" which measures RSS aka \"Resident Set Size\". \n        For more information on \"psutil_pss\" (measuring PSS) and \"psutil_uss\" please refer to:\n        https://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.Process.memory_full_info \n\n    max_iterations : int\n        Limits the number of iterations (calls to the process being monitored). Relevant\n        when the process is a python function.\n\n    Returns\n    -------\n    mem_usage : list of floating-point values\n        memory usage, in MiB. It's length is always < timeout / interval\n        if max_usage is given, returns the two elements maximum memory and\n        number of measurements effectuated\n    ret : return value of the profiled function\n        Only returned if retval is set to True\n    \"\"\"\n    backend = choose_backend(backend)\n    if stream is not None:\n        timestamps = True\n\n    if not max_usage:\n        ret = []\n    else:\n        ret = -1\n\n    if timeout is not None:\n        max_iter = int(round(timeout / interval))\n    elif isinstance(proc, int):\n        # external process and no timeout\n        max_iter = 1\n    else:\n        # for a Python function wait until it finishes\n        max_iter = float('inf')\n        if max_iterations is not None:\n            max_iter = max_iterations\n\n    if callable(proc):\n        proc = (proc, (), {})\n    if isinstance(proc, (list, tuple)):\n        if len(proc) == 1:\n            f, args, kw = (proc[0], (), {})\n        elif len(proc) == 2:\n            f, args, kw = (proc[0], proc[1], {})\n        elif len(proc) == 3:\n            f, args, kw = (proc[0], proc[1], proc[2])\n        else:\n            raise ValueError\n\n        current_iter = 0\n        while True:\n            current_iter += 1\n            child_conn, parent_conn = Pipe()  # this will store MemTimer's results\n            p = MemTimer(os.getpid(), interval, child_conn, backend,\n                         timestamps=timestamps,\n                         max_usage=max_usage,\n                         include_children=include_children)\n            p.start()\n            parent_conn.recv()  # wait until we start getting memory\n\n            # When there is an exception in the \"proc\" - the (spawned) monitoring processes don't get killed.\n            # Therefore, the whole process hangs indefinitely. Here, we are ensuring that the process gets killed!\n            try:\n                returned = f(*args, **kw)\n                parent_conn.send(0)  # finish timing\n                ret = parent_conn.recv()\n                n_measurements = parent_conn.recv()\n                if max_usage:\n                    # Convert the one element list produced by MemTimer to a singular value\n                    ret = ret[0]\n                if retval:\n                    ret = ret, returned\n            except Exception:\n                parent = psutil.Process(os.getpid())\n                for child in parent.children(recursive=True):\n                    os.kill(child.pid, SIGKILL)\n                p.join(0)\n                raise\n\n            p.join(5 * interval)\n\n            if (n_measurements > 4) or (current_iter == max_iter) or (interval < 1e-6):\n                break\n            interval /= 10.\n    elif isinstance(proc, subprocess.Popen):\n        # external process, launched from Python\n        line_count = 0\n        while True:\n            if not max_usage:\n                mem_usage = _get_memory(\n                    proc.pid, backend, timestamps=timestamps,\n                    include_children=include_children)\n\n                if mem_usage and stream is not None:\n                    stream.write(\"MEM {0:.6f} {1:.4f}\\n\".format(*mem_usage))\n\n                    # Write children to the stream file\n                    if multiprocess:\n                        for idx, chldmem in _get_child_memory(proc.pid):\n                            stream.write(\"CHLD {0} {1:.6f} {2:.4f}\\n\".format(idx, chldmem, time.time()))\n                else:\n                    # Create a nested list with the child memory\n                    if multiprocess:\n                        mem_usage = [mem_usage]\n                        for _, chldmem in _get_child_memory(proc.pid):\n                            mem_usage.append(chldmem)\n\n                    # Append the memory usage to the return value\n                    ret.append(mem_usage)\n            else:\n                ret = max(ret,\n                          _get_memory(\n                              proc.pid, backend, include_children=include_children))\n            time.sleep(interval)\n            line_count += 1\n            # flush every 50 lines. Make 'tail -f' usable on profile file\n            if line_count > 50:\n                line_count = 0\n                if stream is not None:\n                    stream.flush()\n            if timeout is not None:\n                max_iter -= 1\n                if max_iter == 0:\n                    break\n            if proc.poll() is not None:\n                break\n    else:\n        # external process\n        if max_iter == -1:\n            max_iter = 1\n        counter = 0\n        while counter < max_iter:\n            counter += 1\n            if not max_usage:\n                mem_usage = _get_memory(\n                    proc, backend, timestamps=timestamps,\n                    include_children=include_children)\n                if stream is not None:\n                    stream.write(\"MEM {0:.6f} {1:.4f}\\n\".format(*mem_usage))\n\n                    # Write children to the stream file\n                    if multiprocess:\n                        for idx, chldmem in _get_child_memory(proc):\n                            stream.write(\"CHLD {0} {1:.6f} {2:.4f}\\n\".format(idx, chldmem, time.time()))\n                else:\n                    # Create a nested list with the child memory\n                    if multiprocess:\n                        mem_usage = [mem_usage]\n                        for _, chldmem in _get_child_memory(proc):\n                            mem_usage.append(chldmem)\n\n                    # Append the memory usage to the return value\n                    ret.append(mem_usage)\n            else:\n                ret = max([ret,\n                           _get_memory(proc, backend, include_children=include_children)\n                           ])\n\n            time.sleep(interval)\n            # Flush every 50 lines.\n            if counter % 50 == 0 and stream is not None:\n                stream.flush()\n    if stream:\n        return None\n    return ret\n\n\n# ..\n# .. utility functions for line-by-line ..\n\n\ndef _find_script(script_name):\n    \"\"\" Find the script.\n\n    If the input is not a file, then $PATH will be searched.\n    \"\"\"\n    if os.path.isfile(script_name):\n        return script_name\n    path = os.getenv('PATH', os.defpath).split(os.pathsep)\n    for folder in path:\n        if not folder:\n            continue\n        fn = os.path.join(folder, script_name)\n        if os.path.isfile(fn):\n            return fn\n\n    sys.stderr.write('Could not find script {0}\\n'.format(script_name))\n    raise SystemExit(1)\n\n\nclass _TimeStamperCM(object):\n    \"\"\"Time-stamping context manager.\"\"\"\n\n    def __init__(self, timestamps, filename, backend, timestamper=None, func=None,\n                 include_children=False):\n        self.timestamps = timestamps\n        self.filename = filename\n        self.backend = backend\n        self.ts = timestamper\n        self.func = func\n        self.include_children = include_children\n\n    def __enter__(self):\n        if self.ts is not None:\n            self.ts.current_stack_level += 1\n            self.ts.stack[self.func].append(self.ts.current_stack_level)\n\n        self.timestamps.append(\n            _get_memory(os.getpid(), self.backend, timestamps=True,\n                        include_children=self.include_children, filename=self.filename))\n\n    def __exit__(self, *args):\n        if self.ts is not None:\n            self.ts.current_stack_level -= 1\n\n        self.timestamps.append(\n            _get_memory(os.getpid(), self.backend, timestamps=True,\n                        include_children=self.include_children, filename=self.filename))\n\n\nclass TimeStamper:\n    \"\"\" A profiler that just records start and end execution times for\n    any decorated function.\n    \"\"\"\n\n    def __init__(self, backend, include_children=False):\n        self.functions = {}\n        self.backend = backend\n        self.include_children = include_children\n        self.current_stack_level = -1\n        self.stack = {}\n\n    def __call__(self, func=None, precision=None):\n        if func is not None:\n            if not callable(func):\n                raise ValueError(\"Value must be callable\")\n\n            self.add_function(func)\n            f = self.wrap_function(func)\n            f.__module__ = func.__module__\n            f.__name__ = func.__name__\n            f.__doc__ = func.__doc__\n            f.__dict__.update(getattr(func, '__dict__', {}))\n            return f\n        else:\n            def inner_partial(f):\n                return self.__call__(f, precision=precision)\n\n            return inner_partial\n\n    def timestamp(self, name=\"<block>\"):\n        \"\"\"Returns a context manager for timestamping a block of code.\"\"\"\n        # Make a fake function\n        func = lambda x: x\n        func.__module__ = \"\"\n        func.__name__ = name\n        self.add_function(func)\n        timestamps = []\n        self.functions[func].append(timestamps)\n        # A new object is required each time, since there can be several\n        # nested context managers.\n        try:\n            filename = inspect.getsourcefile(func)\n        except TypeError:\n            filename = '<unknown>'\n        return _TimeStamperCM(\n            timestamps,\n            filename,\n            self.backend,\n            timestamper=self,\n            func=func\n        )\n\n    def add_function(self, func):\n        if func not in self.functions:\n            self.functions[func] = []\n            self.stack[func] = []\n\n    def wrap_function(self, func):\n        \"\"\" Wrap a function to timestamp it.\n        \"\"\"\n\n        def f(*args, **kwds):\n            # Start time\n            try:\n                filename = inspect.getsourcefile(func)\n            except TypeError:\n                filename = '<unknown>'\n            timestamps = [\n                _get_memory(os.getpid(), self.backend, timestamps=True,\n                            include_children=self.include_children, filename=filename)]\n            self.functions[func].append(timestamps)\n            try:\n                with self.call_on_stack(func, *args, **kwds) as result:\n                    return result\n            finally:\n                # end time\n                timestamps.append(_get_memory(os.getpid(), self.backend, timestamps=True,\n                                              include_children=self.include_children,\n                                              filename=filename))\n\n        return f\n\n    @contextmanager\n    def call_on_stack(self, func, *args, **kwds):\n        self.current_stack_level += 1\n        self.stack[func].append(self.current_stack_level)\n\n        yield func(*args, **kwds)\n\n        self.current_stack_level -= 1\n\n    def show_results(self, stream=None):\n        if stream is None:\n            stream = sys.stdout\n\n        for func, timestamps in self.functions.items():\n            function_name = \"%s.%s\" % (func.__module__, func.__name__)\n            for ts, level in zip(timestamps, self.stack[func]):\n                stream.write(\"FUNC %s %.4f %.4f %.4f %.4f %d\\n\" % (\n                    (function_name,) + ts[0] + ts[1] + (level,)))\n\n\nclass CodeMap(dict):\n    def __init__(self, include_children, backend):\n        self.include_children = include_children\n        self._toplevel = []\n        self.backend = backend\n\n    def add(self, code, toplevel_code=None):\n        if code in self:\n            return\n\n        if toplevel_code is None:\n            filename = code.co_filename\n            if filename.endswith((\".pyc\", \".pyo\")):\n                filename = filename[:-1]\n            if not os.path.exists(filename):\n                print('ERROR: Could not find file ' + filename)\n                if filename.startswith((\"ipython-input\", \"<ipython-input\")):\n                    print(\n                        \"NOTE: %mprun can only be used on functions defined in\"\n                        \" physical files, and not in the IPython environment.\")\n                return\n\n            toplevel_code = code\n            (sub_lines, start_line) = inspect.getsourcelines(code)\n            linenos = range(start_line,\n                            start_line + len(sub_lines))\n            self._toplevel.append((filename, code, linenos))\n            self[code] = {}\n        else:\n            self[code] = self[toplevel_code]\n\n        for subcode in filter(inspect.iscode, code.co_consts):\n            self.add(subcode, toplevel_code=toplevel_code)\n\n    def trace(self, code, lineno, prev_lineno):\n        memory = _get_memory(-1, self.backend, include_children=self.include_children,\n                             filename=code.co_filename)\n        prev_value = self[code].get(lineno, None)\n        previous_memory = prev_value[1] if prev_value else 0\n        previous_inc = prev_value[0] if prev_value else 0\n\n        prev_line_value = self[code].get(prev_lineno, None) if prev_lineno else None\n        prev_line_memory = prev_line_value[1] if prev_line_value else 0\n        occ_count = self[code][lineno][2] + 1 if lineno in self[code] else 1\n        self[code][lineno] = (\n            previous_inc + (memory - prev_line_memory),\n            max(memory, previous_memory),\n            occ_count,\n        )\n\n    def items(self):\n        \"\"\"Iterate on the toplevel code blocks.\"\"\"\n        for (filename, code, linenos) in self._toplevel:\n            measures = self[code]\n            if not measures:\n                continue  # skip if no measurement\n            line_iterator = ((line, measures.get(line)) for line in linenos)\n            yield (filename, line_iterator)\n\n\nclass LineProfiler(object):\n    \"\"\" A profiler that records the amount of memory for each line \"\"\"\n\n    def __init__(self, **kw):\n        include_children = kw.get('include_children', False)\n        backend = kw.get('backend', 'psutil')\n        self.code_map = CodeMap(\n            include_children=include_children, backend=backend)\n        self.enable_count = 0\n        self.max_mem = kw.get('max_mem', None)\n        self.prevlines = []\n        self.backend = choose_backend(kw.get('backend', None))\n        self.prev_lineno = None\n\n    def __call__(self, func=None, precision=1):\n        if func is not None:\n            self.add_function(func)\n            f = self.wrap_function(func)\n            f.__module__ = func.__module__\n            f.__name__ = func.__name__\n            f.__doc__ = func.__doc__\n            f.__dict__.update(getattr(func, '__dict__', {}))\n            return f\n        else:\n            def inner_partial(f):\n                return self.__call__(f, precision=precision)\n\n            return inner_partial\n\n    def add_function(self, func):\n        \"\"\" Record line profiling information for the given Python function.\n        \"\"\"\n        try:\n            # func_code does not exist in Python3\n            code = func.__code__\n        except AttributeError:\n            warnings.warn(\"Could not extract a code object for the object %r\"\n                          % func)\n        else:\n            self.code_map.add(code)\n\n    @contextmanager\n    def _count_ctxmgr(self):\n        self.enable_by_count()\n        try:\n            yield\n        finally:\n            self.disable_by_count()\n\n    def wrap_function(self, func):\n        \"\"\" Wrap a function to profile it.\n        \"\"\"\n\n        if iscoroutinefunction(func):\n            @coroutine\n            def f(*args, **kwargs):\n                with self._count_ctxmgr():\n                    res = yield from func(*args, **kwargs)\n                    return res\n        else:\n            def f(*args, **kwds):\n                with self._count_ctxmgr():\n                    return func(*args, **kwds)\n\n        return f\n\n    def runctx(self, cmd, globals, locals):\n        \"\"\" Profile a single executable statement in the given namespaces.\n        \"\"\"\n        self.enable_by_count()\n        try:\n            exec(cmd, globals, locals)\n        finally:\n            self.disable_by_count()\n        return self\n\n    def enable_by_count(self):\n        \"\"\" Enable the profiler if it hasn't been enabled before.\n        \"\"\"\n        if self.enable_count == 0:\n            self.enable()\n        self.enable_count += 1\n\n    def disable_by_count(self):\n        \"\"\" Disable the profiler if the number of disable requests matches the\n        number of enable requests.\n        \"\"\"\n        if self.enable_count > 0:\n            self.enable_count -= 1\n            if self.enable_count == 0:\n                self.disable()\n\n    def trace_memory_usage(self, frame, event, arg):\n        \"\"\"Callback for sys.settrace\"\"\"\n        if frame.f_code in self.code_map:\n            if event == 'call':\n                # \"call\" event just saves the lineno but not the memory\n                self.prevlines.append(frame.f_lineno)\n            elif event == 'line':\n                # trace needs current line and previous line\n                self.code_map.trace(frame.f_code, self.prevlines[-1], self.prev_lineno)\n                # saving previous line\n                self.prev_lineno = self.prevlines[-1]\n                self.prevlines[-1] = frame.f_lineno\n            elif event == 'return':\n                lineno = self.prevlines.pop()\n                self.code_map.trace(frame.f_code, lineno, self.prev_lineno)\n                self.prev_lineno = lineno\n\n        if self._original_trace_function is not None:\n            self._original_trace_function(frame, event, arg)\n\n        return self.trace_memory_usage\n\n    def trace_max_mem(self, frame, event, arg):\n        # run into PDB as soon as memory is higher than MAX_MEM\n        if event in ('line', 'return') and frame.f_code in self.code_map:\n            c = _get_memory(-1, self.backend, filename=frame.f_code.co_filename)\n            if c >= self.max_mem:\n                t = ('Current memory {0:.2f} MiB exceeded the '\n                     'maximum of {1:.2f} MiB\\n'.format(c, self.max_mem))\n                sys.stdout.write(t)\n                sys.stdout.write('Stepping into the debugger \\n')\n                frame.f_lineno -= 2\n                p = pdb.Pdb()\n                p.quitting = False\n                p.stopframe = frame\n                p.returnframe = None\n                p.stoplineno = frame.f_lineno - 3\n                p.botframe = None\n                return p.trace_dispatch\n\n        if self._original_trace_function is not None:\n            (self._original_trace_function)(frame, event, arg)\n\n        return self.trace_max_mem\n\n    def __enter__(self):\n        self.enable_by_count()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.disable_by_count()\n\n    def enable(self):\n        self._original_trace_function = sys.gettrace()\n        if self.max_mem is not None:\n            sys.settrace(self.trace_max_mem)\n        else:\n            sys.settrace(self.trace_memory_usage)\n\n    def disable(self):\n        sys.settrace(self._original_trace_function)\n\n\ndef show_results(prof, stream=None, precision=1):\n    if stream is None:\n        stream = sys.stdout\n    template = '{0:>6} {1:>12} {2:>12}  {3:>10}   {4:<}'\n\n    for (filename, lines) in prof.code_map.items():\n        header = template.format('Line #', 'Mem usage', 'Increment', 'Occurrences',\n                                 'Line Contents')\n\n        stream.write(u'Filename: ' + filename + '\\n\\n')\n        stream.write(header + u'\\n')\n        stream.write(u'=' * len(header) + '\\n')\n\n        all_lines = linecache.getlines(filename)\n\n        float_format = u'{0}.{1}f'.format(precision + 4, precision)\n        template_mem = u'{0:' + float_format + '} MiB'\n        for (lineno, mem) in lines:\n            if mem:\n                inc = mem[0]\n                total_mem = mem[1]\n                total_mem = template_mem.format(total_mem)\n                occurrences = mem[2]\n                inc = template_mem.format(inc)\n            else:\n                total_mem = u''\n                inc = u''\n                occurrences = u''\n            tmp = template.format(lineno, total_mem, inc, occurrences, all_lines[lineno - 1])\n            stream.write(tmp)\n        stream.write(u'\\n\\n')\n\n\ndef _func_exec(stmt, ns):\n    # helper for magic_memit, just a function proxy for the exec\n    # statement\n    exec(stmt, ns)\n\n\n@magics_class\nclass MemoryProfilerMagics(Magics):\n    # A lprun-style %mprun magic for IPython.\n    @line_cell_magic\n    def mprun(self, parameter_s='', cell=None):\n        \"\"\" Execute a statement under the line-by-line memory profiler from the\n        memory_profiler module.\n\n        Usage, in line mode:\n          %mprun -f func1 -f func2 <statement>\n\n        Usage, in cell mode:\n          %%mprun -f func1 -f func2 [statement]\n          code...\n          code...\n\n        In cell mode, the additional code lines are appended to the (possibly\n        empty) statement in the first line. Cell mode allows you to easily\n        profile multiline blocks without having to put them in a separate\n        function.\n\n        The given statement (which doesn't require quote marks) is run via the\n        LineProfiler. Profiling is enabled for the functions specified by the -f\n        options. The statistics will be shown side-by-side with the code through\n        the pager once the statement has completed.\n\n        Options:\n\n        -f <function>: LineProfiler only profiles functions and methods it is told\n        to profile.  This option tells the profiler about these functions. Multiple\n        -f options may be used. The argument may be any expression that gives\n        a Python function or method object. However, one must be careful to avoid\n        spaces that may confuse the option parser. Additionally, functions defined\n        in the interpreter at the In[] prompt or via %run currently cannot be\n        displayed.  Write these functions out to a separate file and import them.\n\n        One or more -f options are required to get any useful results.\n\n        -T <filename>: dump the text-formatted statistics with the code\n        side-by-side out to a text file.\n\n        -r: return the LineProfiler object after it has completed profiling.\n\n        -c: If present, add the memory usage of any children process to the report.\n        \"\"\"\n        from io import StringIO\n        from memory_profiler import show_results, LineProfiler\n\n        # Local imports to avoid hard dependency.\n        from distutils.version import LooseVersion\n        import IPython\n        ipython_version = LooseVersion(IPython.__version__)\n        if ipython_version < '0.11':\n            from IPython.genutils import page\n            from IPython.ipstruct import Struct\n            from IPython.ipapi import UsageError\n        else:\n            from IPython.core.page import page\n            from IPython.utils.ipstruct import Struct\n            from IPython.core.error import UsageError\n\n        # Escape quote markers.\n        opts_def = Struct(T=[''], f=[])\n        parameter_s = parameter_s.replace('\"', r'\\\"').replace(\"'\", r\"\\'\")\n        opts, arg_str = self.parse_options(parameter_s, 'rf:T:c',\n                                           list_all=True)\n        opts.merge(opts_def)\n        global_ns = self.shell.user_global_ns\n        local_ns = self.shell.user_ns\n\n        if cell is not None:\n            arg_str += '\\n' + cell\n\n        # Get the requested functions.\n        funcs = []\n        for name in opts.f:\n            try:\n                funcs.append(eval(name, global_ns, local_ns))\n            except Exception as e:\n                raise UsageError('Could not find function %r.\\n%s: %s' % (name,\n                                                                          e.__class__.__name__,\n                                                                          e))\n\n        include_children = 'c' in opts\n        profile = LineProfiler(include_children=include_children)\n        for func in funcs:\n            profile(func)\n\n        # Add the profiler to the builtins for @profile.\n        if 'profile' in builtins.__dict__:\n            had_profile = True\n            old_profile = builtins.__dict__['profile']\n        else:\n            had_profile = False\n            old_profile = None\n        builtins.__dict__['profile'] = profile\n\n        try:\n            profile.runctx(arg_str, global_ns, local_ns)\n            message = ''\n        except SystemExit:\n            message = \"*** SystemExit exception caught in code being profiled.\"\n        except KeyboardInterrupt:\n            message = (\"*** KeyboardInterrupt exception caught in code being \"\n                       \"profiled.\")\n        finally:\n            if had_profile:\n                builtins.__dict__['profile'] = old_profile\n\n        # Trap text output.\n        stdout_trap = StringIO()\n        show_results(profile, stdout_trap)\n        output = stdout_trap.getvalue()\n        output = output.rstrip()\n\n        if ipython_version < '0.11':\n            page(output, screen_lines=self.shell.rc.screen_length)\n        else:\n            page(output)\n        print(message, )\n\n        text_file = opts.T[0]\n        if text_file:\n            with open(text_file, 'w') as pfile:\n                pfile.write(output)\n            print('\\n*** Profile printout saved to text file %s. %s' % (\n                text_file,\n                message))\n\n        return_value = None\n        if 'r' in opts:\n            return_value = profile\n\n        return return_value\n\n    # a timeit-style %memit magic for IPython\n    @line_cell_magic\n    def memit(self, line='', cell=None):\n        \"\"\"Measure memory usage of a Python statement\n\n        Usage, in line mode:\n          %memit [-r<R>t<T>i<I>] statement\n\n        Usage, in cell mode:\n          %%memit [-r<R>t<T>i<I>] setup_code\n          code...\n          code...\n\n        This function can be used both as a line and cell magic:\n\n        - In line mode you can measure a single-line statement (though multiple\n          ones can be chained with using semicolons).\n\n        - In cell mode, the statement in the first line is used as setup code\n          (executed but not measured) and the body of the cell is measured.\n          The cell body has access to any variables created in the setup code.\n\n        Options:\n        -r<R>: repeat the loop iteration <R> times and take the best result.\n        Default: 1\n\n        -t<T>: timeout after <T> seconds. Default: None\n\n        -i<I>: Get time information at an interval of I times per second.\n            Defaults to 0.1 so that there is ten measurements per second.\n\n        -c: If present, add the memory usage of any children process to the report.\n\n        -o: If present, return a object containing memit run details\n\n        -q: If present, be quiet and do not output a result.\n\n        Examples\n        --------\n        ::\n\n          In [1]: %memit range(10000)\n          peak memory: 21.42 MiB, increment: 0.41 MiB\n\n          In [2]: %memit range(1000000)\n          peak memory: 52.10 MiB, increment: 31.08 MiB\n\n          In [3]: %%memit l=range(1000000)\n             ...: len(l)\n             ...:\n          peak memory: 52.14 MiB, increment: 0.08 MiB\n\n        \"\"\"\n        from memory_profiler import memory_usage, _func_exec\n        opts, stmt = self.parse_options(line, 'r:t:i:coq', posix=False,\n                                        strict=False)\n\n        if cell is None:\n            setup = 'pass'\n        else:\n            setup = stmt\n            stmt = cell\n\n        repeat = int(getattr(opts, 'r', 1))\n        if repeat < 1:\n            repeat == 1\n        timeout = int(getattr(opts, 't', 0))\n        if timeout <= 0:\n            timeout = None\n        interval = float(getattr(opts, 'i', 0.1))\n        include_children = 'c' in opts\n        return_result = 'o' in opts\n        quiet = 'q' in opts\n\n        # I've noticed we get less noisier measurements if we run\n        # a garbage collection first\n        import gc\n        gc.collect()\n\n        _func_exec(setup, self.shell.user_ns)\n\n        mem_usage = []\n        counter = 0\n        baseline = memory_usage()[0]\n        while counter < repeat:\n            counter += 1\n            tmp = memory_usage((_func_exec, (stmt, self.shell.user_ns)),\n                               timeout=timeout, interval=interval,\n                               max_usage=True, max_iterations=1,\n                               include_children=include_children)\n            mem_usage.append(tmp)\n\n        result = MemitResult(mem_usage, baseline, repeat, timeout, interval,\n                             include_children)\n\n        if not quiet:\n            if mem_usage:\n                print(result)\n            else:\n                print('ERROR: could not read memory usage, try with a '\n                      'lower interval or more iterations')\n\n        if return_result:\n            return result\n\n    @classmethod\n    def register_magics(cls, ip):\n        from distutils.version import LooseVersion\n        import IPython\n        ipython_version = LooseVersion(IPython.__version__)\n\n        if ipython_version < '0.13':\n            try:\n                _register_magic = ip.define_magic\n            except AttributeError:  # ipython 0.10\n                _register_magic = ip.expose_magic\n\n            _register_magic('mprun', cls.mprun.__func__)\n            _register_magic('memit', cls.memit.__func__)\n        else:\n            ip.register_magics(cls)\n\n\n# commenting out due to failures with some versions of IPython\n# see https://github.com/fabianp/memory_profiler/issues/106\n# # Ensuring old interface of magics expose for IPython 0.10\n# magic_mprun = MemoryProfilerMagics().mprun.__func__\n# magic_memit = MemoryProfilerMagics().memit.__func__\n\n\ndef load_ipython_extension(ip):\n    \"\"\"This is called to load the module as an IPython extension.\"\"\"\n\n    MemoryProfilerMagics.register_magics(ip)\n\n\ndef profile(func=None, stream=None, precision=1, backend='psutil'):\n    \"\"\"\n    Decorator that will run the function and print a line-by-line profile\n    \"\"\"\n    backend = choose_backend(backend)\n    if backend == 'tracemalloc' and has_tracemalloc:\n        if not tracemalloc.is_tracing():\n            tracemalloc.start()\n    if func is not None:\n        get_prof = partial(LineProfiler, backend=backend)\n        show_results_bound = partial(\n            show_results, stream=stream, precision=precision\n        )\n        if iscoroutinefunction(func):\n            @wraps(wrapped=func)\n            @coroutine\n            def wrapper(*args, **kwargs):\n                prof = get_prof()\n                val = yield from prof(func)(*args, **kwargs)\n                show_results_bound(prof)\n                return val\n        else:\n            @wraps(wrapped=func)\n            def wrapper(*args, **kwargs):\n                prof = get_prof()\n                val = prof(func)(*args, **kwargs)\n                show_results_bound(prof)\n                return val\n\n        return wrapper\n    else:\n        def inner_wrapper(f):\n            return profile(f, stream=stream, precision=precision,\n                           backend=backend)\n\n        return inner_wrapper\n\n\ndef choose_backend(new_backend=None):\n    \"\"\"\n    Function that tries to setup backend, chosen by user, and if failed,\n    setup one of the allowable backends\n    \"\"\"\n\n    _backend = 'no_backend'\n    all_backends = [\n        ('psutil', True),\n        ('psutil_pss', True),\n        ('psutil_uss', True),\n        ('posix', os.name == 'posix'),\n        ('tracemalloc', has_tracemalloc),\n    ]\n    backends_indices = dict((b[0], i) for i, b in enumerate(all_backends))\n\n    if new_backend is not None:\n        all_backends.insert(0, all_backends.pop(backends_indices[new_backend]))\n\n    for n_backend, is_available in all_backends:\n        if is_available:\n            _backend = n_backend\n            break\n    if _backend != new_backend and new_backend is not None:\n        warnings.warn('{0} can not be used, {1} used instead'.format(\n            new_backend, _backend))\n    return _backend\n\n\n# Insert in the built-ins to have profile\n# globally defined (global variables is not enough\n# for all cases, e.g. a script that imports another\n# script where @profile is used)\ndef exec_with_profiler(filename, profiler, backend, passed_args=[]):\n    from runpy import run_module\n    builtins.__dict__['profile'] = profiler\n    ns = dict(_CLEAN_GLOBALS,\n              profile=profiler,\n             # Make sure the __file__ variable is usable\n             # by the script we're profiling\n              __file__=filename)\n    # Make sure the script's directory in on sys.path\n    # credit to line_profiler\n    sys.path.insert(0, os.path.dirname(script_filename))\n\n    _backend = choose_backend(backend)\n    sys.argv = [filename] + passed_args\n    try:\n        if _backend == 'tracemalloc' and has_tracemalloc:\n            tracemalloc.start()\n        with io.open(filename, encoding='utf-8') as f:\n            exec(compile(f.read(), filename, 'exec'), ns, ns)\n    finally:\n        if has_tracemalloc and tracemalloc.is_tracing():\n            tracemalloc.stop()\n\n\ndef run_module_with_profiler(module, profiler, backend, passed_args=[]):\n    from runpy import run_module\n    builtins.__dict__['profile'] = profiler\n    ns = dict(_CLEAN_GLOBALS, profile=profiler)\n    _backend = choose_backend(backend)\n    sys.argv = [module] + passed_args\n    if _backend == 'tracemalloc' and has_tracemalloc:\n        tracemalloc.start()\n    try:\n        run_module(module, run_name=\"__main__\", init_globals=ns)\n    finally:\n        if has_tracemalloc and tracemalloc.is_tracing():\n            tracemalloc.stop()\n\n\nclass LogFile(object):\n    \"\"\"File-like object to log text using the `logging` module and the log\n    report can be customised.\"\"\"\n\n    def __init__(self, name=None, reportIncrementFlag=False):\n        \"\"\"\n        :param name: name of the logger module\n               reportIncrementFlag: This must be set to True if only the steps\n               with memory increments are to be reported\n\n        :type self: object\n              name: string\n              reportIncrementFlag: bool\n        \"\"\"\n        self.logger = logging.getLogger(name)\n        self.reportIncrementFlag = reportIncrementFlag\n\n    def write(self, msg, level=logging.INFO):\n        if self.reportIncrementFlag:\n            if \"MiB\" in msg and float(msg.split(\"MiB\")[1].strip()) > 0:\n                self.logger.log(level, msg)\n            elif msg.__contains__(\"Filename:\") or msg.__contains__(\n                    \"Line Contents\"):\n                self.logger.log(level, msg)\n        else:\n            self.logger.log(level, msg)\n\n    def flush(self):\n        for handler in self.logger.handlers:\n            handler.flush()\n\n\nif __name__ == '__main__':\n    from argparse import ArgumentParser, REMAINDER\n\n    parser = ArgumentParser(usage=_CMD_USAGE)\n    parser.add_argument('--version', action='version', version=__version__)\n    parser.add_argument(\n        '--pdb-mmem', dest='max_mem', metavar='MAXMEM',\n        type=float, action='store',\n        help='step into the debugger when memory exceeds MAXMEM')\n    parser.add_argument(\n        '--precision', dest='precision', type=int,\n        action='store', default=3,\n        help='precision of memory output in number of significant digits')\n    parser.add_argument('-o', dest='out_filename', type=str,\n        action='store', default=None,\n        help='path to a file where results will be written')\n    parser.add_argument('--timestamp', dest='timestamp', default=False,\n        action='store_true',\n        help='''print timestamp instead of memory measurement for\n        decorated functions''')\n    parser.add_argument('--include-children', dest='include_children',\n        default=False, action='store_true',\n        help='also include memory used by child processes')\n    parser.add_argument('--backend', dest='backend', type=str, action='store',\n        choices=['tracemalloc', 'psutil', 'psutil_pss', 'psutil_uss', 'posix'], default='psutil',\n        help='backend using for getting memory info '\n             '(one of the {tracemalloc, psutil, posix, psutil_pss, psutil_uss, posix})')\n    parser.add_argument(\"program\", nargs=REMAINDER,\n        help='python script or module followed by command line arguments to run')\n    args = parser.parse_args()\n\n    if len(args.program) == 0:\n        print(\"A program to run must be provided. Use -h for help\")\n        sys.exit(1)\n\n    target = args.program[0]\n    script_args = args.program[1:]\n    _backend = choose_backend(args.backend)\n    if args.timestamp:\n        prof = TimeStamper(_backend, include_children=args.include_children)\n    else:\n        prof = LineProfiler(max_mem=args.max_mem, backend=_backend)\n\n    try:\n        if args.program[0].endswith('.py'):\n            script_filename = _find_script(args.program[0])\n            exec_with_profiler(script_filename, prof, args.backend, script_args)\n        else:\n            run_module_with_profiler(target, prof, args.backend, script_args)\n    finally:\n        if args.out_filename is not None:\n            out_file = open(args.out_filename, \"a\")\n        else:\n            out_file = sys.stdout\n\n        if args.timestamp:\n            prof.show_results(stream=out_file)\n        else:\n            show_results(prof, precision=args.precision, stream=out_file)\n",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n    \n    def complete(self, is_correct: bool, execution_time_ms: Optional[float] = None,\n                memory_usage_mb: Optional[float] = None, passed_test_cases: int = 0,\n                total_test_cases: int = 0, runtime_error: Optional[str] = None) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n        \n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n    \n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n        \n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n        \n        return self.end_time - self.start_time",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n    \n    def complete(self, is_correct: bool, execution_time_ms: Optional[float] = None,\n                memory_usage_mb: Optional[float] = None, passed_test_cases: int = 0,\n                total_test_cases: int = 0, runtime_error: Optional[str] = None) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n        \n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n    \n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n        \n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n        \n        return self.end_time - self.start_time",
                "class ProblemAttempt(BaseModel):\n    \"\"\"\n    Represents an attempt to solve an interview problem.\n    \"\"\"\n    problem_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    code: str = \"\"\n    is_completed: bool = False\n    is_correct: bool = False\n    execution_time_ms: Optional[float] = None\n    memory_usage_mb: Optional[float] = None\n    passed_test_cases: int = 0\n    total_test_cases: int = 0\n    runtime_error: Optional[str] = None\n    \n    def complete(self, is_correct: bool, execution_time_ms: Optional[float] = None,\n                memory_usage_mb: Optional[float] = None, passed_test_cases: int = 0,\n                total_test_cases: int = 0, runtime_error: Optional[str] = None) -> None:\n        \"\"\"\n        Mark the attempt as complete with results.\n        \n        Args:\n            is_correct: Whether the solution is correct\n            execution_time_ms: Execution time in milliseconds\n            memory_usage_mb: Memory usage in megabytes\n            passed_test_cases: Number of test cases passed\n            total_test_cases: Total number of test cases\n            runtime_error: Runtime error message, if any\n        \"\"\"\n        self.end_time = time.time()\n        self.is_completed = True\n        self.is_correct = is_correct\n        self.execution_time_ms = execution_time_ms\n        self.memory_usage_mb = memory_usage_mb\n        self.passed_test_cases = passed_test_cases\n        self.total_test_cases = total_test_cases\n        self.runtime_error = runtime_error\n    \n    def duration_seconds(self) -> float:\n        \"\"\"\n        Get the duration of the attempt in seconds.\n        \n        Returns:\n            Duration of the attempt, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            if self.is_completed:\n                return -1\n            else:\n                return time.time() - self.start_time\n        \n        return self.end_time - self.start_time",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class TestResult(BaseModel):\n    \"\"\"\n    Represents the result of running a test case.\n    \"\"\"\n    test_case_index: int\n    passed: bool\n    actual_output: str\n    expected_output: str\n    execution_time_ms: float\n    memory_usage_mb: float\n    error_message: Optional[str] = None",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class SolutionAnalysis(BaseModel):\n    \"\"\"\n    Represents an analysis of a solution to an interview problem.\n    \"\"\"\n    time_complexity: str\n    space_complexity: str\n    strengths: List[str] = Field(default_factory=list)\n    weaknesses: List[str] = Field(default_factory=list)\n    optimization_suggestions: List[str] = Field(default_factory=list)\n    alternative_approaches: List[str] = Field(default_factory=list)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n    \n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n        \n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n        \n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n            \n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n            \n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n        \n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n    \n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n        \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n    \n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n        \n        Args:\n            difficulty: The difficulty level to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n        \n        Args:\n            category: The problem category to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n        \n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n    \n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n        \n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n        \n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n            \n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n            \n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n        \n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n    \n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n        \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n    \n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n        \n        Args:\n            difficulty: The difficulty level to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n        \n        Args:\n            category: The problem category to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n        \n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "class InterviewStats(BaseModel):\n    \"\"\"\n    Tracks a user's interview preparation statistics.\n    \"\"\"\n    problems_attempted: Set[str] = Field(default_factory=set)\n    problems_solved: Set[str] = Field(default_factory=set)\n    total_time_spent_seconds: float = 0\n    attempts_by_difficulty: Dict[str, int] = Field(default_factory=dict)\n    attempts_by_category: Dict[str, int] = Field(default_factory=dict)\n    \n    def add_attempt(self, attempt: ProblemAttempt, problem: InterviewProblem) -> None:\n        \"\"\"\n        Add an attempt to the statistics.\n        \n        Args:\n            attempt: The ProblemAttempt to add\n            problem: The InterviewProblem that was attempted\n        \"\"\"\n        self.problems_attempted.add(attempt.problem_id)\n        \n        if attempt.is_correct:\n            self.problems_solved.add(attempt.problem_id)\n            \n        # Update time spent\n        if attempt.end_time is not None:\n            self.total_time_spent_seconds += attempt.duration_seconds()\n            \n        # Update difficulty stats\n        difficulty = problem.difficulty.value\n        if difficulty not in self.attempts_by_difficulty:\n            self.attempts_by_difficulty[difficulty] = 0\n        self.attempts_by_difficulty[difficulty] += 1\n        \n        # Update category stats\n        category = problem.category.value\n        if category not in self.attempts_by_category:\n            self.attempts_by_category[category] = 0\n        self.attempts_by_category[category] += 1\n    \n    def get_success_rate(self) -> float:\n        \"\"\"\n        Get the overall success rate.\n        \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return (len(self.problems_solved) / len(self.problems_attempted)) * 100\n    \n    def get_success_rate_by_difficulty(self, difficulty: DifficultyLevel) -> float:\n        \"\"\"\n        Get the success rate for a specific difficulty level.\n        \n        Args:\n            difficulty: The difficulty level to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_success_rate_by_category(self, category: ProblemCategory) -> float:\n        \"\"\"\n        Get the success rate for a specific problem category.\n        \n        Args:\n            category: The problem category to check\n            \n        Returns:\n            Success rate as a percentage (0-100)\n        \"\"\"\n        # This would require tracking more detailed statistics\n        # For now, we'll just return the overall success rate\n        return self.get_success_rate()\n    \n    def get_average_time_per_problem(self) -> float:\n        \"\"\"\n        Get the average time spent per problem in seconds.\n        \n        Returns:\n            Average time in seconds\n        \"\"\"\n        if not self.problems_attempted:\n            return 0.0\n            \n        return self.total_time_spent_seconds / len(self.problems_attempted)",
                "def get_problem(problem_id: str) -> Optional[InterviewProblem]:\n    \"\"\"\n    Get a specific interview problem by ID.\n    \n    Args:\n        problem_id: ID of the problem to retrieve\n        \n    Returns:\n        The InterviewProblem object, or None if not found\n    \"\"\"\n    return SAMPLE_PROBLEMS.get(problem_id)",
                "def get_all_problems() -> List[InterviewProblem]:\n    \"\"\"\n    Get all available interview problems.\n    \n    Returns:\n        List of all InterviewProblem objects\n    \"\"\"\n    return list(SAMPLE_PROBLEMS.values())",
                "def get_problems_by_difficulty(difficulty: DifficultyLevel) -> List[InterviewProblem]:\n    \"\"\"\n    Get problems filtered by difficulty.\n    \n    Args:\n        difficulty: Difficulty level to filter by\n        \n    Returns:\n        List of InterviewProblem objects at the specified difficulty\n    \"\"\"\n    return [p for p in SAMPLE_PROBLEMS.values() if p.difficulty == difficulty]",
                "def get_problems_by_category(category: ProblemCategory) -> List[InterviewProblem]:\n    \"\"\"\n    Get problems filtered by category.\n    \n    Args:\n        category: Category to filter by\n        \n    Returns:\n        List of InterviewProblem objects in the specified category\n    \"\"\"\n    return [p for p in SAMPLE_PROBLEMS.values() if p.category == category]"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/core/__init__.py": {
        "logprobs": -197.41041433829298,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/run_tests.py": {
        "logprobs": -430.8142110440635,
        "metrics": {
            "loc": 72,
            "sloc": 51,
            "lloc": 41,
            "comments": 8,
            "multi": 0,
            "blank": 12,
            "cyclomatic": 6,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/client.py": {
        "logprobs": -1573.1839042524434,
        "metrics": {
            "loc": 302,
            "sloc": 201,
            "lloc": 168,
            "comments": 8,
            "multi": 0,
            "blank": 61,
            "cyclomatic": 43,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class FocusMode:\n    \"\"\"The focus mode system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the focus mode system with the given document.\"\"\"\n        self.document = document\n        self.active_focus: Optional[FocusContext] = None\n        self.focus_history: List[FocusContext] = []\n    \n    def is_active(self) -> bool:\n        \"\"\"Check if focus mode is currently active.\"\"\"\n        return self.active_focus is not None\n    \n    def get_focus_context(self) -> Optional[FocusContext]:\n        \"\"\"Get the current focus context if focus mode is active.\"\"\"\n        return self.active_focus\n    \n    def enter_focus(\n        self, \n        section_index: int, \n        segment_index: int, \n        level: FocusLevel = FocusLevel.PARAGRAPH\n    ) -> Optional[FocusContext]:\n        \"\"\"Enter focus mode for the specified section and segment.\"\"\"\n        section = self.document.get_section(section_index)\n        if not section:\n            return None\n        \n        segment = section.get_segment(segment_index)\n        if not segment:\n            return None\n        \n        self.active_focus = FocusContext(\n            document=self.document,\n            section=section,\n            segment=segment,\n            level=level\n        )\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n    \n    def exit_focus(self) -> bool:\n        \"\"\"Exit focus mode.\"\"\"\n        if self.active_focus:\n            self.active_focus = None\n            return True\n        return False\n    \n    def move_focus(self, direction: int = 1) -> Optional[FocusContext]:\n        \"\"\"Move the focus to the next or previous segment.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        current_segment = self.active_focus.segment\n        current_section = self.active_focus.section\n        \n        # Find the next segment within the current section\n        next_position = current_segment.position + direction\n        next_segment = current_section.get_segment(next_position)\n        \n        if next_segment:\n            # Move focus within the same section\n            self.active_focus = FocusContext(\n                document=self.document,\n                section=current_section,\n                segment=next_segment,\n                level=self.active_focus.level\n            )\n            self.focus_history.append(self.active_focus)\n            return self.active_focus\n        \n        # Try to move to a different section\n        current_section_idx = self.document.current_revision.sections.index(current_section)\n        next_section_idx = current_section_idx + direction\n        \n        if 0 <= next_section_idx < len(self.document.current_revision.sections):\n            next_section = self.document.current_revision.sections[next_section_idx]\n            \n            # Get the first or last segment of the next section depending on direction\n            target_position = 0 if direction > 0 else len(next_section.segments) - 1\n            if 0 <= target_position < len(next_section.segments):\n                next_segment = next_section.segments[target_position]\n                \n                self.active_focus = FocusContext(\n                    document=self.document,\n                    section=next_section,\n                    segment=next_segment,\n                    level=self.active_focus.level\n                )\n                self.focus_history.append(self.active_focus)\n                return self.active_focus\n        \n        return None\n    \n    def change_focus_level(self, level: FocusLevel) -> Optional[FocusContext]:\n        \"\"\"Change the level of focus.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        self.active_focus.level = level\n        self.focus_history.append(self.active_focus)\n        return self.active_focus\n    \n    def edit_focused_content(self, new_content: str) -> Optional[TextSegment]:\n        \"\"\"Edit the content of the focused segment.\"\"\"\n        if not self.active_focus:\n            return None\n        \n        self.active_focus.segment.content = new_content\n        self.document.updated_at = time.time()\n        return self.active_focus.segment\n    \n    def get_focus_time(self) -> float:\n        \"\"\"Get the time spent in the current focus session in seconds.\"\"\"\n        if not self.active_focus:\n            return 0.0\n        \n        return time.time() - self.active_focus.start_time\n    \n    def get_surrounding_context(self, context_size: int = 2) -> List[TextSegment]:\n        \"\"\"Get the surrounding segments around the focused segment.\"\"\"\n        if not self.active_focus:\n            return []\n        \n        section = self.active_focus.section\n        position = self.active_focus.segment.position\n        \n        start = max(0, position - context_size)\n        end = min(len(section.segments), position + context_size + 1)\n        \n        return section.segments[start:end]",
                "class FocusLevel(str, Enum):\n    \"\"\"The level of focus.\"\"\"\n    \n    PARAGRAPH = \"paragraph\"\n    SENTENCE = \"sentence\"\n    SECTION = \"section\"",
                "class WritingStatistics:\n    \"\"\"Writing statistics tracking system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the writing statistics system with the given document.\"\"\"\n        self.document = document\n        self.stats_history: List[DocumentStats] = []\n        self.pace_history: List[WritingPace] = []\n        self.progress_trackers: Dict[str, ProgressTracker] = {}\n        self._last_word_count: int = 0\n        self._last_check_time: float = time.time()\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n    \n    def _count_sentences(self, text: str) -> int:\n        \"\"\"Count the number of sentences in the text.\"\"\"\n        # Simple sentence counting - this could be improved with NLP\n        return len(re.findall(r'[.!?]+\\s+', text)) + 1\n    \n    def _identify_sentence_type(self, sentence: str) -> str:\n        \"\"\"Identify the type of a sentence.\"\"\"\n        sentence = sentence.strip()\n        if not sentence:\n            return \"unknown\"\n        \n        if sentence.endswith('?'):\n            return \"interrogative\"\n        elif sentence.endswith('!'):\n            return \"exclamatory\"\n        elif ',' in sentence and ('but' in sentence.lower() or 'however' in sentence.lower()):\n            return \"complex\"\n        else:\n            return \"declarative\"\n    \n    def _is_complex_sentence(self, sentence: str) -> bool:\n        \"\"\"Check if a sentence is complex (has multiple clauses).\"\"\"\n        # Simple check for coordinating conjunctions and subordinating conjunctions\n        coordinating_conjunctions = [\n            ' and ', ' but ', ' or ', ' nor ', ' so ', ' for ', ' yet '\n        ]\n\n        subordinating_conjunctions = [\n            ' because ', ' although ', ' though ', ' since ', ' unless ',\n            ' if ', ' when ', ' where ', ' while '\n        ]\n\n        # Check for conjunction at beginning of sentence too\n        sentence_starts = [\n            'when ', 'if ', 'while ', 'because ', 'although ', 'though ',\n            'since ', 'unless ', 'where '\n        ]\n\n        sentence = sentence.lower()\n\n        # Check for any coordinating conjunctions within the sentence\n        has_coordinating = any(conj in sentence for conj in coordinating_conjunctions)\n\n        # Check for any subordinating conjunctions within the sentence\n        has_subordinating = any(conj in sentence for conj in subordinating_conjunctions)\n\n        # Check if the sentence starts with a subordinating conjunction\n        starts_with_subordinating = any(sentence.startswith(start) for start in sentence_starts)\n\n        return has_coordinating or has_subordinating or starts_with_subordinating\n    \n    def _calculate_vocabulary_richness(self, total_words: int, unique_words: int) -> float:\n        \"\"\"Calculate vocabulary richness (Type-Token Ratio).\"\"\"\n        if total_words == 0:\n            return 0.0\n        return unique_words / total_words\n    \n    def calculate_stats(self) -> DocumentStats:\n        \"\"\"Calculate the current document statistics.\"\"\"\n        text = self.document.get_content()\n        \n        # Basic counts\n        word_count = len(re.findall(r'\\b\\w+\\b', text))\n        character_count = len(text)\n        paragraph_count = len(re.findall(r'\\n\\s*\\n', text)) + 1\n        \n        # Split into sentences for sentence analysis\n        sentences = re.split(r'[.!?]+\\s+', text)\n        sentence_count = len(sentences)\n        \n        # Analyze sentence structure\n        sentence_lengths = [len(re.findall(r'\\b\\w+\\b', s)) for s in sentences if s.strip()]\n        avg_sentence_length = statistics.mean(sentence_lengths) if sentence_lengths else 0\n        sentence_length_variance = statistics.variance(sentence_lengths) if len(sentence_lengths) > 1 else 0\n        \n        complex_sentences = sum(1 for s in sentences if self._is_complex_sentence(s))\n        \n        sentence_types = {}\n        for s in sentences:\n            if not s.strip():\n                continue\n            sent_type = self._identify_sentence_type(s)\n            sentence_types[sent_type] = sentence_types.get(sent_type, 0) + 1\n        \n        # Analyze word usage\n        words = re.findall(r'\\b\\w+\\b', text.lower())\n        unique_words = len(set(words))\n        \n        word_lengths = [len(w) for w in words]\n        avg_word_length = statistics.mean(word_lengths) if word_lengths else 0\n        \n        # Count word frequencies\n        word_frequencies = {}\n        for word in words:\n            if len(word) > 3:  # Ignore very short words\n                word_frequencies[word] = word_frequencies.get(word, 0) + 1\n        \n        # Get most common words (top 20)\n        most_common = dict(sorted(word_frequencies.items(), key=lambda x: x[1], reverse=True)[:20])\n        \n        # Calculate reading level metrics\n        reading_level = {\n            ReadingLevel.FLESCH_KINCAID_GRADE.value: textstat.flesch_kincaid_grade(text),\n            ReadingLevel.FLESCH_READING_EASE.value: textstat.flesch_reading_ease(text),\n            ReadingLevel.GUNNING_FOG.value: textstat.gunning_fog(text),\n            ReadingLevel.SMOG_INDEX.value: textstat.smog_index(text),\n            ReadingLevel.AUTOMATED_READABILITY_INDEX.value: textstat.automated_readability_index(text),\n            ReadingLevel.COLEMAN_LIAU_INDEX.value: textstat.coleman_liau_index(text)\n        }\n        \n        # Create stats objects\n        word_stats = WordStats(\n            total_words=word_count,\n            unique_words=unique_words,\n            average_word_length=avg_word_length,\n            most_common_words=most_common,\n            vocabulary_richness=self._calculate_vocabulary_richness(word_count, unique_words)\n        )\n        \n        sentence_stats = SentenceStats(\n            total_sentences=sentence_count,\n            average_sentence_length=avg_sentence_length,\n            sentence_length_variance=sentence_length_variance,\n            complex_sentences=complex_sentences,\n            sentence_types=sentence_types\n        )\n        \n        document_stats = DocumentStats(\n            word_count=word_count,\n            character_count=character_count,\n            paragraph_count=paragraph_count,\n            sentence_count=sentence_count,\n            reading_level=reading_level,\n            word_stats=word_stats,\n            sentence_stats=sentence_stats\n        )\n        \n        # Update history\n        self.stats_history.append(document_stats)\n        \n        # Update last word count for pace tracking\n        self._last_word_count = word_count\n        \n        return document_stats\n    \n    def calculate_writing_pace(self) -> WritingPace:\n        \"\"\"Calculate the current writing pace.\"\"\"\n        current_time = time.time()\n        current_word_count = self.document.get_word_count()\n        \n        time_diff_seconds = current_time - self._last_check_time\n        word_diff = current_word_count - self._last_word_count\n        \n        if time_diff_seconds <= 0:\n            words_per_minute = 0.0\n        else:\n            # Calculate words per minute\n            words_per_minute = (word_diff / time_diff_seconds) * 60\n        \n        # Update for next calculation\n        self._last_check_time = current_time\n        self._last_word_count = current_word_count\n        \n        # Create pace object\n        pace = WritingPace(\n            words_per_minute=words_per_minute,\n            words_per_hour=words_per_minute * 60,\n            words_per_day=words_per_minute * 60 * 24\n        )\n        \n        # Update history\n        self.pace_history.append(pace)\n        \n        return pace\n    \n    def set_progress_goal(\n        self, \n        goal_id: str,\n        goal_type: str, \n        target: int, \n        deadline: Optional[datetime] = None\n    ) -> ProgressTracker:\n        \"\"\"Set a new progress goal.\"\"\"\n        tracker = ProgressTracker(\n            start_date=datetime.now(),\n            goal_type=goal_type,\n            goal_target=target,\n            goal_deadline=deadline\n        )\n        \n        self.progress_trackers[goal_id] = tracker\n        return tracker\n    \n    def update_progress(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Update the progress for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n        \n        tracker = self.progress_trackers[goal_id]\n        current_stats = self.calculate_stats()\n        \n        progress_entry = {\n            \"timestamp\": datetime.now(),\n            \"word_count\": current_stats.word_count,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target\n        }\n        \n        if tracker.goal_type == \"word_count\":\n            progress_entry[\"progress_percentage\"] = (current_stats.word_count / tracker.goal_target) * 100\n            progress_entry[\"remaining\"] = max(0, tracker.goal_target - current_stats.word_count)\n        \n        if tracker.goal_deadline:\n            now = datetime.now()\n            if now < tracker.goal_deadline:\n                time_remaining = tracker.goal_deadline - now\n                progress_entry[\"time_remaining_days\"] = time_remaining.days\n                \n                # Estimate completion date based on current pace\n                if self.pace_history and tracker.goal_type == \"word_count\":\n                    latest_pace = self.pace_history[-1]\n                    words_remaining = max(0, tracker.goal_target - current_stats.word_count)\n                    \n                    if latest_pace.words_per_day > 0:\n                        days_needed = words_remaining / latest_pace.words_per_day\n                        progress_entry[\"estimated_completion_date\"] = now + timedelta(days=days_needed)\n        \n        tracker.progress_history.append(progress_entry)\n        return progress_entry\n    \n    def get_progress_report(self, goal_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a detailed progress report for a specific goal.\"\"\"\n        if goal_id not in self.progress_trackers:\n            return None\n        \n        tracker = self.progress_trackers[goal_id]\n        current_progress = self.update_progress(goal_id)\n        \n        if not current_progress or not tracker.progress_history:\n            return None\n        \n        report = {\n            \"goal_id\": goal_id,\n            \"goal_type\": tracker.goal_type,\n            \"goal_target\": tracker.goal_target,\n            \"start_date\": tracker.start_date,\n            \"deadline\": tracker.goal_deadline,\n            \"current_progress\": current_progress,\n            \"history_summary\": {\n                \"start_value\": tracker.progress_history[0].get(\"word_count\", 0),\n                \"current_value\": current_progress.get(\"word_count\", 0),\n                \"total_progress\": current_progress.get(\"word_count\", 0) - tracker.progress_history[0].get(\"word_count\", 0)\n            }\n        }\n        \n        # Calculate average daily progress\n        if len(tracker.progress_history) > 1:\n            first_entry = tracker.progress_history[0]\n            last_entry = tracker.progress_history[-1]\n            \n            first_time = first_entry[\"timestamp\"]\n            last_time = last_entry[\"timestamp\"]\n            \n            time_diff_days = (last_time - first_time).days or 1  # Avoid division by zero\n            progress_diff = last_entry.get(\"word_count\", 0) - first_entry.get(\"word_count\", 0)\n            \n            report[\"average_daily_progress\"] = progress_diff / time_diff_days\n        \n        return report\n    \n    def start_background_tracking(self, interval_seconds: int = 60) -> None:\n        \"\"\"Start tracking statistics in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n        \n        self._stop_background_thread = False\n        \n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.calculate_stats()\n                    self.calculate_writing_pace()\n                    \n                    # Update all progress trackers\n                    for goal_id in self.progress_trackers:\n                        self.update_progress(goal_id)\n                except Exception as e:\n                    print(f\"Error in background tracking: {e}\")\n                \n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n        \n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n    \n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)\n    \n    def get_trend_analysis(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"Analyze trends in writing statistics over the specified number of days.\"\"\"\n        now = datetime.now()\n        cutoff_date = now - timedelta(days=days)\n        \n        # Filter history to the specified time range\n        recent_stats = [s for s in self.stats_history if s.timestamp >= cutoff_date]\n        recent_pace = [p for p in self.pace_history if p.timestamp >= cutoff_date]\n        \n        if not recent_stats:\n            return {\"error\": \"Not enough data for trend analysis\"}\n        \n        # Calculate daily word counts\n        daily_word_counts = {}\n        for stats in recent_stats:\n            day_key = stats.timestamp.strftime(\"%Y-%m-%d\")\n            if day_key not in daily_word_counts:\n                daily_word_counts[day_key] = []\n            daily_word_counts[day_key].append(stats.word_count)\n        \n        # Get the last word count for each day\n        daily_progress = {\n            day: counts[-1] for day, counts in daily_word_counts.items()\n        }\n        \n        # Calculate daily difference\n        days_sorted = sorted(daily_progress.keys())\n        daily_change = {}\n        for i in range(1, len(days_sorted)):\n            prev_day = days_sorted[i-1]\n            curr_day = days_sorted[i]\n            daily_change[curr_day] = daily_progress[curr_day] - daily_progress[prev_day]\n        \n        # Calculate reading level trends\n        reading_level_trends = {}\n        for level_type in ReadingLevel:\n            level_values = [s.reading_level.get(level_type.value, 0) for s in recent_stats]\n            if level_values:\n                reading_level_trends[level_type.value] = {\n                    \"start\": level_values[0],\n                    \"end\": level_values[-1],\n                    \"change\": level_values[-1] - level_values[0],\n                    \"average\": sum(level_values) / len(level_values)\n                }\n        \n        # Calculate pace trends\n        pace_trends = {}\n        if recent_pace:\n            wpm_values = [p.words_per_minute for p in recent_pace]\n            pace_trends[\"words_per_minute\"] = {\n                \"start\": wpm_values[0],\n                \"end\": wpm_values[-1],\n                \"change\": wpm_values[-1] - wpm_values[0],\n                \"average\": sum(wpm_values) / len(wpm_values)\n            }\n        \n        return {\n            \"period_days\": days,\n            \"total_word_count_change\": recent_stats[-1].word_count - recent_stats[0].word_count,\n            \"daily_progress\": daily_progress,\n            \"daily_change\": daily_change,\n            \"average_daily_change\": sum(daily_change.values()) / len(daily_change) if daily_change else 0,\n            \"reading_level_trends\": reading_level_trends,\n            \"pace_trends\": pace_trends,\n            \"vocabulary_richness_change\": (\n                recent_stats[-1].word_stats.vocabulary_richness - \n                recent_stats[0].word_stats.vocabulary_richness\n            )\n        }",
                "class NarrativeTracker:\n    \"\"\"Character and plot element tracking system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the narrative tracking system with the given document.\"\"\"\n        self.document = document\n        self.elements: Dict[str, NarrativeElement] = {}\n        self.consistency_issues: List[ConsistencyIssue] = []\n        self._nlp = None  # Lazy-loaded spaCy model\n        self._background_thread: Optional[threading.Thread] = None\n        self._stop_background_thread: bool = False\n    \n    def _ensure_nlp_loaded(self):\n        \"\"\"Ensure the NLP model is loaded.\"\"\"\n        if self._nlp is None:\n            # Load a smaller spaCy model for performance\n            self._nlp = spacy.load(\"en_core_web_sm\")\n    \n    def _find_element_occurrences(\n        self, \n        element_name: str, \n        aliases: List[str] = None\n    ) -> List[Tuple[Section, TextSegment, int, str]]:\n        \"\"\"Find occurrences of an element in the document by name and aliases.\"\"\"\n        results = []\n        names_to_search = [element_name]\n        if aliases:\n            names_to_search.extend(aliases)\n        \n        # Compile regex pattern for faster matching\n        # Ensure we match whole words only\n        pattern = r'\\b(' + '|'.join(re.escape(name) for name in names_to_search) + r')\\b'\n        regex = re.compile(pattern, re.IGNORECASE)\n        \n        for section in self.document.current_revision.sections:\n            for segment in section.segments:\n                for match in regex.finditer(segment.content):\n                    # Extract some context around the match (up to 100 characters)\n                    start_pos = max(0, match.start() - 50)\n                    end_pos = min(len(segment.content), match.end() + 50)\n                    context = segment.content[start_pos:end_pos]\n                    \n                    results.append((section, segment, match.start(), context))\n        \n        return results\n    \n    def _identify_potential_elements(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Identify potential narrative elements using NLP.\"\"\"\n        self._ensure_nlp_loaded()\n        \n        potential_elements = {\n            ElementType.CHARACTER.value: set(),\n            ElementType.LOCATION.value: set(),\n            ElementType.ITEM.value: set(),\n            ElementType.EVENT.value: set()\n        }\n        \n        # Process the document content\n        text = self.document.get_content()\n        doc = self._nlp(text)\n        \n        # Find named entities\n        for ent in doc.ents:\n            if ent.label_ in (\"PERSON\", \"PER\"):\n                potential_elements[ElementType.CHARACTER.value].add(ent.text)\n            elif ent.label_ in (\"GPE\", \"LOC\", \"FAC\"):\n                potential_elements[ElementType.LOCATION.value].add(ent.text)\n            elif ent.label_ in (\"EVENT\", \"WORK_OF_ART\"):\n                potential_elements[ElementType.EVENT.value].add(ent.text)\n            elif ent.label_ in (\"PRODUCT\", \"OBJECT\"):\n                potential_elements[ElementType.ITEM.value].add(ent.text)\n        \n        # Look for capitalized noun phrases that might be character names\n        for token in doc:\n            if token.is_alpha and token.is_title and token.pos_ == \"PROPN\":\n                # Get the full noun phrase if this is part of one\n                if token.head.pos_ == \"PROPN\":\n                    noun_phrase = \" \".join([t.text for t in token.head.subtree])\n                    potential_elements[ElementType.CHARACTER.value].add(noun_phrase)\n                else:\n                    potential_elements[ElementType.CHARACTER.value].add(token.text)\n        \n        # Convert sets to lists and count occurrences\n        results = {}\n        for element_type, elements in potential_elements.items():\n            results[element_type] = {}\n            for element in elements:\n                # Count occurrences\n                occurrences = len(re.findall(r'\\b' + re.escape(element) + r'\\b', text, re.IGNORECASE))\n                if occurrences > 0:\n                    results[element_type][element] = {\n                        \"occurrences\": occurrences,\n                        \"already_tracked\": element in [e.name for e in self.elements.values()]\n                    }\n        \n        return results\n    \n    def _detect_connections(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Detect connections between elements based on co-occurrence.\"\"\"\n        connections = {}\n        \n        # Iterate through all elements\n        for element_id, element in self.elements.items():\n            connections[element_id] = {}\n            \n            # Get all contexts where this element appears\n            contexts = [occurrence.context for occurrence in element.occurrences]\n            \n            # Check which other elements appear in the same contexts\n            for other_id, other_element in self.elements.items():\n                if other_id == element_id:\n                    continue\n                \n                co_occurrences = 0\n                for context in contexts:\n                    pattern = r'\\b(' + '|'.join(\n                        [re.escape(other_element.name)] + \n                        [re.escape(alias) for alias in other_element.aliases]\n                    ) + r')\\b'\n                    \n                    if re.search(pattern, context, re.IGNORECASE):\n                        co_occurrences += 1\n                \n                if co_occurrences > 0:\n                    # Calculate connection strength (0-1)\n                    strength = co_occurrences / len(contexts) if contexts else 0\n                    connections[element_id][other_id] = strength\n        \n        return connections\n    \n    def _detect_consistency_issues(self) -> List[ConsistencyIssue]:\n        \"\"\"Detect potential consistency issues in the narrative.\"\"\"\n        issues = []\n        \n        # Check for characters appearing in impossible timeframes/locations\n        character_locations = {}\n        \n        for element_id, element in self.elements.items():\n            if element.element_type != ElementType.CHARACTER:\n                continue\n            \n            # Track which sections each character appears in\n            character_locations[element_id] = set()\n            for occurrence in element.occurrences:\n                character_locations[element_id].add(occurrence.section_id)\n        \n        # Perform timeline analysis if we have section metadata with timeline info\n        timeline_sections = {}\n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections[section.id] = section.metadata[\"timeline\"]\n        \n        if timeline_sections:\n            # Check for characters appearing in non-sequential timeline points\n            for char_id, sections in character_locations.items():\n                char_timeline_sections = [s for s in sections if s in timeline_sections]\n                if len(char_timeline_sections) > 1:\n                    # Sort by timeline value\n                    sorted_sections = sorted(char_timeline_sections, key=lambda s: timeline_sections[s])\n                    \n                    # Check if any section is repeated out of order\n                    for i in range(len(sorted_sections) - 1):\n                        for j in range(i + 1, len(sorted_sections)):\n                            if sorted_sections[i] == sorted_sections[j]:\n                                # This character appears in the same timeline point multiple times\n                                # Not necessarily an issue, skip\n                                continue\n                            \n                            for k in range(j + 1, len(sorted_sections)):\n                                if sorted_sections[k] == sorted_sections[i]:\n                                    # Character appears at timeline point i, then j, then i again\n                                    # This could be a flashback, but flag it as a potential issue\n                                    issues.append(ConsistencyIssue(\n                                        id=str(len(issues) + 1),\n                                        issue_type=\"timeline\",\n                                        elements_involved=[char_id],\n                                        description=(\n                                            f\"Character appears in non-sequential timeline points: \"\n                                            f\"{timeline_sections[sorted_sections[i]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[j]]} -> \"\n                                            f\"{timeline_sections[sorted_sections[k]]}\"\n                                        ),\n                                        locations=[\n                                            (sorted_sections[i], \"\"),\n                                            (sorted_sections[j], \"\"),\n                                            (sorted_sections[k], \"\")\n                                        ],\n                                        severity=3\n                                    ))\n        \n        # Look for description inconsistencies by comparing contexts\n        for element_id, element in self.elements.items():\n            if len(element.occurrences) < 2:\n                continue\n            \n            # Extract descriptive contexts\n            descriptive_contexts = []\n            for occurrence in element.occurrences:\n                # Look for descriptions (X was Y, X had Y, etc.)\n                context = occurrence.context\n                element_pos = context.lower().find(element.name.lower())\n                \n                if element_pos >= 0:\n                    # Check text after the element name\n                    after_text = context[element_pos + len(element.name):]\n                    \n                    # Simple pattern matching for descriptions\n                    description_patterns = [\n                        r'\\s+was\\s+(\\w+)',\n                        r'\\s+had\\s+(\\w+)',\n                        r'\\s+with\\s+(\\w+)',\n                        r',\\s+a\\s+(\\w+)',\n                        r',\\s+the\\s+(\\w+)'\n                    ]\n                    \n                    for pattern in description_patterns:\n                        matches = re.finditer(pattern, after_text, re.IGNORECASE)\n                        for match in matches:\n                            descriptive_contexts.append((\n                                occurrence.section_id,\n                                occurrence.segment_id,\n                                match.group(1),\n                                context\n                            ))\n            \n            # Compare descriptions for contradictions\n            if len(descriptive_contexts) > 1:\n                # Very simple contradiction detection - could be improved\n                descriptions = {}\n                for section_id, segment_id, desc, context in descriptive_contexts:\n                    key = desc.lower()\n                    if key not in descriptions:\n                        descriptions[key] = []\n                    descriptions[key].append((section_id, segment_id, context))\n                \n                # Check for antonyms or contradictory descriptions\n                # This is a simplified approach and could be enhanced with a proper lexical database\n                common_antonym_pairs = [\n                    (\"tall\", \"short\"),\n                    (\"large\", \"small\"),\n                    (\"big\", \"little\"),\n                    (\"old\", \"young\"),\n                    (\"dark\", \"light\"),\n                    (\"black\", \"white\"),\n                    (\"angry\", \"calm\"),\n                    (\"happy\", \"sad\"),\n                    (\"rich\", \"poor\")\n                ]\n                \n                for word1, word2 in common_antonym_pairs:\n                    if word1 in descriptions and word2 in descriptions:\n                        # Possible contradiction found\n                        issues.append(ConsistencyIssue(\n                            id=str(len(issues) + 1),\n                            issue_type=\"contradiction\",\n                            elements_involved=[element_id],\n                            description=(\n                                f\"Possible contradictory descriptions: '{word1}' vs '{word2}'\"\n                            ),\n                            locations=[\n                                (descriptions[word1][0][0], descriptions[word1][0][1]),\n                                (descriptions[word2][0][0], descriptions[word2][0][1])\n                            ],\n                            severity=4\n                        ))\n        \n        return issues\n    \n    def track_element(\n        self,\n        name: str,\n        element_type: ElementType,\n        aliases: List[str] = None,\n        description: str = \"\",\n        metadata: Dict[str, Any] = None\n    ) -> NarrativeElement:\n        \"\"\"Track a narrative element by name and aliases.\"\"\"\n        element_id = f\"{element_type.value}_{len(self.elements) + 1}\"\n        \n        # Find occurrences\n        occurrences = []\n        for section, segment, position, context in self._find_element_occurrences(name, aliases):\n            occurrences.append(ElementOccurrence(\n                element_id=element_id,\n                section_id=section.id,\n                segment_id=segment.id,\n                position=position,\n                context=context\n            ))\n        \n        # Create the element\n        element = NarrativeElement(\n            id=element_id,\n            name=name,\n            element_type=element_type,\n            aliases=aliases or [],\n            description=description,\n            metadata=metadata or {},\n            occurrences=occurrences,\n            first_appearance=datetime.now() if occurrences else None,\n            last_appearance=datetime.now() if occurrences else None\n        )\n        \n        self.elements[element_id] = element\n        return element\n    \n    def detect_elements(self) -> Dict[str, List[NarrativeElement]]:\n        \"\"\"Automatically detect and track potential narrative elements.\"\"\"\n        potential_elements = self._identify_potential_elements()\n        \n        # Track elements by type\n        tracked_elements = {\n            ElementType.CHARACTER.value: [],\n            ElementType.LOCATION.value: [],\n            ElementType.ITEM.value: [],\n            ElementType.EVENT.value: []\n        }\n        \n        # Add elements that aren't already tracked\n        for element_type, elements in potential_elements.items():\n            for name, info in elements.items():\n                if not info[\"already_tracked\"] and info[\"occurrences\"] >= 2:\n                    # Only track elements that appear at least twice\n                    element = self.track_element(\n                        name=name,\n                        element_type=ElementType(element_type)\n                    )\n                    tracked_elements[element_type].append(element)\n        \n        # Update element relationships\n        self.update_element_relationships()\n        \n        # Detect consistency issues\n        self.check_consistency()\n        \n        return tracked_elements\n    \n    def update_element_relationships(self) -> None:\n        \"\"\"Update relationships between elements based on co-occurrence.\"\"\"\n        connections = self._detect_connections()\n        \n        # Update related_elements for each element\n        for element_id, related in connections.items():\n            if element_id in self.elements:\n                self.elements[element_id].related_elements = related\n    \n    def check_consistency(self) -> List[ConsistencyIssue]:\n        \"\"\"Check for consistency issues in the narrative.\"\"\"\n        self.consistency_issues = self._detect_consistency_issues()\n        return self.consistency_issues\n    \n    def get_element_appearances(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get detailed information about all appearances of an element.\"\"\"\n        if element_id not in self.elements:\n            return []\n        \n        element = self.elements[element_id]\n        appearances = []\n        \n        for occurrence in element.occurrences:\n            # Find the section and segment\n            section = None\n            segment = None\n            \n            for s in self.document.current_revision.sections:\n                if s.id == occurrence.section_id:\n                    section = s\n                    for seg in s.segments:\n                        if seg.id == occurrence.segment_id:\n                            segment = seg\n                            break\n                    break\n            \n            if section and segment:\n                appearances.append({\n                    \"section_title\": section.title,\n                    \"section_id\": section.id,\n                    \"segment_id\": segment.id,\n                    \"segment_position\": segment.position,\n                    \"context\": occurrence.context,\n                    \"mentioned_with\": [\n                        self.elements[e_id].name \n                        for e_id in occurrence.mentioned_with \n                        if e_id in self.elements\n                    ]\n                })\n        \n        return appearances\n    \n    def get_element_timeline(self, element_id: str) -> List[Dict[str, Any]]:\n        \"\"\"Get a timeline of an element's appearances ordered by position in the document.\"\"\"\n        appearances = self.get_element_appearances(element_id)\n        \n        # Group by section\n        sections = {}\n        for appearance in appearances:\n            section_id = appearance[\"section_id\"]\n            if section_id not in sections:\n                sections[section_id] = {\n                    \"section_title\": appearance[\"section_title\"],\n                    \"appearances\": []\n                }\n            sections[section_id][\"appearances\"].append(appearance)\n        \n        # Order sections by their position in the document\n        ordered_sections = []\n        for section in self.document.current_revision.sections:\n            if section.id in sections:\n                ordered_sections.append({\n                    \"section_id\": section.id,\n                    \"section_title\": sections[section.id][\"section_title\"],\n                    \"appearances\": sorted(\n                        sections[section.id][\"appearances\"],\n                        key=lambda a: a[\"segment_position\"]\n                    )\n                })\n        \n        return ordered_sections\n    \n    def resolve_consistency_issue(self, issue_id: str, notes: str = \"\") -> bool:\n        \"\"\"Mark a consistency issue as resolved with optional notes.\"\"\"\n        for issue in self.consistency_issues:\n            if issue.id == issue_id:\n                issue.resolved = True\n                issue.notes = notes\n                return True\n        return False\n    \n    def start_background_tracking(self, interval_seconds: int = 300) -> None:\n        \"\"\"Start tracking narrative elements in a background thread.\"\"\"\n        if self._background_thread and self._background_thread.is_alive():\n            return  # Already running\n        \n        self._stop_background_thread = False\n        \n        def tracking_task():\n            while not self._stop_background_thread:\n                try:\n                    self.detect_elements()\n                    self.update_element_relationships()\n                    self.check_consistency()\n                except Exception as e:\n                    print(f\"Error in background narrative tracking: {e}\")\n                \n                # Sleep for the specified interval\n                for _ in range(interval_seconds):\n                    if self._stop_background_thread:\n                        break\n                    time.sleep(1)\n        \n        self._background_thread = threading.Thread(target=tracking_task, daemon=True)\n        self._background_thread.start()\n    \n    def stop_background_tracking(self) -> None:\n        \"\"\"Stop the background tracking thread.\"\"\"\n        self._stop_background_thread = True\n        if self._background_thread:\n            self._background_thread.join(timeout=5)",
                "class ElementType(str, Enum):\n    \"\"\"Types of narrative elements.\"\"\"\n    \n    CHARACTER = \"character\"\n    LOCATION = \"location\"\n    ITEM = \"item\"\n    EVENT = \"event\"\n    TERM = \"term\"\n    CUSTOM = \"custom\"",
                "class DocumentNavigator:\n    \"\"\"Non-linear document navigation system.\"\"\"\n    \n    def __init__(self, document: Document, narrative_tracker: Optional[NarrativeTracker] = None):\n        \"\"\"Initialize the navigation system with the given document.\"\"\"\n        self.document = document\n        self.narrative_tracker = narrative_tracker\n        self.elements: Dict[str, NavigationElement] = {}\n        self.views: Dict[str, NavigationView] = {}\n        self.tags: Dict[str, NavigationTag] = {}\n        self.links: Dict[str, NavigationLink] = {}\n        self.current_position: Optional[NavigationPosition] = None\n        \n        # Initialize with default linear view\n        self._initialize_linear_view()\n    \n    def _initialize_linear_view(self) -> None:\n        \"\"\"Initialize the default linear view of the document.\"\"\"\n        # Create view\n        view_id = \"view_linear\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Linear View\",\n            view_type=NavigationViewType.LINEAR\n        )\n        \n        # Create elements for sections and segments\n        root_elements = []\n        \n        for section_idx, section in enumerate(self.document.current_revision.sections):\n            # Create element for the section\n            section_element_id = f\"element_section_{section.id}\"\n            section_element = NavigationElement(\n                id=section_element_id,\n                element_type=\"section\",\n                name=section.title,\n                original_id=section.id\n            )\n            \n            # Add to elements\n            self.elements[section_element_id] = section_element\n            root_elements.append(section_element_id)\n            \n            # Create elements for segments\n            for segment_idx, segment in enumerate(section.segments):\n                segment_element_id = f\"element_segment_{segment.id}\"\n                segment_element = NavigationElement(\n                    id=segment_element_id,\n                    element_type=\"segment\",\n                    name=f\"Paragraph {segment_idx + 1}\",\n                    original_id=segment.id\n                )\n                \n                # Add to elements\n                self.elements[segment_element_id] = segment_element\n                \n                # Add to section's children\n                section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        # Set current position to the first section if available\n        if root_elements:\n            self.current_position = NavigationPosition(\n                view_id=view_id,\n                element_id=root_elements[0]\n            )\n    \n    def _create_character_view(self) -> str:\n        \"\"\"Create a view organized by characters.\"\"\"\n        if not self.narrative_tracker:\n            return \"\"\n        \n        # Create view\n        view_id = \"view_character\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Character View\",\n            view_type=NavigationViewType.CHARACTER\n        )\n        \n        # Get character elements from the narrative tracker\n        character_elements = [\n            element for element in self.narrative_tracker.elements.values()\n            if element.element_type == ElementType.CHARACTER\n        ]\n        \n        # Create elements for each character\n        root_elements = []\n        \n        for character in character_elements:\n            # Create element for the character\n            character_element_id = f\"element_character_{character.id}\"\n            character_element = NavigationElement(\n                id=character_element_id,\n                element_type=\"character\",\n                name=character.name,\n                original_id=character.id,\n                metadata={\"description\": character.description}\n            )\n            \n            # Add to elements\n            self.elements[character_element_id] = character_element\n            root_elements.append(character_element_id)\n            \n            # Get appearances of this character\n            appearances = self.narrative_tracker.get_element_appearances(character.id)\n            \n            # Group by section\n            section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n            for appearance in appearances:\n                section_id = appearance[\"section_id\"]\n                if section_id not in section_appearances:\n                    section_appearances[section_id] = []\n                section_appearances[section_id].append(appearance)\n            \n            # Create elements for each section with appearances\n            for section_id, section_apps in section_appearances.items():\n                # Get the section\n                section = None\n                for s in self.document.current_revision.sections:\n                    if s.id == section_id:\n                        section = s\n                        break\n                \n                if not section:\n                    continue\n                \n                # Create element for the section\n                section_element_id = f\"element_character_section_{character.id}_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                \n                # Add to character's children\n                character_element.children.append(section_element_id)\n                \n                # Create elements for each appearance\n                for appearance in section_apps:\n                    segment_id = appearance[\"segment_id\"]\n                    \n                    # Get the segment\n                    segment = None\n                    for seg in section.segments:\n                        if seg.id == segment_id:\n                            segment = seg\n                            break\n                    \n                    if not segment:\n                        continue\n                    \n                    # Create element for the segment\n                    segment_element_id = f\"element_character_segment_{character.id}_{segment.id}\"\n                    \n                    # Skip if already added\n                    if segment_element_id in self.elements:\n                        continue\n                    \n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Appearance {len(section_element.children) + 1}\",\n                        original_id=segment.id,\n                        metadata={\"context\": appearance[\"context\"]}\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def _create_plot_view(self) -> str:\n        \"\"\"Create a view organized by plot elements.\"\"\"\n        # Create view\n        view_id = \"view_plot\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Plot View\",\n            view_type=NavigationViewType.PLOT\n        )\n        \n        # First, look for plot-related metadata in the document\n        plot_elements = []\n        \n        # Check for plot tags\n        plot_tags = [tag for tag in self.tags.values() if \"plot\" in tag.name.lower()]\n        \n        if plot_tags:\n            # Organize by plot tags\n            for tag in plot_tags:\n                # Create element for the tag\n                tag_element_id = f\"element_plot_tag_{tag.id}\"\n                tag_element = NavigationElement(\n                    id=tag_element_id,\n                    element_type=\"tag\",\n                    name=tag.name,\n                    original_id=tag.id\n                )\n                \n                # Add to elements\n                self.elements[tag_element_id] = tag_element\n                plot_elements.append(tag_element_id)\n                \n                # Find elements with this tag\n                for element_id, element in self.elements.items():\n                    if tag.id in element.tags:\n                        # Create a reference element\n                        ref_element_id = f\"element_plot_ref_{tag.id}_{element.id}\"\n                        ref_element = NavigationElement(\n                            id=ref_element_id,\n                            element_type=element.element_type,\n                            name=element.name,\n                            original_id=element.original_id\n                        )\n                        \n                        # Add to elements\n                        self.elements[ref_element_id] = ref_element\n                        \n                        # Add to tag's children\n                        tag_element.children.append(ref_element_id)\n        \n        # If we have a narrative tracker, use plot elements from there\n        elif self.narrative_tracker:\n            # Get plot elements from the narrative tracker\n            plot_narrative_elements = [\n                element for element in self.narrative_tracker.elements.values()\n                if element.element_type in (ElementType.EVENT, ElementType.ITEM, ElementType.TERM)\n            ]\n            \n            for plot_element in plot_narrative_elements:\n                # Create element for the plot element\n                plot_element_id = f\"element_plot_{plot_element.id}\"\n                plot_nav_element = NavigationElement(\n                    id=plot_element_id,\n                    element_type=\"plot\",\n                    name=plot_element.name,\n                    original_id=plot_element.id,\n                    metadata={\"description\": plot_element.description}\n                )\n                \n                # Add to elements\n                self.elements[plot_element_id] = plot_nav_element\n                plot_elements.append(plot_element_id)\n                \n                # Get appearances of this plot element\n                appearances = self.narrative_tracker.get_element_appearances(plot_element.id)\n                \n                # Group by section\n                section_appearances: Dict[str, List[Dict[str, Any]]] = {}\n                for appearance in appearances:\n                    section_id = appearance[\"section_id\"]\n                    if section_id not in section_appearances:\n                        section_appearances[section_id] = []\n                    section_appearances[section_id].append(appearance)\n                \n                # Create elements for each section with appearances\n                for section_id, section_apps in section_appearances.items():\n                    # Get the section\n                    section = None\n                    for s in self.document.current_revision.sections:\n                        if s.id == section_id:\n                            section = s\n                            break\n                    \n                    if not section:\n                        continue\n                    \n                    # Create element for the section\n                    section_element_id = f\"element_plot_section_{plot_element.id}_{section.id}\"\n                    section_element = NavigationElement(\n                        id=section_element_id,\n                        element_type=\"section\",\n                        name=section.title,\n                        original_id=section.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[section_element_id] = section_element\n                    \n                    # Add to plot element's children\n                    plot_nav_element.children.append(section_element_id)\n                    \n                    # Create elements for each appearance\n                    for appearance in section_apps:\n                        segment_id = appearance[\"segment_id\"]\n                        \n                        # Get the segment\n                        segment = None\n                        for seg in section.segments:\n                            if seg.id == segment_id:\n                                segment = seg\n                                break\n                        \n                        if not segment:\n                            continue\n                        \n                        # Create element for the segment\n                        segment_element_id = f\"element_plot_segment_{plot_element.id}_{segment.id}\"\n                        \n                        # Skip if already added\n                        if segment_element_id in self.elements:\n                            continue\n                        \n                        segment_element = NavigationElement(\n                            id=segment_element_id,\n                            element_type=\"segment\",\n                            name=f\"Reference {len(section_element.children) + 1}\",\n                            original_id=segment.id,\n                            metadata={\"context\": appearance[\"context\"]}\n                        )\n                        \n                        # Add to elements\n                        self.elements[segment_element_id] = segment_element\n                        \n                        # Add to section's children\n                        section_element.children.append(segment_element_id)\n        \n        # If we don't have plot tags or narrative tracker, create a dummy structure\n        if not plot_elements:\n            # Create a default \"plot\" element\n            plot_element_id = \"element_plot_default\"\n            plot_element = NavigationElement(\n                id=plot_element_id,\n                element_type=\"plot\",\n                name=\"Main Plot\"\n            )\n            \n            # Add to elements\n            self.elements[plot_element_id] = plot_element\n            plot_elements.append(plot_element_id)\n            \n            # Add all sections as children\n            for section in self.document.current_revision.sections:\n                # Create element for the section\n                section_element_id = f\"element_plot_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                \n                # Add to plot's children\n                plot_element.children.append(section_element_id)\n        \n        # Update view\n        view.root_elements = plot_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def _create_timeline_view(self) -> str:\n        \"\"\"Create a view organized by timeline/chronology.\"\"\"\n        # Create view\n        view_id = \"view_timeline\"\n        view = NavigationView(\n            id=view_id,\n            name=\"Timeline View\",\n            view_type=NavigationViewType.TIMELINE\n        )\n        \n        # Check for timeline metadata in sections\n        timeline_sections = []\n        \n        for section in self.document.current_revision.sections:\n            if \"timeline\" in section.metadata:\n                timeline_sections.append((section, section.metadata[\"timeline\"]))\n        \n        # If we have timeline metadata, use it to organize the view\n        if timeline_sections:\n            # Sort sections by timeline value\n            timeline_sections.sort(key=lambda x: x[1])\n            \n            # Create elements for each section in chronological order\n            root_elements = []\n            \n            for section, timeline in timeline_sections:\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=f\"{timeline}: {section.title}\",\n                    original_id=section.id,\n                    metadata={\"timeline\": timeline}\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n                \n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        else:\n            # Create a simple chronological view (same as linear)\n            root_elements = []\n            \n            for section_idx, section in enumerate(self.document.current_revision.sections):\n                # Create element for the section\n                section_element_id = f\"element_timeline_section_{section.id}\"\n                section_element = NavigationElement(\n                    id=section_element_id,\n                    element_type=\"section\",\n                    name=section.title,\n                    original_id=section.id,\n                    metadata={\"position\": section_idx}\n                )\n                \n                # Add to elements\n                self.elements[section_element_id] = section_element\n                root_elements.append(section_element_id)\n                \n                # Create elements for segments\n                for segment_idx, segment in enumerate(section.segments):\n                    segment_element_id = f\"element_timeline_segment_{segment.id}\"\n                    segment_element = NavigationElement(\n                        id=segment_element_id,\n                        element_type=\"segment\",\n                        name=f\"Paragraph {segment_idx + 1}\",\n                        original_id=segment.id\n                    )\n                    \n                    # Add to elements\n                    self.elements[segment_element_id] = segment_element\n                    \n                    # Add to section's children\n                    section_element.children.append(segment_element_id)\n        \n        # Update view\n        view.root_elements = root_elements\n        self.views[view_id] = view\n        \n        return view_id\n    \n    def create_view(self, name: str, view_type: NavigationViewType) -> str:\n        \"\"\"Create a new navigation view.\"\"\"\n        if view_type == NavigationViewType.CHARACTER:\n            return self._create_character_view()\n        elif view_type == NavigationViewType.PLOT:\n            return self._create_plot_view()\n        elif view_type == NavigationViewType.TIMELINE:\n            return self._create_timeline_view()\n        elif view_type == NavigationViewType.CUSTOM:\n            # Create a custom view\n            view_id = f\"view_custom_{len(self.views) + 1}\"\n            view = NavigationView(\n                id=view_id,\n                name=name,\n                view_type=view_type\n            )\n            \n            self.views[view_id] = view\n            return view_id\n        else:\n            # Linear view already exists\n            return \"view_linear\"\n    \n    def create_tag(self, name: str, color: str = \"#CCCCCC\") -> str:\n        \"\"\"Create a new tag for navigation elements.\"\"\"\n        tag_id = f\"tag_{len(self.tags) + 1}\"\n        tag = NavigationTag(\n            id=tag_id,\n            name=name,\n            color=color\n        )\n        \n        self.tags[tag_id] = tag\n        return tag_id\n    \n    def add_tag_to_element(self, element_id: str, tag_id: str) -> bool:\n        \"\"\"Add a tag to a navigation element.\"\"\"\n        if element_id not in self.elements or tag_id not in self.tags:\n            return False\n        \n        element = self.elements[element_id]\n        if tag_id not in element.tags:\n            element.tags.append(tag_id)\n        \n        return True\n    \n    def create_link(\n        self, \n        source_type: str, \n        source_id: str, \n        target_type: str, \n        target_id: str, \n        link_type: str\n    ) -> str:\n        \"\"\"Create a link between two navigation elements.\"\"\"\n        link_id = f\"link_{len(self.links) + 1}\"\n        link = NavigationLink(\n            id=link_id,\n            source_type=source_type,\n            source_id=source_id,\n            target_type=target_type,\n            target_id=target_id,\n            link_type=link_type\n        )\n        \n        self.links[link_id] = link\n        return link_id\n    \n    def add_element_to_view(self, view_id: str, element_id: str, parent_id: Optional[str] = None) -> bool:\n        \"\"\"Add an element to a view, optionally as a child of another element.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n        \n        view = self.views[view_id]\n        \n        if parent_id:\n            if parent_id not in self.elements:\n                return False\n            \n            parent = self.elements[parent_id]\n            if element_id not in parent.children:\n                parent.children.append(element_id)\n        else:\n            if element_id not in view.root_elements:\n                view.root_elements.append(element_id)\n        \n        return True\n    \n    def get_current_element(self) -> Optional[NavigationElement]:\n        \"\"\"Get the current navigation element.\"\"\"\n        if not self.current_position:\n            return None\n        \n        element_id = self.current_position.element_id\n        return self.elements.get(element_id)\n    \n    def get_element_content(self, element_id: str) -> Optional[str]:\n        \"\"\"Get the content of a navigation element.\"\"\"\n        if element_id not in self.elements:\n            return None\n        \n        element = self.elements[element_id]\n        original_id = element.original_id\n        \n        if not original_id:\n            return None\n        \n        if element.element_type == \"section\":\n            # Find the section\n            for section in self.document.current_revision.sections:\n                if section.id == original_id:\n                    return section.get_content()\n        \n        elif element.element_type == \"segment\":\n            # Find the segment\n            for section in self.document.current_revision.sections:\n                for segment in section.segments:\n                    if segment.id == original_id:\n                        return segment.content\n        \n        return None\n    \n    def navigate_to(self, view_id: str, element_id: str) -> bool:\n        \"\"\"Navigate to a specific element in a view.\"\"\"\n        if view_id not in self.views or element_id not in self.elements:\n            return False\n        \n        self.current_position = NavigationPosition(\n            view_id=view_id,\n            element_id=element_id\n        )\n        \n        return True\n    \n    def navigate_to_related(self, link_type: Optional[str] = None) -> List[NavigationElement]:\n        \"\"\"Navigate to elements related to the current element.\"\"\"\n        if not self.current_position:\n            return []\n        \n        current_element_id = self.current_position.element_id\n        \n        # Find links with this element as source\n        related_links = []\n        for link in self.links.values():\n            if link.source_id == current_element_id:\n                if not link_type or link.link_type == link_type:\n                    related_links.append(link)\n        \n        # Get related elements\n        related_elements = []\n        for link in related_links:\n            target_id = link.target_id\n            if target_id in self.elements:\n                related_elements.append(self.elements[target_id])\n        \n        return related_elements\n    \n    def navigate_parent(self) -> bool:\n        \"\"\"Navigate to the parent of the current element.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Find parent element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Navigate to parent\n            self.current_position = NavigationPosition(\n                view_id=view_id,\n                element_id=parent_id\n            )\n            return True\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Already at top level\n            return False\n        \n        return False\n    \n    def navigate_next(self) -> bool:\n        \"\"\"Navigate to the next element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Check if this element is a child of another element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n            \n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n                \n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(siblings):\n                    next_id = siblings[current_index + 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=next_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n                \n                # If there's a next sibling, navigate to it\n                if current_index + 1 < len(view.root_elements):\n                    next_id = view.root_elements[current_index + 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=next_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        return False\n    \n    def navigate_previous(self) -> bool:\n        \"\"\"Navigate to the previous element at the same level.\"\"\"\n        if not self.current_position:\n            return False\n        \n        current_element_id = self.current_position.element_id\n        view_id = self.current_position.view_id\n        \n        # Check if this element is a child of another element\n        parent_id = None\n        \n        for element_id, element in self.elements.items():\n            if current_element_id in element.children:\n                parent_id = element_id\n                break\n        \n        if parent_id:\n            # Get siblings\n            parent = self.elements[parent_id]\n            siblings = parent.children\n            \n            # Find current index\n            try:\n                current_index = siblings.index(current_element_id)\n                \n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = siblings[current_index - 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=prev_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        # Check if this is a root element in the view\n        view = self.views.get(view_id)\n        if view and current_element_id in view.root_elements:\n            # Find current index\n            try:\n                current_index = view.root_elements.index(current_element_id)\n                \n                # If there's a previous sibling, navigate to it\n                if current_index > 0:\n                    prev_id = view.root_elements[current_index - 1]\n                    self.current_position = NavigationPosition(\n                        view_id=view_id,\n                        element_id=prev_id\n                    )\n                    return True\n            except ValueError:\n                pass\n        \n        return False\n    \n    def navigate_children(self) -> List[NavigationElement]:\n        \"\"\"Get the children of the current element.\"\"\"\n        if not self.current_position:\n            return []\n        \n        current_element_id = self.current_position.element_id\n        \n        # Get element\n        element = self.elements.get(current_element_id)\n        if not element:\n            return []\n        \n        # Get children\n        children = []\n        for child_id in element.children:\n            if child_id in self.elements:\n                children.append(self.elements[child_id])\n        \n        return children\n    \n    def find_elements_by_tag(self, tag_id: str) -> List[NavigationElement]:\n        \"\"\"Find all elements with a specific tag.\"\"\"\n        if tag_id not in self.tags:\n            return []\n        \n        # Find elements with this tag\n        tagged_elements = []\n        for element_id, element in self.elements.items():\n            if tag_id in element.tags:\n                tagged_elements.append(element)\n        \n        return tagged_elements\n    \n    def find_elements_by_name(self, name: str) -> List[NavigationElement]:\n        \"\"\"Find elements by name (case-insensitive partial match).\"\"\"\n        name = name.lower()\n        \n        matching_elements = []\n        for element_id, element in self.elements.items():\n            if name in element.name.lower():\n                matching_elements.append(element)\n        \n        return matching_elements\n    \n    def get_path_to_element(self, element_id: str) -> List[str]:\n        \"\"\"Get the path from root to the specified element.\"\"\"\n        if element_id not in self.elements:\n            return []\n        \n        # Find view that contains this element\n        view_id = None\n        for view_id, view in self.views.items():\n            if element_id in view.root_elements:\n                break\n            \n            # Check if it's a descendant of any root element\n            for root_id in view.root_elements:\n                if self._is_descendant(root_id, element_id):\n                    view_id = view_id\n                    break\n            \n            if view_id:\n                break\n        \n        if not view_id:\n            return []\n        \n        # Find path\n        path = []\n        current_id = element_id\n        \n        while current_id:\n            path.insert(0, current_id)\n            \n            # Find parent\n            parent_id = None\n            for element_id, element in self.elements.items():\n                if current_id in element.children:\n                    parent_id = element_id\n                    break\n            \n            # If no parent, check if it's a root element\n            if not parent_id:\n                # If it's a root element, we've reached the top\n                if current_id in self.views[view_id].root_elements:\n                    break\n            \n            current_id = parent_id\n        \n        return path\n    \n    def _is_descendant(self, ancestor_id: str, descendant_id: str) -> bool:\n        \"\"\"Check if descendant_id is a descendant of ancestor_id.\"\"\"\n        if ancestor_id not in self.elements:\n            return False\n        \n        # Check direct children\n        ancestor = self.elements[ancestor_id]\n        if descendant_id in ancestor.children:\n            return True\n        \n        # Check descendants recursively\n        for child_id in ancestor.children:\n            if self._is_descendant(child_id, descendant_id):\n                return True\n        \n        return False",
                "class NavigationViewType(str, Enum):\n    \"\"\"Types of navigation views.\"\"\"\n    \n    LINEAR = \"linear\"  # Traditional linear document view\n    CHAPTER = \"chapter\"  # Organized by chapters/sections\n    CHARACTER = \"character\"  # Organized by character appearances\n    PLOT = \"plot\"  # Organized by plot elements/arcs\n    TIMELINE = \"timeline\"  # Organized by timeline/chronology\n    CUSTOM = \"custom\"",
                "class RevisionManager:\n    \"\"\"Revision management system.\"\"\"\n    \n    def __init__(self, document: Document):\n        \"\"\"Initialize the revision manager with the given document.\"\"\"\n        self.document = document\n        self.diffs: Dict[str, RevisionDiff] = {}\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        return self.document.create_revision(name=name, metadata=metadata)\n    \n    def compare_revisions(self, old_revision_name: str, new_revision_name: str) -> Optional[RevisionDiff]:\n        \"\"\"Compare two revisions and generate a diff.\"\"\"\n        old_revision = self.document.get_revision(old_revision_name)\n        new_revision = self.document.get_revision(new_revision_name)\n        \n        if not old_revision or not new_revision:\n            return None\n        \n        # Create a unique ID for this diff\n        diff_id = f\"{old_revision_name}_{new_revision_name}\"\n        \n        # Check if we already have this diff\n        if diff_id in self.diffs:\n            return self.diffs[diff_id]\n        \n        # Create a new diff\n        revision_diff = RevisionDiff(\n            old_revision_id=old_revision.id,\n            new_revision_id=new_revision.id,\n            old_revision_name=old_revision_name,\n            new_revision_name=new_revision_name\n        )\n        \n        # Compare sections\n        old_sections_by_id = {section.id: section for section in old_revision.sections}\n        new_sections_by_id = {section.id: section for section in new_revision.sections}\n        \n        # Find common section IDs\n        common_section_ids = set(old_sections_by_id.keys()) & set(new_sections_by_id.keys())\n        \n        # Find added and removed sections\n        added_section_ids = set(new_sections_by_id.keys()) - set(old_sections_by_id.keys())\n        removed_section_ids = set(old_sections_by_id.keys()) - set(new_sections_by_id.keys())\n        \n        # Process added sections\n        for section_id in added_section_ids:\n            section = new_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.INSERT,\n                section_id=section_id,\n                new_title=section.title\n            )\n            \n            # Add all segments as inserted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment.id,\n                    new_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            revision_diff.section_diffs.append(section_diff)\n        \n        # Process removed sections\n        for section_id in removed_section_ids:\n            section = old_sections_by_id[section_id]\n            section_diff = SectionDiff(\n                diff_type=DiffType.DELETE,\n                section_id=section_id,\n                old_title=section.title\n            )\n            \n            # Add all segments as deleted\n            for segment in section.segments:\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment.id,\n                    old_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            revision_diff.section_diffs.append(section_diff)\n        \n        # Process common sections\n        for section_id in common_section_ids:\n            old_section = old_sections_by_id[section_id]\n            new_section = new_sections_by_id[section_id]\n            \n            # Check if title changed\n            if old_section.title != new_section.title:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.REPLACE,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title\n                )\n            else:\n                section_diff = SectionDiff(\n                    diff_type=DiffType.EQUAL,\n                    section_id=section_id,\n                    old_title=old_section.title,\n                    new_title=new_section.title\n                )\n            \n            # Compare segments within the section\n            old_segments_by_id = {segment.id: segment for segment in old_section.segments}\n            new_segments_by_id = {segment.id: segment for segment in new_section.segments}\n            \n            # Find common segment IDs\n            common_segment_ids = set(old_segments_by_id.keys()) & set(new_segments_by_id.keys())\n            \n            # Find added and removed segments\n            added_segment_ids = set(new_segments_by_id.keys()) - set(old_segments_by_id.keys())\n            removed_segment_ids = set(old_segments_by_id.keys()) - set(new_segments_by_id.keys())\n            \n            # Process added segments\n            for segment_id in added_segment_ids:\n                segment = new_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.INSERT,\n                    segment_id=segment_id,\n                    new_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            # Process removed segments\n            for segment_id in removed_segment_ids:\n                segment = old_segments_by_id[segment_id]\n                segment_diff = SegmentDiff(\n                    diff_type=DiffType.DELETE,\n                    segment_id=segment_id,\n                    old_content=segment.content,\n                    position=segment.position\n                )\n                section_diff.segment_diffs.append(segment_diff)\n            \n            # Process common segments\n            for segment_id in common_segment_ids:\n                old_segment = old_segments_by_id[segment_id]\n                new_segment = new_segments_by_id[segment_id]\n                \n                # Check if content changed\n                if old_segment.content != new_segment.content:\n                    segment_diff = SegmentDiff(\n                        diff_type=DiffType.REPLACE,\n                        segment_id=segment_id,\n                        old_content=old_segment.content,\n                        new_content=new_segment.content,\n                        position=new_segment.position\n                    )\n                    section_diff.segment_diffs.append(segment_diff)\n            \n            # Only add section diff if there are changes\n            if section_diff.diff_type != DiffType.EQUAL or section_diff.segment_diffs:\n                revision_diff.section_diffs.append(section_diff)\n        \n        # Store and return the diff\n        self.diffs[diff_id] = revision_diff\n        return revision_diff\n    \n    def get_html_diff(self, old_content: str, new_content: str) -> str:\n        \"\"\"Generate an HTML diff of two texts.\"\"\"\n        differ = difflib.HtmlDiff()\n        return differ.make_file(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            context=True\n        )\n    \n    def get_unified_diff(self, old_content: str, new_content: str, context_lines: int = 3) -> str:\n        \"\"\"Generate a unified diff of two texts.\"\"\"\n        return \"\\n\".join(difflib.unified_diff(\n            old_content.splitlines(),\n            new_content.splitlines(),\n            \"Old Version\",\n            \"New Version\",\n            n=context_lines\n        ))\n    \n    def get_detailed_segment_diff(self, old_content: str, new_content: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate a detailed word-level diff of two segment contents.\"\"\"\n        # Split into words\n        old_words = old_content.split()\n        new_words = new_content.split()\n        \n        # Get opcodes\n        matcher = difflib.SequenceMatcher(None, old_words, new_words)\n        opcodes = matcher.get_opcodes()\n        \n        result = []\n        for tag, i1, i2, j1, j2 in opcodes:\n            if tag == 'equal':\n                result.append({\n                    'type': 'equal',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n            elif tag == 'replace':\n                result.append({\n                    'type': 'delete',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n                result.append({\n                    'type': 'insert',\n                    'content': ' '.join(new_words[j1:j2])\n                })\n            elif tag == 'delete':\n                result.append({\n                    'type': 'delete',\n                    'content': ' '.join(old_words[i1:i2])\n                })\n            elif tag == 'insert':\n                result.append({\n                    'type': 'insert',\n                    'content': ' '.join(new_words[j1:j2])\n                })\n        \n        return result\n    \n    def apply_diff(self, diff: RevisionDiff, target_revision_name: Optional[str] = None) -> Optional[Revision]:\n        \"\"\"Apply a diff to a revision to create a new revision.\"\"\"\n        # If target_revision_name is not provided, create a new revision\n        if not target_revision_name:\n            target_revision_name = f\"Merged_{diff.old_revision_name}_{diff.new_revision_name}\"\n        \n        # Create a new revision based on the old revision\n        old_revision = self.document.get_revision(diff.old_revision_name)\n        if not old_revision:\n            return None\n        \n        # Create a deep copy of the old revision\n        target_revision = self.create_revision(\n            name=target_revision_name,\n            metadata={\"merged_from\": [diff.old_revision_name, diff.new_revision_name]}\n        )\n        \n        # Apply section changes\n        for section_diff in diff.section_diffs:\n            section_id = section_diff.section_id\n            \n            if section_diff.diff_type == DiffType.INSERT:\n                # Add new section\n                new_section = Section(\n                    id=section_id,\n                    title=section_diff.new_title or \"\",\n                    segments=[]\n                )\n                \n                # Add segment diffs\n                for segment_diff in section_diff.segment_diffs:\n                    if segment_diff.diff_type == DiffType.INSERT:\n                        segment = TextSegment(\n                            id=segment_diff.segment_id or \"\",\n                            content=segment_diff.new_content or \"\",\n                            position=segment_diff.position or 0\n                        )\n                        new_section.segments.append(segment)\n                \n                # Add to target revision\n                target_revision.sections.append(new_section)\n            \n            elif section_diff.diff_type == DiffType.DELETE:\n                # Remove section\n                for i, section in enumerate(target_revision.sections):\n                    if section.id == section_id:\n                        target_revision.sections.pop(i)\n                        break\n            \n            elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                # Update section title if it changed\n                for section in target_revision.sections:\n                    if section.id == section_id:\n                        if section_diff.new_title:\n                            section.title = section_diff.new_title\n                        \n                        # Process segment changes\n                        for segment_diff in section_diff.segment_diffs:\n                            segment_id = segment_diff.segment_id\n                            \n                            if segment_diff.diff_type == DiffType.INSERT:\n                                # Add new segment\n                                segment = TextSegment(\n                                    id=segment_id or \"\",\n                                    content=segment_diff.new_content or \"\",\n                                    position=segment_diff.position or 0\n                                )\n                                \n                                # Insert at the right position\n                                if segment_diff.position is not None:\n                                    if segment_diff.position < len(section.segments):\n                                        section.segments.insert(segment_diff.position, segment)\n                                    else:\n                                        section.segments.append(segment)\n                                else:\n                                    section.segments.append(segment)\n                                \n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n                            \n                            elif segment_diff.diff_type == DiffType.DELETE:\n                                # Remove segment\n                                for i, segment in enumerate(section.segments):\n                                    if segment.id == segment_id:\n                                        section.segments.pop(i)\n                                        break\n                                \n                                # Update positions\n                                for i, seg in enumerate(section.segments):\n                                    seg.position = i\n                            \n                            elif segment_diff.diff_type == DiffType.REPLACE:\n                                # Update segment content\n                                for segment in section.segments:\n                                    if segment.id == segment_id and segment_diff.new_content:\n                                        segment.content = segment_diff.new_content\n                                        break\n                        \n                        break\n        \n        # Update document's current revision\n        self.document.current_revision = target_revision\n        \n        return target_revision\n    \n    def merge_revisions(\n        self, \n        base_revision_name: str, \n        revision_names: List[str], \n        merge_strategy: Dict[str, str] = None\n    ) -> Optional[Revision]:\n        \"\"\"Merge multiple revisions into a new revision.\"\"\"\n        # Get base revision\n        base_revision = self.document.get_revision(base_revision_name)\n        if not base_revision:\n            return None\n        \n        # Create a new revision based on the base revision\n        merged_revision_name = f\"Merged_{base_revision_name}_{'_'.join(revision_names)}\"\n        merged_revision = self.create_revision(\n            name=merged_revision_name,\n            metadata={\"merged_from\": [base_revision_name] + revision_names}\n        )\n        \n        # Default merge strategy: last writer wins\n        if not merge_strategy:\n            merge_strategy = {}\n        \n        # Apply diffs from each revision\n        for revision_name in revision_names:\n            # Compare with base revision\n            diff = self.compare_revisions(base_revision_name, revision_name)\n            if not diff:\n                continue\n            \n            # Apply changes\n            for section_diff in diff.section_diffs:\n                section_id = section_diff.section_id\n                \n                # Check merge strategy for this section\n                section_strategy = merge_strategy.get(section_id, \"last_writer_wins\")\n                \n                if section_strategy == \"ignore\":\n                    # Skip this section\n                    continue\n                \n                if section_diff.diff_type == DiffType.INSERT:\n                    # Add new section\n                    new_section = Section(\n                        id=section_id,\n                        title=section_diff.new_title or \"\",\n                        segments=[]\n                    )\n                    \n                    # Add segment diffs\n                    for segment_diff in section_diff.segment_diffs:\n                        if segment_diff.diff_type == DiffType.INSERT:\n                            segment = TextSegment(\n                                id=segment_diff.segment_id or \"\",\n                                content=segment_diff.new_content or \"\",\n                                position=segment_diff.position or 0\n                            )\n                            new_section.segments.append(segment)\n                    \n                    # Add to merged revision\n                    merged_revision.sections.append(new_section)\n                \n                elif section_diff.diff_type == DiffType.DELETE:\n                    if section_strategy == \"last_writer_wins\":\n                        # Remove section\n                        for i, section in enumerate(merged_revision.sections):\n                            if section.id == section_id:\n                                merged_revision.sections.pop(i)\n                                break\n                \n                elif section_diff.diff_type in (DiffType.REPLACE, DiffType.EQUAL):\n                    # Update section title if it changed\n                    for section in merged_revision.sections:\n                        if section.id == section_id:\n                            if section_diff.new_title and section_strategy == \"last_writer_wins\":\n                                section.title = section_diff.new_title\n                            \n                            # Process segment changes\n                            for segment_diff in section_diff.segment_diffs:\n                                segment_id = segment_diff.segment_id\n                                \n                                # Check merge strategy for this segment\n                                segment_strategy = merge_strategy.get(f\"{section_id}_{segment_id}\", section_strategy)\n                                \n                                if segment_strategy == \"ignore\":\n                                    # Skip this segment\n                                    continue\n                                \n                                if segment_diff.diff_type == DiffType.INSERT:\n                                    # Add new segment\n                                    segment = TextSegment(\n                                        id=segment_id or \"\",\n                                        content=segment_diff.new_content or \"\",\n                                        position=segment_diff.position or 0\n                                    )\n                                    \n                                    # Insert at the right position\n                                    if segment_diff.position is not None:\n                                        if segment_diff.position < len(section.segments):\n                                            section.segments.insert(segment_diff.position, segment)\n                                        else:\n                                            section.segments.append(segment)\n                                    else:\n                                        section.segments.append(segment)\n                                    \n                                    # Update positions\n                                    for i, seg in enumerate(section.segments):\n                                        seg.position = i\n                                \n                                elif segment_diff.diff_type == DiffType.DELETE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Remove segment\n                                        for i, segment in enumerate(section.segments):\n                                            if segment.id == segment_id:\n                                                section.segments.pop(i)\n                                                break\n                                        \n                                        # Update positions\n                                        for i, seg in enumerate(section.segments):\n                                            seg.position = i\n                                \n                                elif segment_diff.diff_type == DiffType.REPLACE:\n                                    if segment_strategy == \"last_writer_wins\":\n                                        # Update segment content\n                                        for segment in section.segments:\n                                            if segment.id == segment_id and segment_diff.new_content:\n                                                segment.content = segment_diff.new_content\n                                                break\n                            \n                            break\n        \n        # Update document's current revision\n        self.document.current_revision = merged_revision\n        \n        return merged_revision\n    \n    def export_revision_history(self) -> Dict[str, Any]:\n        \"\"\"Export the revision history as a structured dictionary.\"\"\"\n        history = {\n            \"current_revision\": self.document.current_revision.name,\n            \"revisions\": {}\n        }\n        \n        for name, revision in self.document.revisions.items():\n            history[\"revisions\"][name] = {\n                \"id\": revision.id,\n                \"timestamp\": revision.timestamp.isoformat(),\n                \"metadata\": revision.metadata,\n                \"section_count\": len(revision.sections),\n                \"word_count\": sum(\n                    sum(segment.get_word_count() for segment in section.segments)\n                    for section in revision.sections\n                )\n            }\n        \n        return history\n    \n    def get_revision_by_timestamp(self, timestamp: datetime) -> Optional[Revision]:\n        \"\"\"Get the revision closest to the specified timestamp.\"\"\"\n        closest_revision = None\n        min_diff = None\n        \n        for revision in self.document.revisions.values():\n            diff = abs((revision.timestamp - timestamp).total_seconds())\n            \n            if min_diff is None or diff < min_diff:\n                min_diff = diff\n                closest_revision = revision\n        \n        return closest_revision"
            ]
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/revision.py": {
        "logprobs": -1358.4568216574214,
        "metrics": {
            "loc": 560,
            "sloc": 382,
            "lloc": 308,
            "comments": 63,
            "multi": 0,
            "blank": 99,
            "cyclomatic": 130,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))",
                "class Revision(BaseModel):\n    \"\"\"A revision of a document.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n    sections: List[Section] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)"
            ]
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/document.py": {
        "logprobs": -626.8838140128579,
        "metrics": {
            "loc": 194,
            "sloc": 133,
            "lloc": 166,
            "comments": 2,
            "multi": 0,
            "blank": 35,
            "cyclomatic": 48,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/tests/conftest.py": {
        "logprobs": -612.6367394454267,
        "metrics": {
            "loc": 62,
            "sloc": 41,
            "lloc": 40,
            "comments": 6,
            "multi": 0,
            "blank": 12,
            "cyclomatic": 3,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/study/__init__.py": {
        "logprobs": -199.41026139277997,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/core/history.py": {
        "logprobs": -507.41162418917366,
        "metrics": {
            "loc": 161,
            "sloc": 72,
            "lloc": 72,
            "comments": 5,
            "multi": 60,
            "blank": 27,
            "cyclomatic": 15,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/core/editor.py": {
        "logprobs": -1138.7696246677049,
        "metrics": {
            "loc": 348,
            "sloc": 186,
            "lloc": 183,
            "comments": 14,
            "multi": 96,
            "blank": 48,
            "cyclomatic": 51,
            "internal_imports": [
                "class TextBuffer(BaseModel):\n    \"\"\"\n    A text buffer that stores the content of a file as a list of lines.\n    \n    This is the core data structure for the text editor, handling storage,\n    insertion, deletion, and retrieval of text.\n    \"\"\"\n    lines: List[str] = []\n    \n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new text buffer with the given content.\n        \n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__()\n        self.lines = content.split(\"\\n\") if content else [\"\"]\n    \n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the buffer as a string.\n        \n        Returns:\n            The content of the buffer as a string with lines joined by newlines\n        \"\"\"\n        return \"\\n\".join(self.lines)\n    \n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n        \n        Args:\n            line_number: The line number to retrieve (0-indexed)\n            \n        Returns:\n            The requested line as a string\n            \n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        if 0 <= line_number < len(self.lines):\n            return self.lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n    \n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n        \n        Returns:\n            The number of lines in the buffer\n        \"\"\"\n        return len(self.lines)\n    \n    def insert_text(self, line: int, column: int, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position in the buffer.\n        \n        Args:\n            line: Line number where text should be inserted (0-indexed)\n            column: Column number where text should be inserted (0-indexed)\n            text: The text to insert\n            \n        Raises:\n            IndexError: If the line or column is out of range\n        \"\"\"\n        # Ensure line is valid\n        if not (0 <= line < len(self.lines)):\n            raise IndexError(f\"Line number {line} out of range\")\n        \n        # Ensure column is valid\n        current_line = self.lines[line]\n        if not (0 <= column <= len(current_line)):\n            raise IndexError(f\"Column number {column} out of range for line {line}\")\n        \n        # Handle multi-line insertion\n        if \"\\n\" in text:\n            # Split the text into lines\n            new_lines = text.split(\"\\n\")\n            \n            # Handle the first line (insert at the current position)\n            first_part = current_line[:column]\n            last_part = current_line[column:]\n            \n            # Create the new set of lines\n            new_content = [first_part + new_lines[0]]\n            new_content.extend(new_lines[1:-1])\n            new_content.append(new_lines[-1] + last_part)\n            \n            # Update the buffer\n            self.lines[line:line+1] = new_content\n        else:\n            # Simple single-line insertion\n            new_line = current_line[:column] + text + current_line[column:]\n            self.lines[line] = new_line\n    \n    def delete_text(self, start_line: int, start_col: int, \n                   end_line: int, end_col: int) -> str:\n        \"\"\"\n        Delete text between the specified positions and return the deleted text.\n        \n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            \n        Returns:\n            The deleted text\n            \n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n        \n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise IndexError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise IndexError(f\"End line {end_line} out of range\")\n        \n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n        \n        if not (0 <= start_col <= len(start_line_text)):\n            raise IndexError(f\"Start column {start_col} out of range for line {start_line}\")\n        if not (0 <= end_col <= len(end_line_text)):\n            raise IndexError(f\"End column {end_col} out of range for line {end_line}\")\n        \n        # Handle deletion within a single line\n        if start_line == end_line:\n            deleted_text = start_line_text[start_col:end_col]\n            self.lines[start_line] = start_line_text[:start_col] + start_line_text[end_col:]\n            return deleted_text\n        \n        # Handle multi-line deletion\n        deleted_lines = []\n        \n        # Get the first partial line\n        deleted_lines.append(start_line_text[start_col:])\n        \n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            deleted_lines.extend(self.lines[start_line+1:end_line])\n        \n        # Get the last partial line\n        deleted_lines.append(end_line_text[:end_col])\n        \n        # Join the deleted text\n        deleted_text = \"\\n\".join(deleted_lines)\n        \n        # Update the buffer\n        new_line = start_line_text[:start_col] + end_line_text[end_col:]\n        self.lines[start_line:end_line+1] = [new_line]\n        \n        return deleted_text\n        \n    def replace_text(self, start_line: int, start_col: int,\n                    end_line: int, end_col: int, new_text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n        \n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n            \n        Returns:\n            The replaced text\n            \n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        # Delete the text first and get what was deleted\n        deleted_text = self.delete_text(start_line, start_col, end_line, end_col)\n        \n        # Insert the new text\n        self.insert_text(start_line, start_col, new_text)\n        \n        return deleted_text\n    \n    def clear(self) -> None:\n        \"\"\"Clear the buffer, removing all content.\"\"\"\n        self.lines = [\"\"]",
                "class Cursor(BaseModel):\n    \"\"\"\n    Represents a cursor position within a text buffer.\n    \n    The cursor tracks the current position in the buffer and provides methods\n    for moving the cursor and ensuring it remains within valid bounds.\n    \"\"\"\n    line: int = 0\n    column: int = 0\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n    \n    def move_to(self, line: int, column: int) -> None:\n        \"\"\"\n        Move the cursor to the specified position.\n        \n        Args:\n            line: Target line number (0-indexed)\n            column: Target column number (0-indexed)\n            \n        Raises:\n            IndexError: If the position is invalid\n        \"\"\"\n        # Check if line is valid\n        if not (0 <= line < self.buffer.get_line_count()):\n            raise IndexError(f\"Line number {line} out of range\")\n        \n        # Check if column is valid\n        line_length = len(self.buffer.get_line(line))\n        if not (0 <= column <= line_length):\n            raise IndexError(f\"Column number {column} out of range for line {line}\")\n        \n        self.line = line\n        self.column = column\n    \n    def get_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n        \n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return (self.line, self.column)\n    \n    def move_up(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor up by the specified number of lines.\n        \n        Args:\n            count: Number of lines to move up (default: 1)\n        \"\"\"\n        target_line = max(0, self.line - count)\n        # Ensure column is valid in the new line\n        target_column = min(self.column, len(self.buffer.get_line(target_line)))\n        self.move_to(target_line, target_column)\n    \n    def move_down(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor down by the specified number of lines.\n        \n        Args:\n            count: Number of lines to move down (default: 1)\n        \"\"\"\n        target_line = min(self.buffer.get_line_count() - 1, self.line + count)\n        # Ensure column is valid in the new line\n        target_column = min(self.column, len(self.buffer.get_line(target_line)))\n        self.move_to(target_line, target_column)\n    \n    def move_left(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor left by the specified number of characters.\n        \n        If the cursor is at the beginning of a line, it will move to the\n        end of the previous line.\n        \n        Args:\n            count: Number of characters to move left (default: 1)\n        \"\"\"\n        remaining_moves = count\n        \n        while remaining_moves > 0:\n            if self.column > 0:\n                # We can move left within the current line\n                move_amount = min(remaining_moves, self.column)\n                self.column -= move_amount\n                remaining_moves -= move_amount\n            elif self.line > 0:\n                # Move to the end of the previous line\n                self.line -= 1\n                self.column = len(self.buffer.get_line(self.line))\n                remaining_moves -= 1\n            else:\n                # Already at the start of the buffer\n                break\n    \n    def move_right(self, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor right by the specified number of characters.\n        \n        If the cursor is at the end of a line, it will move to the\n        beginning of the next line.\n        \n        Args:\n            count: Number of characters to move right (default: 1)\n        \"\"\"\n        remaining_moves = count\n        \n        while remaining_moves > 0:\n            current_line_length = len(self.buffer.get_line(self.line))\n            \n            if self.column < current_line_length:\n                # We can move right within the current line\n                move_amount = min(remaining_moves, current_line_length - self.column)\n                self.column += move_amount\n                remaining_moves -= move_amount\n            elif self.line < self.buffer.get_line_count() - 1:\n                # Move to the beginning of the next line\n                self.line += 1\n                self.column = 0\n                remaining_moves -= 1\n            else:\n                # Already at the end of the buffer\n                break\n    \n    def move_to_line_start(self) -> None:\n        \"\"\"Move the cursor to the start of the current line.\"\"\"\n        self.column = 0\n    \n    def move_to_line_end(self) -> None:\n        \"\"\"Move the cursor to the end of the current line.\"\"\"\n        self.column = len(self.buffer.get_line(self.line))\n    \n    def move_to_buffer_start(self) -> None:\n        \"\"\"Move the cursor to the start of the buffer.\"\"\"\n        self.line = 0\n        self.column = 0\n    \n    def move_to_buffer_end(self) -> None:\n        \"\"\"Move the cursor to the end of the buffer.\"\"\"\n        self.line = self.buffer.get_line_count() - 1\n        self.column = len(self.buffer.get_line(self.line))",
                "class FileManager(BaseModel):\n    \"\"\"\n    Manages file operations for the text editor.\n    \n    This class provides functionality for loading from and saving to files,\n    tracking file state, and handling file-related operations.\n    \"\"\"\n    current_path: Optional[str] = None\n    last_saved_time: Optional[float] = None\n    \n    def load_file(self, file_path: str) -> str:\n        \"\"\"\n        Load content from a file.\n        \n        Args:\n            file_path: Path to the file to load\n            \n        Returns:\n            The file content as a string\n            \n        Raises:\n            FileNotFoundError: If the file does not exist\n            PermissionError: If the file cannot be read\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            \n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n            \n            # Calculate loading time for performance metrics\n            load_time_ms = (time.time() - start_time) * 1000\n            return content\n            \n        except UnicodeDecodeError:\n            # Try with latin-1 encoding as a fallback\n            with open(file_path, 'r', encoding='latin-1') as f:\n                content = f.read()\n            \n            self.current_path = file_path\n            self.last_saved_time = os.path.getmtime(file_path)\n            \n            return content\n    \n    def save_file(self, content: str, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n        \n        Args:\n            content: The content to save\n            file_path: Path to save to (if None, uses current_path)\n            \n        Raises:\n            ValueError: If no file path is provided and no current path is set\n            PermissionError: If the file cannot be written\n        \"\"\"\n        start_time = time.time()\n        \n        # Use the provided path or the current path\n        path = file_path or self.current_path\n        \n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n        \n        with open(path, 'w', encoding='utf-8') as f:\n            f.write(content)\n        \n        self.current_path = path\n        self.last_saved_time = time.time()\n        \n        # Calculate saving time for performance metrics\n        save_time_ms = (time.time() - start_time) * 1000\n    \n    def is_file_modified(self, file_path: Optional[str] = None) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n        \n        Args:\n            file_path: Path to check (if None, uses current_path)\n            \n        Returns:\n            True if the file has been modified, False otherwise\n            \n        Raises:\n            ValueError: If no file path is provided and no current path is set\n        \"\"\"\n        path = file_path or self.current_path\n        \n        if not path:\n            raise ValueError(\"No file path provided and no current path set\")\n        \n        if not os.path.exists(path):\n            return True\n        \n        if not self.last_saved_time:\n            return True\n        \n        return os.path.getmtime(path) > self.last_saved_time\n    \n    def get_current_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n        \n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.current_path",
                "class History(BaseModel):\n    \"\"\"\n    Manages the history of editing operations for undo/redo functionality.\n    \"\"\"\n    undo_stack: List[EditOperation] = Field(default_factory=list)\n    redo_stack: List[EditOperation] = Field(default_factory=list)\n    max_history_size: int = 1000\n    \n    def record_insert(self, line: int, col: int, text: str) -> None:\n        \"\"\"\n        Record an insert operation.\n        \n        Args:\n            line: Line where text was inserted\n            col: Column where text was inserted\n            text: Text that was inserted\n        \"\"\"\n        operation = EditOperation(\n            type=\"insert\",\n            start_line=line,\n            start_col=col,\n            text=text\n        )\n        \n        self._add_to_undo_stack(operation)\n    \n    def record_delete(self, start_line: int, start_col: int, \n                     end_line: int, end_col: int, deleted_text: str) -> None:\n        \"\"\"\n        Record a delete operation.\n        \n        Args:\n            start_line: Starting line of deleted text\n            start_col: Starting column of deleted text\n            end_line: Ending line of deleted text\n            end_col: Ending column of deleted text\n            deleted_text: The text that was deleted\n        \"\"\"\n        operation = EditOperation(\n            type=\"delete\",\n            start_line=start_line,\n            start_col=start_col,\n            end_line=end_line,\n            end_col=end_col,\n            deleted_text=deleted_text\n        )\n        \n        self._add_to_undo_stack(operation)\n    \n    def record_replace(self, start_line: int, start_col: int,\n                      end_line: int, end_col: int, \n                      new_text: str, deleted_text: str) -> None:\n        \"\"\"\n        Record a replace operation.\n        \n        Args:\n            start_line: Starting line of replaced text\n            start_col: Starting column of replaced text\n            end_line: Ending line of replaced text\n            end_col: Ending column of replaced text\n            new_text: The text that was inserted\n            deleted_text: The text that was deleted\n        \"\"\"\n        operation = EditOperation(\n            type=\"replace\",\n            start_line=start_line,\n            start_col=start_col,\n            end_line=end_line,\n            end_col=end_col,\n            text=new_text,\n            deleted_text=deleted_text\n        )\n        \n        self._add_to_undo_stack(operation)\n    \n    def _add_to_undo_stack(self, operation: EditOperation) -> None:\n        \"\"\"\n        Add an operation to the undo stack and clear the redo stack.\n        \n        Args:\n            operation: The operation to add\n        \"\"\"\n        self.undo_stack.append(operation)\n        self.redo_stack = []  # Clear redo stack when a new edit is made\n        \n        # Limit history size\n        if len(self.undo_stack) > self.max_history_size:\n            self.undo_stack.pop(0)\n    \n    def can_undo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be undone.\n        \n        Returns:\n            True if undo is possible, False otherwise\n        \"\"\"\n        return len(self.undo_stack) > 0\n    \n    def can_redo(self) -> bool:\n        \"\"\"\n        Check if there are operations that can be redone.\n        \n        Returns:\n            True if redo is possible, False otherwise\n        \"\"\"\n        return len(self.redo_stack) > 0\n    \n    def undo(self) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last operation for undoing.\n        \n        Returns:\n            The operation to undo, or None if there are no operations to undo\n        \"\"\"\n        if not self.can_undo():\n            return None\n        \n        operation = self.undo_stack.pop()\n        self.redo_stack.append(operation)\n        return operation\n    \n    def redo(self) -> Optional[EditOperation]:\n        \"\"\"\n        Get the last undone operation for redoing.\n        \n        Returns:\n            The operation to redo, or None if there are no operations to redo\n        \"\"\"\n        if not self.can_redo():\n            return None\n        \n        operation = self.redo_stack.pop()\n        self.undo_stack.append(operation)\n        return operation\n    \n    def clear(self) -> None:\n        \"\"\"Clear all history.\"\"\"\n        self.undo_stack = []\n        self.redo_stack = []",
                "class EditOperation(BaseModel):\n    \"\"\"\n    Represents an editing operation that can be undone or redone.\n    \"\"\"\n    type: str  # \"insert\", \"delete\", \"replace\"\n    start_line: int\n    start_col: int\n    end_line: Optional[int] = None\n    end_col: Optional[int] = None\n    text: str = \"\"  # For insert and replace, this is the text that was inserted\n    deleted_text: str = \"\"  # For delete and replace, this is the text that was deleted\n    timestamp: float = Field(default_factory=time.time)"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/core/cursor.py": {
        "logprobs": -504.57304488517394,
        "metrics": {
            "loc": 149,
            "sloc": 62,
            "lloc": 77,
            "comments": 10,
            "multi": 45,
            "blank": 28,
            "cyclomatic": 20,
            "internal_imports": [
                "class TextBuffer(BaseModel):\n    \"\"\"\n    A text buffer that stores the content of a file as a list of lines.\n    \n    This is the core data structure for the text editor, handling storage,\n    insertion, deletion, and retrieval of text.\n    \"\"\"\n    lines: List[str] = []\n    \n    def __init__(self, content: str = \"\"):\n        \"\"\"\n        Initialize a new text buffer with the given content.\n        \n        Args:\n            content: Initial text content (defaults to empty string)\n        \"\"\"\n        super().__init__()\n        self.lines = content.split(\"\\n\") if content else [\"\"]\n    \n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the buffer as a string.\n        \n        Returns:\n            The content of the buffer as a string with lines joined by newlines\n        \"\"\"\n        return \"\\n\".join(self.lines)\n    \n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n        \n        Args:\n            line_number: The line number to retrieve (0-indexed)\n            \n        Returns:\n            The requested line as a string\n            \n        Raises:\n            IndexError: If the line number is out of range\n        \"\"\"\n        if 0 <= line_number < len(self.lines):\n            return self.lines[line_number]\n        raise IndexError(f\"Line number {line_number} out of range\")\n    \n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n        \n        Returns:\n            The number of lines in the buffer\n        \"\"\"\n        return len(self.lines)\n    \n    def insert_text(self, line: int, column: int, text: str) -> None:\n        \"\"\"\n        Insert text at the specified position in the buffer.\n        \n        Args:\n            line: Line number where text should be inserted (0-indexed)\n            column: Column number where text should be inserted (0-indexed)\n            text: The text to insert\n            \n        Raises:\n            IndexError: If the line or column is out of range\n        \"\"\"\n        # Ensure line is valid\n        if not (0 <= line < len(self.lines)):\n            raise IndexError(f\"Line number {line} out of range\")\n        \n        # Ensure column is valid\n        current_line = self.lines[line]\n        if not (0 <= column <= len(current_line)):\n            raise IndexError(f\"Column number {column} out of range for line {line}\")\n        \n        # Handle multi-line insertion\n        if \"\\n\" in text:\n            # Split the text into lines\n            new_lines = text.split(\"\\n\")\n            \n            # Handle the first line (insert at the current position)\n            first_part = current_line[:column]\n            last_part = current_line[column:]\n            \n            # Create the new set of lines\n            new_content = [first_part + new_lines[0]]\n            new_content.extend(new_lines[1:-1])\n            new_content.append(new_lines[-1] + last_part)\n            \n            # Update the buffer\n            self.lines[line:line+1] = new_content\n        else:\n            # Simple single-line insertion\n            new_line = current_line[:column] + text + current_line[column:]\n            self.lines[line] = new_line\n    \n    def delete_text(self, start_line: int, start_col: int, \n                   end_line: int, end_col: int) -> str:\n        \"\"\"\n        Delete text between the specified positions and return the deleted text.\n        \n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            \n        Returns:\n            The deleted text\n            \n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        # Validate positions\n        if start_line > end_line or (start_line == end_line and start_col > end_col):\n            raise ValueError(\"End position must come after start position\")\n        \n        # Ensure positions are within range\n        if not (0 <= start_line < len(self.lines)):\n            raise IndexError(f\"Start line {start_line} out of range\")\n        if not (0 <= end_line < len(self.lines)):\n            raise IndexError(f\"End line {end_line} out of range\")\n        \n        start_line_text = self.lines[start_line]\n        end_line_text = self.lines[end_line]\n        \n        if not (0 <= start_col <= len(start_line_text)):\n            raise IndexError(f\"Start column {start_col} out of range for line {start_line}\")\n        if not (0 <= end_col <= len(end_line_text)):\n            raise IndexError(f\"End column {end_col} out of range for line {end_line}\")\n        \n        # Handle deletion within a single line\n        if start_line == end_line:\n            deleted_text = start_line_text[start_col:end_col]\n            self.lines[start_line] = start_line_text[:start_col] + start_line_text[end_col:]\n            return deleted_text\n        \n        # Handle multi-line deletion\n        deleted_lines = []\n        \n        # Get the first partial line\n        deleted_lines.append(start_line_text[start_col:])\n        \n        # Get any full lines in the middle\n        if end_line - start_line > 1:\n            deleted_lines.extend(self.lines[start_line+1:end_line])\n        \n        # Get the last partial line\n        deleted_lines.append(end_line_text[:end_col])\n        \n        # Join the deleted text\n        deleted_text = \"\\n\".join(deleted_lines)\n        \n        # Update the buffer\n        new_line = start_line_text[:start_col] + end_line_text[end_col:]\n        self.lines[start_line:end_line+1] = [new_line]\n        \n        return deleted_text\n        \n    def replace_text(self, start_line: int, start_col: int,\n                    end_line: int, end_col: int, new_text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n        \n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n            \n        Returns:\n            The replaced text\n            \n        Raises:\n            IndexError: If any position is out of range\n            ValueError: If the end position comes before the start position\n        \"\"\"\n        # Delete the text first and get what was deleted\n        deleted_text = self.delete_text(start_line, start_col, end_line, end_col)\n        \n        # Insert the new text\n        self.insert_text(start_line, start_col, new_text)\n        \n        return deleted_text\n    \n    def clear(self) -> None:\n        \"\"\"Clear the buffer, removing all content.\"\"\"\n        self.lines = [\"\"]"
            ]
        }
    },
    "text_editor/text_editor_student/conftest.py": {
        "logprobs": -203.528954500875,
        "metrics": {
            "loc": 6,
            "sloc": 1,
            "lloc": 2,
            "comments": 1,
            "multi": 3,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/focus.py": {
        "logprobs": -716.8821240693705,
        "metrics": {
            "loc": 163,
            "sloc": 108,
            "lloc": 110,
            "comments": 4,
            "multi": 0,
            "blank": 37,
            "cyclomatic": 27,
            "internal_imports": [
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/learning/models.py": {
        "logprobs": -757.7017440856047,
        "metrics": {
            "loc": 165,
            "sloc": 75,
            "lloc": 120,
            "comments": 5,
            "multi": 56,
            "blank": 31,
            "cyclomatic": 16,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/customization/models.py": {
        "logprobs": -675.0564331912658,
        "metrics": {
            "loc": 155,
            "sloc": 65,
            "lloc": 98,
            "comments": 0,
            "multi": 56,
            "blank": 32,
            "cyclomatic": 25,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/customization/playground.py": {
        "logprobs": -1285.8373463493363,
        "metrics": {
            "loc": 304,
            "sloc": 116,
            "lloc": 110,
            "comments": 18,
            "multi": 105,
            "blank": 62,
            "cyclomatic": 30,
            "internal_imports": [
                "class CustomizationManager(BaseModel):\n    \"\"\"\n    Manages the customization system for the text editor.\n    \n    This class provides a safe environment for experimenting with \n    different editor behaviors and algorithms.\n    \"\"\"\n    components: Dict[str, CustomizableComponent] = Field(default_factory=dict)\n    history: CustomizationHistory = Field(default_factory=CustomizationHistory)\n    environment: Optional[IsolatedEnvironment] = None\n    active_experiment: Optional[ExperimentResults] = None\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the customization manager with default components.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default components\n        for component in DEFAULT_COMPONENTS:\n            self.components[component.id] = component\n            \n        # Initialize the isolated environment\n        self.environment = IsolatedEnvironment()\n    \n    def get_component(self, component_id: str) -> Optional[CustomizableComponent]:\n        \"\"\"\n        Get a specific customizable component.\n        \n        Args:\n            component_id: ID of the component to retrieve\n            \n        Returns:\n            The CustomizableComponent object, or None if not found\n        \"\"\"\n        return self.components.get(component_id)\n    \n    def get_all_components(self) -> List[CustomizableComponent]:\n        \"\"\"\n        Get all customizable components.\n        \n        Returns:\n            List of all CustomizableComponent objects\n        \"\"\"\n        return list(self.components.values())\n    \n    def get_components_by_category(self, category: CustomizationCategory) -> List[CustomizableComponent]:\n        \"\"\"\n        Get components filtered by category.\n        \n        Args:\n            category: Category to filter by\n            \n        Returns:\n            List of CustomizableComponent objects in the specified category\n        \"\"\"\n        return [c for c in self.components.values() if c.category == category]\n    \n    def get_components_by_difficulty(self, difficulty: CustomizationDifficulty) -> List[CustomizableComponent]:\n        \"\"\"\n        Get components filtered by difficulty.\n        \n        Args:\n            difficulty: Difficulty level to filter by\n            \n        Returns:\n            List of CustomizableComponent objects at the specified difficulty\n        \"\"\"\n        return [c for c in self.components.values() if c.difficulty == difficulty]\n    \n    def start_experiment(self, component_id: str, implementation_id: str) -> Optional[ExperimentResults]:\n        \"\"\"\n        Start a customization experiment.\n        \n        Args:\n            component_id: ID of the component to customize\n            implementation_id: ID of the implementation to test\n            \n        Returns:\n            The ExperimentResults object, or None if the experiment couldn't be started\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return None\n            \n        # Check if the implementation exists\n        if (implementation_id != \"default\" and \n            implementation_id not in component.alternative_implementations):\n            return None\n            \n        # Create a new experiment\n        experiment = ExperimentResults(\n            component_id=component_id,\n            implementation_id=implementation_id,\n            start_time=time.time()\n        )\n        \n        # Save the current state\n        snapshot_id = f\"{component_id}_{int(experiment.start_time)}\"\n        self.history.save_snapshot(snapshot_id, {\n            \"component\": component.dict(),\n            \"current_implementation\": component.current_implementation\n        })\n        \n        # Set the active experiment\n        self.active_experiment = experiment\n        \n        # Update the component's current implementation\n        component.current_implementation = implementation_id\n        \n        return experiment\n    \n    def complete_experiment(self, success: bool, metrics: Dict[str, float] = None, error: str = None) -> None:\n        \"\"\"\n        Complete the active experiment with results.\n        \n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        if not self.active_experiment:\n            return\n            \n        # Complete the experiment\n        self.active_experiment.complete(success, metrics, error)\n        \n        # Add to history\n        self.history.add_experiment(self.active_experiment)\n        \n        # If the experiment failed, revert the component\n        if not success:\n            component_id = self.active_experiment.component_id\n            component = self.get_component(component_id)\n            if component:\n                component.current_implementation = \"default\"\n                \n        # Clear the active experiment\n        self.active_experiment = None\n    \n    def cancel_experiment(self) -> None:\n        \"\"\"Cancel the active experiment and revert changes.\"\"\"\n        if not self.active_experiment:\n            return\n            \n        component_id = self.active_experiment.component_id\n        component = self.get_component(component_id)\n        \n        if component:\n            # Revert to the default implementation\n            component.current_implementation = \"default\"\n            \n        # Mark as failed and add to history\n        self.active_experiment.complete(False, error=\"Experiment cancelled\")\n        self.history.add_experiment(self.active_experiment)\n        \n        # Clear the active experiment\n        self.active_experiment = None\n    \n    def run_code_in_sandbox(self, code: str) -> Tuple[bool, Any, str]:\n        \"\"\"\n        Run code in a sandboxed environment to test a customization.\n        \n        Args:\n            code: The Python code to execute\n            \n        Returns:\n            Tuple of (success, result, error_message)\n        \"\"\"\n        # Execute the code without resetting the environment\n        # This allows us to preserve any variables added to the environment\n        return self.environment.execute(code)\n    \n    def get_experiment_history(self, component_id: Optional[str] = None) -> List[ExperimentResults]:\n        \"\"\"\n        Get the history of experiments.\n        \n        Args:\n            component_id: ID of the component to filter by (optional)\n            \n        Returns:\n            List of ExperimentResults objects\n        \"\"\"\n        if component_id:\n            return self.history.get_experiments_for_component(component_id)\n        else:\n            return self.history.experiments\n    \n    def get_implementation_details(self, component_id: str, implementation_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Get details about a specific implementation.\n        \n        Args:\n            component_id: ID of the component\n            implementation_id: ID of the implementation\n            \n        Returns:\n            Dictionary with implementation details\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return {}\n            \n        if implementation_id == \"default\":\n            description = f\"Default implementation: {component.default_implementation}\"\n            impl_id = component.default_implementation\n        else:\n            description = component.alternative_implementations.get(implementation_id, \"\")\n            impl_id = implementation_id\n            \n        # Get performance history for this implementation\n        experiments = self.history.get_experiments_for_component(component_id)\n        matching_experiments = [e for e in experiments if e.implementation_id == impl_id]\n        \n        # Calculate success rate\n        total = len(matching_experiments)\n        successful = len([e for e in matching_experiments if e.success])\n        success_rate = successful / total if total > 0 else 0\n        \n        # Get average performance metrics\n        avg_metrics = {}\n        if successful > 0:\n            for experiment in [e for e in matching_experiments if e.success]:\n                for metric, value in experiment.performance_metrics.items():\n                    if metric not in avg_metrics:\n                        avg_metrics[metric] = []\n                    avg_metrics[metric].append(value)\n                    \n            avg_metrics = {\n                metric: sum(values) / len(values)\n                for metric, values in avg_metrics.items()\n            }\n            \n        return {\n            \"description\": description,\n            \"total_experiments\": total,\n            \"successful_experiments\": successful,\n            \"success_rate\": success_rate,\n            \"average_metrics\": avg_metrics,\n            \"is_current\": component.current_implementation == impl_id\n        }\n    \n    def apply_component_customization(self, component_id: str, implementation_id: str, \n                                     code: str) -> Tuple[bool, str]:\n        \"\"\"\n        Apply a customization to a component.\n        \n        Args:\n            component_id: ID of the component to customize\n            implementation_id: ID of the implementation to apply\n            code: Custom implementation code\n            \n        Returns:\n            Tuple of (success, error_message)\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return False, f\"Component {component_id} not found\"\n            \n        # Check if the implementation exists\n        if (implementation_id != \"default\" and \n            implementation_id not in component.alternative_implementations):\n            return False, f\"Implementation {implementation_id} not found\"\n            \n        # Start an experiment\n        experiment = self.start_experiment(component_id, implementation_id)\n        if not experiment:\n            return False, \"Failed to start experiment\"\n            \n        # Run the code in the sandbox\n        success, result, error = self.run_code_in_sandbox(code)\n        \n        # Get performance metrics\n        metrics = {}\n        if success and isinstance(result, dict):\n            metrics = result.get(\"metrics\", {})\n            \n        # Complete the experiment\n        self.complete_experiment(success, metrics, error)\n        \n        if not success:\n            return False, error\n            \n        return True, \"\"\n    \n    def revert_to_default(self, component_id: str) -> bool:\n        \"\"\"\n        Revert a component to its default implementation.\n        \n        Args:\n            component_id: ID of the component to revert\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return False\n            \n        # Cancel any active experiment for this component\n        if (self.active_experiment and \n            self.active_experiment.component_id == component_id):\n            self.cancel_experiment()\n            \n        # Set to default implementation\n        component.current_implementation = \"default\"\n        \n        return True\n    \n    def get_current_implementation(self, component_id: str) -> Optional[str]:\n        \"\"\"\n        Get the current implementation for a component.\n        \n        Args:\n            component_id: ID of the component to check\n            \n        Returns:\n            The implementation ID, or None if the component doesn't exist\n        \"\"\"\n        component = self.get_component(component_id)\n        if not component:\n            return None\n            \n        return component.current_implementation",
                "class CustomizableComponent(BaseModel):\n    \"\"\"\n    Represents a component of the editor that can be customized.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: CustomizationCategory\n    difficulty: CustomizationDifficulty\n    default_implementation: str\n    alternative_implementations: Dict[str, str] = Field(default_factory=dict)\n    impact_description: str\n    implementation_hints: List[str] = Field(default_factory=list)\n    current_implementation: str = \"default\"",
                "class CustomizationCategory(Enum):\n    \"\"\"Categories of editor components that can be customized.\"\"\"\n    TEXT_STORAGE = \"text_storage\"\n    CURSOR_BEHAVIOR = \"cursor_behavior\"\n    EDITING_OPERATIONS = \"editing_operations\"\n    SEARCH_ALGORITHM = \"search_algorithm\"\n    UNDO_REDO = \"undo_redo\"\n    FILE_HANDLING = \"file_handling\"\n    PERFORMANCE = \"performance\"",
                "class CustomizationDifficulty(Enum):\n    \"\"\"Difficulty levels for customization tasks.\"\"\"\n    BASIC = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class ExperimentResults(BaseModel):\n    \"\"\"\n    Represents the results of a customization experiment.\n    \"\"\"\n    component_id: str\n    implementation_id: str\n    start_time: float\n    end_time: Optional[float] = None\n    success: bool = False\n    error_message: Optional[str] = None\n    performance_metrics: Dict[str, float] = Field(default_factory=dict)\n    notes: str = \"\"\n    \n    def complete(self, success: bool, metrics: Dict[str, float] = None, error: str = None) -> None:\n        \"\"\"\n        Mark the experiment as complete with results.\n        \n        Args:\n            success: Whether the experiment was successful\n            metrics: Performance metrics from the experiment\n            error: Error message if the experiment failed\n        \"\"\"\n        self.end_time = time.time()\n        self.success = success\n        \n        if metrics:\n            self.performance_metrics = metrics\n            \n        if error:\n            self.error_message = error\n    \n    def duration(self) -> float:\n        \"\"\"\n        Get the duration of the experiment in seconds.\n        \n        Returns:\n            Duration of the experiment, or -1 if not completed\n        \"\"\"\n        if self.end_time is None:\n            return -1\n        \n        return self.end_time - self.start_time",
                "class Editor(BaseModel):\n    \"\"\"\n    Core editor class that combines buffer and cursor functionality.\n\n    This class provides the basic editing operations that form the foundation\n    of the text editor, including text insertion, deletion, navigation, and\n    other fundamental operations.\n    \"\"\"\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n    cursor: Cursor = None\n    file_manager: FileManager = Field(default_factory=FileManager)\n    history: History = Field(default_factory=History)\n\n    def __init__(self, content: str = \"\", file_path: Optional[str] = None):\n        \"\"\"\n        Initialize a new editor with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n            file_path: Path to the file being edited (optional)\n        \"\"\"\n        super().__init__()\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.file_manager = FileManager(current_path=file_path)\n        self.history = History()\n    \n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the editor.\n        \n        Returns:\n            The content as a string\n        \"\"\"\n        return self.buffer.get_content()\n    \n    def get_cursor_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n        \n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return self.cursor.get_position()\n    \n    def insert_text(self, text: str) -> None:\n        \"\"\"\n        Insert text at the current cursor position.\n\n        Args:\n            text: The text to insert\n        \"\"\"\n        line, column = self.cursor.get_position()\n        self.buffer.insert_text(line, column, text)\n\n        # Record the operation in history\n        self.history.record_insert(line, column, text)\n\n        # Update cursor position\n        if \"\\n\" in text:\n            # Move to the end of the inserted text\n            lines = text.split(\"\\n\")\n            new_line = line + len(lines) - 1\n            new_column = len(lines[-1])\n            self.cursor.move_to(new_line, new_column)\n        else:\n            # Move cursor forward by the length of the inserted text\n            self.cursor.move_to(line, column + len(text))\n    \n    def delete_char_before_cursor(self) -> None:\n        \"\"\"Delete the character before the cursor (backspace operation).\"\"\"\n        line, column = self.cursor.get_position()\n\n        if column > 0:\n            # Delete character in the current line\n            deleted_text = self.buffer.delete_text(line, column - 1, line, column)\n            self.history.record_delete(line, column - 1, line, column, deleted_text)\n            self.cursor.move_to(line, column - 1)\n        elif line > 0:\n            # At the beginning of a line, join with the previous line\n            prev_line_length = len(self.buffer.get_line(line - 1))\n            deleted_text = self.buffer.delete_text(line - 1, prev_line_length, line, 0)\n            self.history.record_delete(line - 1, prev_line_length, line, 0, deleted_text)\n            self.cursor.move_to(line - 1, prev_line_length)\n    \n    def delete_char_after_cursor(self) -> None:\n        \"\"\"Delete the character after the cursor (delete key operation).\"\"\"\n        line, column = self.cursor.get_position()\n        line_length = len(self.buffer.get_line(line))\n\n        if column < line_length:\n            # Delete character in the current line\n            deleted_text = self.buffer.delete_text(line, column, line, column + 1)\n            self.history.record_delete(line, column, line, column + 1, deleted_text)\n        elif line < self.buffer.get_line_count() - 1:\n            # At the end of a line, join with the next line\n            deleted_text = self.buffer.delete_text(line, line_length, line + 1, 0)\n            self.history.record_delete(line, line_length, line + 1, 0, deleted_text)\n    \n    def new_line(self) -> None:\n        \"\"\"Insert a new line at the cursor position.\"\"\"\n        self.insert_text(\"\\n\")\n    \n    def move_cursor(self, direction: str, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor in the specified direction.\n        \n        Args:\n            direction: One of \"up\", \"down\", \"left\", \"right\", \n                      \"line_start\", \"line_end\", \"buffer_start\", \"buffer_end\"\n            count: Number of units to move (for up, down, left, right)\n        \"\"\"\n        if direction == \"up\":\n            self.cursor.move_up(count)\n        elif direction == \"down\":\n            self.cursor.move_down(count)\n        elif direction == \"left\":\n            self.cursor.move_left(count)\n        elif direction == \"right\":\n            self.cursor.move_right(count)\n        elif direction == \"line_start\":\n            self.cursor.move_to_line_start()\n        elif direction == \"line_end\":\n            self.cursor.move_to_line_end()\n        elif direction == \"buffer_start\":\n            self.cursor.move_to_buffer_start()\n        elif direction == \"buffer_end\":\n            self.cursor.move_to_buffer_end()\n        else:\n            raise ValueError(f\"Unknown direction: {direction}\")\n    \n    def set_cursor_position(self, line: int, column: int) -> None:\n        \"\"\"\n        Set the cursor to the specified position.\n        \n        Args:\n            line: Line number (0-indexed)\n            column: Column number (0-indexed)\n        \"\"\"\n        self.cursor.move_to(line, column)\n    \n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n        \n        Args:\n            line_number: The line number to retrieve (0-indexed)\n            \n        Returns:\n            The requested line as a string\n        \"\"\"\n        return self.buffer.get_line(line_number)\n    \n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n        \n        Returns:\n            The number of lines\n        \"\"\"\n        return self.buffer.get_line_count()\n    \n    def replace_text(self, start_line: int, start_col: int,\n                    end_line: int, end_col: int, new_text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n        \"\"\"\n        deleted_text = self.buffer.replace_text(start_line, start_col, end_line, end_col, new_text)\n        self.history.record_replace(start_line, start_col, end_line, end_col, new_text, deleted_text)\n        return deleted_text\n    \n    def clear(self) -> None:\n        \"\"\"Clear the editor, removing all content.\"\"\"\n        content = self.buffer.get_content()\n        if content:\n            self.history.record_delete(0, 0, self.buffer.get_line_count() - 1,\n                                     len(self.buffer.get_line(self.buffer.get_line_count() - 1)),\n                                     content)\n        self.buffer.clear()\n        self.cursor.move_to_buffer_start()\n\n    def undo(self) -> bool:\n        \"\"\"\n        Undo the last operation.\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        operation = self.history.undo()\n        if not operation:\n            return False\n\n        if operation.type == \"insert\":\n            # To undo an insert, we delete the inserted text\n            self.buffer.delete_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.text.count(\"\\n\"),\n                operation.start_col + len(operation.text.split(\"\\n\")[-1]) if \"\\n\" in operation.text\n                else operation.start_col + len(operation.text)\n            )\n            self.cursor.move_to(operation.start_line, operation.start_col)\n        elif operation.type == \"delete\":\n            # To undo a delete, we insert the deleted text\n            self.buffer.insert_text(operation.start_line, operation.start_col, operation.deleted_text)\n            end_lines = operation.deleted_text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.deleted_text)\n            self.cursor.move_to(end_line, end_col)\n        elif operation.type == \"replace\":\n            # To undo a replace, we delete the new text and insert the old text\n            self.buffer.replace_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.text.count(\"\\n\"),\n                operation.start_col + len(operation.text.split(\"\\n\")[-1]) if \"\\n\" in operation.text\n                else operation.start_col + len(operation.text),\n                operation.deleted_text\n            )\n            end_lines = operation.deleted_text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.deleted_text)\n            self.cursor.move_to(end_line, end_col)\n\n        return True\n\n    def redo(self) -> bool:\n        \"\"\"\n        Redo the last undone operation.\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        operation = self.history.redo()\n        if not operation:\n            return False\n\n        if operation.type == \"insert\":\n            # To redo an insert, we insert the text again\n            self.buffer.insert_text(operation.start_line, operation.start_col, operation.text)\n            end_lines = operation.text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.text)\n            self.cursor.move_to(end_line, end_col)\n        elif operation.type == \"delete\":\n            # To redo a delete, we delete the text again\n            self.buffer.delete_text(\n                operation.start_line,\n                operation.start_col,\n                operation.end_line,\n                operation.end_col\n            )\n            self.cursor.move_to(operation.start_line, operation.start_col)\n        elif operation.type == \"replace\":\n            # To redo a replace, we replace the text again\n            self.buffer.replace_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.deleted_text.count(\"\\n\"),\n                operation.start_col + len(operation.deleted_text.split(\"\\n\")[-1]) if \"\\n\" in operation.deleted_text\n                else operation.start_col + len(operation.deleted_text),\n                operation.text\n            )\n            end_lines = operation.text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.text)\n            self.cursor.move_to(end_line, end_col)\n\n        return True\n\n    def load_file(self, file_path: str) -> None:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n        \"\"\"\n        content = self.file_manager.load_file(file_path)\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.history.clear()\n\n    def save_file(self, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            file_path: Path to save to (if None, uses current path)\n        \"\"\"\n        content = self.buffer.get_content()\n        self.file_manager.save_file(content, file_path)\n\n    def get_current_file_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.file_manager.get_current_path()\n\n    def is_file_modified(self) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Returns:\n            True if the file has been modified, False otherwise\n        \"\"\"\n        return self.file_manager.is_file_modified()"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/customization/__init__.py": {
        "logprobs": -198.06698763391296,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/features/models.py": {
        "logprobs": -903.1267122857068,
        "metrics": {
            "loc": 189,
            "sloc": 105,
            "lloc": 116,
            "comments": 7,
            "multi": 41,
            "blank": 30,
            "cyclomatic": 36,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/setup.py": {
        "logprobs": -174.95993078939446,
        "metrics": {
            "loc": 11,
            "sloc": 10,
            "lloc": 2,
            "comments": 0,
            "multi": 0,
            "blank": 1,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/study/manager.py": {
        "logprobs": -1854.938839278,
        "metrics": {
            "loc": 614,
            "sloc": 290,
            "lloc": 233,
            "comments": 41,
            "multi": 160,
            "blank": 125,
            "cyclomatic": 90,
            "internal_imports": [
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudyTopic(BaseModel):\n    \"\"\"\n    Represents a topic to be studied.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    status: TopicStatus = TopicStatus.NEW\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n    last_studied: Optional[float] = None\n    next_review: Optional[float] = None\n    repetition_count: int = 0\n    difficulty_rating: int = 3  # 1 (easiest) to 5 (hardest)\n    mastery_level: float = 0.0  # 0.0 to 1.0\n    related_topics: List[str] = Field(default_factory=list)\n    notes: str = \"\"",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n    \n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"start\",\n                details=\"Session started\"\n            )\n        )\n    \n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n        \n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"pause\",\n                details=reason\n            )\n        )\n    \n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"resume\",\n                details=\"Session resumed\"\n            )\n        )\n    \n    def complete(self, achievements: Optional[List[str]] = None, \n                rating: Optional[int] = None) -> None:\n        \"\"\"\n        Complete the study session.\n        \n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n        \n        if achievements:\n            self.achievements = achievements\n            \n        if rating:\n            self.rating = rating\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=\"Session completed\"\n            )\n        )\n    \n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n        \n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=f\"Session cancelled: {reason}\"\n            )\n        )\n    \n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n        \n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"note\",\n                details=note\n            )\n        )\n    \n    def record_distraction(self, details: Optional[str] = None, \n                          duration_seconds: Optional[float] = None) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n        \n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\",\n                details=details,\n                duration=duration_seconds\n            )\n        )\n    \n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n        \n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n            \n        end_time = self.actual_end_time or time.time()\n        \n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n        \n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= (event.timestamp - pause_start)\n                pause_start = None\n                \n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= (end_time - pause_start)\n            \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n        \n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n    \n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n        \n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n        \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n        \n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n        \n        if total_minutes <= 0:\n            return 0\n            \n        return max(0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100))",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n    \n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"start\",\n                details=\"Session started\"\n            )\n        )\n    \n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n        \n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"pause\",\n                details=reason\n            )\n        )\n    \n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"resume\",\n                details=\"Session resumed\"\n            )\n        )\n    \n    def complete(self, achievements: Optional[List[str]] = None, \n                rating: Optional[int] = None) -> None:\n        \"\"\"\n        Complete the study session.\n        \n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n        \n        if achievements:\n            self.achievements = achievements\n            \n        if rating:\n            self.rating = rating\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=\"Session completed\"\n            )\n        )\n    \n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n        \n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=f\"Session cancelled: {reason}\"\n            )\n        )\n    \n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n        \n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"note\",\n                details=note\n            )\n        )\n    \n    def record_distraction(self, details: Optional[str] = None, \n                          duration_seconds: Optional[float] = None) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n        \n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\",\n                details=details,\n                duration=duration_seconds\n            )\n        )\n    \n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n        \n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n            \n        end_time = self.actual_end_time or time.time()\n        \n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n        \n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= (event.timestamp - pause_start)\n                pause_start = None\n                \n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= (end_time - pause_start)\n            \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n        \n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n    \n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n        \n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n        \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n        \n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n        \n        if total_minutes <= 0:\n            return 0\n            \n        return max(0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100))",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n    \n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"start\",\n                details=\"Session started\"\n            )\n        )\n    \n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n        \n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"pause\",\n                details=reason\n            )\n        )\n    \n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"resume\",\n                details=\"Session resumed\"\n            )\n        )\n    \n    def complete(self, achievements: Optional[List[str]] = None, \n                rating: Optional[int] = None) -> None:\n        \"\"\"\n        Complete the study session.\n        \n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n        \n        if achievements:\n            self.achievements = achievements\n            \n        if rating:\n            self.rating = rating\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=\"Session completed\"\n            )\n        )\n    \n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n        \n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=f\"Session cancelled: {reason}\"\n            )\n        )\n    \n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n        \n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"note\",\n                details=note\n            )\n        )\n    \n    def record_distraction(self, details: Optional[str] = None, \n                          duration_seconds: Optional[float] = None) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n        \n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\",\n                details=details,\n                duration=duration_seconds\n            )\n        )\n    \n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n        \n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n            \n        end_time = self.actual_end_time or time.time()\n        \n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n        \n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= (event.timestamp - pause_start)\n                pause_start = None\n                \n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= (end_time - pause_start)\n            \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n        \n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n    \n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n        \n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n        \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n        \n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n        \n        if total_minutes <= 0:\n            return 0\n            \n        return max(0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100))",
                "class StudySession(BaseModel):\n    \"\"\"\n    Represents a study session for learning.\n    \"\"\"\n    id: str\n    topics: List[str]  # List of topic IDs\n    planned_start_time: float\n    planned_duration_minutes: int\n    actual_start_time: Optional[float] = None\n    actual_end_time: Optional[float] = None\n    status: StudySessionStatus = StudySessionStatus.PLANNED\n    events: List[StudySessionEvent] = Field(default_factory=list)\n    techniques: List[StudyTechnique] = Field(default_factory=list)\n    goals: List[str] = Field(default_factory=list)\n    achievements: List[str] = Field(default_factory=list)\n    rating: Optional[int] = None  # 1 to 5, self-evaluation of productivity\n    notes: str = \"\"\n    \n    def start(self) -> None:\n        \"\"\"Start the study session.\"\"\"\n        self.actual_start_time = time.time()\n        self.status = StudySessionStatus.IN_PROGRESS\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"start\",\n                details=\"Session started\"\n            )\n        )\n    \n    def pause(self, reason: Optional[str] = None) -> None:\n        \"\"\"\n        Pause the study session.\n        \n        Args:\n            reason: Reason for pausing (optional)\n        \"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"pause\",\n                details=reason\n            )\n        )\n    \n    def resume(self) -> None:\n        \"\"\"Resume the study session.\"\"\"\n        if self.status != StudySessionStatus.IN_PROGRESS:\n            return\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"resume\",\n                details=\"Session resumed\"\n            )\n        )\n    \n    def complete(self, achievements: Optional[List[str]] = None, \n                rating: Optional[int] = None) -> None:\n        \"\"\"\n        Complete the study session.\n        \n        Args:\n            achievements: List of achievements during the session (optional)\n            rating: Self-evaluation rating (optional)\n        \"\"\"\n        self.actual_end_time = time.time()\n        self.status = StudySessionStatus.COMPLETED\n        \n        if achievements:\n            self.achievements = achievements\n            \n        if rating:\n            self.rating = rating\n            \n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=\"Session completed\"\n            )\n        )\n    \n    def cancel(self, reason: str) -> None:\n        \"\"\"\n        Cancel the study session.\n        \n        Args:\n            reason: Reason for cancellation\n        \"\"\"\n        self.status = StudySessionStatus.CANCELLED\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"end\",\n                details=f\"Session cancelled: {reason}\"\n            )\n        )\n    \n    def add_note(self, note: str) -> None:\n        \"\"\"\n        Add a note to the study session.\n        \n        Args:\n            note: The note to add\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"note\",\n                details=note\n            )\n        )\n    \n    def record_distraction(self, details: Optional[str] = None, \n                          duration_seconds: Optional[float] = None) -> None:\n        \"\"\"\n        Record a distraction during the study session.\n        \n        Args:\n            details: Details about the distraction (optional)\n            duration_seconds: Duration of the distraction in seconds (optional)\n        \"\"\"\n        self.events.append(\n            StudySessionEvent(\n                event_type=\"distraction\",\n                details=details,\n                duration=duration_seconds\n            )\n        )\n    \n    def get_actual_duration_minutes(self) -> float:\n        \"\"\"\n        Get the actual duration of the study session in minutes.\n        \n        Returns:\n            Duration in minutes, or -1 if the session hasn't ended\n        \"\"\"\n        if not self.actual_start_time:\n            return 0\n            \n        end_time = self.actual_end_time or time.time()\n        \n        # Calculate total time\n        total_seconds = end_time - self.actual_start_time\n        \n        # Subtract pause durations\n        pause_start = None\n        for event in self.events:\n            if event.event_type == \"pause\":\n                pause_start = event.timestamp\n            elif event.event_type == \"resume\" and pause_start:\n                total_seconds -= (event.timestamp - pause_start)\n                pause_start = None\n                \n        # If there's an active pause, subtract that too\n        if pause_start:\n            total_seconds -= (end_time - pause_start)\n            \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_distractions_count(self) -> int:\n        \"\"\"\n        Get the number of distractions during the session.\n        \n        Returns:\n            Number of distractions\n        \"\"\"\n        return sum(1 for event in self.events if event.event_type == \"distraction\")\n    \n    def get_distraction_time_minutes(self) -> float:\n        \"\"\"\n        Get the total time spent on distractions in minutes.\n        \n        Returns:\n            Total distraction time in minutes\n        \"\"\"\n        total_seconds = sum(\n            event.duration or 0\n            for event in self.events\n            if event.event_type == \"distraction\" and event.duration\n        )\n        \n        return total_seconds / 60  # Convert to minutes\n    \n    def get_focus_percentage(self) -> float:\n        \"\"\"\n        Get the percentage of time spent focused (not distracted).\n        \n        Returns:\n            Focus percentage (0-100)\n        \"\"\"\n        total_minutes = self.get_actual_duration_minutes()\n        distraction_minutes = self.get_distraction_time_minutes()\n        \n        if total_minutes <= 0:\n            return 0\n            \n        return max(0, min(100, ((total_minutes - distraction_minutes) / total_minutes) * 100))",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionStatus(Enum):\n    \"\"\"Status of a study session.\"\"\"\n    PLANNED = \"planned\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n    CANCELLED = \"cancelled\"",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class StudySessionEvent(BaseModel):\n    \"\"\"\n    Represents an event that occurred during a study session.\n    \"\"\"\n    timestamp: float = Field(default_factory=time.time)\n    event_type: str  # \"start\", \"pause\", \"resume\", \"end\", \"note\", \"distraction\"\n    details: Optional[str] = None\n    duration: Optional[float] = None",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class TopicStatus(Enum):\n    \"\"\"Status of a study topic.\"\"\"\n    NEW = \"new\"\n    LEARNING = \"learning\"\n    REVIEWING = \"reviewing\"\n    MASTERED = \"mastered\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudyTechnique(Enum):\n    \"\"\"Study techniques that can be applied.\"\"\"\n    POMODORO = \"pomodoro\"\n    SPACED_REPETITION = \"spaced_repetition\"\n    ACTIVE_RECALL = \"active_recall\"\n    FEYNMAN_TECHNIQUE = \"feynman_technique\"\n    MIND_MAPPING = \"mind_mapping\"\n    INTERLEAVING = \"interleaving\"",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(default_factory=SpacedRepetitionAlgorithm)\n    \n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n        \n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n    \n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n        \n        Args:\n            session_id: ID of the session to retrieve\n            \n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n    \n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look ahead\n            \n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n    \n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look back\n            \n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if (session.status == StudySessionStatus.COMPLETED or\n                session.status == StudySessionStatus.CANCELLED)\n            and session.planned_start_time >= cutoff\n        ]\n    \n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n        \n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.planned_start_time = new_start_time\n        return True\n    \n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n        \n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.cancel(reason)\n        return True\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(default_factory=SpacedRepetitionAlgorithm)\n    \n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n        \n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n    \n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n        \n        Args:\n            session_id: ID of the session to retrieve\n            \n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n    \n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look ahead\n            \n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n    \n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look back\n            \n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if (session.status == StudySessionStatus.COMPLETED or\n                session.status == StudySessionStatus.CANCELLED)\n            and session.planned_start_time >= cutoff\n        ]\n    \n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n        \n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.planned_start_time = new_start_time\n        return True\n    \n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n        \n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.cancel(reason)\n        return True\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(default_factory=SpacedRepetitionAlgorithm)\n    \n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n        \n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n    \n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n        \n        Args:\n            session_id: ID of the session to retrieve\n            \n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n    \n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look ahead\n            \n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n    \n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look back\n            \n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if (session.status == StudySessionStatus.COMPLETED or\n                session.status == StudySessionStatus.CANCELLED)\n            and session.planned_start_time >= cutoff\n        ]\n    \n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n        \n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.planned_start_time = new_start_time\n        return True\n    \n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n        \n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.cancel(reason)\n        return True\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class StudySchedule(BaseModel):\n    \"\"\"\n    Represents a schedule of study sessions.\n    \"\"\"\n    sessions: Dict[str, StudySession] = Field(default_factory=dict)\n    spaced_repetition: SpacedRepetitionAlgorithm = Field(default_factory=SpacedRepetitionAlgorithm)\n    \n    def add_session(self, session: StudySession) -> None:\n        \"\"\"\n        Add a session to the schedule.\n        \n        Args:\n            session: The session to add\n        \"\"\"\n        self.sessions[session.id] = session\n    \n    def get_session(self, session_id: str) -> Optional[StudySession]:\n        \"\"\"\n        Get a specific session by ID.\n        \n        Args:\n            session_id: ID of the session to retrieve\n            \n        Returns:\n            The StudySession object, or None if not found\n        \"\"\"\n        return self.sessions.get(session_id)\n    \n    def get_upcoming_sessions(self, days: int = 7) -> List[StudySession]:\n        \"\"\"\n        Get upcoming sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look ahead\n            \n        Returns:\n            List of upcoming StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now + (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if session.status == StudySessionStatus.PLANNED\n            and now <= session.planned_start_time <= cutoff\n        ]\n    \n    def get_past_sessions(self, days: int = 30) -> List[StudySession]:\n        \"\"\"\n        Get past sessions within the specified number of days.\n        \n        Args:\n            days: Number of days to look back\n            \n        Returns:\n            List of past StudySession objects\n        \"\"\"\n        now = time.time()\n        cutoff = now - (days * 86400)  # Convert days to seconds\n        \n        return [\n            session for session in self.sessions.values()\n            if (session.status == StudySessionStatus.COMPLETED or\n                session.status == StudySessionStatus.CANCELLED)\n            and session.planned_start_time >= cutoff\n        ]\n    \n    def reschedule_session(self, session_id: str, new_start_time: float) -> bool:\n        \"\"\"\n        Reschedule a session to a new time.\n        \n        Args:\n            session_id: ID of the session to reschedule\n            new_start_time: New start time (timestamp)\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.planned_start_time = new_start_time\n        return True\n    \n    def cancel_session(self, session_id: str, reason: str) -> bool:\n        \"\"\"\n        Cancel a session.\n        \n        Args:\n            session_id: ID of the session to cancel\n            reason: Reason for cancellation\n            \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        session = self.get_session(session_id)\n        if not session or session.status != StudySessionStatus.PLANNED:\n            return False\n            \n        session.cancel(reason)\n        return True\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        return self.spaced_repetition.calculate_next_review(topic, quality)",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n    \n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = 2.5  # This would be stored with the topic in a real implementation\n            repetition_count = topic.repetition_count\n            \n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (topic.next_review - topic.last_studied) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n        \n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))\n            )\n        )\n        \n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n            \n        # Cap the interval\n        interval_days = min(self.interval_max_days, max(self.interval_min_days, interval_days))\n        \n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n        \n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n    \n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = 2.5  # This would be stored with the topic in a real implementation\n            repetition_count = topic.repetition_count\n            \n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (topic.next_review - topic.last_studied) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n        \n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))\n            )\n        )\n        \n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n            \n        # Cap the interval\n        interval_days = min(self.interval_max_days, max(self.interval_min_days, interval_days))\n        \n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n        \n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n    \n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = 2.5  # This would be stored with the topic in a real implementation\n            repetition_count = topic.repetition_count\n            \n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (topic.next_review - topic.last_studied) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n        \n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))\n            )\n        )\n        \n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n            \n        # Cap the interval\n        interval_days = min(self.interval_max_days, max(self.interval_min_days, interval_days))\n        \n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n        \n        return next_review",
                "class SpacedRepetitionAlgorithm(BaseModel):\n    \"\"\"\n    Algorithm for calculating spaced repetition intervals.\n    \n    This implements a simplified version of the SM-2 algorithm used in\n    spaced repetition systems like Anki.\n    \"\"\"\n    ease_factor_min: float = 1.3\n    ease_factor_default: float = 2.5\n    ease_factor_max: float = 4.0\n    interval_min_days: int = 1\n    interval_max_days: int = 365\n    \n    def calculate_next_review(self, topic: StudyTopic, quality: int) -> float:\n        \"\"\"\n        Calculate the next review time for a topic.\n        \n        Args:\n            topic: The topic to calculate for\n            quality: Rating of how well the material was recalled (0-5)\n            \n        Returns:\n            Timestamp for the next review\n        \"\"\"\n        # Initialize values for new topics\n        if topic.next_review is None:\n            ease_factor = self.ease_factor_default\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            # Use existing values for topics that have been reviewed before\n            ease_factor = 2.5  # This would be stored with the topic in a real implementation\n            repetition_count = topic.repetition_count\n            \n            # Calculate interval based on repetition count\n            if repetition_count == 0:\n                interval_days = 1\n            elif repetition_count == 1:\n                interval_days = 6\n            else:\n                # This is a simplification; real SM-2 uses more complex calculations\n                last_interval = (topic.next_review - topic.last_studied) / 86400  # Convert to days\n                interval_days = int(last_interval * ease_factor)\n        \n        # Adjust ease factor based on quality\n        ease_factor = max(\n            self.ease_factor_min,\n            min(\n                self.ease_factor_max,\n                ease_factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))\n            )\n        )\n        \n        # Failed recall (quality < 3) means start over\n        if quality < 3:\n            interval_days = self.interval_min_days\n            repetition_count = 0\n        else:\n            repetition_count += 1\n            \n        # Cap the interval\n        interval_days = min(self.interval_max_days, max(self.interval_min_days, interval_days))\n        \n        # Calculate next review time\n        next_review = time.time() + (interval_days * 86400)  # Convert days to seconds\n        \n        return next_review"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/study/models.py": {
        "logprobs": -1419.9344265197856,
        "metrics": {
            "loc": 447,
            "sloc": 223,
            "lloc": 230,
            "comments": 25,
            "multi": 125,
            "blank": 83,
            "cyclomatic": 69,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/interview/problems.py": {
        "logprobs": -1723.0847229656065,
        "metrics": {
            "loc": 809,
            "sloc": 682,
            "lloc": 17,
            "comments": 9,
            "multi": 29,
            "blank": 97,
            "cyclomatic": 8,
            "internal_imports": [
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class InterviewProblem(BaseModel):\n    \"\"\"\n    Represents an interview practice problem.\n    \"\"\"\n    id: str\n    title: str\n    description: str\n    difficulty: DifficultyLevel\n    category: ProblemCategory\n    time_limit_seconds: int = 3600  # Default to 1 hour\n    memory_limit_mb: int = 128\n    test_cases: List[TestCase] = Field(default_factory=list)\n    solution: Optional[str] = None\n    hints: List[str] = Field(default_factory=list)\n    related_problems: List[str] = Field(default_factory=list)\n    tags: List[str] = Field(default_factory=list)",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class DifficultyLevel(Enum):\n    \"\"\"Difficulty levels for interview problems.\"\"\"\n    EASY = \"easy\"\n    MEDIUM = \"medium\"\n    HARD = \"hard\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class ProblemCategory(Enum):\n    \"\"\"Categories of interview problems.\"\"\"\n    ARRAYS = \"arrays\"\n    STRINGS = \"strings\"\n    LINKED_LISTS = \"linked_lists\"\n    TREES = \"trees\"\n    GRAPHS = \"graphs\"\n    DYNAMIC_PROGRAMMING = \"dynamic_programming\"\n    RECURSION = \"recursion\"\n    SORTING = \"sorting\"\n    SEARCHING = \"searching\"\n    HASH_TABLES = \"hash_tables\"\n    MATH = \"math\"\n    BIT_MANIPULATION = \"bit_manipulation\"",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False",
                "class TestCase(BaseModel):\n    \"\"\"\n    Represents a test case for an interview problem.\n    \"\"\"\n    input: str\n    expected_output: str\n    explanation: Optional[str] = None\n    is_hidden: bool = False"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/__init__.py": {
        "logprobs": -189.61366630325003,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/learning/__init__.py": {
        "logprobs": -196.22333478946496,
        "metrics": {
            "loc": 1,
            "sloc": 0,
            "lloc": 0,
            "comments": 1,
            "multi": 0,
            "blank": 0,
            "cyclomatic": 0,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_writer/src/writer_text_editor/statistics.py": {
        "logprobs": -1952.9523454975845,
        "metrics": {
            "loc": 469,
            "sloc": 324,
            "lloc": 297,
            "comments": 38,
            "multi": 0,
            "blank": 94,
            "cyclomatic": 80,
            "internal_imports": [
                "from __future__ import annotations\n\nimport warnings\n\nfrom .backend import transformations, validations, selections, counts, metrics, utils\n\n\nclass textstatistics:\n    \"\"\"Main textstat class with methods to calculate readability indices.\n\n    Attributes\n    ----------\n    text_encoding : str\n        Default: \"utf-8\"\n    __lang : str\n        Default : \"en_US\"\n    __easy_word_sets (deprecated) : dict\n        Dictionary of easy word sets.\n\n        deprecated:: 0.7.6\n            This attribute has no effect. It will be removed in version 0.8.0.\n    __round_outputs (deprecated) : bool or None\n        Whether to round the outputs of all textstat methods. Default: None\n\n        deprecated:: 0.7.6\n            This attribute has no effect. It will be removed in version 0.8.0.\n    __round_points : int or None\n        The number of decimals to use when rounding outputs. If round_points is set to\n        None, the outputs will not be rounded. Default: None\n    __rm_apostrophe : bool\n        If True, the remove_punctuation method will remove the apostrophe in\n        contractions along with other punctuation. If False, punctuation is\n        removed with the exception of apostrophes in common English contractions.\n        Default: True\n    \"\"\"\n\n    __lang = \"en_US\"\n    __easy_word_sets = {}\n    __round_outputs = None\n    __round_points = None\n    __rm_apostrophe = True\n    text_encoding = \"utf-8\"\n\n    def __init__(self):\n        self.set_lang(self.__lang)\n\n    def _cache_clear(self) -> None:\n        \"\"\"Clear the cache.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        None\n\n        deprecated:: 0.7.6\n            This method has no effect due to a caching redesign.\n            It will be removed in version 0.8.0.\n\n        \"\"\"\n        warnings.warn(\n            \"The _cache_clear() method is deprecated and \"\n            \"will be removed in version 0.8.0. \"\n            \"It has no effect due to a caching redesign.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        pass\n\n    def _legacy_round(self, number: float, points: int | None = None) -> float:\n        \"\"\"Round `number`, unless the attribute `__round_points` is `None`.\n\n        Round floating point outputs for backwards compatibility. Rounding can be\n        turned on or off by calling `set_rounding_points`.\n\n        Parameters\n        ----------\n        number : float\n        points (deprecated) : int, optional\n            This argument is deprecated and has no effect.\n\n            deprecated:: 0.7.6\n                Use set_rounding_points instead.\n                It will be removed in version 0.8.0.\n\n        Returns\n        -------\n        float\n\n        \"\"\"\n        if points is not None:\n            warnings.warn(\n                \"The points argument is deprecated and \"\n                \"will be removed in version 0.8.0. \"\n                \"Use set_rounding_points instead.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        if self.__round_points is None:\n            return number\n        return round(number, self.__round_points)\n\n    def set_rounding_points(self, points: int | None) -> None:\n        \"\"\"Set the number of decimal digits for rounding textstat outputs.\n        Setting `points` to None will disable rounding.\n\n        Parameters\n        ----------\n        points : int or None\n            The number of decimal digits for the outputs of all textstat\n            methods. The default is None (no rounding).\n\n        Returns\n        -------\n        None\n\n        \"\"\"\n        self.__round_points = points\n\n    def set_rounding(self, rounding: bool, points: int | None = None) -> None:\n        \"\"\"Set the rounding behavior. Setting `rounding` to True will round all\n        textstat outputs to the number of decimal digits specified by `points`.\n        Setting `rounding` to False will disable rounding as will setting `points`\n        to None.\n\n        Parameters\n        ----------\n        rounding (deprecated) : bool\n            Whether to round the outputs of all textstat methods.\n        points (deprecated) : int or None, optional\n            The number of decimal digits for the outputs of all textstat\n            methods. The default is None.\n\n        Returns\n        -----\n        None.\n\n        deprecated:: 0.7.6\n            Use set_rounding_points instead.\n            It will be removed in version 0.8.0.\n\n        \"\"\"\n        warnings.warn(\n            \"set_rounding is deprecated and will be removed in version 0.8.0. \"\n            \"Use set_rounding_points instead\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        if rounding:\n            self.__round_points = points\n        else:\n            self.__round_points = None\n\n    def set_rm_apostrophe(self, rm_apostrophe: bool) -> None:\n        \"\"\"Sets whether other methods should remove apostrophes in common\n        English contractions when removing punctuation.\n\n        Parameters\n        ----------\n        rm_apostrophe : bool\n            If True, the remove_punctuation method will remove the apostrophe in\n            contractions along with other punctuation. If False, punctuation is\n            removed with the exception of apostrophes in common English contractions.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.__rm_apostrophe = rm_apostrophe\n\n    def set_lang(self, lang: str) -> None:\n        \"\"\"Set the language of your text strings.\n\n        The default locale ID is 'en_US'.\n\n        Parameters\n        ----------\n        lang : str\n            A locale ID.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        self.__lang = lang\n\n    def char_count(self, text: str, ignore_spaces: bool = True) -> int:\n        \"\"\"Count the number of characters in a text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        ignore_spaces : bool, optional\n            Ignore whitespaces if True. The default is True.\n\n        Returns\n        -------\n        int\n            Number of characters.\n\n        \"\"\"\n        return counts.count_chars(text, ignore_spaces)\n\n    def letter_count(self, text: str, ignore_spaces: bool | None = None) -> int:\n        \"\"\"Count letters in a text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        ignore_spaces (deprecated) : bool, optional\n            Ignore whitespaces if True.\n\n            deprecated:: 0.7.6\n                This argument is deprecated and has no effect.\n                It will be removed in version 0.8.0.\n\n        Returns\n        -------\n        int\n            The number of letters in text.\n\n        \"\"\"\n        if ignore_spaces is not None:\n            warnings.warn(\n                \"The 'ignore_spaces' argument has been deprecated \"\n                \"and will be removed in version 0.8.0. \"\n                \"This argument has no effect.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        return counts.count_letters(text)\n\n    def remove_punctuation(self, text: str) -> str:\n        \"\"\"Remove punctuation.\n\n        If the instance attribute `__rm_apostrophe` is set to True, all\n        punctuation is removed, including apostrophes.\n        If the instance attribute `__rm_apostrophe` is set to False,\n        punctuation is removed with the exception of apostrophes in common\n        English contractions.\n        Hyphens are always removed.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        text : str\n            A copy of the input text with punctuation removed.\n\n        \"\"\"\n        return transformations.remove_punctuation(text, self.__rm_apostrophe)\n\n    def lexicon_count(\n        self,\n        text: str,\n        removepunct: bool = True,\n        split_contractions: bool = False,\n        split_hyphens: bool = False,\n    ) -> int:\n        \"\"\"Count the number of words in a text.\n\n        English contractions (e.g. \"aren't\") and hyphenated words are counted as one\n        words by default, but can be counted as multiple words with\n        `split_contractions=True` and `split_hyphens=True` respectively. If\n        `removepunct` is set to False, \"words\" with no letters (e.g. \" .? \") are\n        counted as words.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        removepunct : bool, optional\n            Remove punctuation. The default is True.\n        split_contractions : bool, optional\n            Split common English contractions. The default is False.\n        split_hyphens : bool, optional\n            Split hyphenated words. The default is False.\n\n        Returns\n        -------\n        count : int\n            Number of words.\n\n        \"\"\"\n        return counts.count_words(\n            text,\n            rm_punctuation=removepunct,\n            split_contractions=split_contractions,\n            split_hyphens=split_hyphens,\n        )\n\n    def miniword_count(self, text: str, max_size: int = 3) -> int:\n        \"\"\"Count common words with `max_size` letters or less in a text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        max_size : int, optional\n            Maximum number of letters in a word for it to be counted. The\n            default is 3.\n\n        Returns\n        -------\n        count : int\n\n        \"\"\"\n        return counts.count_miniwords(text, max_size)\n\n    def syllable_count(self, text: str, lang: str | None = None) -> int:\n        \"\"\"Estimate the number of syllables in a text using Pyphen.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str or None\n            The language of the text.\n\n            deprecated:: 0.5.7\n                This argument is deprecated and has no effect.\n                It will be removed in version 0.8.0.\n\n        Returns\n        -------\n        int\n            Number of syllables in `text`.\n        \"\"\"\n        if lang:\n            warnings.warn(\n                \"The 'lang' argument has been moved to \"\n                \"'textstat.set_lang(<lang>)'. This argument will be removed \"\n                \"in the future.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n\n        return counts.count_syllables(text, self.__lang)\n\n    def sentence_count(self, text: str) -> int:\n        \"\"\"Count the sentences in the text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of sentences in `text`.\n\n        \"\"\"\n        return counts.count_sentences(text)\n\n    def avg_sentence_length(self, text: str) -> float:\n        \"\"\"Calculate the average sentence length in words.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The average sentence length.\n\n        deprecated:: 0.7.6\n            Use `words_per_sentence` instead.\n            It will be removed in version 0.8.0.\n\n        \"\"\"\n        warnings.warn(\n            \"The 'avg_sentence_length' method has been deprecated due to being \"\n            \"the same as 'words_per_sentence'. This method will be removed in the\"\n            \"future.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self._legacy_round(metrics.words_per_sentence(text))\n\n    def avg_syllables_per_word(self, text: str, interval: int | None = None) -> float:\n        \"\"\"Get the average number of syllables per `interval` words. If\n        `interval` is None, it will be interpreted as 1.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        interval : int or None, optional\n            The interval. The default is None (1).\n\n        Returns\n        -------\n        float\n            The average number of syllables per `interval` words.\n\n        \"\"\"\n        if interval is None:\n            interval = 1\n        aspw = metrics.syllables_per_word(text, self.__lang)\n        aspw *= interval\n        return self._legacy_round(aspw)\n\n    def avg_character_per_word(self, text: str) -> float:\n        \"\"\"Calculate the average word length in characters.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The average number of characters per word.\n\n        \"\"\"\n        return self._legacy_round(metrics.chars_per_word(text))\n\n    def avg_letter_per_word(self, text: str) -> float:\n        \"\"\"Calculate the average  word length in letters.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The average number of letters per word.\n\n        \"\"\"\n        return self._legacy_round(metrics.letters_per_word(text))\n\n    def avg_sentence_per_word(self, text: str) -> float:\n        \"\"\"Get the number of sentences per word.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            Number of sentences per word.\n\n        \"\"\"\n        return self._legacy_round(metrics.sentences_per_word(text))\n\n    def words_per_sentence(self, text: str) -> float:\n        \"\"\"Calculate the average number of words per sentence.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The average number of words per sentence.\n\n        \"\"\"\n        return self._legacy_round(metrics.words_per_sentence(text))\n\n    def count_complex_arabic_words(self, text: str) -> int:\n        \"\"\"\n        Count complex arabic words.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of arabic complex words.\n\n        \"\"\"\n        return counts.count_complex_arabic_words(text)\n\n    def count_arabic_syllables(self, text: str) -> int:\n        \"\"\"Count arabic syllables.\n\n        Long and stressed syllables are counted double.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of arabic syllables.\n\n        \"\"\"\n        return counts.count_arabic_syllables(text)\n\n    def count_faseeh(self, text: str) -> int:\n        \"\"\"Counts faseeh in arabic texts.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of faseeh.\n\n        \"\"\"\n        return counts.count_faseeh(text)\n\n    def count_arabic_long_words(self, text: str) -> int:\n        \"\"\"Counts long arabic words without short vowels (tashkeel).\n\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of long arabic words without short vowels (tashkeel).\n\n        \"\"\"\n        return counts.count_arabic_long_words(text)\n\n    def flesch_reading_ease(self, text: str) -> float:\n        \"\"\"Calculate the Flesch Reading Ease formula.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Flesch Reading Ease for `text`.\n        \"\"\"\n        return self._legacy_round(metrics.flesch_reading_ease(text, self.__lang))\n\n    def flesch_kincaid_grade(self, text: str) -> float:\n        r\"\"\"Calculate the Flesh-Kincaid Grade for `text`.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Flesh-Kincaid Grade for `text`.\n\n        Notes\n        -----\n        The Flesh-Kincaid Grade is calculated as:\n\n        .. math::\n\n            (.39*avg\\ sentence\\ length)+(11.8*avg\\ syllables\\ per\\ word)-15.59\n\n        \"\"\"\n        return self._legacy_round(metrics.flesch_kincaid_grade(text, self.__lang))\n\n    def polysyllabcount(self, text: str) -> int:\n        \"\"\"Count the number of words with three or more syllables.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n            Number of words with three or more syllables.\n\n        Notes\n        -----\n        The function uses text.split() to generate a list of words.\n        Contractions and hyphenations are therefore counted as one word.\n\n        \"\"\"\n        return counts.count_polysyllable_words(text, self.__lang)\n\n    def smog_index(self, text: str) -> float:\n        r\"\"\"Calculate the SMOG index.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The SMOG index for `text`.\n\n        Notes\n        -----\n        The SMOG index is calculated as:\n\n        .. math::\n\n            (1.043*(30*(n\\ polysyllabic\\ words/n\\ sentences))^{.5})+3.1291\n\n        Polysyllabic words are defined as words with more than 3 syllables.\n        \"\"\"\n        return self._legacy_round(metrics.smog_index(text, self.__lang))\n\n    def coleman_liau_index(self, text: str) -> float:\n        r\"\"\"Calculate the Coleman-Liaux index.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Coleman-Liaux index for `text`.\n\n        Notes\n        -----\n        The Coleman-Liaux index is calculated as:\n\n        .. math::\n\n            (0.058*n\\ letters/n\\ words)-(0.296*n\\ sentences/n\\ words)-15.8\n\n        \"\"\"\n        return self._legacy_round(metrics.coleman_liau_index(text))\n\n    def automated_readability_index(self, text: str) -> float:\n        r\"\"\"Calculate the Automated Readability Index (ARI).\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The ARI for `text`.\n\n        Notes\n        -----\n        The ARI is calculated as:\n\n        .. math::\n\n            (4.71*n\\ characters/n\\ words)+(0.5*n\\ words/n\\ sentences)-21.43\n\n        \"\"\"\n        return self._legacy_round(metrics.automated_readability_index(text))\n\n    def linsear_write_formula(\n        self, text: str, strict_lower: bool = False, strict_upper: bool = True\n    ) -> float:\n        r\"\"\"Calculate the Linsear-Write (Lw) metric.\n\n        Canonically the Lw only uses the first 100 words of text. To disable this\n        functionality, set `strict_upper` to False.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str\n            The language of the text.\n        strict_lower : bool, optional\n            If True, the Lw is only calculated if the number of words is at least\n            100. The default is False.\n        strict_upper : bool, optional\n            If True, the Lw is only calculated on the first 100 words. The default is\n            True.\n\n        Returns\n        -------\n        float\n            The Lw for `text`.\n\n        Notes\n        -----\n        The Lw is calculated using the first 100 words:\n\n        .. math::\n\n            n\\ easy\\ words+(n\\ difficult\\ words*3))/n\\ sentences\n\n        easy words are defined as words with 2 syllables or less.\n        difficult words are defined as words with 3 syllables or more.\n        r\"\"\"\n        return self._legacy_round(\n            metrics.linsear_write_formula(\n                text, self.__lang, strict_lower=strict_lower, strict_upper=strict_upper\n            )\n        )\n\n    def difficult_words(\n        self, text: str, syllable_threshold: int = 2, unique: bool = True\n    ) -> int:\n        \"\"\"Count the number of difficult words. By default, counts all words,\n        but can be set to count only unique words by using `unique=True`.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str\n            The language of the text.\n        syllable_threshold : int, optional\n            The cut-off for the number of syllables difficult words are\n            required to have. The default is 2.\n        unique : bool, optional\n            Count only unique words. The default is True.\n\n        Returns\n        -------\n        int\n            Number of difficult words.\n\n        \"\"\"\n        return counts.count_difficult_words(\n            text, self.__lang, syllable_threshold, unique\n        )\n\n    def difficult_words_list(\n        self, text: str, syllable_threshold: int = 2, unique: bool = True\n    ) -> list[str]:\n        \"\"\"Get a list of the difficult words in the text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        syllable_threshold : int, optional\n            The cut-off for the number of syllables difficult words are\n            required to have. The default is 2.\n        unique : bool, optional\n            Count only unique words. The default is True.\n\n        Returns\n        -------\n        List[str]\n            A list of the words deemed difficult.\n\n        \"\"\"\n        if unique:\n            return list(\n                selections.set_difficult_words(text, syllable_threshold, self.__lang)\n            )\n        return selections.list_difficult_words(text, syllable_threshold, self.__lang)\n\n    def is_difficult_word(self, word: str, syllable_threshold: int = 2) -> bool:\n        \"\"\"Return True if `word` is a difficult word.\n\n        The function checks if if the word is in the Dale-Chall list of\n        easy words. However, it currently doesn't check if the word is a\n        regular inflection of a word in the Dale-Chall list!\n\n        If the word is not a word, is not in the easy words list, or is shorter\n        than `syllable_threshold`, the function returns False. Else, True.\n\n        Parameters\n        ----------\n        word : str\n            A word.\n        syllable_threshold : int, optional\n            Minimum number of syllables a difficult word must have. The\n            default is 2.\n\n        Returns\n        -------\n        bool\n            False if the word is not a word (i.e. `word` contains whitespace), is not\n            in the easy words list, or is shorter than `syllable_threshold`, else\n            True.\n\n        \"\"\"\n        return validations.is_difficult_word(word, syllable_threshold, self.__lang)\n\n    def is_easy_word(self, word: str, syllable_threshold: int = 2) -> bool:\n        \"\"\"Return True if `word` is not a difficult word. See the docstring for\n        `is_difficult_word` for details.\n\n        Parameters\n        ----------\n        word : str\n            A word.\n        syllable_threshold : int, optional\n            Minimum number of syllables a difficult word must have. The\n            default is 2.\n\n        Returns\n        -------\n        bool\n            True if the word is a word (no whitespace), is not in the easy words list,\n            and is shorter than `syllable_threshold`, else False.\n\n        \"\"\"\n        return (len(word.split()) == 1) and (\n            not self.is_difficult_word(word, syllable_threshold)\n        )\n\n    def dale_chall_readability_score(self, text: str) -> float:\n        r\"\"\"Estimate the Dale-Chall readability score.\n\n        Deviations from the original Dale-Chall readability score:\n        - For now, regular inflections of words in the Dale-Chall list of easy\n          words are counted as difficult words\n          (see documentation for `is_difficult_word`). This may change in the\n          future.\n        - Proper names are also counted as difficult words. This is unlikely to\n          change.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            An approximation of the Dale-Chall readability score.\n\n        Notes\n        -----\n        The estimate of the Dale-Chall readability score is calculated as:\n\n        .. math::\n\n            (0.1579*%\\ difficult\\ words)+(0.0496*avg\\ words\\ per\\ sentence)\n\n        If the percentage of difficult words is > 5, 3.6365 is added to the\n        score.\n        \"\"\"\n        return self._legacy_round(\n            metrics.dale_chall_readability_score(text, self.__lang)\n        )\n\n    def gunning_fog(self, text: str) -> float:\n        \"\"\"Calculate the Gunning Fog Index formula.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Gunning Fog Index for `text`.\n        \"\"\"\n        return self._legacy_round(metrics.gunning_fog(text, self.__lang))\n\n    def lix(self, text: str) -> float:\n        r\"\"\"Calculate the LIX for `text`\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The LIX score for `text`.\n\n        Notes\n        -----\n        The estimate of the LIX score is calculated as:\n\n        .. math::\n\n            LIX = A/B + A*100/C\n\n        A= Number of words\n        B= Number of sentences\n        C= Number of long words (More than 6 letters)\n\n        \"\"\"\n        return self._legacy_round(metrics.lix(text))\n\n    def rix(self, text: str) -> float:\n        r\"\"\"Calculate the RIX for `text`\n\n        A Rix ratio is the number of long words divided by\n        the number of assessed sentences.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The RIX for `text`.\n\n        Notes\n        -----\n        The estimate of the RIX score is calculated as:\n\n        .. math::\n\n            rix = LW/S\n\n        LW= Number of long words (i.e. words of 7 or more characters)\n        S= Number of sentences\n\n        Anderson (1983) specifies that punctuation should be removed and that\n        hyphenated sequences and abbreviations count as single words.\n\n        \"\"\"\n        return self._legacy_round(metrics.rix(text))\n\n    def spache_readability(self, text: str, float_output: bool = True) -> float | int:\n        \"\"\"Calculate SPACHE readability formula for young readers. If `float_output`\n        is True, the function returns a float. Otherwise, it rounds down to an int.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        float_output : bool, optional\n            Whether to return a float or an int. The default is True.\n\n        Returns\n        -------\n        float or int\n            The SPACHE readability score for `text`\n        \"\"\"\n        readability_score = metrics.spache_readability(text, self.__lang)\n        if float_output:\n            return self._legacy_round(readability_score)\n        else:\n            # TODO: should this be rounded instead of int-ed?\n            return int(readability_score)\n\n    def dale_chall_readability_score_v2(self, text: str) -> float:\n        \"\"\"Calculate New Dale Chall Readability formula.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The New Dale Chall Readability Score for `text`\n        \"\"\"\n        return self._legacy_round(\n            metrics.dale_chall_readability_score_v2(text, self.__lang)\n        )\n\n    def text_standard(self, text: str, float_output: bool = False) -> float | str:\n        \"\"\"Calculate the Text Standard for `text`. If `float_output` is True,\n        calculates the numerical value. Otherwise, returns a string of the form\n        \"XX and YY grade\" where XX and YY are gotten by rounding the float value\n        down and up, respectively.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        float_output : bool, optional\n            Whether to return a float or a string. The default is False.\n\n        Returns\n        -------\n        float\n            The Text Standard for `text`.\n        \"\"\"\n        standard_value = metrics.text_standard(text, self.__lang)\n        if float_output:\n            return self._legacy_round(standard_value)\n        else:\n            lower_score = int(standard_value) - 1\n            upper_score = lower_score + 1\n            return \"{}{} and {}{} grade\".format(\n                lower_score,\n                utils.get_grade_suffix(lower_score),\n                upper_score,\n                utils.get_grade_suffix(upper_score),\n            )\n\n    def reading_time(self, text: str, ms_per_char: float = 14.69) -> float:\n        \"\"\"Calculate reading time (Demberg & Keller, 2008).\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        ms_per_char : float\n            The reading speed in milliseconds per character. The default is 14.69.\n\n        Returns\n        -------\n        float\n            The reading time for `text`.\n        \"\"\"\n        return self._legacy_round(metrics.reading_time(text, ms_per_char))\n\n    # Spanish readability tests\n    def fernandez_huerta(self, text: str) -> float:\n        \"\"\"Calculate Fernandez Huerta readability score\n        https://legible.es/blog/lecturabilidad-fernandez-huerta/\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str\n            The language of the text.\n\n        Returns\n        -------\n        float\n            The Fernandez Huerta readability score for `text`\n        \"\"\"\n        return self._legacy_round(metrics.fernandez_huerta(text, self.__lang))\n\n    def szigriszt_pazos(self, text: str) -> float:\n        \"\"\"Calculate Szigriszt Pazos readability score (1992)\n        https://legible.es/blog/perspicuidad-szigriszt-pazos/\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str\n            The language of the text.\n\n        Returns\n        -------\n        float\n            The Szigriszt Pazos readability score for `text`\n        \"\"\"\n        return self._legacy_round(metrics.szigriszt_pazos(text, self.__lang))\n\n    def gutierrez_polini(self, text: str) -> float:\n        \"\"\"Calculate Guttierrez de Polini index\n        https://legible.es/blog/comprensibilidad-gutierrez-de-polini/\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Gutierrez de Polini index for `text`\n        \"\"\"\n        return self._legacy_round(metrics.gutierrez_polini(text))\n\n    def crawford(self, text: str) -> float:\n        r\"\"\"Calculate the Crawford index for the text.\n\n        https://legible.es/blog/formula-de-crawford/\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        lang : str\n            The language of the text.\n\n        Returns\n        -------\n        float\n            The Crawford index for `text`.\n\n        Notes\n        -----\n        The Crawford index is calculated as:\n\n        .. math::\n\n            (-0.205*n\\ sentences/n\\ words)+(0.049*n\\ syllables/n\\ words)-3.407\n\n        \"\"\"\n        return self._legacy_round(metrics.crawford(text, self.__lang))\n\n    def osman(self, text: str) -> float:\n        \"\"\"Calculate Osman index for Arabic texts\n        https://www.aclweb.org/anthology/L16-1038.pdf\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Osman index for `text`\n        \"\"\"\n        return self._legacy_round(metrics.osman(text))\n\n    def gulpease_index(self, text: str) -> float:\n        \"\"\"Calculate Indice Gulpease Index for Italian texts\n        https://it.wikipedia.org/wiki/Indice_Gulpease\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The Gulpease Index for `text`\n        \"\"\"\n        return self._legacy_round(metrics.gulpease_index(text))\n\n    def long_word_count(self, text: str, threshold: int = 6) -> int:\n        \"\"\"Counts words with more than `threshold` (default 6) letters.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        threshold : int\n            The minimum number of letters in a word for it to be counted.\n\n        Returns\n        -------\n        int\n            Number of words with more than `threshold` letters.\n        \"\"\"\n        return counts.count_long_words(text, threshold=threshold)\n\n    def monosyllabcount(self, text: str) -> int:\n        \"\"\"Counts words with only one syllable in a text.\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        int\n        Number of monosyllable words in the text.\n        \"\"\"\n        return counts.count_monosyllable_words(text, self.__lang)\n\n    def wiener_sachtextformel(self, text: str, variant: int) -> float:\n        \"\"\"Calculate Wiener Sachtextformel for readability assessment of German texts\n\n        https://de.wikipedia.org/wiki/Lesbarkeitsindex#Wiener_Sachtextformel\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n        variant : int\n            The variant of the formula.\n\n        Returns\n        -------\n        float\n            The Wiener Sachtextformel readability score for `text`\n        \"\"\"\n        return self._legacy_round(\n            metrics.wiener_sachtextformel(text, variant, self.__lang)\n        )\n\n    def mcalpine_eflaw(self, text: str) -> float:\n        \"\"\"Calculate McAlpine EFLAW score, which asseses the readability of English\n        texts for English foreign learners.\n\n        https://strainindex.wordpress.com/2009/04/30/mcalpine-eflaw-readability-score/\n\n        Parameters\n        ----------\n        text : str\n            A text string.\n\n        Returns\n        -------\n        float\n            The McAlpine EFLAW readability score for `text`\n        \"\"\"\n        return self._legacy_round(metrics.mcalpine_eflaw(text))\n\n    def __get_lang_cfg(self, key: str) -> float:\n        \"\"\"Get a value from the configuration for a specific language.\n\n        Parameters\n        ----------\n        key : str\n            The key to retrieve from the configuration.\n\n        Returns\n        -------\n        float\n            The value from the configuration.\n\n        \"\"\"\n        return utils.get_lang_cfg(self.__lang, key)\n\n    def __get_lang_root(self) -> str:\n        \"\"\"Get the root language of a language.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        str\n            The root language of the given language.\n        \"\"\"\n        return utils.get_lang_root(self.__lang)\n\n    def __get_lang_easy_words(self) -> set[str]:\n        \"\"\"Get the easy words for a language.\n\n        Parameters\n        ----------\n        None\n\n        Returns\n        -------\n        set[str]\n            The easy words for the given language.\n        \"\"\"\n        return utils.get_lang_easy_words(self.__lang)\n\n\ntextstat = textstatistics()\n",
                "class Document(BaseModel):\n    \"\"\"A document in the writer text editor.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    current_revision: Revision\n    revisions: Dict[str, Revision] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    class Config:\n        arbitrary_types_allowed = True\n    \n    def __init__(self, title: str, **data: Any):\n        \"\"\"Initialize a new document with the given title.\"\"\"\n        initial_revision = Revision(name=\"Initial\")\n        super().__init__(\n            title=title,\n            current_revision=initial_revision,\n            **data\n        )\n        self.revisions[\"Initial\"] = initial_revision\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the total number of words in the document.\"\"\"\n        return sum(section.get_word_count() for section in self.current_revision.sections)\n    \n    def add_section(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> Section:\n        \"\"\"Add a new section to the document.\"\"\"\n        section = Section(title=title, metadata=metadata or {})\n        self.current_revision.sections.append(section)\n        self.updated_at = datetime.now()\n        return section\n    \n    def get_section(self, index: int) -> Optional[Section]:\n        \"\"\"Get the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            return self.current_revision.sections[index]\n        return None\n    \n    def get_section_by_title(self, title: str) -> Optional[Section]:\n        \"\"\"Get the first section with the specified title.\"\"\"\n        for section in self.current_revision.sections:\n            if section.title == title:\n                return section\n        return None\n    \n    def update_section_title(self, index: int, title: str) -> Optional[Section]:\n        \"\"\"Update the title of the section at the specified index.\"\"\"\n        section = self.get_section(index)\n        if section:\n            section.title = title\n            self.updated_at = datetime.now()\n            return section\n        return None\n    \n    def delete_section(self, index: int) -> bool:\n        \"\"\"Delete the section at the specified index.\"\"\"\n        if 0 <= index < len(self.current_revision.sections):\n            self.current_revision.sections.pop(index)\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def create_revision(self, name: str, metadata: Optional[Dict[str, Any]] = None) -> Revision:\n        \"\"\"Create a new revision of the document.\"\"\"\n        # Deep copy the current revision\n        import copy\n        new_revision = copy.deepcopy(self.current_revision)\n        new_revision.id = str(uuid.uuid4())\n        new_revision.name = name\n        new_revision.timestamp = datetime.now()\n        new_revision.metadata = metadata or {}\n        \n        self.revisions[name] = new_revision\n        self.current_revision = new_revision\n        self.updated_at = datetime.now()\n        \n        return new_revision\n    \n    def get_revision(self, name: str) -> Optional[Revision]:\n        \"\"\"Get a revision by name.\"\"\"\n        return self.revisions.get(name)\n    \n    def switch_to_revision(self, name: str) -> bool:\n        \"\"\"Switch to a different revision.\"\"\"\n        revision = self.get_revision(name)\n        if revision:\n            self.current_revision = revision\n            self.updated_at = datetime.now()\n            return True\n        return False\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of the document.\"\"\"\n        return \"\\n\\n\".join([\n            f\"# {section.title}\\n\\n{section.get_content()}\"\n            for section in self.current_revision.sections\n        ])\n    \n    def find_segments_by_content(self, pattern: str) -> List[Tuple[Section, TextSegment]]:\n        \"\"\"Find segments that match the given pattern.\"\"\"\n        results = []\n        for section in self.current_revision.sections:\n            for segment in section.segments:\n                if re.search(pattern, segment.content, re.IGNORECASE):\n                    results.append((section, segment))\n        return results",
                "class Section(BaseModel):\n    \"\"\"A section of a document, such as a chapter or scene.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    title: str\n    segments: List[TextSegment] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_content(self) -> str:\n        \"\"\"Get the full content of this section.\"\"\"\n        return \"\\n\".join([segment.content for segment in self.segments])\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this section.\"\"\"\n        return sum(segment.get_word_count() for segment in self.segments)\n    \n    def add_segment(self, content: str, metadata: Optional[Dict[str, Any]] = None) -> TextSegment:\n        \"\"\"Add a new segment to this section.\"\"\"\n        position = len(self.segments)\n        segment = TextSegment(\n            content=content,\n            position=position,\n            metadata=metadata or {}\n        )\n        self.segments.append(segment)\n        return segment\n    \n    def get_segment(self, position: int) -> Optional[TextSegment]:\n        \"\"\"Get the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            return self.segments[position]\n        return None\n    \n    def update_segment(self, position: int, content: str) -> Optional[TextSegment]:\n        \"\"\"Update the content of the segment at the specified position.\"\"\"\n        segment = self.get_segment(position)\n        if segment:\n            segment.content = content\n            return segment\n        return None\n    \n    def delete_segment(self, position: int) -> bool:\n        \"\"\"Delete the segment at the specified position.\"\"\"\n        if 0 <= position < len(self.segments):\n            self.segments.pop(position)\n            # Update positions of all segments after the deleted one\n            for i in range(position, len(self.segments)):\n                self.segments[i].position = i\n            return True\n        return False",
                "class TextSegment(BaseModel):\n    \"\"\"A segment of text, such as a paragraph or sentence.\"\"\"\n    \n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    content: str\n    position: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    \n    def get_word_count(self) -> int:\n        \"\"\"Get the number of words in this segment.\"\"\"\n        return len(re.findall(r'\\b\\w+\\b', self.content))"
            ]
        }
    },
    "text_editor/text_editor_student/text_editor/interview/models.py": {
        "logprobs": -831.9531866890367,
        "metrics": {
            "loc": 230,
            "sloc": 116,
            "lloc": 175,
            "comments": 8,
            "multi": 66,
            "blank": 39,
            "cyclomatic": 27,
            "internal_imports": []
        }
    },
    "text_editor/text_editor_student/text_editor/features/integration.py": {
        "logprobs": -1587.0690107689334,
        "metrics": {
            "loc": 370,
            "sloc": 149,
            "lloc": 165,
            "comments": 32,
            "multi": 108,
            "blank": 76,
            "cyclomatic": 61,
            "internal_imports": [
                "class Editor(BaseModel):\n    \"\"\"\n    Core editor class that combines buffer and cursor functionality.\n\n    This class provides the basic editing operations that form the foundation\n    of the text editor, including text insertion, deletion, navigation, and\n    other fundamental operations.\n    \"\"\"\n    buffer: TextBuffer = Field(default_factory=TextBuffer)\n    cursor: Cursor = None\n    file_manager: FileManager = Field(default_factory=FileManager)\n    history: History = Field(default_factory=History)\n\n    def __init__(self, content: str = \"\", file_path: Optional[str] = None):\n        \"\"\"\n        Initialize a new editor with the given content.\n\n        Args:\n            content: Initial text content (defaults to empty string)\n            file_path: Path to the file being edited (optional)\n        \"\"\"\n        super().__init__()\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.file_manager = FileManager(current_path=file_path)\n        self.history = History()\n    \n    def get_content(self) -> str:\n        \"\"\"\n        Get the entire content of the editor.\n        \n        Returns:\n            The content as a string\n        \"\"\"\n        return self.buffer.get_content()\n    \n    def get_cursor_position(self) -> Tuple[int, int]:\n        \"\"\"\n        Get the current cursor position.\n        \n        Returns:\n            A tuple of (line, column)\n        \"\"\"\n        return self.cursor.get_position()\n    \n    def insert_text(self, text: str) -> None:\n        \"\"\"\n        Insert text at the current cursor position.\n\n        Args:\n            text: The text to insert\n        \"\"\"\n        line, column = self.cursor.get_position()\n        self.buffer.insert_text(line, column, text)\n\n        # Record the operation in history\n        self.history.record_insert(line, column, text)\n\n        # Update cursor position\n        if \"\\n\" in text:\n            # Move to the end of the inserted text\n            lines = text.split(\"\\n\")\n            new_line = line + len(lines) - 1\n            new_column = len(lines[-1])\n            self.cursor.move_to(new_line, new_column)\n        else:\n            # Move cursor forward by the length of the inserted text\n            self.cursor.move_to(line, column + len(text))\n    \n    def delete_char_before_cursor(self) -> None:\n        \"\"\"Delete the character before the cursor (backspace operation).\"\"\"\n        line, column = self.cursor.get_position()\n\n        if column > 0:\n            # Delete character in the current line\n            deleted_text = self.buffer.delete_text(line, column - 1, line, column)\n            self.history.record_delete(line, column - 1, line, column, deleted_text)\n            self.cursor.move_to(line, column - 1)\n        elif line > 0:\n            # At the beginning of a line, join with the previous line\n            prev_line_length = len(self.buffer.get_line(line - 1))\n            deleted_text = self.buffer.delete_text(line - 1, prev_line_length, line, 0)\n            self.history.record_delete(line - 1, prev_line_length, line, 0, deleted_text)\n            self.cursor.move_to(line - 1, prev_line_length)\n    \n    def delete_char_after_cursor(self) -> None:\n        \"\"\"Delete the character after the cursor (delete key operation).\"\"\"\n        line, column = self.cursor.get_position()\n        line_length = len(self.buffer.get_line(line))\n\n        if column < line_length:\n            # Delete character in the current line\n            deleted_text = self.buffer.delete_text(line, column, line, column + 1)\n            self.history.record_delete(line, column, line, column + 1, deleted_text)\n        elif line < self.buffer.get_line_count() - 1:\n            # At the end of a line, join with the next line\n            deleted_text = self.buffer.delete_text(line, line_length, line + 1, 0)\n            self.history.record_delete(line, line_length, line + 1, 0, deleted_text)\n    \n    def new_line(self) -> None:\n        \"\"\"Insert a new line at the cursor position.\"\"\"\n        self.insert_text(\"\\n\")\n    \n    def move_cursor(self, direction: str, count: int = 1) -> None:\n        \"\"\"\n        Move the cursor in the specified direction.\n        \n        Args:\n            direction: One of \"up\", \"down\", \"left\", \"right\", \n                      \"line_start\", \"line_end\", \"buffer_start\", \"buffer_end\"\n            count: Number of units to move (for up, down, left, right)\n        \"\"\"\n        if direction == \"up\":\n            self.cursor.move_up(count)\n        elif direction == \"down\":\n            self.cursor.move_down(count)\n        elif direction == \"left\":\n            self.cursor.move_left(count)\n        elif direction == \"right\":\n            self.cursor.move_right(count)\n        elif direction == \"line_start\":\n            self.cursor.move_to_line_start()\n        elif direction == \"line_end\":\n            self.cursor.move_to_line_end()\n        elif direction == \"buffer_start\":\n            self.cursor.move_to_buffer_start()\n        elif direction == \"buffer_end\":\n            self.cursor.move_to_buffer_end()\n        else:\n            raise ValueError(f\"Unknown direction: {direction}\")\n    \n    def set_cursor_position(self, line: int, column: int) -> None:\n        \"\"\"\n        Set the cursor to the specified position.\n        \n        Args:\n            line: Line number (0-indexed)\n            column: Column number (0-indexed)\n        \"\"\"\n        self.cursor.move_to(line, column)\n    \n    def get_line(self, line_number: int) -> str:\n        \"\"\"\n        Get a specific line from the buffer.\n        \n        Args:\n            line_number: The line number to retrieve (0-indexed)\n            \n        Returns:\n            The requested line as a string\n        \"\"\"\n        return self.buffer.get_line(line_number)\n    \n    def get_line_count(self) -> int:\n        \"\"\"\n        Get the total number of lines in the buffer.\n        \n        Returns:\n            The number of lines\n        \"\"\"\n        return self.buffer.get_line_count()\n    \n    def replace_text(self, start_line: int, start_col: int,\n                    end_line: int, end_col: int, new_text: str) -> str:\n        \"\"\"\n        Replace text between the specified positions with new text.\n\n        Args:\n            start_line: Starting line number (0-indexed)\n            start_col: Starting column number (0-indexed)\n            end_line: Ending line number (0-indexed)\n            end_col: Ending column number (0-indexed)\n            new_text: The text to insert\n\n        Returns:\n            The replaced text\n        \"\"\"\n        deleted_text = self.buffer.replace_text(start_line, start_col, end_line, end_col, new_text)\n        self.history.record_replace(start_line, start_col, end_line, end_col, new_text, deleted_text)\n        return deleted_text\n    \n    def clear(self) -> None:\n        \"\"\"Clear the editor, removing all content.\"\"\"\n        content = self.buffer.get_content()\n        if content:\n            self.history.record_delete(0, 0, self.buffer.get_line_count() - 1,\n                                     len(self.buffer.get_line(self.buffer.get_line_count() - 1)),\n                                     content)\n        self.buffer.clear()\n        self.cursor.move_to_buffer_start()\n\n    def undo(self) -> bool:\n        \"\"\"\n        Undo the last operation.\n\n        Returns:\n            True if an operation was undone, False otherwise\n        \"\"\"\n        operation = self.history.undo()\n        if not operation:\n            return False\n\n        if operation.type == \"insert\":\n            # To undo an insert, we delete the inserted text\n            self.buffer.delete_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.text.count(\"\\n\"),\n                operation.start_col + len(operation.text.split(\"\\n\")[-1]) if \"\\n\" in operation.text\n                else operation.start_col + len(operation.text)\n            )\n            self.cursor.move_to(operation.start_line, operation.start_col)\n        elif operation.type == \"delete\":\n            # To undo a delete, we insert the deleted text\n            self.buffer.insert_text(operation.start_line, operation.start_col, operation.deleted_text)\n            end_lines = operation.deleted_text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.deleted_text)\n            self.cursor.move_to(end_line, end_col)\n        elif operation.type == \"replace\":\n            # To undo a replace, we delete the new text and insert the old text\n            self.buffer.replace_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.text.count(\"\\n\"),\n                operation.start_col + len(operation.text.split(\"\\n\")[-1]) if \"\\n\" in operation.text\n                else operation.start_col + len(operation.text),\n                operation.deleted_text\n            )\n            end_lines = operation.deleted_text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.deleted_text)\n            self.cursor.move_to(end_line, end_col)\n\n        return True\n\n    def redo(self) -> bool:\n        \"\"\"\n        Redo the last undone operation.\n\n        Returns:\n            True if an operation was redone, False otherwise\n        \"\"\"\n        operation = self.history.redo()\n        if not operation:\n            return False\n\n        if operation.type == \"insert\":\n            # To redo an insert, we insert the text again\n            self.buffer.insert_text(operation.start_line, operation.start_col, operation.text)\n            end_lines = operation.text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.text)\n            self.cursor.move_to(end_line, end_col)\n        elif operation.type == \"delete\":\n            # To redo a delete, we delete the text again\n            self.buffer.delete_text(\n                operation.start_line,\n                operation.start_col,\n                operation.end_line,\n                operation.end_col\n            )\n            self.cursor.move_to(operation.start_line, operation.start_col)\n        elif operation.type == \"replace\":\n            # To redo a replace, we replace the text again\n            self.buffer.replace_text(\n                operation.start_line,\n                operation.start_col,\n                operation.start_line + operation.deleted_text.count(\"\\n\"),\n                operation.start_col + len(operation.deleted_text.split(\"\\n\")[-1]) if \"\\n\" in operation.deleted_text\n                else operation.start_col + len(operation.deleted_text),\n                operation.text\n            )\n            end_lines = operation.text.split(\"\\n\")\n            if len(end_lines) > 1:\n                end_line = operation.start_line + len(end_lines) - 1\n                end_col = len(end_lines[-1])\n            else:\n                end_line = operation.start_line\n                end_col = operation.start_col + len(operation.text)\n            self.cursor.move_to(end_line, end_col)\n\n        return True\n\n    def load_file(self, file_path: str) -> None:\n        \"\"\"\n        Load content from a file.\n\n        Args:\n            file_path: Path to the file to load\n        \"\"\"\n        content = self.file_manager.load_file(file_path)\n        self.buffer = TextBuffer(content)\n        self.cursor = Cursor(buffer=self.buffer)\n        self.history.clear()\n\n    def save_file(self, file_path: Optional[str] = None) -> None:\n        \"\"\"\n        Save content to a file.\n\n        Args:\n            file_path: Path to save to (if None, uses current path)\n        \"\"\"\n        content = self.buffer.get_content()\n        self.file_manager.save_file(content, file_path)\n\n    def get_current_file_path(self) -> Optional[str]:\n        \"\"\"\n        Get the current file path.\n\n        Returns:\n            The current file path, or None if no file is open\n        \"\"\"\n        return self.file_manager.get_current_path()\n\n    def is_file_modified(self) -> bool:\n        \"\"\"\n        Check if the file has been modified since it was last saved.\n\n        Returns:\n            True if the file has been modified, False otherwise\n        \"\"\"\n        return self.file_manager.is_file_modified()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n    \n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n        \n        # Enable all beginner features by default\n        self._enable_beginner_features()\n    \n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n    \n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n        \n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n    \n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n        \n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n                \n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids\n                    for prereq in feature.prerequisites\n                )\n                \n                if prerequisites_met:\n                    pending.append(feature)\n        \n        return pending\n    \n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n        \n        Args:\n            feature_id: ID of the feature to unlock\n            \n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n            \n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n            \n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n                \n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n        \n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n        \n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n                \n        return feature\n    \n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n        \n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n        \n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n                \n        return newly_unlocked\n    \n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n        \n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n            \n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (last_assessment is None or \n                time.time() - last_assessment > self.assessment_interval):\n                self.user_progress.assess_skill()\n                \n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n    \n    def register_feature_hook(self, feature_id: str, hook: Callable[[Feature], None]) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n        \n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n            \n        self.feature_hooks[feature_id].append(hook)\n    \n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n        \n        Args:\n            feature_id: ID of the feature to check\n            \n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return (feature_id in self.features and \n                self.features[feature_id].is_enabled())\n    \n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n        \n        Args:\n            feature_id: ID of the feature to get guidance for\n            \n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation\n        }\n    \n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n        \n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n    \n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n        \n        Args:\n            level: The new skill level to set\n            \n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n    \n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n        \n        # Enable all beginner features by default\n        self._enable_beginner_features()\n    \n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n    \n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n        \n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n    \n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n        \n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n                \n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids\n                    for prereq in feature.prerequisites\n                )\n                \n                if prerequisites_met:\n                    pending.append(feature)\n        \n        return pending\n    \n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n        \n        Args:\n            feature_id: ID of the feature to unlock\n            \n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n            \n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n            \n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n                \n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n        \n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n        \n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n                \n        return feature\n    \n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n        \n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n        \n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n                \n        return newly_unlocked\n    \n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n        \n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n            \n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (last_assessment is None or \n                time.time() - last_assessment > self.assessment_interval):\n                self.user_progress.assess_skill()\n                \n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n    \n    def register_feature_hook(self, feature_id: str, hook: Callable[[Feature], None]) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n        \n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n            \n        self.feature_hooks[feature_id].append(hook)\n    \n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n        \n        Args:\n            feature_id: ID of the feature to check\n            \n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return (feature_id in self.features and \n                self.features[feature_id].is_enabled())\n    \n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n        \n        Args:\n            feature_id: ID of the feature to get guidance for\n            \n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation\n        }\n    \n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n        \n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n    \n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n        \n        Args:\n            level: The new skill level to set\n            \n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n    \n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n        \n        # Enable all beginner features by default\n        self._enable_beginner_features()\n    \n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n    \n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n        \n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n    \n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n        \n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n                \n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids\n                    for prereq in feature.prerequisites\n                )\n                \n                if prerequisites_met:\n                    pending.append(feature)\n        \n        return pending\n    \n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n        \n        Args:\n            feature_id: ID of the feature to unlock\n            \n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n            \n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n            \n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n                \n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n        \n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n        \n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n                \n        return feature\n    \n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n        \n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n        \n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n                \n        return newly_unlocked\n    \n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n        \n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n            \n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (last_assessment is None or \n                time.time() - last_assessment > self.assessment_interval):\n                self.user_progress.assess_skill()\n                \n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n    \n    def register_feature_hook(self, feature_id: str, hook: Callable[[Feature], None]) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n        \n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n            \n        self.feature_hooks[feature_id].append(hook)\n    \n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n        \n        Args:\n            feature_id: ID of the feature to check\n            \n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return (feature_id in self.features and \n                self.features[feature_id].is_enabled())\n    \n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n        \n        Args:\n            feature_id: ID of the feature to get guidance for\n            \n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation\n        }\n    \n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n        \n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n    \n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n        \n        Args:\n            level: The new skill level to set\n            \n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n    \n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n        \n        # Enable all beginner features by default\n        self._enable_beginner_features()\n    \n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n    \n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n        \n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n    \n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n        \n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n                \n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids\n                    for prereq in feature.prerequisites\n                )\n                \n                if prerequisites_met:\n                    pending.append(feature)\n        \n        return pending\n    \n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n        \n        Args:\n            feature_id: ID of the feature to unlock\n            \n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n            \n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n            \n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n                \n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n        \n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n        \n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n                \n        return feature\n    \n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n        \n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n        \n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n                \n        return newly_unlocked\n    \n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n        \n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n            \n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (last_assessment is None or \n                time.time() - last_assessment > self.assessment_interval):\n                self.user_progress.assess_skill()\n                \n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n    \n    def register_feature_hook(self, feature_id: str, hook: Callable[[Feature], None]) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n        \n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n            \n        self.feature_hooks[feature_id].append(hook)\n    \n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n        \n        Args:\n            feature_id: ID of the feature to check\n            \n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return (feature_id in self.features and \n                self.features[feature_id].is_enabled())\n    \n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n        \n        Args:\n            feature_id: ID of the feature to get guidance for\n            \n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation\n        }\n    \n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n        \n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n    \n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n        \n        Args:\n            level: The new skill level to set\n            \n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureManager(BaseModel):\n    \"\"\"\n    Manages the progressive feature system.\n    \n    This class handles feature unlocking, tracking user progress,\n    and providing appropriate features based on skill level.\n    \"\"\"\n    features: Dict[str, Feature] = Field(default_factory=dict)\n    user_progress: UserProgress = Field(default_factory=UserProgress)\n    feature_hooks: Dict[str, List[Callable]] = Field(default_factory=dict)\n    assessment_interval: int = 3600  # Time in seconds between skill assessments\n    \n    def __init__(self, **kwargs):\n        \"\"\"Initialize the feature manager with default features.\"\"\"\n        super().__init__(**kwargs)\n        \n        # Initialize with default features\n        for feature in DEFAULT_FEATURES:\n            self.features[feature.id] = feature\n        \n        # Enable all beginner features by default\n        self._enable_beginner_features()\n    \n    def _enable_beginner_features(self) -> None:\n        \"\"\"Enable all beginner-level features by default.\"\"\"\n        for feature_id, feature in self.features.items():\n            if feature.required_skill_level == SkillLevel.BEGINNER:\n                feature.enable()\n                self.user_progress.unlock_feature(feature_id)\n    \n    def get_available_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of all available (enabled) features.\n        \n        Returns:\n            List of enabled Feature objects\n        \"\"\"\n        return [f for f in self.features.values() if f.is_enabled()]\n    \n    def get_pending_features(self) -> List[Feature]:\n        \"\"\"\n        Get a list of features that could be unlocked next.\n        \n        Returns:\n            List of Feature objects that can be unlocked\n        \"\"\"\n        user_level = self.user_progress.skill_level\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        pending = []\n        for feature_id, feature in self.features.items():\n            # Skip already unlocked features\n            if feature_id in unlocked_feature_ids:\n                continue\n                \n            # Check if the feature is appropriate for the user's level\n            if feature.required_skill_level.value <= user_level.value:\n                # Check if prerequisites are met\n                prerequisites_met = all(\n                    prereq in unlocked_feature_ids\n                    for prereq in feature.prerequisites\n                )\n                \n                if prerequisites_met:\n                    pending.append(feature)\n        \n        return pending\n    \n    def unlock_feature(self, feature_id: str) -> Optional[Feature]:\n        \"\"\"\n        Unlock a specific feature for the user.\n        \n        Args:\n            feature_id: ID of the feature to unlock\n            \n        Returns:\n            The unlocked Feature object, or None if the feature doesn't exist\n            or prerequisites are not met\n        \"\"\"\n        # Check if the feature exists\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        unlocked_feature_ids = self.user_progress.unlocked_features\n        \n        # Check if the feature is already unlocked\n        if feature_id in unlocked_feature_ids:\n            return feature\n            \n        # Check if the user has the required skill level\n        if feature.required_skill_level.value > self.user_progress.skill_level.value:\n            return None\n            \n        # Check if prerequisites are met\n        for prereq in feature.prerequisites:\n            if prereq not in unlocked_feature_ids:\n                return None\n                \n        # Unlock the feature\n        start_time = time.time()\n        self.user_progress.unlock_feature(feature_id)\n        feature.enable()\n        \n        # Calculate unlock time for performance metrics\n        unlock_time_ms = (time.time() - start_time) * 1000\n        \n        # Call any registered hooks for this feature\n        if feature_id in self.feature_hooks:\n            for hook in self.feature_hooks[feature_id]:\n                hook(feature)\n                \n        return feature\n    \n    def unlock_appropriate_features(self) -> List[Feature]:\n        \"\"\"\n        Unlock all features that are appropriate for the user's current skill level.\n        \n        Returns:\n            List of newly unlocked Feature objects\n        \"\"\"\n        pending_features = self.get_pending_features()\n        newly_unlocked = []\n        \n        for feature in pending_features:\n            unlocked_feature = self.unlock_feature(feature.id)\n            if unlocked_feature:\n                newly_unlocked.append(unlocked_feature)\n                \n        return newly_unlocked\n    \n    def record_feature_usage(self, feature_id: str) -> None:\n        \"\"\"\n        Record that the user has used a feature.\n        \n        Args:\n            feature_id: ID of the feature that was used\n        \"\"\"\n        if feature_id in self.features:\n            self.user_progress.record_feature_usage(feature_id)\n            \n            # Check if we should assess skill level\n            last_assessment = self.user_progress.last_assessment_time\n            if (last_assessment is None or \n                time.time() - last_assessment > self.assessment_interval):\n                self.user_progress.assess_skill()\n                \n                # After assessment, unlock appropriate features\n                self.unlock_appropriate_features()\n    \n    def register_feature_hook(self, feature_id: str, hook: Callable[[Feature], None]) -> None:\n        \"\"\"\n        Register a hook to be called when a feature is unlocked.\n        \n        Args:\n            feature_id: ID of the feature to hook\n            hook: Callback function to call when the feature is unlocked\n        \"\"\"\n        if feature_id not in self.feature_hooks:\n            self.feature_hooks[feature_id] = []\n            \n        self.feature_hooks[feature_id].append(hook)\n    \n    def is_feature_enabled(self, feature_id: str) -> bool:\n        \"\"\"\n        Check if a feature is enabled for the current user.\n        \n        Args:\n            feature_id: ID of the feature to check\n            \n        Returns:\n            True if the feature is enabled, False otherwise\n        \"\"\"\n        return (feature_id in self.features and \n                self.features[feature_id].is_enabled())\n    \n    def get_feature_guidance(self, feature_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Get guidance information for a feature.\n        \n        Args:\n            feature_id: ID of the feature to get guidance for\n            \n        Returns:\n            Dictionary with guidance information, or None if the feature doesn't exist\n        \"\"\"\n        if feature_id not in self.features:\n            return None\n            \n        feature = self.features[feature_id]\n        return {\n            \"name\": feature.name,\n            \"description\": feature.description,\n            \"usage_examples\": feature.usage_examples,\n            \"documentation\": feature.documentation\n        }\n    \n    def get_user_progress_report(self) -> Dict[str, Any]:\n        \"\"\"\n        Get a report of the user's progress.\n        \n        Returns:\n            Dictionary with progress information\n        \"\"\"\n        return self.user_progress.get_progress_report()\n    \n    def set_skill_level(self, level: SkillLevel) -> List[Feature]:\n        \"\"\"\n        Set the user's skill level directly.\n        \n        Args:\n            level: The new skill level to set\n            \n        Returns:\n            List of newly unlocked features\n        \"\"\"\n        self.user_progress.skill_level = level\n        return self.unlock_appropriate_features()",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class FeatureCategory(Enum):\n    \"\"\"Categories of editor features that can be progressively unlocked.\"\"\"\n    BASIC_EDITING = \"basic_editing\"\n    TEXT_NAVIGATION = \"text_navigation\"\n    SEARCH_REPLACE = \"search_replace\"\n    ADVANCED_EDITING = \"advanced_editing\"\n    FILE_OPERATIONS = \"file_operations\"\n    HISTORY_OPERATIONS = \"history_operations\"\n    CODE_FORMATTING = \"code_formatting\"\n    CODE_INTELLIGENCE = \"code_intelligence\"\n    CUSTOMIZATION = \"customization\"\n    AUTOMATION = \"automation\"",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class SkillLevel(Enum):\n    \"\"\"Enum representing different skill levels for users.\"\"\"\n    BEGINNER = 1\n    INTERMEDIATE = 2\n    ADVANCED = 3\n    EXPERT = 4",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled",
                "class Feature(BaseModel):\n    \"\"\"\n    Represents a feature in the text editor that can be progressively unlocked.\n    \"\"\"\n    id: str\n    name: str\n    description: str\n    category: FeatureCategory\n    required_skill_level: SkillLevel\n    prerequisites: List[str] = Field(default_factory=list)\n    usage_examples: List[str] = Field(default_factory=list)\n    documentation: str = \"\"\n    enabled: bool = False\n    \n    def enable(self) -> None:\n        \"\"\"Enable this feature.\"\"\"\n        self.enabled = True\n    \n    def disable(self) -> None:\n        \"\"\"Disable this feature.\"\"\"\n        self.enabled = False\n    \n    def is_enabled(self) -> bool:\n        \"\"\"Check if this feature is enabled.\"\"\"\n        return self.enabled"
            ]
        }
    },
    "total_loc": 9865,
    "total_sloc": 5898,
    "total_lloc": 4321,
    "total_comments": 655,
    "total_multi": 1440,
    "total_blank": 1749,
    "total_cyclomatic": 1323,
    "total_internal_imports": 190
}